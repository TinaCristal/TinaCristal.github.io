<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++中字符数组与string的相互转换</title>
    <url>/2019/04/20/1/</url>
    <content><![CDATA[<p>字符数组转化成string类型</p>
<p>char ch [] = “ABCDEFG”;</p>
<p>string str(ch);//也可string str = ch;</p>
<p>或者</p>
<p>char ch [] = “ABCDEFG”;</p>
<p>string str;</p>
<p>str = ch;//在原有基础上添加可以用str += ch;</p>
<a id="more"></a>
<p>将string类型转换为字符数组</p>
<p>char buf[10];</p>
<p>string str(“ABCDEFG”);</p>
<p>length = str.copy(buf, 9);</p>
<p>buf[length] = ‘\0’;</p>
<p>或者</p>
<p>char buf[10];</p>
<p>string str(“ABCDEFG”);</p>
<p>strcpy(buf, str.c_str());//strncpy(buf, str.c_str(), 10);</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>B1003 我要通过！ </title>
    <url>/2019/03/18/1003/</url>
    <content><![CDATA[<p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。<br><a id="more"></a><br>得到“答案正确”的条件是：</p>
<p>字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符；<br>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；<br>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母  A 组成的字符串。<br>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。</p>
<p>输入格式：<br>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>
<p>输出格式：<br>每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">8</span><br><span class="line">PAT</span><br><span class="line">PAAT</span><br><span class="line">AAPATAA</span><br><span class="line">AAPAATAAAA</span><br><span class="line">xPATx</span><br><span class="line">PT</span><br><span class="line">Whatever</span><br><span class="line">APAAATAA</span><br><span class="line">输出样例：</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure></p>
<p>所有的Yes都源于条件2<br>条件3 逆推 最后都是判断条件2的成立</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define MAX 10001</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	getchar();</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		string s;</span><br><span class="line">		getline(cin,s);</span><br><span class="line">		int loc_p,loc_a,loc_t,others=0;</span><br><span class="line">		int num_p=0,num_t=0,num_a=0;</span><br><span class="line">		for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">			if(s[i]==&apos;P&apos;)&#123;</span><br><span class="line">				loc_p=i;</span><br><span class="line">				num_p++;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(s[i]==&apos;T&apos;)&#123;</span><br><span class="line">				loc_t=i;num_t++;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(s[i]==&apos;A&apos;)&#123;</span><br><span class="line">				num_a++;</span><br><span class="line">			&#125;</span><br><span class="line">			else others++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(num_a==0||others!=0||num_p!=1||num_t!=1) &#123;</span><br><span class="line">		cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;continue;</span><br><span class="line">	&#125;</span><br><span class="line">	int x=loc_p,y=loc_t-loc_p-1,z=s.length()-1-loc_t;</span><br><span class="line">	if(z-(y-1)*x==x) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">	else 	cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复习<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	string str;</span><br><span class="line">	getchar();</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		getline(cin,str);	</span><br><span class="line">		int num_p=0,num_t=0,other=0;</span><br><span class="line">		int loc_p=0,loc_t=0;</span><br><span class="line">		for(int i=0;i&lt;str.length();i++)&#123;</span><br><span class="line">			if(str[i]==&apos;P&apos;) &#123;</span><br><span class="line">				num_p++;loc_p=i; </span><br><span class="line">			&#125;</span><br><span class="line">			else if(str[i]==&apos;T&apos;)&#123;</span><br><span class="line">				num_t++;loc_t=i;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(str[i]!=&apos;A&apos;)</span><br><span class="line">			other++;</span><br><span class="line">		&#125;</span><br><span class="line">			int left=loc_p,mid=loc_t-loc_p-1,right=str.length()-loc_t-1;</span><br><span class="line">//			cout&lt;&lt;&quot;!&quot;&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;mid&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;endl;</span><br><span class="line">		if(other&gt;0||num_p!=1||num_t!=1||(loc_t-loc_p&lt;=1)) &#123;</span><br><span class="line">			cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">	</span><br><span class="line">		else&#123;</span><br><span class="line">			</span><br><span class="line">			right-=(mid-1)*left;</span><br><span class="line">			if(right!=left) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">				else	cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>A1003 Emergency</title>
    <url>/2019/03/06/1003-Emergency/</url>
    <content><![CDATA[<p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C<br>​1<br>​​  and C<br>​2<br>​​  - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c<br>​1<br>​​ , c<br>​2<br>​​  and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C<br>​1<br>​​  to C<br>​2<br>​​ .</p>
<p>Output Specification:<br>For each test case, print in one line two numbers: the number of different shortest paths between C<br>​1<br>​​  and C<br>​2<br>​​ , and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">5 6 0 2</span><br><span class="line">1 2 1 5 3</span><br><span class="line">0 1 1</span><br><span class="line">0 2 2</span><br><span class="line">0 3 1</span><br><span class="line">1 2 1</span><br><span class="line">2 4 1</span><br><span class="line">3 4 1</span><br><span class="line">Sample Output:</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define INF 10000000000</span><br><span class="line">#define N 510</span><br><span class="line">using namespace std;</span><br><span class="line">	int n,m,st,ed;</span><br><span class="line">	int wei[N],dis[N],w[N],num[N],g[N][N];</span><br><span class="line">	bool vis[N]=&#123;false&#125;;</span><br><span class="line">void dij(int s)&#123;</span><br><span class="line">//	memset(dis,INF,sizeof(dis));</span><br><span class="line">  fill(dis,dis+N,INF);</span><br><span class="line">	memset(w,0,sizeof(w));</span><br><span class="line">	memset(num,0,sizeof(num));</span><br><span class="line">	dis[s]=0;</span><br><span class="line">	num[s]=1;</span><br><span class="line">	w[s]=wei[s]; </span><br><span class="line">//	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">//	if(g[s][i]!=0x3f)		dis[i]=g[s][i];</span><br><span class="line">//	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		int min=INF,u=-1;</span><br><span class="line">		for(int j=0;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(vis[j]==false&amp;&amp;dis[j]&lt;min)&#123;</span><br><span class="line">				u=j;min=dis[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(u==-1) return;</span><br><span class="line">		vis[u]=true;//先访问起点 </span><br><span class="line">		for(int k=0;k&lt;n;k++)&#123;</span><br><span class="line">			if(vis[k]) continue;</span><br><span class="line">			if(g[u][k]==INF) continue;</span><br><span class="line">			if(dis[u]+g[u][k]&lt;dis[k])&#123;</span><br><span class="line">				dis[k]=dis[u]+g[u][k];</span><br><span class="line">				num[k]=num[u];</span><br><span class="line">				w[k]=w[u]+wei[k];</span><br><span class="line">			&#125;</span><br><span class="line">			else if(dis[u]+g[u][k]==dis[k])&#123;</span><br><span class="line">				if(w[u]+wei[k]&gt;w[k])&#123;</span><br><span class="line">					w[k]=w[u]+wei[k];</span><br><span class="line">				&#125;</span><br><span class="line">				num[k]+=num[u];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//freopen(&quot;36.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;wei[i];</span><br><span class="line">  fill(g[0],g[0]+N*N,INF);</span><br><span class="line">//	memset(g,INF,sizeof(g));</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		int a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		g[a][b]=c;</span><br><span class="line">		g[b][a]=c;</span><br><span class="line">	&#125;</span><br><span class="line">	dij(st);</span><br><span class="line">	cout&lt;&lt;num[ed]&lt;&lt;&quot; &quot;&lt;&lt;w[ed];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>A1048 Find Coins </title>
    <url>/2019/01/26/1048-Find-Coins/</url>
    <content><![CDATA[<p>Eva loves to collect coins from all over the universe,<br><a id="more"></a><br>including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 10<br>​5<br>​​  coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it.</p>
<p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (≤10<br>​5<br>​​ , the total number of coins) and M (≤10<br>​3<br>​​ , the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space.</p>
<p>Output Specification:<br>For each test case, print in one line the two face values V<br>​1<br>​​  and V<br>​2<br>​​  (separated by a space) such that V<br>​1<br>​​ +V<br>​2<br>​​ =M and V<br>​1<br>​​ ≤V<br>​2<br>​​ . If such a solution is not unique, output the one with the smallest V<br>​1<br>​​ . If there is no solution, output No Solution instead.</p>
<p>Sample Input 1:<br>8 15<br>1 2 8 7 2 4 11 15<br>Sample Output 1:<br>4 11<br>Sample Input 2:<br>7 14<br>1 8 7 2 4 11 15<br>Sample Output 2:<br>No Solution</p>
<h2 id="two-pointers-思想"><a href="#two-pointers-思想" class="headerlink" title="two pointers 思想"></a>two pointers 思想</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define maxn 100001</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,ans;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;ans);</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	int p=0;</span><br><span class="line">	int q=n-1;</span><br><span class="line">	int flag=0;</span><br><span class="line">	while(p&lt;q)&#123;</span><br><span class="line">		if(a[p]+a[q]==ans) &#123;</span><br><span class="line">			flag=1;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(a[p]+a[q]&gt;ans)	q--;</span><br><span class="line">		else p++;</span><br><span class="line">	&#125;</span><br><span class="line">	if(flag==1)cout&lt;&lt;a[p]&lt;&lt;&quot; &quot;&lt;&lt;a[q]&lt;&lt;endl;</span><br><span class="line">	else cout&lt;&lt;&quot;No Solution&quot;&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>0-1 背包问题</title>
    <url>/2018/12/19/0-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>题目：</p>
<pre><code>共n个物体，第i个重量为w[i]，价值v[i]，背包最多能背不超过W的物体，求最大的价值
</code></pre><p>分析：</p>
<pre><code>每个物体只有一个，在容量允许时（W&gt;w[i]），则对于每个物体只有取、不取两种选择

状态：dp[i][j]：前i个物体，在容量为j的时候，最大的价值

状态转移：
</code></pre><p> dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">int v[MAX],w[MAX];</span><br><span class="line">int c[MAX][MAX];</span><br><span class="line">int x[MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,W;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	cout&lt;&lt;&quot;购物车重量&quot;; </span><br><span class="line">		cin&gt;&gt;W;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=W;j++)&#123;//枚举购物车的重量 </span><br><span class="line">			if(j&lt;w[i])&#123;</span><br><span class="line">				c[i][j]=c[i-1][j];</span><br><span class="line">			&#125;</span><br><span class="line">            //购物车的重量大于等于第i件商品的重量 </span><br><span class="line">            //考虑此物品放与不放是否能使当前购物车价值最大</span><br><span class="line">			else&#123;</span><br><span class="line">				c[i][j]=max(c[i-1][j-w[i]]+v[i],c[i-1][j]);		</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;最大价值为:&quot;&lt;&lt;c[n][W]&lt;&lt;endl;</span><br><span class="line">	int j=W;</span><br><span class="line">	for(int i=n;i&gt;0;i--)&#123;</span><br><span class="line">		//i&gt;0 i=1的时候可能该商品也在背包里 即c[i][j]&gt;0 </span><br><span class="line">	if(c[i][j]&gt;c[i-1][j])&#123;</span><br><span class="line">		x[i]=1;</span><br><span class="line">		j-=w[i];</span><br><span class="line">	&#125;	</span><br><span class="line">		else x[i]=0;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	if(x[i]==1) cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fybz9tcwv9j30ek05omxf.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">int v[MAX],w[MAX];</span><br><span class="line">int dp[MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,W;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	cout&lt;&lt;&quot;购物车重量&quot;; </span><br><span class="line">		cin&gt;&gt;W;</span><br><span class="line">	/*for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=W;j&gt;0;j--)&#123;//枚举购物车的重量 </span><br><span class="line">			if(j&gt;=w[i])&#123;</span><br><span class="line">			dp[j]=max(dp[j],dp[j-w[i]]+v[i]);	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;*/</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=W;j&gt;=w[i];j--)&#123;//枚举购物车的重量 </span><br><span class="line">			dp[j]=max(dp[j],dp[j-w[i]]+v[i]);	</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;最大价值为:&quot;&lt;&lt;dp[W]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">int v[MAX],w[MAX];</span><br><span class="line">int dp[MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,W;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">	int sum[n+1];</span><br><span class="line">	sum[0]=0;</span><br><span class="line"></span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	cout&lt;&lt;&quot;购物车重量&quot;; </span><br><span class="line">		cin&gt;&gt;W;</span><br><span class="line">		//i</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	sum[i]=sum[i-1]+w[i]; </span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		//剩余容量与w[i]的最大值 </span><br><span class="line">		//sum[i-1]~sum[n]表示 i..n物品重量之和  </span><br><span class="line">		//只需要最后f[v]的值，倒推前一个物品，其实只要知道f[v-w[n]]即可。</span><br><span class="line">		//以此类推，对以第j个背包，其实只需要知道到f[v-sum&#123;w[j..n]&#125;]即可</span><br><span class="line">			int bound=max(w[i],W-(sum[n]-sum[i-1]));</span><br><span class="line">		for(int j=W;j&gt;=bound;j--)&#123;//枚举购物车的重量 </span><br><span class="line">			dp[j]=max(dp[j],dp[j-w[i]]+v[i]);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;最大价值为:&quot;&lt;&lt;dp[W]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个常数优化<br>前面的伪代码中有 for v=V..1，可以将这个循环的下限进行改进。</p>
<p>由于只需要最后f[v]的值，倒推前一个物品，其实只要知道f[v-w[n]]即可。以此类推，对以第j个背包，其实只需要知道到f[v-sum{w[j..n]}]即可，即代码中的</p>
<p>for i=1..N<br>    for v=V..0<br>可以改成</p>
<p>for i=1..n<br>    bound=max{V-sum{w[i..n]},c[i]}<br>    for v=V..bound<br>这对于V比较大时是有用的。</p>
<p>小结<br>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p>
<p>参考博客、<br><a href="http://739789987.blog.51cto.com/8328242/1438296" target="_blank" rel="noopener">http://739789987.blog.51cto.com/8328242/1438296</a><br>背包问题9讲<br><a href="https://www.kancloud.cn/kancloud/pack/70125" target="_blank" rel="noopener">https://www.kancloud.cn/kancloud/pack/70125</a></p>
]]></content>
      <categories>
        <category>趣学算法</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>A1045 Favorite Color Stripe </title>
    <url>/2019/03/10/1045/</url>
    <content><![CDATA[<p>Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe.<br><a id="more"></a><br>It is said that a normal human eye can distinguish about less than 200 different colors, so Eva’s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result.</p>
<p>Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva’s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}.</p>
<p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains a positive integer N (≤200) which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer M (≤200) followed by M Eva’s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L (≤10<br>​4<br>​​ ) which is the length of the given stripe, followed by L colors on the stripe. All the numbers in a line a separated by a space.</p>
<p>Output Specification:<br>For each test case, simply print in a line the maximum length of Eva’s favorite stripe.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">6</span><br><span class="line">5 2 3 1 5 6</span><br><span class="line">12 2 2 4 1 5 5 6 3 1 1 5 6</span><br><span class="line">Sample Output:</span><br><span class="line">7</span><br></pre></td></tr></table></figure></p>
<h2 id="LIS-最长不下降子序列"><a href="#LIS-最长不下降子序列" class="headerlink" title="LIS 最长不下降子序列"></a>LIS 最长不下降子序列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX 10001</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[MAX],hasht[210],a[MAX],b[MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">//	freopen(&quot;t1.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	int n,m,l;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">//		memset(dp,0,sizeof(dp));</span><br><span class="line">		memset(hasht,-1,sizeof(hasht));</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		hasht[a[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;l;</span><br><span class="line">	int num=0;</span><br><span class="line">	for(int i=0;i&lt;l;i++)&#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">//		b[i]=hasht[b[i]];</span><br><span class="line">		if(hasht[x]&gt;=0)&#123;</span><br><span class="line">			b[num++]=hasht[x];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int ans=-1;</span><br><span class="line">	//i&lt;m错误 加入到b数组 是对b数组进去最长不下降子序列长度的统计 </span><br><span class="line">	for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">			dp[i]=1;</span><br><span class="line">		for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">			if(dp[j]+1&gt;dp[i]&amp;&amp;b[j]&lt;=b[i])&#123;</span><br><span class="line">				dp[i]=dp[j]+1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans=max(ans,dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCS-最长公共子序列"><a href="#LCS-最长公共子序列" class="headerlink" title="LCS  最长公共子序列"></a>LCS  最长公共子序列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 10002</span><br><span class="line">int a[201],b[MAX],dp[201][MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">//	freopen(&quot;11.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	int t,n;</span><br><span class="line">	cin&gt;&gt;t&gt;&gt;n; </span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line">	int m;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	for(int j=1;j&lt;=m;j++)</span><br><span class="line">	cin&gt;&gt;b[j];</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;=m;i++)</span><br><span class="line">	dp[0][i]=0;</span><br><span class="line">		for(int i=0;i&lt;=n;i++)</span><br><span class="line">	dp[i][0]=0;</span><br><span class="line">	//dp[i][j-1] 从1开始枚举 </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			int maxn=max(dp[i][j-1],dp[i-1][j]);</span><br><span class="line">			if(a[i]==b[j]) dp[i][j]=maxn+1;</span><br><span class="line">			else dp[i][j]=maxn;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>LIS</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title>A1035 Password </title>
    <url>/2019/03/18/1005/</url>
    <content><![CDATA[<p>To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase). One solution is to replace 1 (one) by @, 0 (zero) by %, l by L, and O by o. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. Each case contains a positive integer N (≤1000), followed by N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.</p>
<p>Output Specification:<br>For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line There are N accounts and no account is modified where N is the total number of accounts. However, if N is one, you must print There is 1 account and no account is modified instead.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input 1:</span><br><span class="line">3</span><br><span class="line">Team000002 Rlsp0dfa</span><br><span class="line">Team000003 perfectpwd</span><br><span class="line">Team000001 R1spOdfa</span><br><span class="line">Sample Output 1:</span><br><span class="line">2</span><br><span class="line">Team000002 RLsp%dfa</span><br><span class="line">Team000001 R@spodfa</span><br><span class="line">Sample Input 2:</span><br><span class="line">1</span><br><span class="line">team110 abcdefg332</span><br><span class="line">Sample Output 2:</span><br><span class="line">There is 1 account and no account is modified</span><br><span class="line">Sample Input 3:</span><br><span class="line">2</span><br><span class="line">team110 abcdefg222</span><br><span class="line">team220 abcdefg333</span><br><span class="line">Sample Output 3:</span><br><span class="line">There are 2 accounts and no account is modified</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int cnt=0;</span><br><span class="line">struct acc&#123;</span><br><span class="line">	string name,pass;</span><br><span class="line">	acc(string nn,string pa):name(nn),pass(pa)&#123;</span><br><span class="line">	&#125; </span><br><span class="line">	acc()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool change(string &amp;s)&#123;</span><br><span class="line">	bool flag=false;</span><br><span class="line">	for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">		if(s[i]==&apos;1&apos;)&#123;</span><br><span class="line">			flag=true; s[i]=&apos;@&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">        //if!</span><br><span class="line">			if(s[i]==&apos;0&apos;)&#123;</span><br><span class="line">			flag=true; s[i]=&apos;%&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">		if(s[i]==&apos;l&apos;)&#123;</span><br><span class="line">			flag=true; s[i]=&apos;L&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">	if(s[i]==&apos;O&apos;)&#123;</span><br><span class="line">			flag=true; s[i]=&apos;o&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return flag;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	acc account[n];</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;account[i].name&gt;&gt;account[i].pass;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;int&gt; vec;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		if(change(account[i].pass))&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			vec.push_back(i); </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	if(cnt==0)</span><br><span class="line">	&#123;</span><br><span class="line">		if(n==1)</span><br><span class="line">		cout&lt;&lt;&quot;There is 1 account and no account is modified&quot;&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">		else</span><br><span class="line">		cout&lt;&lt;&quot;There are &quot;&lt;&lt;n&lt;&lt;&quot; accounts and no account is modified&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">		for(int j=0;j&lt;vec.size();j++)</span><br><span class="line">        //下标是vec[j]不是j</span><br><span class="line">		cout&lt;&lt;account[vec[j]].name&lt;&lt;&quot; &quot;&lt;&lt;account[vec[j]].pass&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>A1089/B1035  Insert or Merge</title>
    <url>/2019/03/17/1089/</url>
    <content><![CDATA[<p>According to Wikipedia:<br><a id="more"></a><br>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
<p>Merge sort works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining.</p>
<p>Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?</p>
<p>Input Specification:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.</p>
<p>Output Specification:<br>For each test case, print in the first line either “Insertion Sort” or “Merge Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input 1:</span><br><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 6 0</span><br><span class="line">1 2 3 7 8 5 9 4 6 0</span><br><span class="line">Sample Output 1:</span><br><span class="line">Insertion Sort</span><br><span class="line">1 2 3 5 7 8 9 4 6 0</span><br><span class="line">Sample Input 2:</span><br><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 0 6</span><br><span class="line">1 3 2 8 5 7 4 9 0 6</span><br><span class="line">Sample Output 2:</span><br><span class="line">Merge Sort</span><br><span class="line">1 2 3 8 4 5 7 9 0 6</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAX 101</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int ori[MAX],ch[MAX],back[MAX];</span><br><span class="line">void show(int a[])&#123;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;a[i];</span><br><span class="line">		if(i!=n-1) cout&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">bool issame(int ori[],int ch[])&#123;</span><br><span class="line">	bool flag=true;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(ori[i]!=ch[i])&#123;</span><br><span class="line">			flag=false;</span><br><span class="line">			break;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	return flag;</span><br><span class="line">&#125;</span><br><span class="line">bool isort()&#123;</span><br><span class="line">	bool flag=false;</span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		if(i!=1&amp;&amp;issame(ori,ch))&#123;</span><br><span class="line">		flag=true;</span><br><span class="line">		&#125; </span><br><span class="line">		int tmp=ori[i];</span><br><span class="line">		int j=i;</span><br><span class="line">		for(;j&gt;0;j--)&#123;</span><br><span class="line">			if(ori[j-1]&gt;tmp) ori[j]=ori[j-1];</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		ori[j]=tmp;</span><br><span class="line">	if(flag==true) return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">bool msort()&#123;</span><br><span class="line">	bool flag=false;</span><br><span class="line">	for(int step=2;step/2&lt;=n;step*=2)&#123;//两两分组 四个四个一组  !</span><br><span class="line">	if(step!=2&amp;&amp;issame(ori,ch))&#123;</span><br><span class="line">		flag=true;</span><br><span class="line">	&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i+=step)//i&lt;n-step+1 错 最后不一定凑够 组的人数 </span><br><span class="line">		sort(ori+i,min(ori+i+step,ori+n));</span><br><span class="line">		</span><br><span class="line">		if(flag==true) return true;	</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;ori[i];</span><br><span class="line">			back[i]=ori[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;ch[i];	</span><br><span class="line">	if(isort())&#123;</span><br><span class="line">		cout&lt;&lt;&quot;Insertion Sort&quot;&lt;&lt;endl;</span><br><span class="line">		show(ori);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		ori[i]=back[i];</span><br><span class="line">		msort();</span><br><span class="line">		cout&lt;&lt;&quot;Merge Sort&quot;&lt;&lt;endl;</span><br><span class="line">		show(ori);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>蓝桥杯 凑算式</title>
    <url>/2019/03/22/11/</url>
    <content><![CDATA[<p>凑算式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   B    DEF      </span><br><span class="line">A + — + -— —— = 10</span><br><span class="line">   C   GHI</span><br></pre></td></tr></table></figure></p>
<p>这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。</p>
<p>比如：<br>6+8/3+952/714 就是一种解法，<br>5+3/1+972/486 是另一种解法。<br><a id="more"></a><br>这个算式一共有多少种解法？</p>
<p>注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。</p>
<p>这个题不多说了，直接暴力生成9的全排列然后去验证等式是否成立，只是验证的时候如果防止精度问题可以通分把除法变成乘法。<br>答案是：29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//暴力生成9的全排列 dfs</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 10</span><br><span class="line">int tmp[MAX];</span><br><span class="line">int ans=0;</span><br><span class="line">bool vis[10];</span><br><span class="line">//void solve(int tmp[])&#123;</span><br><span class="line">//	int t=tmp[0] +tmp[1]/tmp[2]+(tmp[3]*100+tmp[4]*10+tmp[5])/(tmp[6]*100+tmp[7]*10+tmp[8]);</span><br><span class="line">//	if(t==10) ans++;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">void solve(int num[])</span><br><span class="line">&#123;</span><br><span class="line">	double sum = num[0] + (double)num[1] / num[2] + (double)(num[3]*100+num[4]*10+num[5])/(num[6]*100+num[7]*10+num[8]);</span><br><span class="line">	if(sum == 10)</span><br><span class="line">	&#123;</span><br><span class="line">		ans ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dfs(int index)&#123;</span><br><span class="line">	if(index==9)&#123;</span><br><span class="line">		solve(tmp);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=9;i++)&#123;</span><br><span class="line">		if(!vis[i])&#123;</span><br><span class="line">			tmp[index]=i;</span><br><span class="line">			vis[i]=true;</span><br><span class="line">			dfs(index+1);</span><br><span class="line">			vis[i]=false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	dfs(0);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//暴力生成9的全排列 dfs</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 10</span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">vector&lt;int&gt; v[MAX];</span><br><span class="line">int vis[10];</span><br><span class="line">int cnt=0,num;</span><br><span class="line">void dfs(int k)&#123;</span><br><span class="line">	if(num==9)&#123;</span><br><span class="line">		vec.push_back(k);</span><br><span class="line">		for(int t=0;t&lt;9;t++)</span><br><span class="line">		cout&lt;&lt;vec[t]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		v[cnt++]=vec;</span><br><span class="line">		vec.pop_back(); </span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">		num=0;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[k]=true;</span><br><span class="line">	for(int i=1;i&lt;=9;i++)&#123;</span><br><span class="line">		if(!vis[i])&#123;</span><br><span class="line">			num++;//错误 Num是全局变量 </span><br><span class="line">			vis[i]=true;</span><br><span class="line">			vec.push_back(i);</span><br><span class="line">			dfs(i);</span><br><span class="line">			vis[i]=false;</span><br><span class="line">			vec.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	dfs(1);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 200. Number of Islands</title>
    <url>/2018/12/07/200/</url>
    <content><![CDATA[<p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.<br><a id="more"></a><br>Example 1:</p>
<p>Input:<br>11110</p>
<p>11010</p>
<p>11000</p>
<p>00000</p>
<p>Output: 1</p>
<p>Example 2:</p>
<p>Input:</p>
<p>11000</p>
<p>11000</p>
<p>00100</p>
<p>00011</p>
<p>Output: 3</p>
<p>开始想用vis来记录访问过的岛屿<br>发现超时<br>直接将岛屿所在点变为0（陆地）<br>即可跳过访问grid[x][y] 1-&gt;0</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int m,n;</span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">         m=grid.size();</span><br><span class="line">        if(m==0) return 0;</span><br><span class="line">         n=grid[0].size();</span><br><span class="line">       </span><br><span class="line"> //vector&lt;vector&lt;int&gt; &gt; vis(100,vector&lt;int&gt;(100,0)); 直接把访问过的1岛屿 标记为0 grid[x][y]=0</span><br><span class="line">        int cnt=0;</span><br><span class="line">      </span><br><span class="line">        for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j]!=&apos;0&apos;)&#123;</span><br><span class="line">              //     cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">                 dfs(grid,i,j);</span><br><span class="line">                cnt++;  </span><br><span class="line">              </span><br><span class="line">                &#125;</span><br><span class="line">           </span><br><span class="line">            &#125;</span><br><span class="line">               </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(vector&lt;vector&lt;char&gt; &gt;&amp;grid,int x,int y)&#123;//grid传的是引用</span><br><span class="line">     </span><br><span class="line">        if(x&lt;0||x&gt;=m||y&lt;0||y&gt;=n) return;</span><br><span class="line">        if(grid[x][y]==&apos;0&apos;) return;//grid[x][y]==0 错误的 字符&apos;0&apos;</span><br><span class="line">        //if(vis[x][y]) return;</span><br><span class="line">        grid[x][y]=&apos;0&apos;;</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">        int newx=x+dir[i][0];</span><br><span class="line">            int newy=y+dir[i][1];</span><br><span class="line">            dfs(grid,newx,newy);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>dfs</category>
      </categories>
  </entry>
  <entry>
    <title>12-1 三角形</title>
    <url>/2019/02/24/2-1-%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<p>题目<br>　为二维空间中的点设计一个结构体，在此基础上为三角形设计一个结构体。分别设计独立的函数计算三角形的周长、面积、中心和重心。输入三个点，输出这三个点构成的三角形的周长、面积、外心和重心。结果保留小数点后2位数字。</p>
<p>思路<br>这是数学题<br><a id="more"></a><br>面积用海伦公式：a=AB,b=BC,c=AC,p=(a+b+c)/2,<br>三角形面积s=sqrt(p*(p-a)(p-b)(p-c));</p>
<p><img src="https://img-blog.csdn.net/20170927175541398?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzY1NzAyODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>重心：x=(x1+x2+x3)/3 ; y=(y1+y2+y3)/3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    double x,y;</span><br><span class="line">&#125;Point;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    Point a,b,c;</span><br><span class="line">&#125;Triangle;</span><br><span class="line"></span><br><span class="line">double abso(double n)&#123;</span><br><span class="line">    if(n&lt;0) return -n;</span><br><span class="line">    else return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//周长 </span><br><span class="line">void cir(Triangle tri)&#123;</span><br><span class="line">    double c1=sqrt((tri.a.x-tri.b.x)*(tri.a.x-tri.b.x)+(tri.a.y-tri.b.y)*(tri.a.y-tri.b.y));//ab</span><br><span class="line">    double c2=sqrt((tri.a.x-tri.c.x)*(tri.a.x-tri.c.x)+(tri.a.y-tri.c.y)*(tri.a.y-tri.c.y));//ac</span><br><span class="line">    double c3=sqrt((tri.b.x-tri.c.x)*(tri.b.x-tri.c.x)+(tri.b.y-tri.c.y)*(tri.b.y-tri.c.y));//bc</span><br><span class="line">    printf(&quot;%.2lf\n&quot;,c1+c2+c3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//面积 </span><br><span class="line">void area(Triangle tri)&#123;</span><br><span class="line">    //海伦公式 </span><br><span class="line">    double a=sqrt((tri.a.x-tri.b.x)*(tri.a.x-tri.b.x)+(tri.a.y-tri.b.y)*(tri.a.y-tri.b.y));</span><br><span class="line">    double b=sqrt((tri.b.x-tri.c.x)*(tri.b.x-tri.c.x)+(tri.b.y-tri.c.y)*(tri.b.y-tri.c.y));</span><br><span class="line">    double c=sqrt((tri.a.x-tri.c.x)*(tri.a.x-tri.c.x)+(tri.a.y-tri.c.y)*(tri.a.y-tri.c.y));</span><br><span class="line">    double p=(a+b+c)/2; </span><br><span class="line">    double s=sqrt(p*(p-a)*(p-b)*(p-c));</span><br><span class="line">    printf(&quot;%.2lf\n&quot;,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//外心 </span><br><span class="line">void outside(Triangle tri)&#123;</span><br><span class="line">    Point out;</span><br><span class="line">    double a1=2*(tri.b.x-tri.a.x);</span><br><span class="line">    double b1=2*(tri.b.y-tri.a.y);</span><br><span class="line">    double c1=(tri.b.x)*(tri.b.x)+tri.b.y*tri.b.y-tri.a.x*tri.a.x-tri.a.y*tri.a.y;</span><br><span class="line">    double a2=2*(tri.c.x-tri.b.x); </span><br><span class="line">    double b2=2*(tri.c.y-tri.b.y);</span><br><span class="line">    double c2=tri.c.x*tri.c.x+tri.c.y*tri.c.y-tri.b.x*tri.b.x-tri.b.y*tri.b.y;</span><br><span class="line">    out.x=(c1*b2-c2*b1)/(a1*b2-a2*b1);</span><br><span class="line">    out.y=(a1*c2-a2*c1)/(a1*b2-a2*b1);</span><br><span class="line">    printf(&quot;%.2lf %.2lf\n&quot;,out.x,out.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重心 </span><br><span class="line">void weight(Triangle tri)&#123;</span><br><span class="line">    Point wei;</span><br><span class="line">    wei.x=(tri.a.x+tri.b.x+tri.c.x)/3;</span><br><span class="line">    wei.y=(tri.a.y+tri.b.y+tri.c.y)/3;</span><br><span class="line">    printf(&quot;%.2lf %.2lf\n&quot;,wei.x,wei.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Triangle tri;</span><br><span class="line">    scanf(&quot;%lf%lf&quot;,&amp;tri.a.x,&amp;tri.a.y);</span><br><span class="line">    scanf(&quot;%lf%lf&quot;,&amp;tri.b.x,&amp;tri.b.y);</span><br><span class="line">    scanf(&quot;%lf%lf&quot;,&amp;tri.c.x,&amp;tri.c.y);</span><br><span class="line">    cir(tri);</span><br><span class="line">    area(tri);</span><br><span class="line">    outside(tri);</span><br><span class="line">    weight(tri); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 126. Word Ladder II</title>
    <url>/2018/11/26/126/</url>
    <content><![CDATA[<p>Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:<br><a id="more"></a><br>Only one letter can be changed at a time<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>Note:</p>
<p>Return an empty list if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.</p>
<p>Example 1:</p>
<p>Input:</p>
<p>beginWord = “hit”,</p>
<p>endWord = “cog”,</p>
<p>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>Output:<br>[</p>
<p>[“hit”,”hot”,”dot”,”dog”,”cog”],</p>
<p>[“hit”,”hot”,”lot”,”log”,”cog”]</p>
<p>]<br>Example 2:</p>
<p>Input:</p>
<p>beginWord = “hit”</p>
<p>endWord = “cog”</p>
<p>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]</p>
<p>Output: []</p>
<p>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     unordered_map&lt;string,vector&lt;string&gt;&gt; parents;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">             vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        unordered_set&lt;string&gt; dict(wordList.begin(),wordList.end());</span><br><span class="line">        if(!dict.count(endWord)) return ans;</span><br><span class="line">        dict.erase(beginWord);</span><br><span class="line">        dict.erase(endWord);</span><br><span class="line">        unordered_map&lt;string,int&gt; step&#123;&#123;beginWord,1&#125;&#125;;//,</span><br><span class="line">        q.push(beginWord);</span><br><span class="line">        bool find=false;</span><br><span class="line">         int steps=0;</span><br><span class="line">        while(!q.empty()&amp;&amp;!find)&#123;</span><br><span class="line">            steps++;</span><br><span class="line">           for(int size=q.size();size&gt;0;size--)&#123;     //!!</span><br><span class="line">            //for(int size=0;size&lt;t;size++)&#123; </span><br><span class="line">                //不能写成下面的形式 q弹出来一个元素 queue的size变化了 要么就是在弹出元素前 记录下当前这一层队列的长度</span><br><span class="line">            string p=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            string w=p;   </span><br><span class="line">                //w是P要扩展的节点</span><br><span class="line">            for(int i=0;i&lt;p.length();i++)&#123;</span><br><span class="line">                 char ch=w[i];</span><br><span class="line">                for(int j=0;j&lt;26;j++)&#123;</span><br><span class="line">                    if(&apos;a&apos;+j==ch) continue;//!!</span><br><span class="line">                    w[i]=&apos;a&apos;+j;</span><br><span class="line">                    if(w==endWord) &#123;</span><br><span class="line">                      parents[w].push_back(p);</span><br><span class="line">                        find=true;         </span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                                       </span><br><span class="line">                      //  if(step.count(w)&amp;&amp;step.at(p)&lt;step[w])&#123;</span><br><span class="line">                         if (step.count(w) &amp;&amp; steps &lt; step.at(w))&#123;</span><br><span class="line">                             parents[w].push_back(p);</span><br><span class="line">                         &#125; </span><br><span class="line">                             </span><br><span class="line">                           </span><br><span class="line">                        &#125;</span><br><span class="line">                        if(!dict.count(w)) continue;     </span><br><span class="line">                           parents[w].push_back(p);</span><br><span class="line">                            dict.erase(w);//!!</span><br><span class="line">                            step[w]=step.at(p)+1;</span><br><span class="line">                            q.push(w);    </span><br><span class="line">                    &#125;</span><br><span class="line">                     w[i]=ch;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">          &#125;  </span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">             vector&lt;string&gt; curr&#123;endWord&#125;;</span><br><span class="line">   </span><br><span class="line">     if(find)                                       </span><br><span class="line">        printpath(beginWord, endWord,curr,ans);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        return ans;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">  //加引用！！ curr vector 每次调用 增加一个word  每个curr是个可行解</span><br><span class="line">    </span><br><span class="line">        void printpath(string &amp;beginWord, string &amp;endWord,vector&lt;string&gt; &amp;curr,vector&lt;vector&lt;string&gt;&gt; &amp;ans)&#123;</span><br><span class="line">          if(endWord==beginWord) &#123;</span><br><span class="line">              ans.push_back(vector&lt;string&gt;(curr.rbegin(),curr.rend()));</span><br><span class="line">               return ;</span><br><span class="line">                </span><br><span class="line">          &#125;</span><br><span class="line">            for(int i=0;i&lt;parents[endWord].size();i++)&#123;</span><br><span class="line">                curr.push_back(parents.at(endWord).at(i));//!!</span><br><span class="line">                printpath(beginWord,parents.at(endWord).at(i),curr,ans);</span><br><span class="line">                curr.pop_back();</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="补充-下标访问容器和调用at访问的区别"><a href="#补充-下标访问容器和调用at访问的区别" class="headerlink" title="补充 下标访问容器和调用at访问的区别"></a>补充 下标访问容器和调用at访问的区别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">#include&lt;unordered_map&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//map 用下标访问如果键不存在 会创建 一个空对象</span><br><span class="line">//用at 访问 如果键不存在 会抛出一个异常 </span><br><span class="line">int main()&#123;</span><br><span class="line">	unordered_map&lt;string,int&gt; m&#123;&#123;&quot;1&quot;,2&#125;&#125;;</span><br><span class="line">//	cout&lt;&lt;m[&quot;2&quot;]&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;m.at(&quot;2&quot;)&lt;&lt;endl;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>python文件读read()、readline()、readlines()对比</title>
    <url>/2020/04/19/2005%E5%B9%B4/</url>
    <content><![CDATA[<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>　　特点是：读取整个文件，将文件内容放到一个字符串变量中。<br>　read()直接读取字节到字符串中，包括了换行符<br>　　劣势是：如果文件非常大，尤其是大于内存时，无法使用read()方法<br>  <a id="more"></a><br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  file = open(&apos;兼职模特联系方式.txt&apos;, &apos;r&apos;)  # 创建的这个文件，也是一个可迭代对象</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    text = file.read()  # 结果为str类型</span><br><span class="line">    print(type(text))</span><br><span class="line">    print(text)</span><br><span class="line">finally:</span><br><span class="line">    file.close()</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">吴迪 177 70 13888888</span><br><span class="line">王思 170 50 13988888</span><br><span class="line">白雪 167 48 13324434</span><br><span class="line">黄蓉 166 46 13828382</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h2><p>特点：readline()方法每次读取一行；返回的是一个字符串对象包括了换行符，保持当前行的内存</p>
<p>　　缺点：比readlines慢得多<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  file = open(&apos;兼职模特联系方式.txt&apos;, &apos;r&apos;)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    while True:</span><br><span class="line">        text_line = file.readline()</span><br><span class="line">        if text_line:</span><br><span class="line">            print(type(text_line), text_line)</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">finally:</span><br><span class="line">    file.close()</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&lt;class &apos;str&apos;&gt; 吴迪 177 70 13888888</span><br><span class="line"></span><br><span class="line">&lt;class &apos;str&apos;&gt; 王思 170 50 13988888</span><br><span class="line"></span><br><span class="line">&lt;class &apos;str&apos;&gt; 白雪 167 48 13324434</span><br><span class="line"></span><br><span class="line">&lt;class &apos;str&apos;&gt; 黄蓉 166 46 13828382</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="readlines"><a href="#readlines" class="headerlink" title="readlines"></a>readlines</h2><p>readlines()读取所有行然后把它们作为一个字符串列表返回。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file = open(&apos;兼职模特联系方式.txt&apos;, &apos;r&apos;)</span><br><span class="line">&gt;&gt;&gt; a = file.readlines()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&apos;吴迪 177 70 13888888\n&apos;, &apos;王思 170 50 13988888\n&apos;, &apos;白雪 167 48 13324434\n&apos;, &apos;黄蓉 166 46 13828382&apos;]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>2015-03-4网络延迟</title>
    <url>/2018/11/18/2015-03-4%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F/</url>
    <content><![CDATA[<p>给定一个公司的网络，由n台交换机和m台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。交换机按层级设置，编号为1的交换机为根交换机，层级为1。其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加1。所有的终端电脑都直接连接到交换机上。<br>　　当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。<br><a id="more"></a><br>输入格式</p>
<p>输入的第一行包含两个整数n, m，分别表示交换机的台数和终端电脑的台数。<br>　　第二行包含n - 1个整数，分别表示第2、3、……、n台交换机所连接的比自己上一层的交换机的编号。第i台交换机所连接的上一层的交换机编号一定比自己的编号小。<br>　　第三行包含m个整数，分别表示第1、2、……、m台终端电脑所连接的交换机的编号。</p>
<p>输出格式<br>　　输出一个整数，表示消息传递最多需要的步数。</p>
<p>样例输入</p>
<p>4 2</p>
<p>1 1 3</p>
<p>2 1</p>
<p>样例输出</p>
<p>4</p>
<p>样例说明<br>　　样例的网络连接模式如下，其中圆圈表示交换机，方框表示电脑：</p>
<p>　　其中电脑1与交换机4之间的消息传递花费的时间最长，为4个单位时间。<br><img src="http://118.190.20.162/RequireFile.do?fid=F9GfBRHL" alt="image"><br>样例输入</p>
<p>4 4</p>
<p>1 2 2</p>
<p>3 4 4 4</p>
<p>样例输出</p>
<p>4</p>
<p>评测用例规模与约定</p>
<p>　　前30%的评测用例满足：n ≤ 5, m ≤ 5。<br>　　前50%的评测用例满足：n ≤ 20, m ≤ 20。<br>　　前70%的评测用例满足：n ≤ 100, m ≤ 100。<br>　　所有评测用例都满足：1 ≤ n ≤ 10000，1 ≤ m ≤ 10000。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这是一个树的问题，求树的直径，即在树中找出两个结点，使得这两个结点间的距离最长，这个最长距离称为直径。一般可以用两次DFS或BFS来实现，在树上任意选取1个结点s，先用DFS或BFS找到距离s距离最远的结点start，然后再从结点start开始，再次用DFS或BFS找到距离s距离最远的结点，得到结果。</p>
<p>程序说明：树用邻接结点来存储，使用STL的向量数组vector<int> tree[]来表示，tree[i]中的存储从结点i能够到达的各个结点。其他说明参见源程序。</int></p>
<p>用整数表示结点，结点号是不允许重复的。终端电脑的变化从n+1开始，依次类推。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 10000+10</span><br><span class="line"></span><br><span class="line">void dfs(int now,int last,int dis[],vector&lt;int&gt; v[])&#123;</span><br><span class="line">	int u;</span><br><span class="line">	for(int i=0;i&lt;v[now].size();i++)&#123;</span><br><span class="line">		if((u=v[now][i])!=last) &#123;</span><br><span class="line">			dis[u]=dis[now]+1;</span><br><span class="line">			dfs(u,now,dis,v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int k,t;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	vector&lt;int&gt; v[n+m+2];//!! 数组空间 如果用max 会提示运行错误 </span><br><span class="line">	int dis[n+m+2];</span><br><span class="line">	for(int i=2;i&lt;n+1;i++)&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		v[i].push_back(k);</span><br><span class="line">		v[k].push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;//!! 等于号 </span><br><span class="line">		cin&gt;&gt;t;</span><br><span class="line">		v[n+i].push_back(t);</span><br><span class="line">		v[t].push_back(n+i);</span><br><span class="line">	&#125;</span><br><span class="line">	memset(dis,0,sizeof(dis));</span><br><span class="line">	dfs(1,0,dis,v);</span><br><span class="line">	int maxn=0,mark=0;</span><br><span class="line">	for(int i=1;i&lt;n+m+2;i++)&#123;</span><br><span class="line">		if(dis[i]&gt;maxn)&#123;</span><br><span class="line">			mark=i;</span><br><span class="line">			maxn=dis[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	memset(dis,0,sizeof(dis));</span><br><span class="line">	dfs(mark,0,dis,v);</span><br><span class="line">	int mm=0;</span><br><span class="line">		for(int i=1;i&lt;n+m+2;i++)&#123;</span><br><span class="line">		if(dis[i]&gt;mm)&#123;</span><br><span class="line">			mm=dis[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;mm&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>201703-1 分蛋糕</title>
    <url>/2018/11/06/201703-1-%E5%88%86%E8%9B%8B%E7%B3%95/</url>
    <content><![CDATA[<p>问题描述<br>　<br> 小明今天生日，他有n块蛋糕要分给朋友们吃，这n块蛋糕（编号为1到n）的重量分别为a1, a2, …, an。小明想分给每个朋友至少重量为k的蛋糕。小明的朋友们已经排好队准备领蛋糕，对于每个朋友，小明总是先将自己手中编号最小的蛋糕分给他，当这个朋友所分得蛋糕的重量不到k时，再继续将剩下的蛋糕中编号最小的给他，直到小明的蛋糕分完或者这个朋友分到的蛋糕的总重量大于等于k。<br><a id="more"></a><br>请问当小明的蛋糕分完时，总共有多少个朋友分到了蛋糕。</p>
<p>输入格式<br>　　输入的第一行包含了两个整数n, k，意义如上所述。<br>　　第二行包含n个正整数，依次表示a1, a2, …, an。</p>
<p>输出格式<br>　　输出一个整数，表示有多少个朋友分到了蛋糕。</p>
<p>样例输入<br>6 9<br>2 6 5 6 3 5</p>
<p>样例输出<br>3</p>
<p>样例说明<br>　　第一个朋友分到了前3块蛋糕，第二个朋友分到了第4、5块蛋糕，第三个朋友分到了最后一块蛋糕。<br>评测用例规模与约定<br>　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 10000，1 ≤ ai ≤ 1000。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAXN 100</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,k,sum=0,f=0;</span><br><span class="line">	int a[1000];</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		sum+=a[i];</span><br><span class="line">		if(sum&lt;k&amp;&amp;i==n-1) f++;</span><br><span class="line">		if(sum&gt;=k) &#123;</span><br><span class="line">		</span><br><span class="line">			f++;</span><br><span class="line">			sum=0;</span><br><span class="line">		&#125;</span><br><span class="line">		 </span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;f&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>2018-03-3 URL映射</title>
    <url>/2019/03/04/2018-03-3-URL%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　URL 映射是诸如 Django、Ruby on Rails 等网页框架 (web frameworks) 的一个重要组件。对于从浏览器发来的 HTTP 请求，URL 映射模块会解析请求中的 URL 地址，并将其分派给相应的处理代码。现在，请你来实现一个简单的 URL 映射功能。<br>　　本题中 URL 映射功能的配置由若干条 URL 映射规则组成。当一个请求到达时，URL 映射功能会将请求中的 URL 地址按照配置的先后顺序逐一与这些规则进行匹配。当遇到第一条完全匹配的规则时，匹配成功，得到匹配的规则以及匹配的参数。若不能匹配任何一条规则，则匹配失败。<br>　　本题输入的 URL 地址是以斜杠 / 作为分隔符的路径，保证以斜杠开头。其他合法字符还包括大小写英文字母、阿拉伯数字、减号 -、下划线 _ 和小数点 .。例如，/person/123/ 是一个合法的 URL 地址，而 /person/123? 则不合法（存在不合法的字符问号 ?）。另外，英文字母区分大小写，因此 /case/ 和 /CAse/ 是不同的 URL 地址。<br>　　对于 URL 映射规则，同样是以斜杠开始。除了可以是正常的 URL 地址外，还可以包含参数，有以下 3 种：<br>　　字符串 <str>：用于匹配一段字符串，注意字符串里不能包含斜杠。例如，abcde0123。<br>　　整数 <int>：用于匹配一个不带符号的整数，全部由阿拉伯数字组成。例如，01234。<br>　　路径 <path>：用于匹配一段字符串，字符串可以包含斜杠。例如，abcd/0123/。<br>　　以上 3 种参数都必须匹配非空的字符串。简便起见，题目规定规则中 <str> 和 <int> 前面一定是斜杠，后面要么是斜杠，要么是规则的结束（也就是该参数是规则的最后一部分）。而 <path> 的前面一定是斜杠，后面一定是规则的结束。无论是 URL 地址还是规则，都不会出现连续的斜杠。<br><a id="more"></a><br>输入格式</path></int></str></path></int></str></p>
<p>　　输入第一行是两个正整数 n 和 m，分别表示 URL 映射的规则条数和待处理的 URL 地址个数，中间用一个空格字符分隔。<br>　　第 2 行至第 n+1 行按匹配的先后顺序描述 URL 映射规则的配置信息。第 i+1 行包含两个字符串 pi 和 ri，其中 pi 表示 URL 匹配的规则，ri 表示这条 URL 匹配的名字。两个字符串都非空，且不包含空格字符，两者中间用一个空格字符分隔。<br>　　第 n+2 行至第 n+m+1 行描述待处理的 URL 地址。第 n+1+i 行包含一个字符串 qi，表示待处理的 URL 地址，字符串中不包含空格字符。</p>
<p>输出格式</p>
<p>　　输入共 m 行，第 i 行表示 qi 的匹配结果。如果匹配成功，设匹配了规则 pj ，则输出对应的 rj。同时，如果规则中有参数，则在同一行内依次输出匹配后的参数。注意整数参数输出时要把前导零去掉。相邻两项之间用一个空格字符分隔。如果匹配失败，则输出 404。</p>
<p>样例输入</p>
<p>5 4<br>/articles/2003/ special_case_2003<br>/articles/<int>/ year_archive<br>/articles/<int>/<int>/ month_archive<br>/articles/<int>/<int>/<str>/ article_detail<br>/static/<path> static_serve<br>/articles/2004/<br>/articles/1985/09/aloha/<br>/articles/hello/<br>/static/js/jquery.js</path></str></int></int></int></int></int></p>
<p>样例输出</p>
<p>year_archive 2004<br>article_detail 1985 9 aloha<br>404<br>static_serve js/jquery.js</p>
<p>样例说明</p>
<p>　　对于第 1 个地址 /articles/2004/，无法匹配第 1 条规则，可以匹配第 2 条规则，参数为 2004。<br>　　对于第 2 个地址 /articles/1985/09/aloha/，只能匹配第 4 条规则，参数依次为 1985、9（已经去掉前导零）和 aloha。<br>　　对于第 3 个地址 /articles/hello/，无法匹配任何一条规则。<br>　　对于第 4 个地址 /static/js/jquery.js，可以匹配最后一条规则，参数为 js/jquery.js。</p>
<p>数据规模和约定</p>
<p>　　1 ≤ n ≤ 100，1 ≤ m ≤ 100。<br>　　所有输入行的长度不超过 100 个字符（不包含换行符）。<br>　　保证输入的规则都是合法的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">bool legal(char *s)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;strlen(s);i++)//如果不是合法的 URL地址返回false </span><br><span class="line">	   if(s[i]!=&apos;/&apos;&amp;&amp;s[i]!=&apos;.&apos;&amp;&amp;s[i]!=&apos;-&apos;&amp;&amp;s[i]!=&apos;_&apos;&amp;&amp;!(isalpha(s[i])||isdigit(s[i])))</span><br><span class="line">		return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool int_right(string s) //判断一个字符串是全为数字 </span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;s.length();i++)</span><br><span class="line">	  if(!isdigit(s[i]))</span><br><span class="line">	    return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">struct Rule&#123; //规则 </span><br><span class="line">	vector&lt;string&gt;rule;//存储规则</span><br><span class="line">	string name;//匹配的名字 </span><br><span class="line">	bool flag;//规则结尾是否有 / ，有则为true否则为flase </span><br><span class="line">&#125;r[105];</span><br><span class="line"> </span><br><span class="line">vector&lt;string&gt;url;//存储输入的url路径</span><br><span class="line">vector&lt;string&gt;para;//存储参数 </span><br><span class="line"> </span><br><span class="line">int n; //规则的个数</span><br><span class="line"> </span><br><span class="line">void init() //初始化把规则和匹配名存储在向量中 </span><br><span class="line">&#123;</span><br><span class="line">	string tmp;</span><br><span class="line">	char a[110];//临时字符数组</span><br><span class="line">	int pos=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		scanf(&quot;%s&quot;,a);//读入url规则</span><br><span class="line">		int end=strlen(a);</span><br><span class="line">		if(end&gt;0&amp;&amp;a[end-1]==&apos;/&apos;)</span><br><span class="line">		  r[pos].flag=true;</span><br><span class="line">		else</span><br><span class="line">		  r[pos].flag=false;</span><br><span class="line">		cin&gt;&gt;r[pos].name;//读入url匹配名 </span><br><span class="line">		char *sp=strtok(a,&quot;/&quot;);//以斜杠分割字符串 </span><br><span class="line">		while(sp)&#123;</span><br><span class="line">			r[pos].rule.push_back(sp);</span><br><span class="line">			sp=strtok(NULL,&quot;/&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		pos++;</span><br><span class="line">	&#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">bool postfix;//输入的URL地址的后缀是否有 / </span><br><span class="line"> </span><br><span class="line">void match(char *a) //判断url地址（字符数组a存储的）是否匹配已有的规则 </span><br><span class="line">&#123;</span><br><span class="line">	url.clear();//清空存储url的向量 </span><br><span class="line">	char *sp=strtok(a,&quot;/&quot;);//以斜杠分割字符串,并存储在url向量中 </span><br><span class="line">	while(sp)&#123;</span><br><span class="line">		url.push_back(sp);</span><br><span class="line">		sp=strtok(NULL,&quot;/&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	//匹配</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;//匹配现有的 n 条规则 </span><br><span class="line">	    int j,k;//k表示url的段编号 </span><br><span class="line">	    para.clear();//清空存储参数的向量</span><br><span class="line">	    bool flag=true;</span><br><span class="line">		for(j=0,k=0;j&lt;r[i].rule.size()&amp;&amp;k&lt;url.size();j++,k++)&#123;//每条规则被分割成了r[i].rule.size()段 </span><br><span class="line">		    string s=r[i].rule[j]; </span><br><span class="line">			//情况一 </span><br><span class="line">			if(s==&quot;&lt;int&gt;&quot;)&#123;</span><br><span class="line">				if(!int_right(url[k]))&#123;//如果它不是数字串的话，匹配失败 </span><br><span class="line">					flag=false;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				else&#123;//去掉前导0</span><br><span class="line">				    string str=url[k];</span><br><span class="line">				    int t;</span><br><span class="line">                    for(t=0;t&lt;str.length()-1&amp;&amp;str[t]==&apos;0&apos;;t++);</span><br><span class="line">                    str=str.substr(t);</span><br><span class="line">				    if(str!=&quot;&quot;)</span><br><span class="line">					  para.push_back(str);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//情况二 </span><br><span class="line">		    else if(s==&quot;&lt;str&gt;&quot;)</span><br><span class="line">		    	para.push_back(url[k]);</span><br><span class="line">		    //情况三 </span><br><span class="line">		    else if(s==&quot;&lt;path&gt;&quot;)&#123;</span><br><span class="line">		    	string tmp=url[k++];</span><br><span class="line">		    	for(;k&lt;url.size();k++)</span><br><span class="line">		    	  tmp=tmp+&quot;/&quot;+url[k];</span><br><span class="line">		    	if(postfix)</span><br><span class="line">		    	  tmp+=&quot;/&quot;;</span><br><span class="line">		    	para.push_back(tmp);</span><br><span class="line">			&#125;</span><br><span class="line">			//情况四</span><br><span class="line">			else&#123;</span><br><span class="line">				if(s!=url[k])&#123;</span><br><span class="line">					flag=false;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			  &#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		if(flag&amp;&amp;j&gt;=r[i].rule.size()&amp;&amp;k&gt;=url.size()&amp;&amp;r[i].flag==postfix)&#123;</span><br><span class="line">			cout&lt;&lt;r[i].name;</span><br><span class="line">			for(int ii=0;ii&lt;para.size();ii++)</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;404&quot;&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int m;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	init();//初始化存储n条url规则</span><br><span class="line">	while(m--)&#123;</span><br><span class="line">		char a[110];//临时字符数组</span><br><span class="line">		scanf(&quot;%s&quot;,&amp;a);//读入url地址</span><br><span class="line">		int end=strlen(a);</span><br><span class="line">		if(end&gt;0&amp;&amp;a[end-1]==&apos;/&apos;)</span><br><span class="line">		  postfix=true;</span><br><span class="line">		else</span><br><span class="line">		  postfix=false;</span><br><span class="line">		if(!legal(a))&#123;//如果不是合法的url地址 </span><br><span class="line">			cout&lt;&lt;&quot;404&quot;&lt;&lt;endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		match(a);</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 680. Valid Palindrome II</title>
    <url>/2018/11/25/208/</url>
    <content><![CDATA[<p>Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.<br><a id="more"></a><br>Example 1:</p>
<p>Input: “aba”</p>
<p>Output: True</p>
<p>Example 2:</p>
<p>Input: “abca”</p>
<p>Output: True</p>
<p>Explanation: You could delete the character ‘c’.</p>
<p>Note:</p>
<p>The string will only contain lowercase characters a-z. The maximum length of the string is 50000.</p>
<p><code>`</code><br>class Solution {<br>public:<br>    bool validPalindrome(string s) {<br>        int i=0,j=s.length()-1;<br>        while(i&lt;j){<br>            if(s[i]==s[j]){<br>                i++;j–;<br>            }<br>            else return isvalid(s,i+1,j)||isvalid(s,i,j-1);<br>        }<br>        return true;<br>    }<br>    bool isvalid(string s,int i,int j){<br>        while(i&lt;j){<br>            if(s[i]==s[j]){<br>                i++;j–;<br>            }<br>            else return false;<br>        }<br>        return true;<br>    }</p>
<p>};</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>HDU4506 小明系列故事——师兄帮帮忙【水题】</title>
    <url>/2018/12/10/4506/</url>
    <content><![CDATA[<p>Problem Description<br>　　小明自从告别了ACM/ICPC之后，就开始潜心研究数学问题了，一则可以为接下来的考研做准备，再者可以借此机会帮助一些同学，尤其是漂亮的师妹。这不，班里唯一的女生又拿一道数学题来请教小明，小明当然很高兴的就接受了。不过等他仔细读题以后，发现自己也不会做，这下小明囧了：如果回复说自己不懂，岂不是很没面子？<br>  <a id="more"></a><br>　　所以，他现在私下求你帮忙解决这道题目，题目是这样的：</p>
<p>　　给你n个数字，分别是a1,a2,a3,a4,a5……an，这些数字每过一个单位时间就会改变，假设上一个单位时间的数字为a1’,a2’,a3’……an’，那么这个单位时间的数字a[i] = a[i - 1]’ <em> K(i == 1的时候a[1] = a[n]’ </em> K)，其中K为给定的系数。</p>
<p>　　现在的问题就是求第t单位时间的时候这n个数字变成了什么了？由于数字可能会很大，所以只要你输出数字对10^9 + 7取余以后的结果。</p>
<p>Input<br>　　输入数据第一行是一个正整数T，表示有T组测试数据；<br>　　每组数据有两行，第一行包含输入三个整数n, t, k，其中n代表数字个数，t代表第t个单位时间，k代表系数；第二行输入n个数字ai，代表每个数字开始的时候是多少。</p>
<p>　</p>
<p> [Technical Specification]<br>　<br> T &lt;= 100<br>　<br> 1 &lt;= n &lt;= 10 ^ 4<br>　<br> 0 &lt;= t &lt;= 10 ^ 9　　其中 t = 0 表示初始状态<br>　<br> 1 &lt;= k &lt;= 10 ^ 9<br>　<br> 1 &lt;= ai&lt;= 10 ^ 9</p>
<p>Output<br>　　对于每组数据请输出第t单位时间后这n个数字变成了什么，输出的时候每两个数字之间输出一个空格，行末不要输出多余的空格，具体见样例。</p>
<p>Sample Input<br>2 </p>
<p>3 2 5</p>
<p>1 2 3</p>
<p>3 0 5 </p>
<p>1 2 3</p>
<p>Sample Output</p>
<p>50 75 25</p>
<p>1 2 3</p>
<p>注意 用Longlong 不能溢出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long b[20000];</span><br><span class="line">  long long powermod( unsigned long long a, unsigned long long n, unsigned long long k)</span><br><span class="line">&#123;</span><br><span class="line">long long res=1;</span><br><span class="line">while(n)&#123;</span><br><span class="line">	if(n&amp;1)&#123;</span><br><span class="line">	res*=a;</span><br><span class="line">	res%=k;</span><br><span class="line">	&#125; </span><br><span class="line">	a*=a;</span><br><span class="line">	a%=k;</span><br><span class="line">	n&gt;&gt;=1; </span><br><span class="line">&#125;</span><br><span class="line">return res; </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	long long mm=1000000007;</span><br><span class="line">	int cases;</span><br><span class="line">	 long long num,t,val,k;</span><br><span class="line">	cin&gt;&gt;cases;</span><br><span class="line">	while(cases--)&#123;</span><br><span class="line">	cin&gt;&gt;num&gt;&gt;t&gt;&gt;k;</span><br><span class="line">long long tmp= powermod(k,t,mm);</span><br><span class="line">	for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">		cin&gt;&gt;val;</span><br><span class="line">		b[(i+t)%num]=val*tmp%mm;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">		cout&lt;&lt;b[i];</span><br><span class="line">		if(i!=num-1) cout&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hdu</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 566. Reshape the Matrix</title>
    <url>/2018/12/05/566-1/</url>
    <content><![CDATA[<p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p>
<p>You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.</p>
<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>
<p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
<p>Example 1:</p>
<p>Input: </p>
<p>nums = </p>
<p>[[1,2],</p>
<p>[3,4]]<br>r = 1, c = 4</p>
<p>Output: </p>
<p>[[1,2,3,4]]</p>
<p>Explanation:</p>
<p>The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</p>
<p>Example 2:<br><a id="more"></a><br>Input: </p>
<p>nums = </p>
<p>[[1,2],</p>
<p>[3,4]]</p>
<p>r = 2, c = 4</p>
<p>Output: </p>
<p>[[1,2],</p>
<p>[3,4]]</p>
<p>Explanation:</p>
<p>There is no way to reshape a 2 <em> 2 matrix to a 2 </em> 4 matrix. So output the original matrix.</p>
<p>Note:</p>
<p>The height and width of the given matrix is in range [1, 100].</p>
<p>The given r and c are all positive.<br>坐标映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) &#123;</span><br><span class="line">        int m=nums.size();</span><br><span class="line">        int n=nums[0].size();</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; news(r,vector&lt;int&gt;(c));</span><br><span class="line">        if(m*n!=r*c) &#123;</span><br><span class="line">            news=nums;</span><br><span class="line">            return news;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">                vec.push_back(nums[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;r;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;c;j++)</span><br><span class="line">                news[i][j]=vec[i*c+j];</span><br><span class="line">        &#125;</span><br><span class="line">        return news;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) &#123;</span><br><span class="line">        int m=nums.size();</span><br><span class="line">        int n=nums[0].size();</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; news(r,vector&lt;int&gt;(c));</span><br><span class="line">        if(m*n!=r*c) &#123;</span><br><span class="line">            news=nums;</span><br><span class="line">            return news;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        for(int i=0;i&lt;m*n;i++)&#123;</span><br><span class="line">            int srcx=i/n;</span><br><span class="line">            int srcy=i%n;</span><br><span class="line">            int destx=i/c;</span><br><span class="line">            int desty=i%c;</span><br><span class="line">            news[destx][desty]=nums[srcx][srcy];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return news;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>53-C++ CH08 01</title>
    <url>/2018/12/23/53-C-CH08-01/</url>
    <content><![CDATA[<p>问题描述</p>
<p>已知一个有理数类Zrf_Ratio，实现如下的操作符重载形式：<br>　　friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const zrf_Ratio&amp;);//输出最简分数<br>　　friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, zrf_Ratio&amp;);<br>　　friend bool operator==(const zrf_Ratio&amp;, const zrf_Ratio&amp;);<br>　　friend bool operator&lt;(const zrf_Ratio&amp;, const zrf_Ratio&amp;);<br><a id="more"></a><br>测试</p>
<p>测试时主程序会输入四个整数a, b, c, d，表示两个分数a/b和c/d。要求输出最简分数以及两个分数相等和大小的比较结果。</p>
<p>样例输入</p>
<p>1 7 26 25</p>
<p>样例输出</p>
<p>zrf is:1/7; ssh is:26/25</p>
<p>(zrf==ssh) is:0; (zrf&lt;ssh) is:1</p>
<p>填空题 看清题目 已知一个有理数类<br>补充代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const zrf_Ratio&amp; p)//输出最简分数</span><br><span class="line">&#123;</span><br><span class="line">	os&lt;&lt;p.num&lt;&lt;&quot;/&quot;&lt;&lt;p.den;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; operator&gt;&gt;(std::istream&amp; is, zrf_Ratio&amp; p)&#123;</span><br><span class="line"> 	</span><br><span class="line"> 	is&gt;&gt;p.num&gt;&gt;p.den;</span><br><span class="line"> 	return is;</span><br><span class="line"> &#125;</span><br><span class="line">bool operator==(const zrf_Ratio&amp; p, const zrf_Ratio&amp; q)&#123;</span><br><span class="line"> 	</span><br><span class="line">	 </span><br><span class="line">	 if(p.num*(1.0)/p.den==q.num*(1.0)/q.den) return true;</span><br><span class="line"> 	return false;</span><br><span class="line"> 	</span><br><span class="line">&#125;</span><br><span class="line">bool operator&lt;(const zrf_Ratio&amp; p, const zrf_Ratio&amp; q)&#123;</span><br><span class="line">	return  p.num*(1.0)/p.den&lt;q.num*(1.0)/q.den;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整程序<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;cassert&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">class zrf_Ratio</span><br><span class="line">&#123;</span><br><span class="line">     friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const zrf_Ratio&amp;);</span><br><span class="line">     friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, zrf_Ratio&amp;);</span><br><span class="line">     friend bool operator==(const zrf_Ratio&amp;, const zrf_Ratio&amp;);</span><br><span class="line">     friend bool operator&lt;(const zrf_Ratio&amp;, const zrf_Ratio&amp;);</span><br><span class="line">public:</span><br><span class="line">     zrf_Ratio(int=0,int=1);</span><br><span class="line">     zrf_Ratio(const zrf_Ratio&amp;);</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line">     int num;</span><br><span class="line">     int den;</span><br><span class="line">     void reduce();//化为最简分数</span><br><span class="line">&#125;;</span><br><span class="line">//补充完整构造函数</span><br><span class="line">ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const zrf_Ratio&amp; p)//输出最简分数</span><br><span class="line">&#123;</span><br><span class="line">	// cout&lt;&lt;p</span><br><span class="line">//	int t=zrf_Gcd(p.num,p.den);</span><br><span class="line">	os&lt;&lt;p.num&lt;&lt;&quot;/&quot;&lt;&lt;p.den;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; operator&gt;&gt;(std::istream&amp; is, zrf_Ratio&amp; p)&#123;</span><br><span class="line"> 	</span><br><span class="line"> 	is&gt;&gt;p.num&gt;&gt;p.den;</span><br><span class="line"> 	return is;</span><br><span class="line"> &#125;</span><br><span class="line">bool operator==(const zrf_Ratio&amp; p, const zrf_Ratio&amp; q)&#123;</span><br><span class="line"> 	</span><br><span class="line">	 </span><br><span class="line">	 if(p.num*(1.0)/p.den==q.num*(1.0)/q.den) return true;</span><br><span class="line"> 	return false;</span><br><span class="line"> 	</span><br><span class="line">&#125;</span><br><span class="line">bool operator&lt;(const zrf_Ratio&amp; p, const zrf_Ratio&amp; q)&#123;</span><br><span class="line">	return  p.num*(1.0)/p.den&lt;q.num*(1.0)/q.den;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//公有成员函数:</span><br><span class="line">zrf_Ratio::zrf_Ratio(int num, int den) : num(num), den(den)</span><br><span class="line">&#123;</span><br><span class="line">     reduce();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">zrf_Ratio::zrf_Ratio(const zrf_Ratio&amp; r) : num(r.num), den(r.den)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//私有成员函数:</span><br><span class="line">void swap(int &amp;m, int &amp;n)</span><br><span class="line">&#123;   </span><br><span class="line">     int t;       </span><br><span class="line">     t=m;    </span><br><span class="line">     m=n;    </span><br><span class="line">     n=t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int zrf_Gcd(int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">     if (m&lt;n)</span><br><span class="line">         swap(m,n);</span><br><span class="line">     assert(n&gt;=0);</span><br><span class="line">     while (n&gt;0) </span><br><span class="line">     &#123;</span><br><span class="line">         int r=m%n;  </span><br><span class="line">         m = n;   </span><br><span class="line">         n = r;</span><br><span class="line">     &#125;</span><br><span class="line">     return m;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void zrf_Ratio::reduce()</span><br><span class="line">&#123;</span><br><span class="line">     if (num == 0 || den == 0) </span><br><span class="line">     &#123;</span><br><span class="line">         num = 0;  </span><br><span class="line">         den = 1;  </span><br><span class="line">         return; </span><br><span class="line">     &#125;</span><br><span class="line">     if (den &lt; 0)</span><br><span class="line">     &#123;</span><br><span class="line">         den *= -1;  </span><br><span class="line">         num *= -1;</span><br><span class="line">     &#125;</span><br><span class="line">     if (num == 1)</span><br><span class="line">         return;</span><br><span class="line">     int sgn = (num&lt;0?-1:1);</span><br><span class="line">     int g = zrf_Gcd(sgn*num,den);</span><br><span class="line">     num /= g; </span><br><span class="line">     den /= g;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     int a = 0, b = 0, c = 0, d = 0;</span><br><span class="line">     cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">     zrf_Ratio zrf(a, b),ssh(c, d);</span><br><span class="line">     std::cout&lt;&lt;&quot;zrf is:&quot;&lt;&lt;zrf&lt;&lt;&quot;; ssh is:&quot;&lt;&lt;ssh&lt;&lt;&apos;\n&apos; ;</span><br><span class="line">     std::cout&lt;&lt;&quot;(zrf==ssh) is:&quot;&lt;&lt;(zrf==ssh)&lt;&lt;&quot;; (zrf&lt;ssh) is:&quot;&lt;&lt;(zrf&lt;ssh) &lt;&lt;endl;</span><br><span class="line">     return 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 675  Cut Off Trees for Golf Event</title>
    <url>/2018/12/05/675/</url>
    <content><![CDATA[<p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:</p>
<p>0 represents the obstacle can’t be reached.<br>1 represents the ground can be walked through.<br>The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height.<br>You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).<br><a id="more"></a><br>You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.</p>
<p>You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.</p>
<p>Example 1:<br>Input: </p>
<p>[</p>
<p>[1,2,3],</p>
<p>[0,0,4],</p>
<p>[7,6,5]</p>
<p>]</p>
<p>Output: 6</p>
<p>Example 2:</p>
<p>Input: </p>
<p>[</p>
<p>[1,2,3],</p>
<p>[0,0,0],</p>
<p>[7,6,5]</p>
<p>]</p>
<p>Output: -1</p>
<p>Example 3:</p>
<p>Input: </p>
<p>[</p>
<p>[2,3,4],</p>
<p>[0,0,5],</p>
<p>[8,7,6]</p>
<p>]</p>
<p>Output: 6</p>
<p>Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">int h, x, y;</span><br><span class="line">node( int hh, int xx, int yy ) : h( hh ), x( xx ), y( yy )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">bool operator &lt; (node p) const &#123;</span><br><span class="line">    return(h &lt; p.h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">int	dir[4][2] = &#123; &#123; -1, 0 &#125;, &#123; 1, 0 &#125;, &#123; 0, 1 &#125;, &#123; 0, -1 &#125; &#125;;</span><br><span class="line">class	Solution &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">	int m, n;</span><br><span class="line">	int cutOffTree( vector&lt;vector&lt;int&gt; &gt; &amp; forest )</span><br><span class="line">	&#123;</span><br><span class="line">		m	= forest.size();</span><br><span class="line">		n	= forest[0].size();</span><br><span class="line">         vector&lt;node&gt; v;</span><br><span class="line">		for ( int i = 0; i &lt; m; i++ )</span><br><span class="line">		&#123;</span><br><span class="line">			for ( int j = 0; j &lt; n; j++ )</span><br><span class="line">			&#123;</span><br><span class="line">				if ( forest[i][j] &gt; 1 )</span><br><span class="line">					v.push_back( node( forest[i][j], i, j ) );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort( v.begin(), v.end() );</span><br><span class="line">       </span><br><span class="line">		int	totalstep	= 0;</span><br><span class="line">		int	sr		= 0, sc = 0;</span><br><span class="line">		int	destx, desty;</span><br><span class="line">		for ( int i = 0; i &lt; v.size(); i++ )</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			destx	= v[i].x;</span><br><span class="line">			desty	= v[i].y;</span><br><span class="line">			int step	= bfs( forest, sr, sc, destx, desty );</span><br><span class="line">			if ( step == -1 )</span><br><span class="line">				return -1;</span><br><span class="line"></span><br><span class="line">			sr  = v[i].x;</span><br><span class="line">			sc		= v[i].y;</span><br><span class="line">			totalstep	+= step;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		return(totalstep);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	int bfs( vector&lt;vector&lt;int&gt; &gt; &amp; forest, int sr, int sc, int destx, int desty )</span><br><span class="line">    &#123;</span><br><span class="line">         vector&lt;vector&lt;int&gt; &gt; vis(m,vector&lt;int&gt;(n,0));</span><br><span class="line">		int step = 0;</span><br><span class="line"></span><br><span class="line">		queue&lt;pair&lt;int, int&gt; &gt; q;</span><br><span class="line">		q.push( pair&lt;int, int&gt;&#123; sr, sc &#125; );</span><br><span class="line">		while ( !q.empty() )</span><br><span class="line">		&#123;</span><br><span class="line">			int size = q.size();</span><br><span class="line">			while ( size-- )//size:一步可到达的节点个数</span><br><span class="line">			&#123;</span><br><span class="line">				pair&lt;int, int&gt; index = q.front();</span><br><span class="line">				q.pop();</span><br><span class="line">				int	x	= index.first;</span><br><span class="line">				int	y	= index.second;</span><br><span class="line">                          if (x == destx &amp;&amp; y == desty )//!!</span><br><span class="line">						return(step);</span><br><span class="line">                </span><br><span class="line">                vis[x][y]=true;</span><br><span class="line">                </span><br><span class="line">				for ( int j = 0; j &lt; 4; j++ )</span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line">					int	newx	= x + dir[j][0];</span><br><span class="line">					int	newy	= y + dir[j][1];</span><br><span class="line"></span><br><span class="line">					if ( newx &gt;= 0 &amp;&amp;</span><br><span class="line">					     newx &lt; m &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; n&amp;&amp;!vis[newx][newy]&amp;&amp;forest[newx][newy]   )</span><br><span class="line"></span><br><span class="line">					&#123;</span><br><span class="line">						q.push( pair&lt;int, int&gt;&#123; newx, newy &#125; );</span><br><span class="line">						vis[newx][newy] = true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			step++;</span><br><span class="line">		&#125;</span><br><span class="line">			return(-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 681. Next Closest Time</title>
    <url>/2018/11/27/681/</url>
    <content><![CDATA[<p>You may assume the given input string is always valid. For example, “01:34”, “12:09” are all valid. “1:34”, “12:9” are all invalid.</p>
<!--mroe-->
<p>Example 1:</p>
<p>Input: “19:34”</p>
<p>Output: “19:39”</p>
<p>Explanation: The next closest time choosing from digits 1, 9, 3, 4, is 19:39,<br>which occurs 5 minutes later.  </p>
<p>It is not 19:33, because this occurs 23 hours and 59 minutes later.</p>
<p>Example 2:</p>
<p>Input: “23:59”</p>
<p>Output: “22:22”</p>
<p>Explanation: The next closest time choosing from digits 2, 3, 5, 9, is 22:22.<br>It may be assumed that the returned time is next day’s time since it is smaller<br>than the input time numerically.</p>
<h2 id="法一-暴力法"><a href="#法一-暴力法" class="headerlink" title="法一 暴力法"></a>法一 暴力法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string nextCloseTime(string time)</span><br><span class="line">&#123;</span><br><span class="line">	//!!</span><br><span class="line">	set&lt;char&gt; t(time.begin(),time.end());</span><br><span class="line">	int hour=stoi(time.substr(0,2));</span><br><span class="line">	int min=stoi(time.substr(3,2));</span><br><span class="line">	char str[5];</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		min++;</span><br><span class="line">		if(min==60)&#123;</span><br><span class="line">			min=0;</span><br><span class="line">			hour=(hour+1)%24;</span><br><span class="line">		&#125;</span><br><span class="line">		sprintf(str,&quot;%02d:%02d&quot;,hour,min);</span><br><span class="line">		set&lt;char&gt; s(str,str+sizeof(str));</span><br><span class="line">		//比较是排好序的两个序列 </span><br><span class="line">		if(includes(t.begin(),t.end(),s.begin(),s.end())) break;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	string ans=(string)str;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">string p=&quot;19:34&quot;;</span><br><span class="line">string ans=nextCloseTime(p);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二-dfs"><a href="#法二-dfs" class="headerlink" title="法二 dfs"></a>法二 dfs</h2><p>用best表示与当前时间相差的分钟数 维护best</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#define INT_MAX 0xffff</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void dfs(int depth,int &amp;best,int curr[],int digits[],int &amp;ans)&#123;</span><br><span class="line"></span><br><span class="line">	if(depth==4)&#123;</span><br><span class="line">		if(curr[0]*10+curr[1]&gt;24) return;</span><br><span class="line">		if(curr[2]*10+curr[3]&gt;59) return;</span><br><span class="line">		int curtime=(curr[0]*10+curr[1])*60+curr[2]*10+curr[3];</span><br><span class="line">		int pastime=(digits[0]*10+digits[1])*60+digits[2]*10+digits[3];</span><br><span class="line">		int tt=(curtime-pastime+24*60)%(24*60);</span><br><span class="line">		if(curtime==pastime) tt=24*60;</span><br><span class="line">		if(tt&lt;best) </span><br><span class="line">		&#123;</span><br><span class="line">			best=tt;			</span><br><span class="line">		    ans=curtime;		  </span><br><span class="line">		&#125;	</span><br><span class="line">	  return;</span><br><span class="line">	&#125;</span><br><span class="line">    else&#123;</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">	curr[depth]=digits[i];</span><br><span class="line">	dfs(depth+1,best,curr,digits,ans); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">string nextCloseTime(string time)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int hour=(int)stoi(time.substr(0,2));</span><br><span class="line">int min=(int)stoi(time.substr(3,2));</span><br><span class="line">int digits[4]=&#123;hour/10,hour%10,min/10,min%10&#125;;</span><br><span class="line">int best=INT_MAX;</span><br><span class="line">int curr[5];</span><br><span class="line">int dep=0;</span><br><span class="line">int ans;</span><br><span class="line">dfs(dep,best,curr,digits,ans);</span><br><span class="line">char buff[5];</span><br><span class="line">sprintf(buff, &quot;%02d:%02d&quot;, ans/60, ans%60);</span><br><span class="line">return (string)buff;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">string p=&quot;23:59&quot;;</span><br><span class="line">string ans=nextCloseTime(p);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接</p>
<p><a href="https://zxi.mytechroad.com/blog/?s=681" target="_blank" rel="noopener">https://zxi.mytechroad.com/blog/?s=681</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>HDU5701 中位数计数【中位数+水题】</title>
    <url>/2018/12/10/5701/</url>
    <content><![CDATA[<p>Problem Description<br>中位数定义为所有值从小到大排序后排在正中间的那个数，如果值有偶数个，通常取最中间的两个数值的平均数作为中位数。</p>
<p>现在有个数，每个数都是独一无二的，求出每个数在多少个包含其的区间中是中位数。</p>
<a id="more"></a>
<p>Input<br>多组测试数据</p>
<p>第一行一个数</p>
<p>第二行个数，每个数,</p>
<p>Output<br>个数，依次表示第个数在多少包含其的区间中是中位数。</p>
<p>Sample Input</p>
<p>5 </p>
<p>1 2 3 4 5</p>
<p>Sample Output</p>
<p>1 2 3 2 1</p>
<p>其实题目中说的很明白了，我们要求的中位数就是一个排好序的数列中中间的那个数，这个题要我们求的就是第 i 个数在多少包含其的区间中是中位数（求得是区间个数）。那么我们可以这么想，我们将这个数分成两个部分假设这个数的下标是i（初始时从1开始的）那么这两部分就是[1,i-1]和[i+1, n]，我们可以每次暴力求这个两个区间内比它大的数和比它小的数。<br>现在在第一个区间内：如果一个数比当前这个数小那么sum++,否则sum–（因为不存在两个相同的数）<br>现在在第二个区间内：如果一个数比当前这个数大那么sum++,否则sum–（因为不存在两个相同的数）<br>那么在加和减的过程中如果遇到sum==0的情况那么它必定是一个区间的中位数用ans++，然后再定义两个数组num1[],num2[]，因为在比较的过程中sum可能出现负数，那么我们只需要将这个数加上n就行了，即num1[n+sum]++,num2[sum+n]++;然后我们就是让相等的数进行相乘，(num1和num2初始化为0)最后输出就行了，在这里注意格式错误，最后一个没有空格，复杂度 O（2<em>n^2）。<br>　　我在解释下为什么要num1乘num2，因为num1中存的是前半部分sum的值出现的次数，比如num1[n+1]=2 就代表sum为1时出现2次，num2中存的是后半部分sum的值出现的次数，比如num2[n+1]=3 就代表sum为1时出现3次。这时他们就要相乘了，因为每一次num1都可以匹配所有的num2，比如刚才说的，那就是1次num1匹配3次num2，因为是2次，所以就是当了3+3=2</em>3=6次中位数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAX = 8000+5;</span><br><span class="line">int a[MAX];</span><br><span class="line">int num1[2*MAX];</span><br><span class="line">int num2[2*MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n;</span><br><span class="line">	while(cin&gt;&gt;n)&#123;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		memset(num1,0,sizeof(num1));</span><br><span class="line">		memset(num2,0,sizeof(num2));</span><br><span class="line">			int ans=1;</span><br><span class="line">				int 	sum=0;</span><br><span class="line">		for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">			if(a[j]&gt;=a[i]) sum++;</span><br><span class="line">			else sum--;</span><br><span class="line">			if(sum==0) ans++;</span><br><span class="line">			num2[n+sum]++;</span><br><span class="line">		&#125;</span><br><span class="line">	sum=0;</span><br><span class="line">		for(int j=i-1;j&gt;0;j--)&#123;</span><br><span class="line">			if(a[j]&lt;=a[i]) sum++;</span><br><span class="line">			else sum--;</span><br><span class="line">			if(sum==0) ans++;</span><br><span class="line">			num1[n+sum]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		for(int k=0;k&lt;2*n;k++)</span><br><span class="line">			ans+=num1[k]*num2[k];</span><br><span class="line">		cout&lt;&lt;ans;</span><br><span class="line">            if(i != n)</span><br><span class="line">                cout&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hdu</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 72. Edit Distance</title>
    <url>/2018/11/25/72/</url>
    <content><![CDATA[<p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.<br><a id="more"></a><br>You have the following 3 operations permitted on a word:</p>
<p>Insert a character</p>
<p>Delete a character</p>
<p>Replace a character</p>
<p>Example 1:</p>
<p>Input: word1 = “horse”, word2 = “ros”</p>
<p>Output: 3</p>
<p>Explanation: </p>
<p>horse -&gt; rorse (replace ‘h’ with ‘r’)</p>
<p>rorse -&gt; rose (remove ‘r’)</p>
<p>rose -&gt; ros (remove ‘e’)</p>
<p>Example 2:</p>
<p>Input: word1 = “intention”, word2 = “execution”</p>
<p>Output: 5</p>
<p>Explanation: </p>
<p>intention -&gt; inention (remove ‘t’)</p>
<p>inention -&gt; enention (replace ‘i’ with ‘e’)</p>
<p>enention -&gt; exention (replace ‘n’ with ‘x’)</p>
<p>exention -&gt; exection (replace ‘n’ with ‘c’)</p>
<p>exection -&gt; execution (insert ‘u’)</p>
<h2 id="优化后的递归程序"><a href="#优化后的递归程序" class="headerlink" title="优化后的递归程序"></a>优化后的递归程序</h2><p>用d_ 二维向量来存储 word1前i个字符 变化到 word2前j个字符 所需的步骤<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //static int step;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; d_;</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        int l1=word1.length();</span><br><span class="line">        int l2=word2.length();</span><br><span class="line">        d_=vector&lt;vector&lt;int&gt;&gt;(l1+1,vector&lt;int&gt;(l2+1,-1));</span><br><span class="line">        //空串到空串 变化就是0次，所以初始化向量为-1</span><br><span class="line">        return M(word1,word2,l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">    long M(string &amp;word1,string &amp;word2,int i,int j)&#123;</span><br><span class="line">        long steps;</span><br><span class="line">        //if(i==0&amp;&amp;j==0) return 0;</span><br><span class="line">        if(d_[i][j]&gt;=0) return d_[i][j];</span><br><span class="line">        if(i==0) return j;</span><br><span class="line">        if(j==0) return i;</span><br><span class="line">        if(word1[i-1]==word2[j-1]) return M(word1,word2,i-1,j-1);</span><br><span class="line">        steps=1+min(min(M(word1,word2,i-1,j-1),M(word1,word2,i,j-1)),M(word1,word2,i-1,j));</span><br><span class="line">          return d_[i][j]=steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>之前的递归程序 栈递归 溢出time exceeded<br><strong>反复计算 所以可以优化递归 存储中间结果</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //static int step;</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        return M(word1,word2,word1.length(),word2.length());</span><br><span class="line">    &#125;</span><br><span class="line">    long M(string &amp;word1,string &amp;word2,int i,int j)&#123;</span><br><span class="line">        long steps;</span><br><span class="line">        //if(i==0&amp;&amp;j==0) return 0;</span><br><span class="line">        if(i==0) return j;</span><br><span class="line">        if(j==0) return i;</span><br><span class="line">        if(word1[i-1]==word2[j-1]) return M(word1,word2,i-1,j-1);</span><br><span class="line">        steps=1+min(min(M(word1,word2,i-1,j-1),M(word1,word2,i,j-1)),M(word1,word2,i-1,j));</span><br><span class="line">          return steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 720. Longest Word in Dictionary</title>
    <url>/2018/11/25/720/</url>
    <content><![CDATA[<p>Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order.<br><a id="more"></a><br>If there is no answer, return the empty string.<br>Example 1:<br>Input: </p>
<p>words = [“w”,”wo”,”wor”,”worl”, “world”]</p>
<p>Output: “world”</p>
<p>Explanation: </p>
<p>The word “world” can be built one character at a time by “w”, “wo”, “wor”, and “worl”.</p>
<p>Example 2:</p>
<p>Input:<br>words = [“a”, “banana”, “app”, “appl”, “ap”, “apply”, “apple”]</p>
<p>Output: “apple”</p>
<p>Explanation: </p>
<p>Both “apply” and “apple” can be built from other words in the dictionary. However,<br>“apple” is lexicographically smaller than “apply”.</p>
<p>Note:</p>
<p>All the strings in the input will only contain lowercase letters.</p>
<p>The length of words will be in the range [1, 1000].</p>
<p>The length of words[i] will be in the range [1, 30].</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //返回1 s1优先排序在s2前</span><br><span class="line">    bool static const cmp(string &amp;s1,string &amp;s2)&#123;</span><br><span class="line">       if(s1.length()&gt;s2.length()) return true;</span><br><span class="line">        if(s1.length()==s2.length()) return s1&lt;s2;</span><br><span class="line">        else return false;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    string longestWord(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        //string!!</span><br><span class="line">        unordered_set&lt;string&gt; dict(words.begin(),words.end());</span><br><span class="line">        sort(words.begin(),words.end(),cmp);</span><br><span class="line">        </span><br><span class="line">        for(auto s:words)&#123;</span><br><span class="line">          //  cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">            bool flag=true;</span><br><span class="line">            string t;</span><br><span class="line">            for(int i=0;i&lt;s.length();i++)</span><br><span class="line">            &#123;t+=s[i];</span><br><span class="line">             if(!dict.count(t)) flag=false; </span><br><span class="line">             &#125;</span><br><span class="line">            if(flag==true) return s;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 743. Network Delay Time</title>
    <url>/2018/12/08/743/</url>
    <content><![CDATA[<p>There are N network nodes, labelled 1 to N.</p>
<p>Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.<br><a id="more"></a><br>Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.</p>
<p>Note:</p>
<p>N will be in the range [1, 100].</p>
<p>K will be in the range [1, N].</p>
<p>The length of times will be in the range [1, 6000].</p>
<p>All edges times[i] = (u, v, w) will have 1 &lt;= u, v &lt;= N and 1 &lt;= w &lt;= 100.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    int num;</span><br><span class="line">    int value;</span><br><span class="line">    node(int nn,int vv):num(nn),value(vv)&#123;&#125;</span><br><span class="line">    bool operator &lt;(node p)const&#123;</span><br><span class="line">        return value&gt;p.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dis[100];</span><br><span class="line">    int vis[100];</span><br><span class="line">    //vector&lt;vector&lt;int&gt; &gt; g;</span><br><span class="line">    map&lt;int,vector&lt;node&gt;&gt; g;</span><br><span class="line">    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123;</span><br><span class="line">        for(int i=0;i&lt;times.size();i++)&#123;</span><br><span class="line">            </span><br><span class="line">            g[times[i][0]].push_back(node(times[i][1],times[i][2]));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">         for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">            dis[i]=1e8;</span><br><span class="line">         &#125;</span><br><span class="line">        for(int j=0;j&lt;g[K].size();j++)&#123;</span><br><span class="line">        dis[g[K][j].num]=g[K][j].value;</span><br><span class="line">        &#125;</span><br><span class="line">            priority_queue&lt;node&gt; pq;</span><br><span class="line">        pq.push(node(K,0));</span><br><span class="line">        dis[K]=0;  </span><br><span class="line">        while(!pq.empty())&#123;</span><br><span class="line">            node t=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            int index=t.num;</span><br><span class="line">            int cost=t.value;</span><br><span class="line">            if(vis[index]) continue;</span><br><span class="line">            vis[index]=1;//!!</span><br><span class="line">            for(int j=0;j&lt;g[index].size();j++)&#123;</span><br><span class="line">                if(cost+g[index][j].value&lt;dis[g[index][j].num])</span><br><span class="line">                &#123;</span><br><span class="line">                dis[g[index][j].num]=cost+g[index][j].value;</span><br><span class="line">            </span><br><span class="line">                    //</span><br><span class="line">                &#125;</span><br><span class="line">                pq.push(node(g[index][j].num, dis[g[index][j].num]));//!!写成dis[j]错误 dis[g[index][j].num]是取出的节点的编号和距离</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        int ans=0;</span><br><span class="line">            </span><br><span class="line">        for(int i=1;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(dis[i]==1e8) return -1;</span><br><span class="line">                        ans=max(ans,dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">         return ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
        <category>dij</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 726. Number of Atoms</title>
    <url>/2018/11/25/726/</url>
    <content><![CDATA[<p>Given a chemical formula (given as a string), return the count of each atom.</p>
<p>An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.</p>
<p>1 or more digits representing the count of that element may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.<br><a id="more"></a><br>Two formulas concatenated together produce another formula. For example, H2O2He3Mg4 is also a formula.</p>
<p>A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.</p>
<p>Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.</p>
<p>Example 1:</p>
<p>Input: </p>
<p>formula = “H2O”</p>
<p>Output: “H2O”</p>
<p>Explanation: </p>
<p>The count of elements are {‘H’: 2, ‘O’: 1}.</p>
<p>Example 2:</p>
<p>Input: </p>
<p>formula = “Mg(OH)2”</p>
<p>Output: “H2MgO2”</p>
<p>Explanation: </p>
<p>The count of elements are {‘H’: 2, ‘Mg’: 1, ‘O’: 2}.</p>
<p>Example 3:</p>
<p>Input: </p>
<p>formula = “K4(ON(SO3)2)2”</p>
<p>Output: “K4N2O14S4”</p>
<p>Explanation: </p>
<p>The count of elements are {‘K’: 4, ‘N’: 2, ‘O’: 14, ‘S’: 4}.<br>Note:</p>
<p>All atom names consist of lowercase letters, except for the first character which is uppercase.</p>
<p>The length of formula will be in the range [1, 1000].<br>formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">   // map&lt;string,int&gt; counts;</span><br><span class="line">    string str;</span><br><span class="line">    string countOfAtoms(string formula) &#123;</span><br><span class="line">        int i=0;</span><br><span class="line">        map&lt;string,int&gt; counts;</span><br><span class="line">        counts=trans(formula,i);</span><br><span class="line">        for(auto t:counts)&#123;</span><br><span class="line">            if(t.second&gt;1) str+=t.first+std::to_string(t.second);</span><br><span class="line">            else str+=t.first;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;string,int&gt; trans(string form,int &amp;i)&#123;</span><br><span class="line">      // map&lt;string,int&gt; tmp;</span><br><span class="line">        map&lt;string,int&gt; counts;//！！ 不能作为静态变量</span><br><span class="line">        while(i!=form.length())&#123;</span><br><span class="line">            if(form[i]==&apos;(&apos;)&#123;</span><br><span class="line">                const auto&amp; tmp=trans(form,++i);</span><br><span class="line">                int cnt=getCnt(form,i);</span><br><span class="line">                for(auto &amp;ch:tmp)&#123;</span><br><span class="line">                    counts[ch.first]+=ch.second*cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            else if(form[i]==&apos;)&apos;)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                return  counts;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">            string t=getStr(form,i);</span><br><span class="line">            int k=getCnt(form,i);</span><br><span class="line">            counts[t]+=k;</span><br><span class="line">          </span><br><span class="line">            &#125; </span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        return counts;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    string getStr(string form,int &amp;i)&#123;</span><br><span class="line">        string t;</span><br><span class="line">        if(isalpha(form[i])&amp;&amp;isupper(form[i])) </span><br><span class="line">        &#123;</span><br><span class="line">        t=form[i];</span><br><span class="line">        i++;   </span><br><span class="line">        &#125;</span><br><span class="line">        while(isalpha(form[i])&amp;&amp;islower(form[i]))&#123;</span><br><span class="line">             t+=form[i];</span><br><span class="line">             i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    int getCnt(string form,int &amp;i)&#123;</span><br><span class="line">        string t;</span><br><span class="line">        while(isdigit(form[i]))&#123;</span><br><span class="line">            t+=form[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return t.empty()?1:std::stoi(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>745. Prefix and Suffix Search</title>
    <url>/2018/11/25/745-Prefix-and-Suffix-Search/</url>
    <content><![CDATA[<p>Given many words, words[i] has weight i.</p>
<p>Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight. If no word exists, return -1.<br><a id="more"></a><br>Examples:</p>
<p>Input:</p>
<p>WordFilter([“apple”])</p>
<p>WordFilter.f(“a”, “e”) // returns 0</p>
<p>WordFilter.f(“b”, “”) // returns -1</p>
<p>Note:<br>words has length in range [1, 15000].</p>
<p>For each test case, up to words.length queries WordFilter.f may be made.<br>words[i] has length in range [1, 10].</p>
<p>prefix, suffix have lengths in range [0, 10].<br>words[i] and prefix, suffix queries consist of lowercase letters only.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>hashtable的思想<br>o(nL^3) 枚举所有单词的前缀后缀 key-&gt;word_index<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class WordFilter &#123;</span><br><span class="line">public:</span><br><span class="line">      unordered_map&lt;string,int&gt; dict;</span><br><span class="line">    WordFilter(vector&lt;string&gt; words) &#123;</span><br><span class="line">         int index=0;</span><br><span class="line">        for(auto word:words)&#123;</span><br><span class="line">            int l=word.length();</span><br><span class="line">            vector&lt;string&gt; prefix(l+1,&quot;&quot;);</span><br><span class="line">            vector&lt;string&gt; suffix(l+1,&quot;&quot;);            </span><br><span class="line">            for(int i=1;i&lt;=l;i++)&#123;</span><br><span class="line">               // for(int j=1;j&lt;=l;j++)&#123; 生成的前缀后缀字符串是笛卡尔乘积 </span><br><span class="line">                    prefix[i]=prefix[i-1]+word[i-1];</span><br><span class="line">                    suffix[i]=word[l-i]+suffix[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">//                       for(string t1:prefix)&#123;</span><br><span class="line">//                           for(string t2:suffix)</span><br><span class="line">//                           &#123;</span><br><span class="line">                              </span><br><span class="line">//                                 dict[t1+&apos;_&apos;+t2]=index;</span><br><span class="line">//                           &#125;</span><br><span class="line">                          </span><br><span class="line">//                       &#125;         </span><br><span class="line">                for(int i=0;i&lt;=l;i++)</span><br><span class="line">                for(int j=0;j&lt;=l;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    string key=prefix[i]+&apos;_&apos;+suffix[j];</span><br><span class="line">                        dict[key]=index;</span><br><span class="line">                &#125;  </span><br><span class="line">                    </span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int f(string prefix, string suffix) &#123;</span><br><span class="line">        string key=prefix+&quot;_&quot;+suffix;</span><br><span class="line">        auto it=dict.find(key);</span><br><span class="line">        if(it!=dict.end()) return it-&gt;second;</span><br><span class="line">         return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your WordFilter object will be instantiated and called as such:</span><br><span class="line"> * WordFilter obj = new WordFilter(words);</span><br><span class="line"> * int param_1 = obj.f(prefix,suffix);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode748  Shortest Completing Word</title>
    <url>/2018/11/23/748/</url>
    <content><![CDATA[<p>Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate. Such a word is said to complete the given string licensePlate<br><a id="more"></a><br>Here, for letters we ignore case. For example, “P” on the licensePlate still matches “p” on the word.</p>
<p>It is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array.</p>
<p>The license plate might have the same letter occurring multiple times. For example, given a licensePlate of “PP”, the word “pair” does not complete the licensePlate, but the word “supper” does.</p>
<p>Example 1:</p>
<p>Input: licensePlate = “1s3 PSt”, words = [“step”, “steps”, “stripe”, “stepple”]</p>
<p>Output: “steps”</p>
<p>Explanation: The smallest length word that contains the letters “S”, “P”, “S”, and “T”.<br>Note that the answer is not “step”, because the letter “s” must occur in the word twice.</p>
<p>Also note that we ignored case for the purposes of comparing whether a letter exists in the word.</p>
<p>Example 2:</p>
<p>Input: licensePlate = “1s3 456”, words = [“looks”, “pest”, “stew”, “show”]</p>
<p>Output: “pest”</p>
<p>Explanation: There are 3 smallest length words that contains the letters “s”.<br>We return the one that occurred first.</p>
<p>Note:</p>
<p>licensePlate will be a string with length in range [1, 7].</p>
<p>licensePlate will contain digits, spaces, or letters (uppercase or lowercase).</p>
<p>words will have a length in the range [10, 1000].</p>
<p>Every words[i] will consist of lowercase letters, and have length in range [1, 15].</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string shortestCompletingWord(string licensePlate, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        vector&lt;int&gt; v(26,0);</span><br><span class="line">        for(const char ch:licensePlate)&#123;</span><br><span class="line">            if(isalpha(ch)) v[tolower(ch)-&apos;a&apos;]++;//tolower</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        int minL=INT_MAX;</span><br><span class="line">        for(int i=0;i&lt;words.size();i++)&#123;</span><br><span class="line">           string word=words[i];</span><br><span class="line">        if(word.length()&gt;=minL) continue;</span><br><span class="line">        if(!match(word,v)) continue;</span><br><span class="line">            </span><br><span class="line">                minL=word.length();</span><br><span class="line">                ans=word;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    bool match(string word,vector&lt;int&gt; v)&#123;//!!</span><br><span class="line">        vector&lt;int&gt; s(26,0);</span><br><span class="line">    </span><br><span class="line">        for(char ch:word)&#123;</span><br><span class="line">            if(isalpha(ch)) s[ch-&apos;a&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]&lt;v[i]) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 787. Cheapest Flights Within K Stops</title>
    <url>/2018/12/06/787/</url>
    <content><![CDATA[<p>There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.</p>
<p>Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.</p>
<p>Example 1:<br>Input:<br><a id="more"></a><br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</p>
<p>src = 0, dst = 2, k = 1</p>
<p>Output: 200</p>
<p>Explanation:<br>The graph looks like this:<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt="image"><br>The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.</p>
<p>Example 2:</p>
<p>Input: </p>
<p>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</p>
<p>src = 0, dst = 2, k = 0</p>
<p>Output: 500</p>
<p>Explanation: </p>
<p>The graph looks like this:</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt="image"></p>
<p>The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.</p>
<p>Note:</p>
<p>The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.</p>
<p>The size of flights will be in range [0, n * (n - 1) / 2].</p>
<p>The format of each flight will be (src, dst, price).</p>
<p>The price of each flight will be in the range [1, 10000].<br>k is in the range of [0, n - 1].</p>
<p>There will not be any duplicated flights or self cycles.</p>
<h2 id="bfs剪枝"><a href="#bfs剪枝" class="headerlink" title="bfs剪枝"></a>bfs剪枝</h2><p>最优化剪枝 </p>
<p>从src 到 dst可能有多条路径</p>
<p>把走一步的节点加进来，统计step数 如果大于k break</p>
<p>累积到当前节点的cost大于记录下的ans 就跳过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    int num;</span><br><span class="line">    int cost;</span><br><span class="line">    node(int nn,int cc)&#123;</span><br><span class="line">        num=nn;</span><br><span class="line">        cost=cc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    map&lt;int,vector&lt;node&gt; &gt;g;</span><br><span class="line">    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) &#123;</span><br><span class="line">        for(int i=0;i&lt;flights.size();i++)&#123;</span><br><span class="line">                g[flights[i][0]].push_back(node(flights[i][1],flights[i][2]));</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=1e8;</span><br><span class="line">         bfs(src,dst,ans,K); </span><br><span class="line">        if(ans==1e8) return -1;</span><br><span class="line">        else return ans; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    void bfs(int src,int dst,int &amp;ans,int k)&#123;   </span><br><span class="line">        queue&lt;node&gt; q;</span><br><span class="line">        int cost=0;</span><br><span class="line">        q.push(node(src,0));</span><br><span class="line">        int step=0;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int size=q.size();</span><br><span class="line"></span><br><span class="line">            while(size--)&#123;</span><br><span class="line">                node t=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(t.num==dst) &#123;</span><br><span class="line">                    ans=min(ans,t.cost);</span><br><span class="line">                &#125;</span><br><span class="line">                //访问过的节点还能访问 k步以内即可</span><br><span class="line">                //  if(vis[t.num]) continue;</span><br><span class="line">                // vis[t.num]=true;!!</span><br><span class="line">                 cost=t.cost;</span><br><span class="line">            for(int i=0;i&lt;g[t.num].size();i++)&#123;</span><br><span class="line">                node  b=g[t.num][i];</span><br><span class="line">              if(cost+b.cost&gt;ans) continue;</span><br><span class="line">                q.push(node(b.num,cost+b.cost));</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                  </span><br><span class="line">            &#125;</span><br><span class="line">         if(step++&gt;k) break;</span><br><span class="line">           </span><br><span class="line">             </span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="dfs-剪枝"><a href="#dfs-剪枝" class="headerlink" title="dfs 剪枝"></a>dfs 剪枝</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int num;</span><br><span class="line">    int cost;</span><br><span class="line">    node(int nn,int cc)&#123;</span><br><span class="line">        num=nn;</span><br><span class="line">        cost=cc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    map&lt;int,vector&lt;node&gt; &gt;g;</span><br><span class="line">    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) &#123;</span><br><span class="line">        for(int i=0;i&lt;flights.size();i++)&#123;</span><br><span class="line">                g[flights[i][0]].push_back(node(flights[i][1],flights[i][2]));</span><br><span class="line">        &#125;</span><br><span class="line">        bool vis[101]=&#123;false&#125;; </span><br><span class="line">        int cost=0,ans=1e8;</span><br><span class="line">         dfs(src,dst,vis,K+1,ans,cost); </span><br><span class="line">        if(ans==1e8) return -1;</span><br><span class="line">        else return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    void dfs(int src,int dst,bool vis[],int k,int &amp;ans,int cost)&#123;   </span><br><span class="line">       if(src==dst) &#123;</span><br><span class="line">           ans=cost;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">        if(k==0) return;</span><br><span class="line">        for(int i=0;i&lt;g[src].size();i++)&#123;</span><br><span class="line">            if(vis[g[src][i].num]) continue;</span><br><span class="line"></span><br><span class="line">            if(g[src][i].cost+cost&gt;ans) continue;</span><br><span class="line">                    vis[g[src][i].num]=true;</span><br><span class="line">            dfs(g[src][i].num,dst,vis,k-1,ans,cost+g[src][i].cost);</span><br><span class="line">                vis[g[src][i].num]=false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 799. Champagne Tower</title>
    <url>/2018/12/05/799/</url>
    <content><![CDATA[<p>We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne.<br><a id="more"></a><br>Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it’s excess champagne fall on the floor.)</p>
<p>For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.</p>
<p>Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)</p>
<p>Example 1:</p>
<p>Input: poured = 1, query_glass = 1, query_row = 1</p>
<p>Output: 0.0</p>
<p>Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.</p>
<p>Example 2:</p>
<p>Input: poured = 2, query_glass = 1, query_row = 1</p>
<p>Output: 0.5</p>
<p>Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of exce</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double champagneTower(int poured, int query_row, int query_glass) &#123;</span><br><span class="line">        double dp[100+1][100+1]=&#123;0&#125;;</span><br><span class="line">        //vector&lt;vector&lt;double&gt; &gt;dp(100,vector&lt;double&gt;(100))</span><br><span class="line">        dp[0][0]=poured;</span><br><span class="line">        for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;=i;j++)&#123;</span><br><span class="line">                if(dp[i][j]&gt;1)&#123;</span><br><span class="line">                    dp[i+1][j]+=(dp[i][j]-1)*1.0/2.0;</span><br><span class="line">                     dp[i+1][j+1]+=(dp[i][j]-1)*1.0/2.0;</span><br><span class="line">                    dp[i][j]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[query_row][query_glass];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>leetcode 802. Find Eventual Safe States</title>
    <url>/2018/12/08/802/</url>
    <content><![CDATA[<p>In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p>
<p>Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.<br><!--mroe--><br>Which nodes are eventually safe?  Return them as an array in sorted order.</p>
<p>The directed graph has N nodes with labels 0, 1, …, N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.</p>
<p>Example:<br>Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]</p>
<p>Output: [2,4,5,6]</p>
<p>Here is a diagram of the above graph.</p>
<p>Illustration of graph</p>
<p>Note:</p>
<p>graph will have length at most 10000.</p>
<p>The number of edges in the graph will not exceed 32000.</p>
<p>Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;g;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; eventualSafeNodes(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        int vis[10000]=&#123;0&#125;;</span><br><span class="line">        int m=graph.size();</span><br><span class="line">        g=vector&lt;vector&lt;int&gt;&gt;(m);//!!</span><br><span class="line">        for(int i=0;i&lt;graph.size();i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;graph[i].size();j++)&#123;</span><br><span class="line">                g[i].push_back(graph[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; s;</span><br><span class="line">        for(int i=0;i&lt;graph.size();i++)&#123;</span><br><span class="line">        if(vis[i]==3) s.push_back(i); </span><br><span class="line">         else if(dfs(i,vis)==3) s.push_back(i);           </span><br><span class="line">        &#125;      </span><br><span class="line">        return s;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        //0:unknown 1:visiting 2:unsafe 3:safe</span><br><span class="line">    int dfs(int cur,int vis[])&#123;</span><br><span class="line">        if(vis[cur]==1) return vis[cur]=2;</span><br><span class="line">        if(vis[cur]!=0)  return vis[cur];</span><br><span class="line">        vis[cur]=1;</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;g[cur].size();i++)&#123;</span><br><span class="line">            if(dfs(g[cur][i],vis)==2) &#123;</span><br><span class="line">           //     cout&lt;&lt;&quot;huan:&quot;&lt;&lt;cur&lt;&lt;&quot; &quot;&lt;&lt;g[cur][i]&lt;&lt;endl;</span><br><span class="line">                return vis[cur]=2;</span><br><span class="line">            &#125;</span><br><span class="line">           //     cout&lt;&lt;cur&lt;&lt;&quot; &quot;&lt;&lt;g[cur][i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return vis[cur]=3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
        <category>dfs</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 827. Making A Large Island</title>
    <url>/2018/12/08/827/</url>
    <content><![CDATA[<p>In a 2D grid of 0s and 1s, we change at most one 0 to a 1.</p>
<p>After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s).</p>
<p>Example 1:<br><a id="more"></a><br>Input: [[1, 0], [0, 1]]</p>
<p>Output: 3</p>
<p>Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.</p>
<p>Example 2:</p>
<p>Input: [[1, 1], [1, 0]]</p>
<p>Output: 4</p>
<p>Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.<br>Example 3:</p>
<p>Input: [[1, 1], [1, 1]]</p>
<p>Output: 4</p>
<p>Explanation: Can’t change any 0 to 1, only one island with area = 4.</p>
<p>Notes:</p>
<p>1 &lt;= grid.length = grid[0].length &lt;= 50.<br>0 &lt;= grid[i][j] &lt;= 1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int m,n;</span><br><span class="line">     map&lt;int,int&gt; mapp;</span><br><span class="line">    int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int color=1;</span><br><span class="line">        m=grid.size();</span><br><span class="line">        n=grid[0].size();</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;grid.size();i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;grid[i].size();j++)&#123;</span><br><span class="line">                if(grid[i][j]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    color++;</span><br><span class="line">                    mapp[color]=getArea(i,j,grid,color);</span><br><span class="line">                    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">       int areas=0,ans=0;</span><br><span class="line">        for(int x=0;x&lt;m;x++)&#123;</span><br><span class="line">            for(int y=0;y&lt;n;y++)&#123;</span><br><span class="line">                if(grid[x][y]==0)&#123;</span><br><span class="line">                      set&lt;int&gt; s;</span><br><span class="line">                    areas=1;</span><br><span class="line">                    for(int i=0;i&lt;4;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                 </span><br><span class="line">                       </span><br><span class="line">                        int newx=x+dir[i][0];</span><br><span class="line">                        int newy=y+dir[i][1];</span><br><span class="line">                         if(newx&lt;0||newx&gt;=m||newy&lt;0||newy&gt;=n) continue;</span><br><span class="line">                        int color=grid[newx][newy];</span><br><span class="line">                      s.insert(color);//用集合 可能（x,y）上面和左边是同一个连通分量 同一个连通分量的面积只加一次</span><br><span class="line">                    &#125; </span><br><span class="line">                    for(auto c:s)&#123;</span><br><span class="line">                        areas+=mapp[c];</span><br><span class="line">                      //!!  cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot;  &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;mapp[c]&lt;&lt;endl; 填充(x,y)这点后所能形成的连通分量的面积‘’</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    ans=max(ans,areas);</span><br><span class="line">                    &#125;                    </span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">          if(areas==0) return m*n;  </span><br><span class="line">        return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    int getArea(int x,int y,vector&lt;vector&lt;int&gt;&gt; &amp;grid,int color)&#123;</span><br><span class="line">    </span><br><span class="line">        if(x&lt;0||x&gt;=m||y&lt;0||y&gt;=n) return 0;</span><br><span class="line">     </span><br><span class="line">        if(grid[x][y]!=1) return 0;//被標記過</span><br><span class="line">        </span><br><span class="line">        grid[x][y]=color;</span><br><span class="line">    </span><br><span class="line">        return 1+getArea(x-1,y,grid,color)+getArea(x+1,y,grid,color)+getArea(x,y+1,grid,color)+getArea(x,y-1,grid,color);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
        <category>dfs</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 841. Keys and Rooms</title>
    <url>/2018/12/07/841/</url>
    <content><![CDATA[<p>There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, …, N-1, and each room may have some keys to access the next room. </p>
<p>Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, …, N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v.<br><a id="more"></a><br>Initially, all the rooms start locked (except for room 0). </p>
<p>You can walk back and forth between rooms freely.</p>
<p>Return true if and only if you can enter every room.</p>
<p>Example 1:</p>
<p>Input: [[1],[2],[3],[]]</p>
<p>Output: true</p>
<p>Explanation:  </p>
<p>We start in room 0, and pick up key 1.</p>
<p>We then go to room 1, and pick up key 2.</p>
<p>We then go to room 2, and pick up key 3.</p>
<p>We then go to room 3.  Since we were able to go to every room, </p>
<p>we return true.</p>
<p>Example 2:</p>
<p>Input: [[1,3],[3,0,1],[2],[0]]</p>
<p>Output: false</p>
<p>Explanation: We can’t enter the room with number 2.<br>Note:</p>
<p>1 &lt;= rooms.length &lt;= 1000</p>
<p>0 &lt;= rooms[i].length &lt;= 1000</p>
<p>The number of keys in all rooms combined is at most 3000.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    map&lt;int,vector&lt;int&gt; &gt;rmap;</span><br><span class="line">    bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) &#123;</span><br><span class="line">        for(int i=0;i&lt;rooms.size();i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;rooms[i].size();j++)</span><br><span class="line">            rmap[i].push_back(rooms[i][j]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;int&gt; s;</span><br><span class="line">        dfs(0,s);</span><br><span class="line">        if(s.size()==rooms.size()) return true;</span><br><span class="line">        else return false;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(int cur,set&lt;int&gt; &amp;s)&#123;</span><br><span class="line">        if(s.count(cur)) return;</span><br><span class="line">        s.insert(cur);</span><br><span class="line">        for(auto t:rmap[cur])&#123;</span><br><span class="line">            //if(s.count(t)) continue;</span><br><span class="line">            dfs(t,s);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
        <category>dfs</category>
      </categories>
  </entry>
  <entry>
    <title>A1020 Tree Traversals</title>
    <url>/2019/03/25/A-0/</url>
    <content><![CDATA[<p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p>
<p>Input Specification:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.<br><a id="more"></a><br>Output Specification:<br>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">Sample Output:</span><br><span class="line">4 1 6 3 5 7 2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt; </span><br><span class="line">#define MAX 40</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int in[MAX],post[MAX];</span><br><span class="line">int n,k,p;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">	int v;</span><br><span class="line">	node *left;</span><br><span class="line">	node *right;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">//返回构建出的二叉树根节点地址 </span><br><span class="line">node* create(int postl,int postr,int inl,int inr)&#123;</span><br><span class="line">	if(postl&gt;postr)</span><br><span class="line">	return NULL;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=inl;i&lt;=inr;i++)&#123;</span><br><span class="line">		if(in[i]==post[postr]) &#123;</span><br><span class="line">		break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	node *t=new node();//! </span><br><span class="line">	t-&gt;v=post[postr];</span><br><span class="line">	int numl=i-inl; //!</span><br><span class="line">	t-&gt;left=create(postl,postl+numl-1,inl,i-1);//!</span><br><span class="line">	t-&gt;right=create(postl+numl,postr-1,i+1,inr);//!</span><br><span class="line">	return t; </span><br><span class="line">&#125;</span><br><span class="line">int num=0;</span><br><span class="line">void bfs(node *root)&#123;</span><br><span class="line">	queue&lt;node*&gt; que;</span><br><span class="line">	que.push(root);</span><br><span class="line">	while(!que.empty())&#123;</span><br><span class="line">		node *t=que.front();</span><br><span class="line">		que.pop();</span><br><span class="line">		cout&lt;&lt;t-&gt;v;</span><br><span class="line">		num++;</span><br><span class="line">		if(num&lt;n) cout&lt;&lt;&quot; &quot;;</span><br><span class="line">		if(t-&gt;left!=NULL) que.push(t-&gt;left);</span><br><span class="line">		if(t-&gt;right!=NULL) que.push(t-&gt;right);		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;=n-1;i++)</span><br><span class="line">	cin&gt;&gt;post[i];</span><br><span class="line">	for(int i=0;i&lt;=n-1;i++)</span><br><span class="line">	cin&gt;&gt;in[i];	</span><br><span class="line">	</span><br><span class="line">	node *root=create(0,n-1,0,n-1);</span><br><span class="line">	bfs(root);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>A1005 Spell It Right</title>
    <url>/2019/03/18/A1005-1/</url>
    <content><![CDATA[<p>Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. Each case occupies one line which contains an N (≤10<br>​100<br>​​ ).</p>
<p>Output Specification:<br>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">12345</span><br><span class="line">Sample Output:</span><br><span class="line">one five</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char name[10][10]=&#123;&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;&#125;;</span><br><span class="line">#define MAX 101</span><br><span class="line">int digit[MAX]; </span><br><span class="line">int main()&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=0;i&lt;s.length();i++)</span><br><span class="line">	sum+=s[i]-&apos;0&apos;; </span><br><span class="line">	int num=0;</span><br><span class="line">	do&#123;</span><br><span class="line">		digit[num++]=sum%10;</span><br><span class="line">		sum/=10;</span><br><span class="line">	&#125;	while(sum!=0);</span><br><span class="line">	for(int i=num-1;i&gt;=0;i--)	</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;name[digit[i]];</span><br><span class="line">			if(i!=0) cout&lt;&lt;&quot; &quot;;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>A1007  最大连续子序列和</title>
    <url>/2019/03/10/A1007/</url>
    <content><![CDATA[<p>LCS 动态规划</p>
<p>dp[i] 表示以a[i]结尾的最大的连续子序列的和</p>
<p>最大连续子序列和=max(dp[0],dp[1],dp[2]….dp[n-1])<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#define MAX 10010</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,k;</span><br><span class="line">int dp[MAX],ss[MAX],a[MAX]; </span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	bool flag=false;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	  	cin&gt;&gt;a[i];</span><br><span class="line">	  	if(a[i]&gt;0) flag=true;</span><br><span class="line">	&#125;</span><br><span class="line">  if(flag==false)&#123;</span><br><span class="line">    cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;a[0]&lt;&lt;&quot; &quot;&lt;&lt;a[n-1]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">	dp[0]=a[0];</span><br><span class="line">	ss[0]=0;</span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		if(dp[i-1]+a[i]&gt;a[i])&#123;</span><br><span class="line">			dp[i]=dp[i-1]+a[i];</span><br><span class="line">			ss[i]=ss[i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			dp[i]=a[i];</span><br><span class="line">			ss[i]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int max=dp[0],k;</span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		if(dp[i]&gt;max)</span><br><span class="line">		&#123;</span><br><span class="line">			max=dp[i];</span><br><span class="line">			k=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;max&lt;&lt;&quot; &quot;&lt;&lt;a[ss[k]]&lt;&lt;&quot; &quot;&lt;&lt;a[k]&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>A1013 Battle over cities</title>
    <url>/2019/03/27/A1013-1/</url>
    <content><![CDATA[<p>It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.<br><a id="more"></a><br>For example, if we have 3 cities and 2 highways connecting city<br>Input Specification:<br>Each input file contains one test case. Each case starts with a line containing 3 numbers N (&lt;1000), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern.</p>
<p>Output Specification:<br>For each of the K cities, output in a line the number of highways need to be repaired if that city is lost.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">3 2 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 2 3</span><br><span class="line">Sample Output:</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1111</span><br><span class="line">vector&lt;int&gt; G[MAX];</span><br><span class="line">bool vis[MAX];</span><br><span class="line">int n,m,k,cur;</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">	if(x==cur) return ;//是否在图中 </span><br><span class="line">	vis[x]=true;//若被标记访问过 所影响的值 </span><br><span class="line">	for(int i=0;i&lt;G[x].size();i++)&#123;</span><br><span class="line">		int v=G[x][i];</span><br><span class="line">			if(!vis[v])&#123;</span><br><span class="line">				dfs(v);</span><br><span class="line">			&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	int a,b; </span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">		G[a].push_back(b);</span><br><span class="line">		G[b].push_back(a);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">		cin&gt;&gt;cur;</span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">		int block=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			if(vis[i]==false&amp;&amp;i!=cur)&#123;</span><br><span class="line">//				cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;cur&lt;&lt;endl;</span><br><span class="line">				dfs(i); </span><br><span class="line">				block++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			cout&lt;&lt;block-1&lt;&lt;endl;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>A1016 Phone Bills</title>
    <url>/2019/03/20/A1016/</url>
    <content><![CDATA[<p>A long-distance telephone company charges its customers by the following rules:<br><a id="more"></a><br>Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.</p>
<p>Input Specification:<br>Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records.</p>
<p>The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day.</p>
<p>The next line contains a positive number N (≤1000), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (mm:dd:hh:mm), and the word on-line or off-line.</p>
<p>For each test case, all dates will be within a single month. Each  on-line record is paired with the chronologically next record for the same customer provided it is an off-line record. Any on-line records that are not paired with an off-line record are ignored, as are off-line records not paired with an on-line record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.</p>
<p>Output Specification:<br>For each test case, you must print a phone bill for each customer.</p>
<p>Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:hh:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10</span><br><span class="line">10</span><br><span class="line">CYLL 01:01:06:01 on-line</span><br><span class="line">CYLL 01:28:16:05 off-line</span><br><span class="line">CYJJ 01:01:07:00 off-line</span><br><span class="line">CYLL 01:01:08:03 off-line</span><br><span class="line">CYJJ 01:01:05:59 on-line</span><br><span class="line">aaa 01:01:01:03 on-line</span><br><span class="line">aaa 01:02:00:01 on-line</span><br><span class="line">CYLL 01:28:15:41 on-line</span><br><span class="line">aaa 01:05:02:24 on-line</span><br><span class="line">aaa 01:04:23:59 off-line</span><br><span class="line">Sample Output:</span><br><span class="line">CYJJ 01</span><br><span class="line">01:05:59 01:07:00 61 $12.10</span><br><span class="line">Total amount: $12.10</span><br><span class="line">CYLL 01</span><br><span class="line">01:06:01 01:08:03 122 $24.40</span><br><span class="line">28:15:41 28:16:05 24 $3.85</span><br><span class="line">Total amount: $28.25</span><br><span class="line">aaa 01</span><br><span class="line">02:00:01 04:23:59 4318 $638.80</span><br><span class="line">Total amount: $638.80</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">#define MAX 1002 </span><br><span class="line">using namespace std;</span><br><span class="line">int toll[24];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">struct record&#123;</span><br><span class="line">	char name[100];</span><br><span class="line">	int month,dd,hh,mm;</span><br><span class="line">	bool status;</span><br><span class="line">//	record(string nn,int m1,int d,int h,int m):name(n),month(m1),dd(d),hh(h),mm(m)&#123;</span><br><span class="line">//	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">record rec[MAX];</span><br><span class="line">bool cmp(record r1,record r2)&#123;</span><br><span class="line">//	if(r1.name!=r2.name) return r1.name&lt;r2.name;</span><br><span class="line">	int t=strcmp(r1.name,r2.name);</span><br><span class="line">	if(t!=0) return t&lt;0;</span><br><span class="line">	if(r1.month!=r2.month) return r1.month&lt;r2.month;</span><br><span class="line">	if(r1.dd!=r2.dd) return r1.dd&lt;r2.dd;</span><br><span class="line">	if(r1.hh!=r2.hh) return r1.hh&lt;r2.hh;</span><br><span class="line">	if(r1.mm!=r2.mm) return r1.mm&lt;r2.mm;</span><br><span class="line">&#125;</span><br><span class="line">void get_ans(int t1,int t2,int &amp;time,double &amp;money)&#123;</span><br><span class="line">		record r1=rec[t1];</span><br><span class="line">		record r2=rec[t2];</span><br><span class="line"></span><br><span class="line">	while(r1.dd!=r2.dd||r1.hh!=r2.hh||r1.mm!=r2.mm)&#123;</span><br><span class="line">		time++;</span><br><span class="line">		money+=toll[r1.hh];</span><br><span class="line">		r1.mm++;</span><br><span class="line">		if(r1.mm==60)&#123;</span><br><span class="line">			r1.mm=0;</span><br><span class="line">			r1.hh++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(r1.hh==24)&#123;//= 和== </span><br><span class="line">			r1.hh=0;</span><br><span class="line">			r1.dd++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">		for(int i=0;i&lt;24;i++)</span><br><span class="line">		cin&gt;&gt;toll[i];</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">			map&lt;string,int&gt;sum;</span><br><span class="line">	map&lt;string,int&gt;tim;</span><br><span class="line">	map&lt;string,int&gt;time;</span><br><span class="line">	map&lt;string,int&gt;vis;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			char str[10];</span><br><span class="line">			scanf(&quot;%s %d:%d:%d:%d %s&quot;,rec[i].name,&amp;rec[i].month,&amp;rec[i].dd,&amp;rec[i].hh,&amp;rec[i].mm,str);</span><br><span class="line">			if(strcmp(str,&quot;on-line&quot;)==0) rec[i].status=true;</span><br><span class="line">			else rec[i].status=false;</span><br><span class="line">			string tmp(rec[i].name);</span><br><span class="line">			tim[tmp]++;//每个name 对应的通话记录</span><br><span class="line">		&#125; </span><br><span class="line">		sort(rec,rec+n,cmp);</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			string tmp(rec[i].name);</span><br><span class="line">			tim[tmp]--;</span><br><span class="line">			if(rec[i].status==true)</span><br><span class="line">			&#123;</span><br><span class="line">				time[tmp]=i;</span><br><span class="line">				if(time[tmp]==0)  time[tmp]=-1;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			//else中rec[i].status=false,time[tmp]记录online时的record下标</span><br><span class="line">            //time[tmp]=-1,1,2,3......</span><br><span class="line">            //用time[tmp]=0代表离线</span><br><span class="line">            </span><br><span class="line">			else if(time[tmp])&#123;</span><br><span class="line">				if(time[tmp]==-1) time[tmp]=0;//!</span><br><span class="line">				int v=time[tmp];</span><br><span class="line">				int ti=0;</span><br><span class="line">				double money=0;</span><br><span class="line">				get_ans(v,i,ti,money);</span><br><span class="line">					time[tmp]=0;</span><br><span class="line">				if(!vis[tmp])&#123;</span><br><span class="line">					  printf(&quot;%s %02d\n&quot;,rec[i].name,rec[i].month);</span><br><span class="line">					vis[tmp]=1;</span><br><span class="line">				&#125;</span><br><span class="line">			printf(&quot;%02d:%02d:%02d %02d:%02d:%02d %d $%.2f\n&quot;,rec[v].dd,rec[v].hh,rec[v].mm,rec[i].dd,rec[i].hh,rec[i].mm,ti,money/100.0);</span><br><span class="line">				sum[tmp]+=money;</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">			if(tim[tmp]==0&amp;&amp;sum[tmp]) printf(&quot;Total amount: $%.2f\n&quot;,sum[tmp]/100.0);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>middle</tag>
      </tags>
  </entry>
  <entry>
    <title>A1018   Public Bike Management </title>
    <url>/2019/03/20/A1018/</url>
    <content><![CDATA[<p>There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city.<br><a id="more"></a><br>The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well.</p>
<p>When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen.</p>
<p>The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex S is the current number of bikes stored at S. Given that the maximum capacity of each station is 10.</p>
<p>Output Specification:<br>For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: </p>
<p>Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique.</p>
<p>题目链接<br><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">10 3 3 5</span><br><span class="line">6 7 0</span><br><span class="line">0 1 1</span><br><span class="line">0 2 1</span><br><span class="line">0 3 3</span><br><span class="line">1 3 1</span><br><span class="line">2 3 1</span><br><span class="line">Sample Output:</span><br><span class="line">3 0-&gt;2-&gt;3 0</span><br></pre></td></tr></table></figure>
<p>思路：<br>dijskstra+dfs<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">#define MAX 510</span><br><span class="line">using namespace std;</span><br><span class="line">int cmax,n,sp,m;</span><br><span class="line">int dis[MAX],g[MAX][MAX],wei[MAX];</span><br><span class="line">vector&lt;int&gt; pre[MAX],tmp,path;</span><br><span class="line">int vis[MAX];</span><br><span class="line">int mini=INF,lremain=INF;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">void dij(int src)&#123;</span><br><span class="line">	fill(dis,dis+MAX,INF);</span><br><span class="line">	dis[src]=0;</span><br><span class="line">	for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">		int min=INF,u=-1;</span><br><span class="line">		for(int j=0;j&lt;=n;j++)&#123;</span><br><span class="line">			if(!vis[j]&amp;&amp;dis[j]&lt;min)&#123;</span><br><span class="line">				min=dis[j];u=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(u==-1) return;</span><br><span class="line">		vis[u]=true;</span><br><span class="line">		for(int v=0;v&lt;=n;v++)&#123;</span><br><span class="line">			if(vis[v]||g[u][v]==INF) continue;</span><br><span class="line">			if(dis[u]+g[u][v]&lt;dis[v])&#123;</span><br><span class="line">				dis[v]=dis[u]+g[u][v];</span><br><span class="line">				pre[v].clear();</span><br><span class="line">				pre[v].push_back(u);</span><br><span class="line">			&#125;</span><br><span class="line">			else if(dis[u]+g[u][v]==dis[v])&#123;</span><br><span class="line">					pre[v].push_back(u);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int remain=0,need=0;</span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">	if(u==0)&#123;</span><br><span class="line">		tmp.push_back(u);</span><br><span class="line">		for(int i=tmp.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">			int v=tmp[i];</span><br><span class="line">			if(wei[v]&gt;0)&#123;</span><br><span class="line">				remain+=wei[v];</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				if(abs(wei[v])&gt;remain)&#123;</span><br><span class="line">					need+=abs(wei[v])-remain;</span><br><span class="line">					remain=0;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					remain-=abs(wei[v]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; </span><br><span class="line">		if(need&lt;mini)&#123;</span><br><span class="line">			mini=need;</span><br><span class="line">			path=tmp;</span><br><span class="line">			lremain=remain;</span><br><span class="line">		&#125; </span><br><span class="line">		else if(need==mini&amp;&amp;remain&lt;lremain)&#123;</span><br><span class="line">			lremain=remain;</span><br><span class="line">			path=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		tmp.pop_back();</span><br><span class="line">		 remain=0,need=0;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp.push_back(u);</span><br><span class="line">	for(int k=0;k&lt;pre[u].size();k++)</span><br><span class="line">		dfs(pre[u][k]);</span><br><span class="line">	tmp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//	freopen(&quot;20.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	fill(g[0],g[0]+MAX*MAX,INF);</span><br><span class="line">	cin&gt;&gt;cmax&gt;&gt;n&gt;&gt;sp&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;wei[i];</span><br><span class="line">			wei[i]-=cmax/2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int j=0;j&lt;m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		int u,v;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		cin&gt;&gt;g[u][v];</span><br><span class="line">		g[v][u]=g[u][v];</span><br><span class="line">	&#125;</span><br><span class="line">	dij(0);</span><br><span class="line">	dfs(sp);</span><br><span class="line">	cout&lt;&lt;mini&lt;&lt;&quot; &quot;;</span><br><span class="line">		for(int i=path.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">		cout&lt;&lt;path[i];</span><br><span class="line">		if(i!=0) cout&lt;&lt;&quot;-&gt;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;&quot; &quot;&lt;&lt;lremain&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>dij</tag>
      </tags>
  </entry>
  <entry>
    <title>A1021 Deepest Root </title>
    <url>/2019/03/18/A1021-1/</url>
    <content><![CDATA[<p>A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root.<br><a id="more"></a></p>
<p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains a positive integer N (≤10<br>​4<br>​​ ) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N−1 lines follow, each describes an edge by given the two adjacent nodes’ numbers.</p>
<p>Output Specification:</p>
<p>For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print Error: K components where K is the number of connected components in the graph.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input 1:</span><br><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">Sample Output 1:</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">Sample Input 2:</span><br><span class="line">5</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">3 4</span><br><span class="line">Sample Output 2:</span><br><span class="line">Error: 2 components</span><br></pre></td></tr></table></figure>
<p>思路:求树的直径</p>
<p>要能处理特殊数据 n=1<br>不能走回头路 要记录前驱节点<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define MAX 10001</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int par[MAX];</span><br><span class="line">int maxn=-1;</span><br><span class="line">vector&lt;int&gt; vec[MAX],ans,tmp;</span><br><span class="line">bool isR[MAX];</span><br><span class="line">int find(int a)&#123;</span><br><span class="line">	if(par[a]!=a) par[a]=find(par[a]);</span><br><span class="line">	return par[a];</span><br><span class="line">&#125; </span><br><span class="line">bool Union(int a,int b)&#123;</span><br><span class="line">		int r1=find(a);</span><br><span class="line">		int r2=find(b);</span><br><span class="line">		if(r1==r2) return false;</span><br><span class="line">		//else par[a]=b;</span><br><span class="line">		par[r1]=r2;//!!</span><br><span class="line">		return true; </span><br><span class="line">&#125;</span><br><span class="line">void dfs(int cur,int hei,int pre)&#123;</span><br><span class="line">	if(hei&gt;maxn)&#123;</span><br><span class="line">		maxn=hei;</span><br><span class="line">		tmp.clear();</span><br><span class="line">		tmp.push_back(cur);</span><br><span class="line">	&#125;</span><br><span class="line">	if(hei==maxn)&#123;</span><br><span class="line">			tmp.push_back(cur);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;vec[cur].size();i++)&#123;</span><br><span class="line">		int v=vec[cur][i];</span><br><span class="line">		if(v==pre) continue;</span><br><span class="line">		dfs(v,hei+1,cur); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//	freopen(&quot;3-18.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	int n,a,b;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">	par[i]=i;</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		vec[a].push_back(b);</span><br><span class="line">		vec[b].push_back(a);</span><br><span class="line">		Union(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		isR[find(i)]=true;</span><br><span class="line">	&#125;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(isR[i]==true) sum++;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	if(sum!=1)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;Error: &quot;&lt;&lt;sum&lt;&lt;&quot; components&quot;&lt;&lt;endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(1,1,-1);</span><br><span class="line"></span><br><span class="line">	ans=tmp;</span><br><span class="line"></span><br><span class="line">	tmp.clear();</span><br><span class="line">	dfs(ans[0],1,-1);</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;tmp.size();i++)&#123;</span><br><span class="line">		ans.push_back(tmp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(ans.begin(),ans.end());</span><br><span class="line">	for(int i=0;i&lt;ans.size();i++)&#123;</span><br><span class="line">		if(ans[i]!=ans[i+1])</span><br><span class="line">			cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>20分代码 用了ans1,ans,vis,dis 内存超限 应该考虑dfs时带参数，直接把最远距离的点放入ans中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define MAX 10001</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int par[MAX];</span><br><span class="line">vector&lt;int&gt; vec[MAX],ans1,ans2;</span><br><span class="line">bool vis[MAX];</span><br><span class="line">int dis[MAX];</span><br><span class="line">int find(int a)&#123;</span><br><span class="line">	if(par[a]!=a) par[a]=find(par[a]);</span><br><span class="line">	return par[a];</span><br><span class="line">&#125; </span><br><span class="line">bool Union(int a,int b)&#123;</span><br><span class="line">		int r1=find(a);</span><br><span class="line">		int r2=find(b);</span><br><span class="line">		if(r1==r2) return false;</span><br><span class="line">		//else par[a]=b;</span><br><span class="line">		par[r1]=r2;//!!</span><br><span class="line">		return true; </span><br><span class="line">&#125;</span><br><span class="line">void dfs(int cur)&#123;</span><br><span class="line">//	if(vis[cur]) return ;</span><br><span class="line">	vis[cur]=true;</span><br><span class="line">	for(int i=0;i&lt;vec[cur].size();i++)&#123;</span><br><span class="line">		int v=vec[cur][i];</span><br><span class="line">		if(vis[v]) continue;</span><br><span class="line"> 		dis[v]=dis[cur]+1;</span><br><span class="line">		dfs(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	set&lt;int&gt; s;</span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">	memset(dis,0,sizeof(dis));</span><br><span class="line">	int n,a,b;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">	par[i]=i;</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		vec[a].push_back(b);</span><br><span class="line">		vec[b].push_back(a);</span><br><span class="line">		Union(a,b);</span><br><span class="line">//		Union(b,a);</span><br><span class="line">	&#125;</span><br><span class="line">	int r=find(1);</span><br><span class="line">	s.insert(r);</span><br><span class="line">	bool flag=true;</span><br><span class="line">	   for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            int t=find(i);</span><br><span class="line">            if(t!=r)  &#123;</span><br><span class="line">            	flag=false;</span><br><span class="line">			&#125;</span><br><span class="line">            s.insert(t);</span><br><span class="line">        &#125;</span><br><span class="line">	if(flag==false) &#123;</span><br><span class="line">		cout&lt;&lt;&quot;Error: &quot;&lt;&lt;s.size()&lt;&lt;&quot; components&quot;&lt;&lt;endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(1);</span><br><span class="line">//	for(int i=1;i&lt;=n;i++)</span><br><span class="line">//		cout&lt;&lt;dis[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">//		cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	int maxn=-1;</span><br><span class="line">	for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">	if(dis[i]&gt;maxn) &#123;</span><br><span class="line">		ans1.clear();</span><br><span class="line">		maxn=dis[i];ans1.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(dis[i]==maxn)&#123;</span><br><span class="line">		ans1.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int k=0;k&lt;ans1.size();k++)&#123;</span><br><span class="line">		</span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">	memset(dis,0,sizeof(dis));</span><br><span class="line">			dfs(ans1[k]);</span><br><span class="line">	for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">	if(dis[i]&gt;maxn) &#123;</span><br><span class="line">		ans2.clear();</span><br><span class="line">		maxn=dis[i];ans2.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(dis[i]==maxn)&#123;</span><br><span class="line">		ans2.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.clear();</span><br><span class="line">	for(int i=0;i&lt;ans1.size();i++)&#123;</span><br><span class="line">		s.insert(ans1[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;ans2.size();i++)&#123;</span><br><span class="line">		s.insert(ans2[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)</span><br><span class="line">		cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>A1034 Head of a Gang</title>
    <url>/2019/03/18/A1021/</url>
    <content><![CDATA[<p>One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threthold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format:</p>
<p>Name1 Name2 Time<br>where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes.</p>
<p>Output Specification:<br>For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input 1:</span><br><span class="line">8 59</span><br><span class="line">AAA BBB 10</span><br><span class="line">BBB AAA 20</span><br><span class="line">AAA CCC 40</span><br><span class="line">DDD EEE 5</span><br><span class="line">EEE DDD 70</span><br><span class="line">FFF GGG 30</span><br><span class="line">GGG HHH 20</span><br><span class="line">HHH FFF 10</span><br><span class="line">Sample Output 1:</span><br><span class="line">2</span><br><span class="line">AAA 3</span><br><span class="line">GGG 3</span><br><span class="line">Sample Input 2:</span><br><span class="line">8 70</span><br><span class="line">AAA BBB 10</span><br><span class="line">BBB AAA 20</span><br><span class="line">AAA CCC 40</span><br><span class="line">DDD EEE 5</span><br><span class="line">EEE DDD 70</span><br><span class="line">FFF GGG 30</span><br><span class="line">GGG HHH 20</span><br><span class="line">HHH FFF 10</span><br><span class="line">Sample Output 2:</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//用邻接矩阵 用邻接表 不方便存储，加边权 </span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define MAX 10001</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int n,num=0,K;</span><br><span class="line">int g[MAX][MAX],vis[MAX],w[MAX];</span><br><span class="line">map&lt;string,int&gt; sdict,gang;</span><br><span class="line">map&lt;int,string&gt; idict;</span><br><span class="line">void dfs(int cur,int &amp;num,int &amp;sum,int &amp;head)&#123;</span><br><span class="line">	if(!vis[cur]) num++;//!</span><br><span class="line">	vis[cur]=true;</span><br><span class="line">	if(w[cur]&gt;w[head])&#123;</span><br><span class="line">		w[head]=w[cur];</span><br><span class="line">		head=cur;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(g[cur][i]&gt;0)&#123;</span><br><span class="line">//			if(vis[i]) continue; 不重复访问边 </span><br><span class="line">					int tmp=g[cur][i];</span><br><span class="line">			g[cur][i]=g[i][cur]=0;</span><br><span class="line">			sum+=tmp;</span><br><span class="line">			dfs(i,num,sum,head);			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int strToInt(string s)&#123;</span><br><span class="line">	if(sdict.count(s))&#123;</span><br><span class="line">	return sdict[s];	</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">	sdict[s]=num;</span><br><span class="line">	idict[num]=s;</span><br><span class="line">	num++; </span><br><span class="line">	return num-1;</span><br><span class="line">	&#125;; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	//freopen(&quot;3-19.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;K;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		string s1,s2;</span><br><span class="line">		int v;</span><br><span class="line">		cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;v;</span><br><span class="line">		int a=strToInt(s1),b=strToInt(s2);</span><br><span class="line">		g[a][b]+=v;</span><br><span class="line">		g[b][a]+=v;</span><br><span class="line">		w[a]+=v;</span><br><span class="line">		w[b]+=v;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line"></span><br><span class="line">		if(!vis[i])&#123;</span><br><span class="line">					int num=0,sum=0;</span><br><span class="line">	</span><br><span class="line">				int head=i;</span><br><span class="line">			dfs(i,num,sum,head);</span><br><span class="line">			</span><br><span class="line">			if(num&gt;2&amp;&amp;sum&gt;K)&#123;</span><br><span class="line">				gang[idict[head]]=num;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;gang.size()&lt;&lt;endl;</span><br><span class="line">	for(map&lt;string,int&gt;::iterator it=gang.begin();it!=gang.end();it++)&#123;</span><br><span class="line">		cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>A1029 Median </title>
    <url>/2019/03/18/A1029/</url>
    <content><![CDATA[<p>Given an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1 = { 11, 12, 13, 14 } is 12, and the median of S2 = { 9, 10, 15, 16, 17 } is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13.</p>
<p>Given two increasing sequences of integers, you are asked to find their median.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N (≤2×10<br>​5<br>​​ ) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of long int.</p>
<p>Output Specification:<br>For each test case you should output the median of the two given sequences in a line.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">4 11 12 13 14</span><br><span class="line">5 9 10 15 16 17</span><br><span class="line">Sample Output:</span><br><span class="line">13</span><br></pre></td></tr></table></figure></p>
<p>最后一个case容易内存超限 主要方法是第二个数组 边存边比较<br>知道中位数的位置</p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>一个队列存好后，把第二个队列边读，边和第一个队列比较，选择出队。这样可以不用一次存完第二个队列，解决超内存的问题。</p>
<p>思路：<br>第一、二个序列分别有n, m个元素，所以需要从队头剔除（n + m – 1） / 2个元素，最后答案就是两个队头的最小值。对于最终答案在第一第二个队列中的情况要分开处理。若答案在第二个队列中，在输入数据时就可以提前得出答案并退出，若答案在第一个队列中，要二次出队才能找到答案。<br>注意：<br>在所有元素入队列完毕后，把INT_MAX入队列，一是这样队列永不为空，方便处理。<br>修改：<br>1.题目说数据不超过long int, long int占4还是8个字节是要看具体情况的。<br>2.根据测试代码1，测得所有数据不超过int<br>3.根据测试代码2，测得PAT中 long int占8个字节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    queue&lt;int&gt; a, b;</span><br><span class="line">    int n, m, num, cnt = 0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">        a.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    a.push(INT_MAX);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">    for(int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">        b.push(num);</span><br><span class="line">        if(cnt == (n + m - 1) / 2) &#123;</span><br><span class="line">            printf(&quot;%d&quot;, min(a.front(), b.front()));</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a.front() &lt; b.front())   </span><br><span class="line">            a.pop();</span><br><span class="line">        else                        </span><br><span class="line">            b.pop();</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    b.push(INT_MAX);</span><br><span class="line">    for(; cnt &lt; (n + m - 1) / 2; cnt++) &#123;</span><br><span class="line">        if(a.front() &lt; b.front())    </span><br><span class="line">            a.pop();</span><br><span class="line">        else                         </span><br><span class="line">            b.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;, min(a.front(), b.front()));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>开一个数组，在线处理第二个数组。 第一二个数组（下标从1开始）分别有n，m个元素，中间数在(n + m + 1) / 2的位置。所以只要从小到大数到(n + m + 1) / 2的位置就行了~ count计总个数 ，给第一个数组设置指针i，每次从第二个数组中读入temp，检查第一个数组中前几个数是不是比temp小，小就count+1并判断是否到数了中间数，到了就输出。 如果数完比temp小的数还没到中间数，count+1，检查temp是不是中间数，是就输出。循环上述过程。如果第二个数组读取完了，还没数到中间数，说明中间数在剩下的第一个数组中，就在剩下的数组中数到中间数位置即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAXN 1000000</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[MAXN],b[MAXN],num[2*MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	a[n]=INF;</span><br><span class="line">//	for(int i=0;i&lt;=n;i++)</span><br><span class="line">//	cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">	int m;</span><br><span class="line">	cin&gt;&gt;m; </span><br><span class="line">	int tmp;</span><br><span class="line">	int i=0,cnt=0;</span><br><span class="line">	int mid=(n+m+1)/2;</span><br><span class="line">	for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">		cin&gt;&gt;tmp;</span><br><span class="line">		while(a[i]&lt;tmp)&#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				if(cnt==mid) cout&lt;&lt;a[i];</span><br><span class="line">				i++;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt++;</span><br><span class="line">			if(cnt==mid) cout&lt;&lt;tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	while(i&lt;n)&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		 if (cnt == mid) cout &lt;&lt; a[i];</span><br><span class="line">        i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>段错误 内存超限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAXN 200010</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[MAXN],b[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	a[n]=INF;</span><br><span class="line">	int m;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">		for(int i=0;i&lt;m;i++)</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">	b[m]=INF;</span><br><span class="line">	</span><br><span class="line">	int i=0,j=0;</span><br><span class="line">	int sum=(n+m-1)/2;</span><br><span class="line">	int cnt=0;</span><br><span class="line">	while(cnt&lt;sum)&#123;</span><br><span class="line">		if(a[i]&lt;=b[j])&#123;</span><br><span class="line">		i++;</span><br><span class="line">		&#125;</span><br><span class="line">		else j++;</span><br><span class="line">	cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">if(a[i]&lt;b[j]) printf(&quot;%d\n&quot;,a[i]);</span><br><span class="line">else  printf(&quot;%d\n&quot;,b[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAXN 20002</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long a[MAXN],b[MAXN],num[40002];</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	</span><br><span class="line">	int m;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">		for(int i=0;i&lt;m;i++)</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">	int i=0,j=0,k=0;</span><br><span class="line">	while(i&lt;n&amp;&amp;j&lt;m)&#123;</span><br><span class="line">		if(a[i]&lt;=b[j])&#123;</span><br><span class="line">			num[k++]=a[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		else num[k++]=b[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	while(i&lt;n) num[k++]=a[i++];</span><br><span class="line">	while(j&lt;m) num[k++]=b[j++];</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;num[(n+m-1)/2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接<br><a href="https://www.xieminjie.cn/?p=257" target="_blank" rel="noopener">https://www.xieminjie.cn/?p=257</a><br><a href="https://blog.csdn.net/liuchuo/article/details/52221378" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52221378</a></p>
]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title>A1030  Travel Plan</title>
    <url>/2019/03/19/A1030/</url>
    <content><![CDATA[<p>A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:</p>
<p>City1 City2 Distance Cost<br>where the numbers are all integers no more than 500, and are separated by a space.</p>
<p>Output Specification:<br>For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br><span class="line">Sample Output:</span><br><span class="line">0 2 3 3 40</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">#define MAX 510</span><br><span class="line">using namespace std;</span><br><span class="line">int d[MAX],c[MAX],p[MAX];</span><br><span class="line">int cost[MAX][MAX],G[MAX][MAX];</span><br><span class="line">int n,m,st,ed;</span><br><span class="line">bool vis[MAX]=&#123;false&#125;;</span><br><span class="line">void dij(int st)&#123;</span><br><span class="line">	fill(d,d+MAX,INF);//!</span><br><span class="line">	d[st]=0;</span><br><span class="line">	c[st]=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		int min=INF,u=-1;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			if(d[j]&lt;min&amp;&amp;!vis[j])&#123;</span><br><span class="line">				min=d[j];</span><br><span class="line">				u=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(u==-1) return;</span><br><span class="line">		vis[u]=true;//!</span><br><span class="line">		for(int v=0;v&lt;n;v++)&#123;</span><br><span class="line">			if(G[u][v]!=INF&amp;&amp;!vis[v])&#123;</span><br><span class="line">				if(d[v]&gt;d[u]+G[u][v])&#123;</span><br><span class="line">					d[v]=d[u]+G[u][v];</span><br><span class="line">					c[v]=c[u]+cost[u][v];</span><br><span class="line">					p[v]=u;</span><br><span class="line">				&#125;</span><br><span class="line">				else if(d[v]==d[u]+G[u][v])&#123;</span><br><span class="line">					if(c[u]+cost[u][v]&lt;c[v])&#123;</span><br><span class="line">					c[v]=c[u]+cost[u][v];</span><br><span class="line">					p[v]=u;				</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(int v)&#123;</span><br><span class="line">	if(v==st)&#123;</span><br><span class="line">		cout&lt;&lt;v&lt;&lt;&quot; &quot;;return;</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(p[v]);</span><br><span class="line">	cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//	freopen(&quot;3-19.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">//	memset(p,-1,sizeof(p));</span><br><span class="line">	fill(G[0],G[0]+MAX*MAX,INF);</span><br><span class="line">//	memset(vis,0,sizeof(vis));</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		int u,v;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		cin&gt;&gt;G[u][v];//!! cin&gt;&gt;u&gt;&gt;v&gt;&gt;G[u][v] 错误 u,v值还没存储 </span><br><span class="line">		cin&gt;&gt;cost[u][v];</span><br><span class="line">		G[v][u]=G[u][v];//! v,u注意</span><br><span class="line">		cost[v][u]=cost[u][v];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dij(st);</span><br><span class="line">	DFS(ed);</span><br><span class="line">	cout&lt;&lt;d[ed]&lt;&lt;&quot; &quot;&lt;&lt;c[ed]&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">#define MAX 510</span><br><span class="line">using namespace std;</span><br><span class="line">int cost[MAX][MAX],G[MAX][MAX];</span><br><span class="line">int dis[MAX];</span><br><span class="line">int n,m,st,ed;</span><br><span class="line">bool vis[MAX];</span><br><span class="line">int mini=INF;</span><br><span class="line">vector&lt;int&gt; tmp,path,pre[MAX];</span><br><span class="line">void dij(int st)&#123;</span><br><span class="line">	fill(dis,dis+MAX,INF);</span><br><span class="line"></span><br><span class="line">	dis[st]=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		int min=INF,k=-1;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			if(dis[j]&lt;min&amp;&amp;vis[j]==false)&#123;</span><br><span class="line">				min=dis[j];</span><br><span class="line">				k=j;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		if(k==-1) return;//!</span><br><span class="line">		vis[k]=true;</span><br><span class="line">		for(int t=0;t&lt;n;t++)&#123;</span><br><span class="line">			if(G[k][t]!=INF&amp;&amp;vis[t]==false)&#123;</span><br><span class="line">				if(G[k][t]+dis[k]&lt;dis[t])&#123;</span><br><span class="line">				</span><br><span class="line">					dis[t]=G[k][t]+dis[k];</span><br><span class="line">					pre[t].clear();</span><br><span class="line">					pre[t].push_back(k);</span><br><span class="line">				&#125;</span><br><span class="line">				else if(G[k][t]+dis[k]==dis[t])&#123;</span><br><span class="line">							pre[t].push_back(k);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int v)&#123;</span><br><span class="line">	if(v==st)&#123;</span><br><span class="line">		tmp.push_back(v);</span><br><span class="line">		int tmpcost=0;</span><br><span class="line">		for(int j=tmp.size()-1;j&gt;0;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			int u=tmp[j],v=tmp[j-1];</span><br><span class="line">			tmpcost+=cost[u][v];</span><br><span class="line">		&#125;</span><br><span class="line">		if(tmpcost&lt;mini)&#123;</span><br><span class="line">			mini=tmpcost;</span><br><span class="line">			path=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp.pop_back();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	tmp.push_back(v);</span><br><span class="line">	for(int i=0;i&lt;pre[v].size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		DFS(pre[v][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	tmp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;st, &amp;ed);</span><br><span class="line">    fill(G[0], G[0] + MAX*MAX, INF);</span><br><span class="line">    fill(cost[0],cost[0] + MAX*MAX, INF);//!</span><br><span class="line">    for(int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int a, b, len, c;</span><br><span class="line">        scanf(&quot;%d %d %d %d&quot;, &amp;a, &amp;b, &amp;len, &amp;co);</span><br><span class="line">        G[a][b] = G[b][a] = len;</span><br><span class="line">       cost[a][b] = cost[b][a] = co;</span><br><span class="line">    &#125;</span><br><span class="line">    dij(st);</span><br><span class="line">    DFS(ed);</span><br><span class="line">    for(int i = path.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, path[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d %d\n&quot;, dis[ed], mini);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接<br><a href="https://blog.csdn.net/feng_zhiyu/article/details/81275054" target="_blank" rel="noopener">https://blog.csdn.net/feng_zhiyu/article/details/81275054</a></p>
]]></content>
  </entry>
  <entry>
    <title>A1040 Longest Symmetric String</title>
    <url>/2019/03/11/A1040/</url>
    <content><![CDATA[<p>Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&amp;TAP symmetric?, the longest symmetric sub-string is s PAT&amp;TAP s, hence you must output 11.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case which gives a non-empty string of length no more than 1000.</p>
<p>Output Specification:<br>For each test case, simply print the maximum length in a line.</p>
<p>Sample Input:<br>Is PAT&amp;TAP symmetric?<br>Sample Output:<br>11</p>
<p><strong>dp[i][j]表示从i到j的子串是否为回文串<br>注意是枚举子串的长度和起始位置<br>如果枚举两个端点 就无后效性</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX 1001</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[MAX][MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	string  s;</span><br><span class="line">//	cin&gt;&gt;s;</span><br><span class="line">getline(cin,s);</span><br><span class="line">	memset(dp,0,sizeof(dp));</span><br><span class="line">	int len=s.length();</span><br><span class="line">	int ans=1;</span><br><span class="line">	for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">		dp[i][i]=1;</span><br><span class="line">		if(i&lt;len-1)&#123;</span><br><span class="line">		if(s[i]==s[i+1]) &#123;</span><br><span class="line">			dp[i][i+1]=1;</span><br><span class="line">			ans=2;</span><br><span class="line">		&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int l=3;l&lt;=len;l++)&#123;</span><br><span class="line">		for(int i=0;i&lt;len-l+1;i++)&#123;</span><br><span class="line">			int j=i+l-1;</span><br><span class="line">			if(s[i]==s[j]&amp;&amp;dp[i+1][j-1]==1)&#123;</span><br><span class="line">				dp[i][j]=1;</span><br><span class="line">				ans=l;</span><br><span class="line">			&#125;</span><br><span class="line">			else dp[i][j]=0; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>A1051  Pop Sequence </title>
    <url>/2019/03/30/A1051/</url>
    <content><![CDATA[<p>Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.</p>
<p>Output Specification:<br>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br><span class="line">Sample Output:</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure></p>
<p><strong>注意 必须判断是否栈空</strong><br><strong>在每个出栈序列前一定要清空栈,否则上个出栈序列没清空 会影响下次出栈序列过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1010</span><br><span class="line">int arr[MAX];</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int M,N,K;</span><br><span class="line">	cin&gt;&gt;M&gt;&gt;N&gt;&gt;K;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;K;i++)&#123;	</span><br><span class="line">	 while(!s.empty())&#123;</span><br><span class="line">	   s.pop();</span><br><span class="line">	 &#125;</span><br><span class="line">		for(int j=1;j&lt;=N;j++ )&#123;</span><br><span class="line">			cin&gt;&gt;arr[j];</span><br><span class="line">//			if(arr[j])</span><br><span class="line">		&#125;</span><br><span class="line">	int cur=1;</span><br><span class="line">	bool f=true;// 3 2 1 5 6 4 </span><br><span class="line">	for(int k=1;k&lt;=N;k++)&#123;</span><br><span class="line">			s.push(k);</span><br><span class="line">			if(s.size()&gt;M) &#123;</span><br><span class="line">				f=false;break;</span><br><span class="line">			&#125;</span><br><span class="line">		while(!s.empty()&amp;&amp;s.top()==arr[cur])&#123;</span><br><span class="line">			s.pop();</span><br><span class="line">			cur++;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(f==true&amp;&amp;s.empty()==true) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>A1057 Stack </title>
    <url>/2019/03/11/A1057/</url>
    <content><![CDATA[<p>Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian – return the median value of all the elements in the stack. With N elements, the median value is defined to be the (N/2)-th smallest element if N is even, or ((N+1)/2)-th if N is odd.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. For each case, the first line contains a positive integer N (≤10<br>​5<br>​​ ). Then N lines follow, each contains a command in one of the following 3 formats:</p>
<p>Push key<br>Pop<br>PeekMedian<br>where key is a positive integer no more than 10<br>​5<br>​​ .</p>
<p>Output Specification:<br>For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">17</span><br><span class="line">Pop</span><br><span class="line">PeekMedian</span><br><span class="line">Push 3</span><br><span class="line">PeekMedian</span><br><span class="line">Push 2</span><br><span class="line">PeekMedian</span><br><span class="line">Push 1</span><br><span class="line">PeekMedian</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 4</span><br><span class="line">PeekMedian</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Sample Output:</span><br><span class="line">Invalid</span><br><span class="line">Invalid</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">Invalid</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//push的是正数 c[1] c[2]这样才有值 </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">#define maxn 100010</span><br><span class="line">int c[maxn];</span><br><span class="line"></span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">	return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line">int getSum(int x)&#123;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=x;i&gt;0;i-=lowbit(i))&#123;</span><br><span class="line">		sum+=c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line">void update(int x,int v)&#123;</span><br><span class="line">	for(int i=x;i&lt;=maxn;i+=lowbit(i))&#123;</span><br><span class="line">		c[i]+=v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//求中位数! </span><br><span class="line">void PeekMedian()&#123;</span><br><span class="line">	int l=1,r=maxn;</span><br><span class="line">	int k=(s.size()+1)/2;</span><br><span class="line">	while(l&lt;r)&#123;</span><br><span class="line">		int mid=(l+r)/2;</span><br><span class="line">		if(getSum(mid)&gt;=k)&#123;</span><br><span class="line">			r=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			l=mid+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	//freopen(&quot;t1.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">		int x;</span><br><span class="line">	string str;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(i&lt;n)&#123;</span><br><span class="line">		cin&gt;&gt;str;</span><br><span class="line">		if(str==&quot;Pop&quot;)&#123;</span><br><span class="line">			if(s.empty()) cout&lt;&lt;&quot;Invalid&quot;&lt;&lt;endl;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line">				update(s.top(),-1);</span><br><span class="line">				s.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(str==&quot;Push&quot;)&#123;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			s.push(x);</span><br><span class="line">			update(x,1);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(str==&quot;PeekMedian&quot;)&#123;</span><br><span class="line">				if(s.empty()) cout&lt;&lt;&quot;Invalid&quot;&lt;&lt;endl;</span><br><span class="line">			 else PeekMedian();</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">#define maxn 100010</span><br><span class="line">int c[maxn];</span><br><span class="line"></span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">	return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line">int getSum(int x)&#123;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=x;i&gt;0;i-=lowbit(i))&#123;</span><br><span class="line">		sum+=c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line">void update(int x,int v)&#123;</span><br><span class="line">	for(int i=x;i&lt;maxn;i+=lowbit(i))&#123;</span><br><span class="line">		c[i]+=v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void PeekMedian()&#123;</span><br><span class="line">	int l=0,r=maxn,ans;</span><br><span class="line">	int k=(s.size()+1)/2;</span><br><span class="line">	while(l&lt;=r)&#123;</span><br><span class="line">		int mid=(l+r)/2;</span><br><span class="line">		if(getSum(mid)&gt;k)&#123;</span><br><span class="line">			r=mid-1;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(getSum(mid)==k) ans=mid;</span><br><span class="line">		else&#123;</span><br><span class="line">			l=mid+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	string str;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(i&lt;n)&#123;</span><br><span class="line">		cin&gt;&gt;str;</span><br><span class="line">		if(str==&quot;Pop&quot;)&#123;</span><br><span class="line">			if(s.empty()) cout&lt;&lt;&quot;Invalid&quot;&lt;&lt;endl;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line">				update(s.top(),-1);</span><br><span class="line">				s.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(str==&quot;Push&quot;)&#123;</span><br><span class="line">			int x;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			s.push(x);</span><br><span class="line">			update(x,1);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(str==&quot;PeekMedian&quot;)&#123;</span><br><span class="line">				if(s.empty()) cout&lt;&lt;&quot;Invalid&quot;&lt;&lt;endl;</span><br><span class="line">			 PeekMedian();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>BIT</tag>
      </tags>
  </entry>
  <entry>
    <title>A1068. Find More Coins </title>
    <url>/2019/03/11/A1068-1/</url>
    <content><![CDATA[<p>Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 10<br>​4<br>​​  coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (≤10<br>​4<br>​​ , the total number of coins) and M (≤10<br>​2<br>​​ , the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space.</p>
<p>Output Specification:<br>For each test case, print in one line the face values V<br>​1<br>​​ ≤V<br>​2<br>​​ ≤⋯≤V<br>​k<br>​​  such that V<br>​1<br>​​ +V<br>​2<br>​​ +⋯+V<br>​k<br>​​ =M. All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output “No Solution” instead.</p>
<p>Note: sequence {A[1], A[2], …} is said to be “smaller” than sequence {B[1], B[2], …} if there exists k≥1 such that A[i]=B[i] for all i&lt;k, and A[k] &lt; B[k].<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input 1:</span><br><span class="line">8 9</span><br><span class="line">5 9 8 7 2 3 4 1</span><br><span class="line">Sample Output 1:</span><br><span class="line">1 3 5</span><br><span class="line">Sample Input 2:</span><br><span class="line">4 8</span><br><span class="line">7 2 4 3</span><br><span class="line">Sample Output 2:</span><br><span class="line">No Solution</span><br></pre></td></tr></table></figure></p>
<p>题目大意：用n个硬币买价值为m的东西，输出使用方案，使得正好几个硬币加起来价值为m。从小到大排列，输出最小的那个排列方案<br>分析：<br>此题中价值c[i]和w[i]是等价的<br>dp[i][j]表示前i(0&lt;=i&lt;n)项物品刚好装进容量为j(0&lt;=j&lt;m)的背包所能获得的最大价值</p>
<p>choice[i][j]表明进行状态转移时选取的哪个策略</p>
<p>01背包问题，因为要输出从小到大的排列，可以先把硬币面额从大到小排列，然后用bool类型的choice[i][j]是否选取，如果选取了就令choice为true；然后进行01背包问题求解，如果最后求解的结果不是恰好等于所需要的价值的，就输出No Soultion，否则从choice[i][j]判断选取的情况，i从n到1表示从后往前看第i个物品的选取情况，j从m到0表示从容量m到0是否选取(j = j – w[i])，把选取情况压入arr向量中，最后输出arr元素<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAX 10001</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">int w[MAX],dp[110],choice[MAX][110];</span><br><span class="line">int cmp(int a,int b)&#123;</span><br><span class="line">	return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;w[i]; </span><br><span class="line">	sort(w,w+n,cmp);</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int v=m;v&gt;=w[i];v--)&#123;</span><br><span class="line">			if(dp[v]&lt;=dp[v-w[i]]+w[i])&#123;</span><br><span class="line">				dp[v]=dp[v-w[i]]+w[i];</span><br><span class="line">				choice[i][v]=1;</span><br><span class="line">			&#125;</span><br><span class="line">			else choice[i][v]=0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		vector&lt;int&gt; arr;</span><br><span class="line">	if(dp[m]!=m) &#123;</span><br><span class="line">		cout&lt;&lt;&quot;No Solution&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else&#123;</span><br><span class="line">		int v=m,k=n-1;</span><br><span class="line">		while(k&gt;=0)&#123;</span><br><span class="line">			if(choice[k][v]==1)&#123;</span><br><span class="line">				arr.push_back(w[k]);</span><br><span class="line">				v-=w[k];</span><br><span class="line">			&#125;</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	for(int j=0;j&lt;arr.size();j++)&#123;</span><br><span class="line">		cout&lt;&lt;arr[j];</span><br><span class="line">		if(j!=arr.size()-1) cout&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dfs+剪枝<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 10001</span><br><span class="line">int n,m,w[MAX];</span><br><span class="line">vector&lt;int&gt; ans;</span><br><span class="line">bool flag=false;</span><br><span class="line">void dfs(int index,int sum)&#123;</span><br><span class="line">	//剪枝 </span><br><span class="line">	if(flag||sum&gt;m) return;</span><br><span class="line">	if(sum==m)&#123;</span><br><span class="line">		flag=true;</span><br><span class="line">		for(vector&lt;int&gt;::iterator it=ans.begin();it!=ans.end();it++)&#123;</span><br><span class="line">		 		cout&lt;&lt;*it;</span><br><span class="line">		 		if(it!=ans.end()-1)cout&lt;&lt;&quot; &quot;; </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int j=index;j&lt;n;j++)&#123;</span><br><span class="line">		ans.push_back(w[j]);</span><br><span class="line">		dfs(j+1,sum+w[j]);</span><br><span class="line">		ans.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//freopen(&quot;31.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;w[i]; </span><br><span class="line">			sum+=w[i];</span><br><span class="line">	&#125;</span><br><span class="line">if(sum&lt;m)&#123;</span><br><span class="line">	       cout&lt;&lt;&quot;No Solution&quot;&lt;&lt;endl;</span><br><span class="line">	       return 0;</span><br><span class="line">&#125;</span><br><span class="line">	sort(w,w+n);</span><br><span class="line">	dfs(0,0);</span><br><span class="line">	 if(!flag) &#123;</span><br><span class="line">       cout&lt;&lt;&quot;No Solution&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="https://blog.csdn.net/feng_zhiyu/article/details/82259498" target="_blank" rel="noopener">https://blog.csdn.net/feng_zhiyu/article/details/82259498</a><br><a href="https://www.liuchuo.net/archives/2323" target="_blank" rel="noopener">https://www.liuchuo.net/archives/2323</a><br><a href="https://blog.csdn.net/xyt8023y/article/details/47255241" target="_blank" rel="noopener">https://blog.csdn.net/xyt8023y/article/details/47255241</a></p>
]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>算法提高 合并石子  </title>
    <url>/2019/03/12/A1068/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　在一条直线上有n堆石子，每堆有一定的数量，每次可以将两堆相邻的石子合并，合并后放在两堆的中间位置，合并的费用为两堆石子的总数。求把所有石子合并成一堆的最小花费。<br>  <a id="more"></a><br>输入格式<br>　　输入第一行包含一个整数n，表示石子的堆数。<br>　　接下来一行，包含n个整数，按顺序给出每堆石子的大小 。<br>输出格式<br>　　输出一个整数，表示合并的最小花费。<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">样例输出</span><br><span class="line">33</span><br><span class="line">数据规模和约定</span><br><span class="line">　　1&lt;=n&lt;=1000, 每堆石子至少1颗，最多10000颗。</span><br></pre></td></tr></table></figure></p>
<p>四边形不等式<br><strong>s[i][j]表示dp[i][j]最优解的位置</strong></p>
<p>我们可以证明，s[i,j-1]≤s[i,j]≤s[i+1,j]<br>那么改变状态转移方程为：<br>dp[i,j]=min{dp[i,k]+dp[k,j]+w[i][j]}(s[i,j-1]≤k≤s[i+1,j])</p>
<p>w[i][j]=sum[j]-sum[i-1] 表示i到j堆石子数量之和  即以k为分割点合并的代价<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX 1010</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int cost[MAX],dp[MAX][MAX],sum[MAX],s[MAX][MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	cin&gt;&gt;cost[i];</span><br><span class="line">	memset(sum,0,sizeof(sum));</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	sum[i]=sum[i-1]+cost[i];</span><br><span class="line">	for(int v=2;v&lt;=n;v++ )&#123;</span><br><span class="line">		for(int i=1;i&lt;=n-v+1;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			int j=i+v-1; </span><br><span class="line">			int k1=(s[i][j-1]&gt;i)?s[i][j-1]:i;</span><br><span class="line">			int k2=(s[i+1][j]&lt;j)?s[i+1][j]:j;</span><br><span class="line">			dp[i][j]=dp[i][k1]+dp[k1+1][j];</span><br><span class="line">			s[i][j]=k1;</span><br><span class="line">			for(int k=k1+1;k&lt;=k2;k++)&#123;</span><br><span class="line">				if(dp[i][j]&gt;dp[i][k]+dp[k+1][j])&#123;</span><br><span class="line">					dp[i][j]=dp[i][k]+dp[k+1][j];</span><br><span class="line">					s[i][j]=k; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			dp[i][j]+=sum[j]-sum[i-1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[1][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://blog.csdn.net/gatieme/article/details/49206193" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/49206193</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>A1072 Gas Station </title>
    <url>/2019/03/20/A1072/</url>
    <content><![CDATA[<p>A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range.</p>
<p>Now given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number.</p>
<p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains 4 positive integers: N (≤10<br>​3<br>​​ ), the total number of houses; M (≤10), the total number of the candidate locations for the gas stations; K (≤10<br>​4<br>​​ ), the number of roads connecting the houses and the gas stations; and D<br>​S<br>​​ , the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N, and all the candidate locations are numbered from G1 to  GM.</p>
<p>Then K lines follow, each describes a road in the format</p>
<p>P1 P2 Dist<br>where P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road.</p>
<p>Output Specification:<br>For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output No Solution.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input 1:</span><br><span class="line">4 3 11 5</span><br><span class="line">1 2 2</span><br><span class="line">1 4 2</span><br><span class="line">1 G1 4</span><br><span class="line">1 G2 3</span><br><span class="line">2 3 2</span><br><span class="line">2 G2 1</span><br><span class="line">3 4 2</span><br><span class="line">3 G3 2</span><br><span class="line">4 G1 3</span><br><span class="line">G2 G1 1</span><br><span class="line">G3 G2 2</span><br><span class="line">Sample Output 1:</span><br><span class="line">G1</span><br><span class="line">2.0 3.3</span><br><span class="line">Sample Input 2:</span><br><span class="line">2 1 2 10</span><br><span class="line">1 G1 9</span><br><span class="line">2 G1 20</span><br><span class="line">Sample Output 2:</span><br><span class="line">No Solution</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">#define MAX 1020</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,k,ds;</span><br><span class="line">int dis[MAX],g[MAX][MAX];</span><br><span class="line">vector&lt;int&gt; pre[MAX],tmp,path;</span><br><span class="line">int vis[MAX];</span><br><span class="line">int mini=INF,lremain=INF;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">void dij(int src)&#123;</span><br><span class="line">	fill(dis,dis+MAX,INF);</span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">	dis[src]=0;</span><br><span class="line">	//循环n+m次 每一次占一个点（城堡） V S-v集合 </span><br><span class="line">	for(int i=0;i&lt;n+m;i++)&#123;</span><br><span class="line">		int min=INF,u=-1;</span><br><span class="line">		for(int j=1;j&lt;=n+m;j++)&#123;</span><br><span class="line">			if(!vis[j]&amp;&amp;dis[j]&lt;min)&#123;</span><br><span class="line">				min=dis[j];u=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(u==-1) return;</span><br><span class="line">		vis[u]=true;</span><br><span class="line">		for(int v=1;v&lt;=n+m;v++)&#123;</span><br><span class="line">			if(vis[v]||g[u][v]==INF) continue;</span><br><span class="line">			if(dis[u]+g[u][v]&lt;dis[v])&#123;</span><br><span class="line">				dis[v]=dis[u]+g[u][v];</span><br><span class="line">				pre[v].clear();</span><br><span class="line">				pre[v].push_back(u);</span><br><span class="line">			&#125;</span><br><span class="line">			else if(dis[u]+g[u][v]==dis[v])&#123;</span><br><span class="line">					pre[v].push_back(u);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">&#125;</span><br><span class="line">int getId(string s)&#123;</span><br><span class="line">	int ans=0;</span><br><span class="line">	bool flag=false;</span><br><span class="line">	for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">		if(s[i]==&apos;G&apos;)&#123;</span><br><span class="line">			flag=true;</span><br><span class="line">		&#125;</span><br><span class="line">		else ans=ans*10+s[i]-&apos;0&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	if(flag==true) return n+ans;</span><br><span class="line">	else return ans;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">//	freopen(&quot;21.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	fill(g[0],g[0]+MAX*MAX,INF);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;ds; </span><br><span class="line">	int ansid=-1;</span><br><span class="line">	double ansA=INF,ansL=-1;</span><br><span class="line">	for(int i=0;i&lt;k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string s1,s2;</span><br><span class="line">		int d;</span><br><span class="line">		cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;d;</span><br><span class="line">		int u=getId(s1),v=getId(s2);</span><br><span class="line">		g[u][v]=g[v][u]=d;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=n+1;i&lt;=n+m;i++)&#123;</span><br><span class="line">		dij(i);</span><br><span class="line">		int  min=INF,u=-1;</span><br><span class="line">		double avg=0;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			if(dis[j]&lt;min)&#123;</span><br><span class="line">				u=j;</span><br><span class="line">				min=dis[j];</span><br><span class="line">			&#125;</span><br><span class="line">			if(dis[j]&gt;ds) &#123;</span><br><span class="line">				min=-1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			avg+=1.0*dis[j]/n;</span><br><span class="line">		&#125;</span><br><span class="line">//		cout&lt;&lt;min&lt;&lt;&quot; &quot;&lt;&lt;avg&lt;&lt;endl;</span><br><span class="line">		if(min==-1) continue;</span><br><span class="line">//		if(min&gt;ds) &#123;</span><br><span class="line">//			continue;</span><br><span class="line">//		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		if(min&gt;ansL)&#123;</span><br><span class="line">			ansid=i; </span><br><span class="line">			ansL=min;</span><br><span class="line">			ansA=avg;</span><br><span class="line">		&#125; </span><br><span class="line">		else if(min==ansL)&#123;</span><br><span class="line">			if(avg&lt;ansA)&#123;</span><br><span class="line">				ansid=i; //!</span><br><span class="line">				ansA=avg;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(ansid==-1) cout&lt;&lt;&quot;No Solution&quot;&lt;&lt;endl;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout&lt;&lt;&apos;G&apos;&lt;&lt;ansid-n&lt;&lt;endl;</span><br><span class="line">		printf(&quot;%.1f %.1f\n&quot;,ansL,ansA);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>dij</tag>
      </tags>
  </entry>
  <entry>
    <title>A1076 Forwards on Weibo </title>
    <url>/2019/03/18/A1076/</url>
    <content><![CDATA[<p>Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤1000), the number of users; and L (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format:</p>
<p>M[i] user_list[i]<br>where M[i] (≤100) is the total number of people that user[i] follows; and user_list[i] is a list of the  M[i] users that followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.</p>
<p>Then finally a positive K is given, followed by K UserID’s for query.</p>
<p>Output Specification:<br>For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">7 3</span><br><span class="line">3 2 3 4</span><br><span class="line">0</span><br><span class="line">2 5 6</span><br><span class="line">2 3 1</span><br><span class="line">2 3 4</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">2 2 6</span><br><span class="line">Sample Output:</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define MAX 10001</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt; g[MAX];</span><br><span class="line">bool vis[MAX];</span><br><span class="line">int n,lev,num=0;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int v,step;</span><br><span class="line">	node(int vv,int ss):v(vv),step(ss)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	node()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//freopen(&quot;3-19.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;lev;</span><br><span class="line">	int k;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		for(int j=0;j&lt;k;j++)&#123;</span><br><span class="line">			int t;</span><br><span class="line">			cin&gt;&gt;t;</span><br><span class="line">			g[t].push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">	int ori;</span><br><span class="line">	for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">		num=0;</span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">		cin&gt;&gt;ori;</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	q.push(node(ori,0));</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		node t=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">	</span><br><span class="line">		if(vis[t.v]) continue;//!</span><br><span class="line">		if(t.step&gt;lev) break;</span><br><span class="line">		else 	num++;</span><br><span class="line">		vis[t.v]=true;</span><br><span class="line">		for(int j=0;j&lt;g[t.v].size();j++)&#123;</span><br><span class="line">			int u=g[t.v][j];</span><br><span class="line">			if(vis[u]) continue;</span><br><span class="line">			q.push(node(u,t.step+1));</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;num-1&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>A1075 PAT Judge</title>
    <url>/2019/01/26/A1075-PAT-Judge/</url>
    <content><![CDATA[<p>The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.<br><a id="more"></a></p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains 3 positive integers, N (≤10^4), the total number of users, K (≤5), the total number of problems, and M (≤10^5 ), the total number of submissions. It is then assumed that the user id’s are 5-digit numbers from 00001 to N, and the problem id’s are from 1 to K. The next line contains K positive integers p[i] (i=1, …, K), where p[i] corresponds to the full mark of the i-th problem. Then M lines follow, each gives the information of a submission in the following format:</p>
<p>user_id problem_id partial_score_obtained<br>where partial_score_obtained is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, p[problem_id]]. All the numbers in a line are separated by a space.</p>
<p>Output Specification:<br>For each test case, you are supposed to output the ranklist in the following format:</p>
<p>rank user_id total_score s[1] … s[K]</p>
<p>where rank is calculated according to the total_score, and all the users with the same total_score obtain the same rank; and s[i] is the partial score obtained for the i-th problem. If a user has never submitted a solution for a problem, then “-“ must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.</p>
<p>The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id’s. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">7 4 20</span><br><span class="line">20 25 25 30</span><br><span class="line">00002 2 12</span><br><span class="line">00007 4 17</span><br><span class="line">00005 1 19</span><br><span class="line">00007 2 25</span><br><span class="line">00005 1 20</span><br><span class="line">00002 2 2</span><br><span class="line">00005 1 15</span><br><span class="line">00001 1 18</span><br><span class="line">00004 3 25</span><br><span class="line">00002 2 25</span><br><span class="line">00005 3 22</span><br><span class="line">00006 4 -1</span><br><span class="line">00001 2 18</span><br><span class="line">00002 1 20</span><br><span class="line">00004 1 15</span><br><span class="line">00002 4 18</span><br><span class="line">00001 3 4</span><br><span class="line">00001 4 2</span><br><span class="line">00005 2 -1</span><br><span class="line">00004 2 0</span><br><span class="line">Sample Output:</span><br><span class="line">1 00002 63 20 25 - 18</span><br><span class="line">2 00005 42 20 0 22 -</span><br><span class="line">2 00007 42 - 25 - 17</span><br><span class="line">2 00001 42 18 18 4 2</span><br><span class="line">5 00004 40 15 0 25 -</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int full[6];</span><br><span class="line">struct student&#123;</span><br><span class="line">	int id;</span><br><span class="line">	int score[6];</span><br><span class="line">	int sum;</span><br><span class="line">	int r;</span><br><span class="line">	int total; </span><br><span class="line">	bool flag;</span><br><span class="line">&#125;stu[10001];</span><br><span class="line">bool cmp(student a,student b)&#123;</span><br><span class="line">	if(a.sum!=b.sum) return a.sum&gt;b.sum;</span><br><span class="line">	if(a.total!=b.total) return a.total&gt;b.total;</span><br><span class="line">	if(a.id!=b.id) return a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int N,K,M;</span><br><span class="line">//	freopen(&quot;s1.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;N,&amp;K,&amp;M);</span><br><span class="line">	for(int i=1;i&lt;=K;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;full[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int j=1;j&lt;=N;j++)&#123;</span><br><span class="line">		stu[j].total=0;</span><br><span class="line">		stu[j].sum=0;</span><br><span class="line">			stu[j].id=j;</span><br><span class="line">		stu[j].flag=false;</span><br><span class="line">		for(int k=1;k&lt;=K;k++)</span><br><span class="line">			stu[j].score[k]=-1;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int j=0;j&lt;M;j++)&#123;</span><br><span class="line">		int id,pid,grade;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;id,&amp;pid,&amp;grade);</span><br><span class="line">		if(grade==-1)&#123;//某题某一次编译错误 </span><br><span class="line">			if(stu[id].score[pid]==-1)stu[id].score[pid]=0;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if(grade==full[pid]&amp;&amp;stu[id].score[pid]&lt;full[pid])&#123;</span><br><span class="line">				stu[id].total++;</span><br><span class="line">			&#125;</span><br><span class="line">			stu[id].score[pid]=max(stu[id].score[pid],grade);</span><br><span class="line">			stu[id].flag=true;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	for(int j=1;j&lt;=N;j++)&#123;</span><br><span class="line">		for(int k=1;k&lt;=K;k++ )&#123;</span><br><span class="line">			if(stu[j].score[k]!=-1)</span><br><span class="line">			stu[j].sum+=stu[j].score[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	sort(stu+1,stu+N+1,cmp);</span><br><span class="line">	stu[1].r=1;</span><br><span class="line">	for(int k=2;k&lt;=N;k++)&#123;</span><br><span class="line">		if(stu[k].sum==stu[k-1].sum) stu[k].r=stu[k-1].r;</span><br><span class="line">		else stu[k].r=k;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">	if(stu[i].flag!=false)&#123;</span><br><span class="line">			printf(&quot;%d %05d %d&quot;,stu[i].r,stu[i].id,stu[i].sum);</span><br><span class="line">			for(int j=1;j&lt;=K;j++)</span><br><span class="line">			if(stu[i].score[j]==-1) printf(&quot; -&quot;);</span><br><span class="line">			else printf(&quot; %d&quot;,stu[i].score[j]);</span><br><span class="line">				cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
  </entry>
  <entry>
    <title>A1081 Rational Sum</title>
    <url>/2019/03/25/A1081/</url>
    <content><![CDATA[<p>Given N rational numbers in the form numerator/denominator, you are supposed to calculate their sum.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. Each case starts with a positive integer N (≤100), followed in the next line N rational numbers a1/b1 a2/b2 … where all the numerators and denominators are in the range of long int. If there is a negative number, then the sign must appear in front of the numerator.</p>
<p>Output Specification:<br>For each test case, output the sum in the simplest form integer numerator/denominator where  integer is the integer part of the sum, numerator &lt; denominator, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input 1:</span><br><span class="line">5</span><br><span class="line">2/5 4/15 1/30 -2/60 8/3</span><br><span class="line">Sample Output 1:</span><br><span class="line">3 1/3</span><br><span class="line">Sample Input 2:</span><br><span class="line">2</span><br><span class="line">4/3 2/3</span><br><span class="line">Sample Output 2:</span><br><span class="line">2</span><br><span class="line">Sample Input 3:</span><br><span class="line">3</span><br><span class="line">1/3 -1/6 1/8</span><br><span class="line">Sample Output 3:</span><br><span class="line">7/24</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt; </span><br><span class="line">#define MAX 110</span><br><span class="line">using namespace std;</span><br><span class="line">struct fract&#123;</span><br><span class="line">	int a,b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int n;</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">	if(a%b==0) return b;</span><br><span class="line">	gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">fract f[MAX];</span><br><span class="line">fract redu(fract m)&#123;</span><br><span class="line">	fract res;</span><br><span class="line">	if(m.b&lt;0)&#123;</span><br><span class="line">		m.b=-m.b;</span><br><span class="line">		m.a=-m.a;</span><br><span class="line">	&#125; </span><br><span class="line">	int g=gcd(abs(m.a),abs(m.b));</span><br><span class="line">	res.a=m.a/g;</span><br><span class="line">	res.b=m.b/g;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">fract add(fract m,fract n)&#123;</span><br><span class="line">	fract res;</span><br><span class="line">	res.b=m.b*n.b;</span><br><span class="line">	res.a=m.a*n.b+n.a*m.b;</span><br><span class="line">	return redu(res); </span><br><span class="line">	 </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void show(fract ff)&#123;</span><br><span class="line">	if(ff.b==1) &#123;</span><br><span class="line">	cout&lt;&lt;ff.a&lt;&lt;endl;</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else if(abs(ff.a)&gt;ff.b)&#123;</span><br><span class="line">	int t=ff.a/ff.b;</span><br><span class="line">	int wei=ff.a-ff.b*t;</span><br><span class="line">	cout&lt;&lt;t&lt;&lt;&quot; &quot;&lt;&lt;wei&lt;&lt;&quot;/&quot;&lt;&lt;ff.b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else cout&lt;&lt;ff.a&lt;&lt;&quot;/&quot;&lt;&lt;ff.b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	fract sum;</span><br><span class="line">	sum.a=0;</span><br><span class="line">	sum.b=1;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d/%d&quot;,&amp;f[i].a,&amp;f[i].b);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		sum=add(sum,f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	show(sum);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>A1086 Tree Traversals Again </title>
    <url>/2019/04/20/A1086/</url>
    <content><![CDATA[<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.<br><a id="more"></a><br>Figure 1<br>Input Specification:<br>Each input file contains one test case. For each case, the first line contains a positive integer N (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p>
<p>Output Specification:<br>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure></p>
<p>解题思路<br>先序遍历序列是push的顺序<br>中序遍历序列是pop的顺序<br>先序：先中间后左右(中左右)<br>中序：先左后中再右（左中右）</p>
<p>在中序序列中找根节点（中间元素） 再递归左右建立二叉树<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 50 </span><br><span class="line">stack&lt;int&gt; st;</span><br><span class="line">int n;</span><br><span class="line">int pre[MAX],mid[MAX];</span><br><span class="line">struct node&#123;</span><br><span class="line">	int data;</span><br><span class="line">	node *l,*r;</span><br><span class="line">&#125;;</span><br><span class="line">node* create(int preL,int preR,int inL,int inR)&#123;</span><br><span class="line">	//递归要有终止条件</span><br><span class="line">	if(preL&gt;preR)&#123;</span><br><span class="line">		return NULL;//!</span><br><span class="line">	&#125; </span><br><span class="line">	node *head=(node*)malloc(sizeof(node));</span><br><span class="line">	head-&gt;data=pre[preL];</span><br><span class="line">	int k;</span><br><span class="line">	for(int i=inL;i&lt;=inR;i++)&#123;</span><br><span class="line">		if(mid[i]==pre[preL])&#123;</span><br><span class="line">			k=i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int numl=k-inL;</span><br><span class="line">	head-&gt;l=create(preL+1,preL+numl,inL,k-1);</span><br><span class="line">		head-&gt;r=create(preL+numl+1,preR,k+1,inR);</span><br><span class="line">		return head;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int num=0;</span><br><span class="line">void postorder(node *root)&#123;</span><br><span class="line">	if(root==NULL) return;</span><br><span class="line">	postorder(root-&gt;l);</span><br><span class="line">	postorder(root-&gt;r);</span><br><span class="line">	num++;</span><br><span class="line">	cout&lt;&lt;root-&gt;data;</span><br><span class="line">	if(num&lt;n) cout&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	char str[20];</span><br><span class="line">	int pind=0,zind=0,x;</span><br><span class="line">	for(int i=0;i&lt;2*n;i++)&#123;</span><br><span class="line">		scanf(&quot;%s&quot;,str);</span><br><span class="line">		if(strcmp(str,&quot;Push&quot;)==0)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">			pre[pind++]=x;</span><br><span class="line">			st.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">//			scanf(&quot;%d&quot;,&amp;x);	</span><br><span class="line">			mid[zind++]=st.top();</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">//	node * root=create(0,pind-1,0,zind-1);!</span><br><span class="line">node * root=create(0,n-1,0,n-1);</span><br><span class="line">	postorder(root);	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>pat</category>
      </categories>
  </entry>
  <entry>
    <title>A1082 Read Number in Chinese</title>
    <url>/2019/01/25/A1082-Read-Number-in-Chinese/</url>
    <content><![CDATA[<p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case, which gives an integer with no more than 9 digits.</p>
<p>Output Specification:<br>For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.</p>
<p>Sample Input 1:</p>
<p>-123456789</p>
<p>Sample Output 1:</p>
<p>Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</p>
<p>Sample Input 2:</p>
<p>100800</p>
<p>Sample Output 2:</p>
<p>yi Shi Wan ling ba Bai</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char name[10][5]=&#123;&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;&#125;;</span><br><span class="line">string wei[6]=&#123;&quot;Shi&quot;,&quot;Bai&quot;,&quot;Qian&quot;,&quot;Wan&quot;,&quot;Yi&quot;&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">	int len=s.length();</span><br><span class="line"> 	int left=0,right=len-1;</span><br><span class="line"> 		if(s[0]==&apos;-&apos;)  &#123;	</span><br><span class="line">		cout&lt;&lt;&quot;Fu&quot;;</span><br><span class="line">		left++;</span><br><span class="line">	&#125;</span><br><span class="line">	while(left+4&lt;=right)&#123;</span><br><span class="line">		right-=4;</span><br><span class="line">	&#125;</span><br><span class="line">	while(left&lt;len)&#123;</span><br><span class="line">		int flag=0;</span><br><span class="line">		bool isP=false;</span><br><span class="line">		while(left&lt;=right)&#123;</span><br><span class="line">			if(s[left]==&apos;0&apos;&amp;&amp;left&gt;0) flag=1;</span><br><span class="line">			else&#123;</span><br><span class="line">				if(flag==1) &#123;</span><br><span class="line">					cout&lt;&lt;&quot; ling&quot;;</span><br><span class="line">					flag=0;//!!</span><br><span class="line">				&#125;</span><br><span class="line">				isP=true;</span><br><span class="line">				if(left&gt;0) cout&lt;&lt;&quot; &quot;;</span><br><span class="line">				cout&lt;&lt;name[s[left]-&apos;0&apos;];</span><br><span class="line">				if(right-left&gt;=1) cout&lt;&lt;&quot; &quot;&lt;&lt;wei[right-left-1];	</span><br><span class="line">			&#125;	 </span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(isP==true&amp;&amp;right!=len-1)&#123;//不是个位 ,万、亿位 </span><br><span class="line">			int tmp=len-1-right;</span><br><span class="line">			</span><br><span class="line">			cout&lt;&lt;&quot; &quot;&lt;&lt;wei[2+tmp/4] ;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		right+=4;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
  </entry>
  <entry>
    <title>A1087  All Roads Lead to Rome </title>
    <url>/2019/03/22/A1087/</url>
    <content><![CDATA[<p>Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. For each case, the first line contains 2 positive integers N (2≤N≤200), the number of cities, and K, the total number of routes between pairs of cities; followed by the name of the starting city. The next N−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K lines follow, each describes a route between two cities in the format City1 City2 Cost. Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome.</p>
<p>Output Specification:<br>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.</p>
<p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format City1-&gt;City2-&gt;…-&gt;ROM.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">6 7 HZH</span><br><span class="line">ROM 100</span><br><span class="line">PKN 40</span><br><span class="line">GDN 55</span><br><span class="line">PRS 95</span><br><span class="line">BLN 80</span><br><span class="line">ROM GDN 1</span><br><span class="line">BLN ROM 1</span><br><span class="line">HZH PKN 1</span><br><span class="line">PRS ROM 2</span><br><span class="line">BLN HZH 2</span><br><span class="line">PKN GDN 1</span><br><span class="line">HZH PRS 1</span><br><span class="line">Sample Output:</span><br><span class="line">3 3 195 97</span><br><span class="line">HZH-&gt;PRS-&gt;ROM</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define MAX 210</span><br><span class="line">using namespace std;</span><br><span class="line">bool vis[MAX];</span><br><span class="line">int cnt=0;</span><br><span class="line">int dis[MAX],num[MAX],wei[MAX];</span><br><span class="line">int g[MAX][MAX];</span><br><span class="line">map&lt;string,int&gt; dict;</span><br><span class="line">map&lt;int,string&gt; road;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">int sum=0;</span><br><span class="line">int ed,st,n,m;</span><br><span class="line">vector&lt;int&gt; tmp,path,pre[MAX];</span><br><span class="line">int findDict(string s)&#123;</span><br><span class="line">	if(!dict.count(s))&#123;</span><br><span class="line">		road[sum]=s;</span><br><span class="line">		sum++;</span><br><span class="line">		return dict[s]=sum-1;</span><br><span class="line">	&#125;</span><br><span class="line">	else return dict[s];</span><br><span class="line">&#125;</span><br><span class="line">void dij(int st)&#123;</span><br><span class="line">	fill(dis,dis+MAX,INF);</span><br><span class="line">	dis[st]=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		int min=INF,u=-1;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			//if(dis[j]&lt;min)！</span><br><span class="line">			if(vis[j]==false&amp;&amp;dis[j]&lt;min)&#123;</span><br><span class="line">				min=dis[j];</span><br><span class="line">				u=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(u==-1) return;</span><br><span class="line">		vis[u]=true;</span><br><span class="line">		for(int v=0;v&lt;n;v++)&#123;</span><br><span class="line">			if(vis[v]) continue;</span><br><span class="line">			if(g[u][v]==INF) continue;</span><br><span class="line">			if(dis[u]+g[u][v]&lt;dis[v])&#123;</span><br><span class="line">				dis[v]=dis[u]+g[u][v];</span><br><span class="line">				pre[v].clear();</span><br><span class="line">					pre[v].push_back(u);</span><br><span class="line">//					num[v]=num[u];</span><br><span class="line">			&#125;</span><br><span class="line">			else if(dis[u]+g[u][v]==dis[v])&#123;</span><br><span class="line">				pre[v].push_back(u);</span><br><span class="line">//				num[v]+=num[u];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int maxi=-1;</span><br><span class="line">double mavg=-1;</span><br><span class="line">void dfs(int ed)&#123;</span><br><span class="line">	if(ed==st)&#123;//dfs中遍历的路径都是最短的</span><br><span class="line">		cnt++;//最短路径条数</span><br><span class="line">		int w=0;</span><br><span class="line">		tmp.push_back(ed);</span><br><span class="line">		for(int j=tmp.size()-2;j&gt;=0;j--)&#123;</span><br><span class="line">			w+=wei[tmp[j]];</span><br><span class="line">		&#125;</span><br><span class="line">		//w*1.0</span><br><span class="line">		double avg=w*1.0/(tmp.size()-1);</span><br><span class="line">		if(maxi&lt;w) &#123;</span><br><span class="line">			maxi=w;</span><br><span class="line">			path=tmp;</span><br><span class="line">			mavg=avg;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(maxi==w&amp;&amp;mavg&lt;avg)&#123;</span><br><span class="line">			</span><br><span class="line">			mavg=avg;</span><br><span class="line">			path=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp.pop_back();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp.push_back(ed);</span><br><span class="line">	for(int k=0;k&lt;pre[ed].size();k++)</span><br><span class="line">	dfs(pre[ed][k]);</span><br><span class="line">	tmp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string start,end=&quot;ROM&quot;;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	cin&gt;&gt;start;</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string s;</span><br><span class="line">		int t;</span><br><span class="line">		cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">		wei[findDict(s)]=t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">		st=findDict(start);</span><br><span class="line">		ed=findDict(end);//!</span><br><span class="line">			wei[st]=0;</span><br><span class="line">	fill(g[0],g[0]+MAX*MAX,INF);</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		string s1,s2;</span><br><span class="line">		int t;</span><br><span class="line">		cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">		cin&gt;&gt;t;</span><br><span class="line">		int a=findDict(s1),b=findDict(s2);</span><br><span class="line">		g[a][b]=g[b][a]=t;</span><br><span class="line">	&#125;</span><br><span class="line">	dij(st);</span><br><span class="line"></span><br><span class="line">	dfs(ed);</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;cnt&lt;&lt;&quot; &quot;&lt;&lt;dis[ed]&lt;&lt;&quot; &quot;&lt;&lt;maxi&lt;&lt;&quot; &quot;&lt;&lt;(int)mavg&lt;&lt;endl;</span><br><span class="line">	for(int k=path.size()-1;k&gt;=0;k--)</span><br><span class="line">		&#123;</span><br><span class="line">		cout&lt;&lt;road[path[k]];</span><br><span class="line">		if(k!=0) cout&lt;&lt;&quot;-&gt;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 202</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">map&lt;string,int&gt; dict;</span><br><span class="line">map&lt;int,string&gt; is;</span><br><span class="line">int cnt=0;</span><br><span class="line">int n,m;</span><br><span class="line">int g[MAX][MAX],vis[MAX],dis[MAX];</span><br><span class="line">int cost[MAX],pre[MAX];</span><br><span class="line">int c[MAX];</span><br><span class="line">int num[MAX],pt[MAX];</span><br><span class="line">int strToInt(string city)&#123;</span><br><span class="line">	if(!dict.count(city))&#123;</span><br><span class="line">		dict[city]=cnt++;</span><br><span class="line">		is[dict[city]]=city;</span><br><span class="line">	&#125; </span><br><span class="line">	 return dict[city];</span><br><span class="line">&#125; </span><br><span class="line">void dij(int st,int ed)&#123;</span><br><span class="line">	fill(dis,dis+MAX,INF);</span><br><span class="line">	</span><br><span class="line">	dis[st]=0;	</span><br><span class="line">	num[st]=1;</span><br><span class="line">	pt[st]=0;</span><br><span class="line">	pre[st]=-1;</span><br><span class="line">	c[st]=cost[st]; //!</span><br><span class="line">	for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">		</span><br><span class="line">	int maxn=INF,k=-1;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(dis[i]&lt;maxn&amp;&amp;!vis[i])&#123;</span><br><span class="line">			k=i;</span><br><span class="line">			maxn=dis[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(k==-1) return;</span><br><span class="line">	//cout&lt;&lt;&quot;k:&quot;&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">	vis[k]=true; </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(g[k][i]!=INF&amp;&amp;!vis[i])&#123;</span><br><span class="line">			if(dis[i]&gt;dis[k]+g[k][i])&#123;</span><br><span class="line">				dis[i]=dis[k]+g[k][i];</span><br><span class="line">				c[i]=c[k]+cost[i];</span><br><span class="line">				num[i]=num[k]; </span><br><span class="line">				//记录经过点的个数 </span><br><span class="line">				pt[i]=pt[k]+1;</span><br><span class="line">				pre[i]=k;</span><br><span class="line">			&#125; //没看题 先点权 后平均点权 </span><br><span class="line">			else if(dis[i]==dis[k]+g[k][i])&#123;</span><br><span class="line">					num[i]+=num[k];</span><br><span class="line">				if(c[i]&lt;c[k]+cost[i])&#123;</span><br><span class="line">						c[i]=c[k]+cost[i];</span><br><span class="line">						pre[i]=k;</span><br><span class="line">						pt[i]=pt[k]+1;</span><br><span class="line">				&#125;</span><br><span class="line">				else if(c[i]==c[k]+cost[i])&#123;</span><br><span class="line">					double kavg=(c[k]+cost[i])*1.0/(pt[k]+1);</span><br><span class="line">					double iavg=c[i]*(1.0)/pt[i];</span><br><span class="line">					if(kavg&gt;iavg)&#123;</span><br><span class="line">							pre[i]=k;</span><br><span class="line">							pt[i]=pt[k]+1;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int end)&#123;</span><br><span class="line">//st(HZH)-&gt;-1 终止 HZH(-&gt;PRS -&gt;ROM) </span><br><span class="line">		if(pre[end]==-1) &#123;</span><br><span class="line">			cout&lt;&lt;is[end];</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">    	dfs(pre[end]);</span><br><span class="line">		cout&lt;&lt;&quot;-&gt;&quot;;//!</span><br><span class="line">	cout&lt;&lt;is[end];</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string st;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	cin&gt;&gt;st;</span><br><span class="line">	fill(g[0],g[0]+MAX*MAX,INF);</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">		string str;int x;</span><br><span class="line">		cin&gt;&gt;str;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		int id=strToInt(str);</span><br><span class="line">		cost[id]=x;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">		string chu,dao;</span><br><span class="line">		cin&gt;&gt;chu&gt;&gt;dao;</span><br><span class="line">		int stt=strToInt(chu),edd=strToInt(dao);</span><br><span class="line">				cin&gt;&gt;g[stt][edd];</span><br><span class="line">		g[edd][stt]=g[stt][edd];</span><br><span class="line">	&#125;</span><br><span class="line">	int beg=strToInt(st),end=strToInt(&quot;ROM&quot;);</span><br><span class="line">	dij(beg,end);</span><br><span class="line">	cout&lt;&lt;num[end]&lt;&lt;&quot; &quot;&lt;&lt;dis[end]&lt;&lt;&quot; &quot;&lt;&lt;c[end]&lt;&lt;&quot; &quot;&lt;&lt;c[end]/pt[end]&lt;&lt;endl;//注意先后顺序</span><br><span class="line">	dfs(end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>dij</tag>
      </tags>
  </entry>
  <entry>
    <title>A1080 Graduate Admission</title>
    <url>/2019/01/26/A1095-Cars-on-Campus/</url>
    <content><![CDATA[<p>It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.<br><a id="more"></a><br> The admission rules are:</p>
<p>The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.</p>
<p>If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade G<br>​E<br>​​ . If still tied, their ranks must be the same.</p>
<p>Each applicant may have K choices and the admission will be done according to his/her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.</p>
<p>If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, even if its quota will be exceeded.</p>
<p>Input Specification:<br>Each input file contains one test case.</p>
<p>Each case starts with a line containing three positive integers: N (≤40,000), the total number of applicants; M (≤100), the total number of graduate schools; and K (≤5), the number of choices an applicant may have.</p>
<p>In the next line, separated by a space, there are M positive integers. The i-th integer is the quota of the i-th graduate school respectively.</p>
<p>Then N lines follow, each contains 2+K integers separated by a space. The first 2 integers are the applicant’s G<br>​E<br>​​  and G<br>​I<br>​​ , respectively. The next K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M−1, and the applicants are numbered from 0 to N−1.</p>
<p>Output Specification:<br>For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">11 6 3</span><br><span class="line">2 1 2 2 2 3</span><br><span class="line">100 100 0 1 2</span><br><span class="line">60 60 2 3 5</span><br><span class="line">100 90 0 3 4</span><br><span class="line">90 100 1 2 0</span><br><span class="line">90 90 5 1 3</span><br><span class="line">80 90 1 0 2</span><br><span class="line">80 80 0 1 2</span><br><span class="line">80 80 0 1 2</span><br><span class="line">80 70 1 3 2</span><br><span class="line">70 80 1 2 3</span><br><span class="line">100 100 0 2 4</span><br><span class="line">Sample Output:</span><br><span class="line">0 10</span><br><span class="line">3</span><br><span class="line">5 6 7</span><br><span class="line">2 8</span><br><span class="line"></span><br><span class="line">1 4</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct stu&#123;</span><br><span class="line">	int ge,gi,sum;</span><br><span class="line">		int rank,stuID;</span><br><span class="line">	int choice[6];</span><br><span class="line">&#125;stud[40001];</span><br><span class="line">struct school&#123;</span><br><span class="line">	int quota;</span><br><span class="line">	int lastA;</span><br><span class="line">	int num;</span><br><span class="line"></span><br><span class="line">	int id[40001];</span><br><span class="line">	</span><br><span class="line">&#125;sc[101];</span><br><span class="line">bool cmp(stu a,stu b)&#123;</span><br><span class="line">if(a.sum!=b.sum) return a.sum&gt;b.sum;</span><br><span class="line">else return a.ge&gt;b.ge;</span><br><span class="line">&#125;</span><br><span class="line">bool cmpID(int a,int b)&#123;</span><br><span class="line">return stud[a].stuID&lt;stud[b].stuID;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m,K;</span><br><span class="line">//	cin&gt;&gt;n&gt;&gt;m&gt;&gt;K; </span><br><span class="line">//坑点 ： 倒数第二个测试点如果用 cin cout 会超时,改成 scanf 就好了</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);</span><br><span class="line">	for(int i=0;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	  scanf(&quot;%d&quot;,&amp;sc[i].quota);</span><br><span class="line">	  	sc[i].lastA=-1;</span><br><span class="line">	  	sc[i].num=0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;		</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;stud[i].ge,&amp;stud[i].gi);</span><br><span class="line">		stud[i].stuID=i;</span><br><span class="line">		stud[i].sum=stud[i].ge+stud[i].gi;</span><br><span class="line">		for(int j=0;j&lt;K;j++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;stud[i].choice[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(stud,stud+n,cmp);</span><br><span class="line">		stud[0].rank=0;</span><br><span class="line">	for(int k=1;k&lt;n;k++)&#123;</span><br><span class="line">		if(stud[k].sum==stud[k-1].sum&amp;&amp;stud[k].ge==stud[k-1].ge)&#123;</span><br><span class="line">		stud[k].rank=stud[k-1].rank;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		stud[k].rank=k;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;K;j++ )&#123;</span><br><span class="line">			int index=stud[i].choice[j];</span><br><span class="line">			</span><br><span class="line">			if(sc[index].num&lt;sc[index].quota||(sc[index].lastA!=-1&amp;&amp;stud[sc[index].lastA].rank==stud[i].rank))</span><br><span class="line">			&#123;</span><br><span class="line">			int num=sc[index].num;</span><br><span class="line">				sc[index].id[num]=i;</span><br><span class="line">				sc[index].lastA=i;</span><br><span class="line">					sc[index].num++;</span><br><span class="line">					break;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		if(sc[i].num&gt;0)&#123;</span><br><span class="line">			sort(sc[i].id,sc[i].id+sc[i].num,cmpID);</span><br><span class="line">			for(int j=0;j&lt;sc[i].num;j++)&#123;</span><br><span class="line">				printf(&quot;%d&quot;,stud[sc[i].id[j]].stuID);</span><br><span class="line">				if(j!=sc[i].num-1)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
  </entry>
  <entry>
    <title>A1099  Build A Binary Search Tree </title>
    <url>/2019/03/26/A1099/</url>
    <content><![CDATA[<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:<br><a id="more"></a><br>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2.</p>
<p><img src="http://ww1.sinaimg.cn/large/006wtREyly1g1gktq6ea5j30f909hmzd.jpg" alt></p>
<p>Input Specification:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format  left_index right_index, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line.</p>
<p>Output Specification:<br>For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">9</span><br><span class="line">1 6</span><br><span class="line">2 3</span><br><span class="line">-1 -1</span><br><span class="line">-1 4</span><br><span class="line">5 -1</span><br><span class="line">-1 -1</span><br><span class="line">7 -1</span><br><span class="line">-1 8</span><br><span class="line">-1 -1</span><br><span class="line">73 45 11 58 82 25 67 38 42</span><br><span class="line">Sample Output:</span><br><span class="line">58 25 82 11 38 67 45 73 42</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">#define MAX 110</span><br><span class="line">int in[MAX],num[MAX];</span><br><span class="line">struct node&#123;</span><br><span class="line">	int v;</span><br><span class="line">	int l,r;</span><br><span class="line">&#125;;</span><br><span class="line">node tree[MAX];</span><br><span class="line">bool cmp(int m,int n)&#123;</span><br><span class="line">	return m&lt;n;</span><br><span class="line">&#125;</span><br><span class="line">int sum=0;</span><br><span class="line">void inorder(int t)&#123;</span><br><span class="line">	if(t==-1) return;</span><br><span class="line">	inorder(tree[t].l);</span><br><span class="line">	tree[t].v=in[sum++];</span><br><span class="line">	inorder(tree[t].r); </span><br><span class="line">&#125;</span><br><span class="line">void bfs(int r)&#123;</span><br><span class="line">	sum=0;</span><br><span class="line">	queue&lt;int&gt; que;</span><br><span class="line">	que.push(r);</span><br><span class="line">	while(!que.empty())&#123;</span><br><span class="line">		int tt=que.front();</span><br><span class="line">		cout&lt;&lt;tree[tt].v;</span><br><span class="line">		sum++;</span><br><span class="line">		if(sum&lt;n) cout&lt;&lt;&quot; &quot;;</span><br><span class="line">		que.pop();</span><br><span class="line">		if(tree[tt].l!=-1) que.push(tree[tt].l);</span><br><span class="line">		if(tree[tt].r!=-1) que.push(tree[tt].r);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;tree[i].l&gt;&gt;tree[i].r;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int j=0;j&lt;n;j++)</span><br><span class="line">	cin&gt;&gt;in[j];</span><br><span class="line">	sort(in,in+n,cmp);</span><br><span class="line">	inorder(0);	</span><br><span class="line">	bfs(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>bst</tag>
      </tags>
  </entry>
  <entry>
    <title>A1103 Integer Factorization</title>
    <url>/2019/03/25/A1103/</url>
    <content><![CDATA[<p>The K−P factorization of a positive integer N is to write N as the sum of the P-th power of K positive integers. You are supposed to write a program to find the K−P factorization of N for any positive integers N, K and P.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case which gives in a line the three positive integers N (≤400), K (≤N) and P (1&lt;P≤7). The numbers in a line are separated by a space.</p>
<p>Output Specification:<br>For each case, if the solution exists, output in the format:</p>
<p>N = n[1]^P + … n[K]^P<br>where n[i] (i = 1, …, K) is the i-th factor. All the factors must be printed in non-increasing order.</p>
<p>Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 12<br>or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen – sequence<br>If there is no solution, simple output Impossible.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input 1:</span><br><span class="line">169 5 2</span><br><span class="line">Sample Output 1:</span><br><span class="line">169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2</span><br><span class="line">Sample Input 2:</span><br><span class="line">169 167 3</span><br><span class="line">Sample Output 2:</span><br><span class="line">Impossible</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt; </span><br><span class="line">#define MAX 110</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n,k,p;</span><br><span class="line">int pow(int x,int p)&#123;</span><br><span class="line">	int sum=1;</span><br><span class="line">	for(int i=1;i&lt;=p;i++)</span><br><span class="line">	sum*=x;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line">int maxi=-1;</span><br><span class="line">vector&lt;int&gt; ans,tmp,fac;</span><br><span class="line">void init()&#123;</span><br><span class="line">	fac.push_back(0); </span><br><span class="line">	for(int i=1;;i++)&#123;</span><br><span class="line">		int t=pow(i,p);</span><br><span class="line">			if(t&gt;n) break;</span><br><span class="line">		else fac.push_back(t);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int ind,int nk,int sum,int fsum)&#123;</span><br><span class="line">	if(sum==n&amp;&amp;nk==k)</span><br><span class="line">	&#123;</span><br><span class="line">		if(fsum&gt;maxi)&#123;</span><br><span class="line">			maxi=fsum;</span><br><span class="line">			ans=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(sum&gt;n||nk&gt;k) return;</span><br><span class="line">	if(ind&gt;=1)&#123;</span><br><span class="line">		tmp.push_back(ind);</span><br><span class="line">		//选的话可以重复选 </span><br><span class="line">		dfs(ind,nk+1,sum+fac[ind],fsum+ind);</span><br><span class="line">		tmp.pop_back();</span><br><span class="line">		//不选的分支 </span><br><span class="line">		dfs(ind-1,nk,sum,fsum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k&gt;&gt;p;</span><br><span class="line">	init();</span><br><span class="line"></span><br><span class="line">	dfs(fac.size()-1,0,0,0);</span><br><span class="line">		if(ans.size()==0)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;&quot; = &quot;; </span><br><span class="line">	for(int i=0;i&lt;ans.size();i++)&#123;</span><br><span class="line">		cout&lt;&lt;ans[i]&lt;&lt;&quot;^&quot;&lt;&lt;p;</span><br><span class="line">		if(i!=ans.size()-1) cout&lt;&lt;&quot; + &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda使用教程</title>
    <url>/2018/05/05/Anaconda%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>1.去官网下载Anaconda 下载地址 选择对应的你的系统版本<br>2.无脑点下一步安装，选择你的安装路径，我本机的安装路径在E:\Program Files\Anaconda2 ，然后耐心等待，等到安装完成。<br>3.conda –version查看版本号<br>4.因为我安装的是2.7的Anaconda环境，所以默认的python就是2.7的。不信你在命令行中输入python –version 他出来的就是python2.7.5<br><a id="more"></a></p>
<h2 id="利用Anaconda做python多开发环境多版本的配置"><a href="#利用Anaconda做python多开发环境多版本的配置" class="headerlink" title="利用Anaconda做python多开发环境多版本的配置"></a>利用Anaconda做python多开发环境多版本的配置</h2><p>创建一个除了root分支之外的2.7.×的python环境<br>创建一个名为python27的环境，指定Python版本是2.7（不用管是2.7.x，conda会为我们自动寻找2.7.x中的最新版本）<br>conda create –name python27 python=2.7<br><img src="http://7xtgar.com1.z0.glb.clouddn.com/drag/sp161225_11531542.png" alt="image"></p>
<p>同理再创建一个3.4.×的python环境<br>conda create –name python34 python=3.4<br>然后这个时候你就可以继续查看E:\Program Files\Anaconda2\envs目录下面的文件夹了，应该会多了一个python27和python34，那么恭喜你， 成功的安装了两个版本的python开发环境。</p>
<p>查看你现在所在的版本分支:<br>conda info –e<br>在这里你就会看到你所有的python版本，和你现在所在的分支<br><img src="http://7xtgar.com1.z0.glb.clouddn.com/drag/sp161225_12054455.png" alt="image"></p>
<h3 id="切换到你所需要的分支"><a href="#切换到你所需要的分支" class="headerlink" title="切换到你所需要的分支"></a>切换到你所需要的分支</h3><p>Linux, OS X: source activate bunnies<br>Windows: activate bunnies<br>比如你需要切换到python3.4的版本，那么你如果在windows下就直接运行 activate python34就好了<br><img src="http://7xtgar.com1.z0.glb.clouddn.com/drag/sp161225_12122186.png" alt="image"><br>切换回root分支</p>
<p>Linux, OS X: source deactivate<br>Windows: deactivate</p>
<h2 id="案例：安装beautifulsoup4"><a href="#案例：安装beautifulsoup4" class="headerlink" title="案例：安装beautifulsoup4"></a>案例：安装beautifulsoup4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#首先你需要切换到python34这个环境下。</span><br><span class="line">activate python34</span><br><span class="line">#查看这个环境下的包列表</span><br><span class="line">conda list</span><br><span class="line">#这个python34的环境报下面没有beautifulsoup4，所以我们想要安装一个</span><br><span class="line">#查找beautifulsoup4的包</span><br><span class="line">conda search beautifulsoup4</span><br><span class="line">#为python34安装beautifulsoup</span><br><span class="line">#Tips:</span><br><span class="line">#NOTE: You must tell conda the name of the environment (--name bunnies) OR it will install in the current environment.你必须告诉conda你要安装包的环境的名称，不然会安装在当前环境下。我这里的环境就是python34</span><br><span class="line">conda install --name python34 beautifulsoup4</span><br><span class="line">#查看你安装的包</span><br><span class="line">conda list</span><br></pre></td></tr></table></figure>
<h2 id="熟悉基础命令"><a href="#熟悉基础命令" class="headerlink" title="熟悉基础命令"></a>熟悉基础命令</h2><h3 id="管理conda："><a href="#管理conda：" class="headerlink" title="管理conda："></a>管理conda：</h3><p>Conda既是一个包管理器又是一个环境管理器。你肯定知道包管理器，它可以帮你发现和查看包。但是如果当我们想要安装一个包，但是这个包只支持跟我们目前使用的python不同的版本时。你只需要几行命令，就可以搭建起一个可以运行另外python版本的环境。，这就是conda环境管理器的强大功能。<br>提示：无论你使用Linux、OS X或者Windows命令行工具，在你的命令行终端conda指令都是一样的，除非有特别说明。</p>
<p>检查conda已经被安装。<br>为了确保你已经在正确的位置安装好了conda，让我们来检查你是否已经成功安装好了Anaconda。在你的命令行终端窗口，输入如下代码：</p>
<p>conda –version<br>Conda会返回你安装Anaconda软件的版本。<br>提示：如果你看到了错误信息，检查你是否在安装过程中选择了仅为当前用户按安装，并且是否以同样的账户来操作。确保用同样的账户登录安装了之后重新打开命令行终端窗口。</p>
<p>升级当前版本的conda<br>接下来，让我们通过使用如下update命令来升级conda：</p>
<p>conda update conda<br>conda将会比较新旧版本并且告诉你哪一个版本的conda可以被安装。它也会通知你伴随这次升级其它包同时升级的情况。<br>如果新版本的conda可用，它会提示你输入y进行升级.</p>
<p>proceed ([y]/n)? y<br>conda更新到最新版后，我们将进入下一个主题。</p>
<h3 id="管理环境。"><a href="#管理环境。" class="headerlink" title="管理环境。"></a>管理环境。</h3><p>现在我们通过创建一些环境来展示conda的环境操作，然后移动它们。</p>
<p>创建并激活一个环境<br>使用conda create命令，后边跟上你希望用来称呼它的任何名字：</p>
<p>conda create –name snowflake biopython<br>这条命令将会给biopython包创建一个新的环境，位置在/envs/snowflakes</p>
<p>可以略写为一个短线加命令首字母。所以–name选项和-n的作用是一样的。通过conda -h或conda –-help来看大量的缩写。</p>
<h3 id="创建第二个环境"><a href="#创建第二个环境" class="headerlink" title="创建第二个环境"></a>创建第二个环境</h3><p>conda create -n bunnies python=3 Astroid Babel<br>这将创建第二个基于python3 ，包含Astroid 和 Babel 包，称为bunnies的新环境，在/envs/bunnies文件夹里。<br>小技巧：在此同时安装你想在这个环境中运行的包，<br>小提示：在你创建环境的同时安装好所有你想要的包，在后来依次安装可能会导致依赖性问题（貌似是，不太懂这个术语怎么翻）。<br>小技巧：你可以在conda create命令后边附加跟多的条件，键入conda create –h 查看更多细节。</p>
<h3 id="激活这个新环境"><a href="#激活这个新环境" class="headerlink" title="激活这个新环境"></a>激活这个新环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux，OS X: source activate snowflakes</span><br><span class="line">Windows：activate snowflake`</span><br></pre></td></tr></table></figure>
<p>新的开发环境会被默认安装在你conda目录下的envs文件目录下。<br>如果我们没有指定安装python的版本，conda会安装我们最初安装conda时所装的那个版本的python。</p>
<h3 id="列出所有的环境"><a href="#列出所有的环境" class="headerlink" title="列出所有的环境"></a>列出所有的环境</h3><p>现在让我们来检查一下截至目前你所安装的环境，使用conda environment info 命令来查看它:</p>
<p>conda info -envis<br>你将会看到如下的环境列表：</p>
<p>conda environments:</p>
<p> snowflakes          * /home/username/miniconda/envs/snowflakes</p>
<p> bunnies               /home/username/miniconda/envs/bunnies</p>
<p> root                  /home/username/miniconda</p>
<h3 id="确认当前环境"><a href="#确认当前环境" class="headerlink" title="确认当前环境"></a>确认当前环境</h3><p> 你现在处于哪个环境中呢？snowflakes还是bunnies？想要确定它，输入下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda info -envis</span><br></pre></td></tr></table></figure></p>
<p>conda将会显示所有环境的列表，当前环境会显示在一个括号内。</p>
<p>(snowflakes)</p>
<h3 id="切换到另一个环境-activate-deactivate"><a href="#切换到另一个环境-activate-deactivate" class="headerlink" title="切换到另一个环境(activate/deactivate)"></a>切换到另一个环境(activate/deactivate)</h3><p>切换到另一个环境，键入下列命令以及所需环境的名字。<br>Linux，OS X: source activate snowflakes<br>Windows：activate snowflakes</p>
<p>如果要从你当前工作环境的路径切换到系统根目录时，键入：<br>Linux，OS X: source deactivate<br>Windows: deactivate<br>当该环境不再活动时，将不再被提前显示。</p>
<h3 id="复制一个环境"><a href="#复制一个环境" class="headerlink" title="复制一个环境"></a>复制一个环境</h3><p>conda create -n flowers –clone snowflakes</p>
<h3 id="删除一个环境"><a href="#删除一个环境" class="headerlink" title="删除一个环境"></a>删除一个环境</h3><p>如果你不想要这个名为flowers的环境，就按照如下方法移除该环境：<br>conda remove -n flowers –all<br>conda info -e 查看到flowers 已经不再在你的环境列表里了</p>
<p>参考链接<br><a href="https://blog.csdn.net/fang1192801693/article/details/77196979" target="_blank" rel="noopener">https://blog.csdn.net/fang1192801693/article/details/77196979</a></p>
]]></content>
      <categories>
        <category>Anaconda</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>B1015 德才论 </title>
    <url>/2019/01/26/B1015/</url>
    <content><![CDATA[<p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”<br><a id="more"></a><br>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p>
<p>输入格式：<br>输入第一行给出 3 个正整数，分别为：N（≤10<br>​5<br>​​ ），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。</p>
<p>随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。</p>
<p>输出格式：<br>输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">14 60 80</span><br><span class="line">10000001 64 90</span><br><span class="line">10000002 90 60</span><br><span class="line">10000011 85 80</span><br><span class="line">10000003 85 80</span><br><span class="line">10000004 80 85</span><br><span class="line">10000005 82 77</span><br><span class="line">10000006 83 76</span><br><span class="line">10000007 90 78</span><br><span class="line">10000008 75 79</span><br><span class="line">10000009 59 90</span><br><span class="line">10000010 88 45</span><br><span class="line">10000012 80 100</span><br><span class="line">10000013 90 99</span><br><span class="line">10000014 66 60</span><br><span class="line">输出样例：</span><br><span class="line">12</span><br><span class="line">10000013 90 99</span><br><span class="line">10000012 80 100</span><br><span class="line">10000003 85 80</span><br><span class="line">10000011 85 80</span><br><span class="line">10000004 80 85</span><br><span class="line">10000007 90 78</span><br><span class="line">10000006 83 76</span><br><span class="line">10000005 82 77</span><br><span class="line">10000002 90 60</span><br><span class="line">10000014 66 60</span><br><span class="line">10000008 75 79</span><br><span class="line">10000001 64 90</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct student&#123;</span><br><span class="line">	char id[10];</span><br><span class="line">	int de,cai,sum;</span><br><span class="line">	int level;</span><br><span class="line">&#125;stu[100001];</span><br><span class="line">bool cmp(student a,student b)&#123;</span><br><span class="line">	if(a.level!=b.level) return a.level&gt;b.level;</span><br><span class="line">	if(a.sum!=b.sum) return a.sum&gt;b.sum;</span><br><span class="line">	if(a.de!=b.de) return a.de&gt;b.de;</span><br><span class="line">	else return strcmp(a.id,b.id)&lt;0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,l,h;</span><br><span class="line">//	cin&gt;&gt;n&gt;&gt;l&gt;&gt;h;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;l,&amp;h);</span><br><span class="line">	int num=n;</span><br><span class="line">	 for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	 	scanf(&quot;%s%d%d&quot;,stu[i].id,&amp;stu[i].de,&amp;stu[i].cai);</span><br><span class="line">	</span><br><span class="line">	 	stu[i].level=0;</span><br><span class="line">		stu[i].sum=stu[i].de+stu[i].cai;</span><br><span class="line">		</span><br><span class="line">		if(stu[i].de&gt;=h&amp;&amp;stu[i].cai&gt;=h) stu[i].level=3;</span><br><span class="line">		else if(stu[i].de&gt;=h&amp;&amp;stu[i].cai&gt;=l) stu[i].level=2;</span><br><span class="line">		else if(stu[i].de&gt;=l&amp;&amp;stu[i].cai&gt;=l&amp;&amp;stu[i].de&gt;=stu[i].cai) stu[i].level=1;</span><br><span class="line">		else if(stu[i].de&gt;=l&amp;&amp;stu[i].cai&gt;=l&amp;&amp;stu[i].de&lt;stu[i].cai) stu[i].level=0;</span><br><span class="line">		else if(stu[i].de&lt;l||stu[i].cai&lt;l) &#123;</span><br><span class="line">			stu[i].level=-1;</span><br><span class="line">			num--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	sort(stu,stu+n,cmp);</span><br><span class="line">	cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">	for(int j=0;j&lt;num;j++)&#123;</span><br><span class="line">		cout&lt;&lt;stu[j].id&lt;&lt;&quot; &quot;&lt;&lt;stu[j].de&lt;&lt;&quot; &quot;&lt;&lt;stu[j].cai&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
  </entry>
  <entry>
    <title>B1027 打印沙漏</title>
    <url>/2019/01/23/B1027-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/</url>
    <content><![CDATA[<p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p>
<p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p>
<p>输入格式:<br>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p>
<p>输出格式:<br>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入样例:</span><br><span class="line">19 *</span><br><span class="line">输出样例:</span><br><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	char c;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	getchar();</span><br><span class="line">	cin&gt;&gt;c;</span><br><span class="line">	int b=sqrt(floor(2*(n+1)))-1;</span><br><span class="line">	if(b%2==0) b--; </span><br><span class="line">	int N=(b+1)/2;</span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;i;j++)</span><br><span class="line">		cout&lt;&lt;&quot; &quot;;</span><br><span class="line">		for(int k=0;k&lt;b-i*2;k++)</span><br><span class="line">		cout&lt;&lt;c;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">				for(int j=0;j&lt;N-1-i;j++)</span><br><span class="line">		cout&lt;&lt;&quot; &quot;;</span><br><span class="line">		for(int j=0;j&lt;i*2+1;j++)</span><br><span class="line">		cout&lt;&lt;c;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;n-(b+1)*(b+1)/2+1&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>patB</category>
      </categories>
  </entry>
  <entry>
    <title>C++判断两个序列的包含关系： std::includes</title>
    <url>/2018/11/27/C-C-%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BF%AB%E9%80%9F%E5%88%9D%E5%A7%8B%E5%8C%96-1/</url>
    <content><![CDATA[<p>std::includes用于判断序列S2是否包含于序列S1，前提是序列S1,S2必须为有序序列（若为无序序列，首先应该通过std::sort使其变为有序序列），返回false（不包含）或者true（包含）。但是该功能并要求序列S2中的元素在序列S1中仍然连续出现，只是用来判断序列S1是否包含S2中的所有元素（不要求连续），并不类似于字符串判断中的子序列函数strstr。判断两个元素是否相等，需要以less和greater为判断依据，因此配合着两个有序序列S1、S2的排序方式（递增或递减），includes算法可以供用户选择less或者greater进行两个元素的大小比较。<br>若S1、S2为递增数列，includes函数应该以如下方式使用:<br><a id="more"></a><br>includes(S1.begin(),S1.end(),S2.begin(),S2.end());<br>1<br>和如下代码完全相同（默认为less比较）</p>
<p>includes(S1.begin(),S1.end(),S2.begin(),S2.end(),less<int>());</int></p>
<p>但是如果S1和S2是递增数列，includes函数应该以如下方式使用：</p>
<p>includes(S1.begin(),S1.end(),S2.begin(),S2.end(),greater<int>());<br>1<br>如果S1或S2中的元素可以重复，那么“S1中包含S2”的定义：假设某元素在S2中出现n次，在S1中出现m次，如果m</int></p>
<p>template<class inputiterator1,class inputiterator2><br>bool includes(InputIterator1 first1,InputIterator1      last1,InputIterator2 first2,InputIterator2 last2)<br>{<br>    while (first1!=last1 &amp;&amp; first2!=last2) //若均未到达尾端，则进行以下操作<br>    {<br>        if (<em>first2&lt;</em>first1)      //说明，first1前面没有小于等于first2的元素，包含情况肯定不成立（有序序列）<br>            return false;<br>        else if (<em>first1&lt;</em>first2)//序列二的相关元素大于<br>                                 //序列一，序列一前进<br>            first1++;<br>        else            //若二者相同，两序列各自前进1<br>        {<br>            first1++;<br>            first2++;<br>        }<br>    }<br>    return first2==first1;  //有一个序列走完了，判断最后一关<br>}</class></p>
<p>版本二：自定义比较算子</p>
<p>template<class inputiterator1,class inputiterator2,class outputiterator,classs compare><br>bool includes(InputIterator1 first1,InputIterator1 last1,InputIterator2 first2,InputIterator2 last2,Compare comp)<br>{<br>    while (first1!=last1 &amp;&amp; first2!=last2) //若均未到达尾端，则进行以下操作<br>    {<br>        if (comp(<em>first2,</em>first1))        //说明，comp(S2元素,S1元素)为真，包含情况肯定不成立（有序序列）<br>            return false;<br>        else if (comp(<em>first1,</em>first2))  //comp(S1元素,S2元素)为真，序列一前进<br>            first1++;<br>        else  //若二者相同，两序列各自前进1<br>        {<br>            first1++;<br>            first2++;<br>        }<br>    }<br>    return first2==first1; //有一个序列走完了，判断最后一关<br>}</class></p>
<p>示例（less比较符）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int iarr1[]=&#123;1,10,5,7,19,4,9,1&#125;;</span><br><span class="line">    int iarr2[]=&#123;1,19,7&#125;;</span><br><span class="line">    std::sort(std::begin(iarr1),std::end(iarr1));</span><br><span class="line">    std::sort(std::begin(iarr2),std::end(iarr2));      </span><br><span class="line">    bool ret;</span><br><span class="line">    ret=includes(std::begin(iarr1),std::end(iarr1),</span><br><span class="line">                 std::begin(iarr2),std::end(iarr2),</span><br><span class="line">                 less&lt;int&gt;());      //ret为true  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例（greater比较符）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int iarr1[]=&#123;1,10,5,7,19,4,9,1&#125;;</span><br><span class="line">    int iarr2[]=&#123;1,19,7&#125;;       </span><br><span class="line">    std::sort(std::begin(iarr1),std::end(iarr1),greater&lt;int&gt;());</span><br><span class="line">    std::sort(std::begin(iarr2),std::end(iarr2),greater&lt;int&gt;());       </span><br><span class="line">    bool ret;</span><br><span class="line">    ret=includes(std::begin(iarr1),std::end(iarr1),</span><br><span class="line">                 std::begin(iarr2),std::end(iarr2),</span><br><span class="line">                 greater&lt;int&gt;());       //ret为true  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考博客<br><a href="http://classfoo.com/ccby/article/6lkafJ" target="_blank" rel="noopener">http://classfoo.com/ccby/article/6lkafJ</a></p>
]]></content>
  </entry>
  <entry>
    <title>C/C++各种类型的快速初始化</title>
    <url>/2018/11/26/C-C-%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BF%AB%E9%80%9F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>数组的初始化<br>普通的数组可以使用大括号来初始化，且这个大括号是可以嵌套使用的：</p>
<a id="more"></a>
<p>int a[1][1][1] = { { {0} } };<br>C++ 11中，std::vector 也可以使用括号来初始化，</p>
<p>vector&lt;vector<int> &gt; v = { {1, 2, 3, 4}, {1, 2, 3, 4, 4} };<br>不支持 C++11 的环境中，可以使用如下的方法初始化一位数组（c++ - How to initialize an STL vector with hardcoded elements in the easiest way? - Stack Overflow）：</int></p>
<p>static const int arr[] = {16,2,77,29};<br>vector<int> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );<br>vector 在初始化时，还可以使用 reserve 和 resize 两个函数为 vector 预留空间，两者的区别可以参见 ping不見路: STL vector 效率小記。</int></p>
<p>字典的初始化<br>C++11 中可以直接使用大括号进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map&lt;int,int&gt; _map = &#123;</span><br><span class="line">    &#123;1, 2&#125;,</span><br><span class="line">    &#123;3, 4&#125;,</span><br><span class="line">    &#123;5, 6&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在不支持 C++11 的环境下，只能自己写一个函数来创建了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">map&lt;int,int&gt; create_map()</span><br><span class="line">&#123;</span><br><span class="line">  map&lt;int,int&gt; m;</span><br><span class="line">  m[1] = 2;</span><br><span class="line">  m[3] = 4;</span><br><span class="line">  m[5] = 6;</span><br><span class="line">  return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>map&lt;int,int&gt; m = create_map();<br>当字典的 value 是一个结构体时，可以直接使用 [] 对结构体中的一个变量进行赋值，达到生成一个结构体，并赋值的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//This structure takes care of data forwarding</span><br><span class="line">struct pit_entry &#123;</span><br><span class="line">    int interfaces;</span><br><span class="line">    unordered_set&lt;int&gt; nonces;</span><br><span class="line">    int time; //&lt;aa&gt; last time this entry has been updated&lt;/aa&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    unordered_map &lt;int, pit_entry &gt; PIT;</span><br><span class="line">    PIT[1].time = 1;</span><br><span class="line">    cout&lt;&lt;PIT[1].time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ STL之vector用法总结</title>
    <url>/2018/11/04/C-STL%E4%B9%8Bvector%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>vector是表示可变大小数组的序列容器。<br><a id="more"></a><br>就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。</p>
<p>本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。<br>vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。</p>
<p>因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。</p>
<p>与其它动态序列容器相比（deques, lists and forward_lists）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。</p>
<!--more-->
<ol>
<li>头文件</li>
</ol>
<p>#include<vector></vector></p>
<ol start="2">
<li><p>vector声明及初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; vec;        //声明一个int型向量</span><br><span class="line">vector&lt;int&gt; vec(5);     //声明一个初始大小为5的int向量</span><br><span class="line">vector&lt;int&gt; vec(10, 1); //声明一个初始大小为10且值都是1的向量</span><br><span class="line">vector&lt;int&gt; vec(tmp);   //声明并用tmp向量初始化vec向量</span><br><span class="line">vector&lt;int&gt; tmp(vec.begin(), vec.begin() + 3);  //用向量vec的第0个到第2个值初始化tmp</span><br><span class="line">int arr[5] = &#123;1, 2, 3, 4, 5&#125;;   </span><br><span class="line">vector&lt;int&gt; vec(arr, arr + 5);      //将arr数组的元素用于初始化vec向量</span><br><span class="line">//说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，</span><br><span class="line">//这个主要是为了和vec.end()指针统一。</span><br><span class="line">vector&lt;int&gt; vec(&amp;arr[1], &amp;arr[4]); //将arr[1]~arr[4]范围内的元素作为vec的初始值</span><br></pre></td></tr></table></figure>
</li>
<li><p>vector基本操作</p>
</li>
</ol>
<p>(1). 容量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">向量大小： vec.size();</span><br><span class="line">向量最大容量： vec.max_size();</span><br><span class="line">更改向量大小： vec.resize();</span><br><span class="line">向量真实大小： vec.capacity();</span><br><span class="line">向量判空： vec.empty();</span><br><span class="line">减少向量大小到满足元素所占存储空间的大小： vec.shrink_to_fit(); //shrink_to_fit</span><br></pre></td></tr></table></figure></p>
<p>(2). 修改<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多个元素赋值： vec.assign(); //类似于初始化时用数组进行赋值</span><br><span class="line">末尾添加元素： vec.push_back();</span><br><span class="line">末尾删除元素： vec.pop_back();</span><br><span class="line">任意位置插入元素： vec.insert();</span><br><span class="line">任意位置删除元素： vec.erase();</span><br><span class="line">交换两个向量的元素： vec.swap();</span><br><span class="line">清空向量元素： vec.clear();</span><br></pre></td></tr></table></figure></p>
<p>(3)迭代器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开始指针：vec.begin();</span><br><span class="line">末尾指针：vec.end(); //指向最后一个元素的下一个位置</span><br><span class="line">指向常量的开始指针： vec.cbegin(); //意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。</span><br><span class="line">指向常量的末尾指针： vec.cend();</span><br></pre></td></tr></table></figure></p>
<p>(4)元素的访问<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下标访问： vec[1]; //并不会检查是否越界</span><br><span class="line">at方法访问： vec.at(1); //以上两者的区别就是at会检查是否越界，是则抛出out of range异常</span><br><span class="line">访问第一个元素： vec.front();</span><br><span class="line">访问最后一个元素： vec.back();</span><br><span class="line">返回一个指针： int* p = vec.data(); //可行的原因在于vector在内存中就是一个连续存储的数组，所以可以返回一个指针指向这个数组。这是是C++11的特性。</span><br></pre></td></tr></table></figure></p>
<p>(4)算法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">遍历元素</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">for (it = vec.begin(); it != vec.end(); it++)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">//或者</span><br><span class="line">for (size_t i = 0; i &lt; vec.size(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; vec.at(i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">元素翻转</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">reverse(vec.begin(), vec.end());</span><br><span class="line">元素排序</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">sort(vec.begin(), vec.end()); //采用的是从小到大的排序</span><br><span class="line">//如果想从大到小排序，可以采用上面反转函数，也可以采用下面方法:</span><br><span class="line">bool Comp(const int&amp; a, const int&amp; b) &#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">sort(vec.begin(), vec.end(), Comp);</span><br></pre></td></tr></table></figure></p>
<p>关于erase</p>
<p><a href="https://www.cnblogs.com/cLockey/p/3770622.html" target="_blank" rel="noopener">https://www.cnblogs.com/cLockey/p/3770622.html</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ cout 输出 16, 8 , 2进制</title>
    <url>/2018/11/05/C-cout-%E8%BE%93%E5%87%BA-16-8-2%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<p>C++ cout 输出 16, 8 , 2进制<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using std::bitset;</span><br><span class="line">using std::hex;</span><br><span class="line">using std::oct;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::cin;</span><br><span class="line">using std::endl;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int a=10; </span><br><span class="line"> cout&lt;&lt;&quot;Dec:&quot;&lt;&lt;a&lt;&lt;endl; </span><br><span class="line"> cout&lt;&lt;hex&lt;&lt;&quot;Hex:&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;oct&lt;&lt;&quot;Oct:&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;bitset&lt;32&gt;(a)&lt;&lt;endl;</span><br><span class="line"> getchar();</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">C++ 操作符</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">注：下面的scientific 和 fixed不能同时使用</span><br><span class="line">double a=123.456789012345;对a赋初值</span><br><span class="line">(1) cout&lt;&lt;a;输出： 123.456  </span><br><span class="line">(2) cout&lt;&lt;setprecision(9)&lt;&lt;a;输出： 123.456789  </span><br><span class="line">(3) cout&lt;&lt;setprecision(6);恢复默认格式(精度为6)</span><br><span class="line">(4) cout&lt;&lt; setiosflags(ios∷fixed);输出： 123.456789</span><br><span class="line">(5) cout&lt;&lt;setiosflags(ios∷fixed)&lt;&lt;setprecision(8)&lt;&lt;a;输出： 123.45678901</span><br><span class="line">(6) cout&lt;&lt;setiosflags(ios∷scientific)&lt;&lt;a;输出： 1.234568e+02</span><br><span class="line">(7) cout&lt;&lt;setiosflags(ios∷scientific)&lt;&lt;setprecision(4)&lt;&lt;a; 输出： 1.2346e02</span><br><span class="line">下面是整数输出的例子： </span><br><span class="line">int b=123456;对b赋初值</span><br><span class="line">(1) cout&lt;&lt;b;输出： 123456</span><br><span class="line">(2) cout&lt;&lt;hex&lt;&lt;b; 输出： 1e240     </span><br><span class="line">(3) cout&lt;&lt;setiosflags(ios∷uppercase)&lt;&lt;b;输出： 1E240     </span><br><span class="line">(4) cout&lt;&lt;setw(10)&lt;&lt;b&lt;&lt;′,′&lt;&lt;b; 输出：     123456，123456</span><br><span class="line">(5) cout&lt;&lt;setfill(′*′)&lt;&lt;setw(10)&lt;&lt;b;输出： **** 123456</span><br><span class="line">(6) cout&lt;&lt;setiosflags(ios∷showpos)&lt;&lt;b;输出： +123456</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    bitset&lt;32&gt; b0(a);</span><br><span class="line">    // 输出二进制</span><br><span class="line">    cout &lt;&lt; b0 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 转化string类型</span><br><span class="line">    bitset&lt;32&gt; b1(7);</span><br><span class="line">    string str(b1.to_string());</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>C++之split字符串分割</title>
    <url>/2019/03/04/C-%E4%B9%8Bsplit%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<p>在C++中没有直接对应的split函数，字符串分割可借助以下方法实现：</p>
<p>1、借助strtok函数</p>
<p>函数原型：char <em> strtok (char </em>str, char * delim);</p>
<p>函数功能：以delim为分隔符分割字符串str</p>
<p>参数说明：str：要分隔的字符串；delim：分隔符</p>
<p>返回值：从str开头开始的一个个被分割的字符串。当没有被分割时则返回null<br><a id="more"></a><br>代码1:直接使用strtok函数分割char*类型的字符串<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">	char s[] = &quot;my name is lmm&quot;;</span><br><span class="line">	char *p;</span><br><span class="line">	const char *delim = &quot; &quot;;</span><br><span class="line">	p = strtok(s, delim);</span><br><span class="line">	while(p) &#123;</span><br><span class="line">		cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">		p = strtok(NULL, delim);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码2:借助strtok分割string类型的字符串，将结果保存在vector<string>中<br>思路：先将整个string字符串转换为char<em>类型，分割后得到char</em>类型的子字符串，将子字符串转换为string类型，并存入结果数组中。</string></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">vector&lt;string&gt; split(const string&amp; str, const string&amp; delim) &#123;</span><br><span class="line">	vector&lt;string&gt; res;</span><br><span class="line">	if(&quot;&quot; == str) return res;</span><br><span class="line">	//先将要切割的字符串从string类型转换为char*类型</span><br><span class="line">	char * strs = new char[str.length() + 1] ; //不要忘了</span><br><span class="line">	strcpy(strs, str.c_str()); </span><br><span class="line"> </span><br><span class="line">	char * d = new char[delim.length() + 1];</span><br><span class="line">	strcpy(d, delim.c_str());</span><br><span class="line"> </span><br><span class="line">	char *p = strtok(strs, d);</span><br><span class="line">	while(p) &#123;</span><br><span class="line">		string s = p; //分割得到的字符串转换为string类型</span><br><span class="line">		res.push_back(s); //存入结果数组</span><br><span class="line">		p = strtok(NULL, d);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test1() &#123; //空字符串</span><br><span class="line">	cout &lt;&lt; &quot;******test1****** &quot;&lt;&lt;endl;</span><br><span class="line">	string s = &quot;&quot;;</span><br><span class="line">	</span><br><span class="line">	std::vector&lt;string&gt; res = split(s, &quot; &quot;);</span><br><span class="line">	for (int i = 0; i &lt; res.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void test2() &#123; //只有一个字符串</span><br><span class="line">	cout &lt;&lt; &quot;******test2****** &quot; &lt;&lt;endl;</span><br><span class="line">	string s = &quot;my&quot;;</span><br><span class="line">	</span><br><span class="line">	std::vector&lt;string&gt; res = split(s, &quot; &quot;);</span><br><span class="line">	for (int i = 0; i &lt; res.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void test3() &#123; //正常字符串</span><br><span class="line">	cout &lt;&lt; &quot;******test3****** &quot;&lt;&lt;endl;</span><br><span class="line">	string s = &quot;my name is lmm   &quot;;//连续多个空格，空格会被过滤掉</span><br><span class="line">	</span><br><span class="line">	std::vector&lt;string&gt; res = split(s, &quot; &quot;);</span><br><span class="line">	for (int i = 0; i &lt; res.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line"> </span><br><span class="line">	test1();</span><br><span class="line">	test2();</span><br><span class="line">	test3();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：test3中连续多个空格出现，空格都会被过滤掉</p>
<p>2、借助于string类的find和substr函数</p>
<p>1）find函数</p>
<p>函数原型：size_t find(const string&amp; str, size_t pos = 0) const;</p>
<p>功能说明：从pos位置开始查找子字符串str第一次出现的位置</p>
<p>参数说明：str为要查找的子字符串，pos从为初始查找位置</p>
<p>返回值：找到的话返回子字符串第一次出现的位置，否则返回string::npos</p>
<p>2）substr函数</p>
<p>函数原型：string substr(size_t pos = 0, size_t n = npos) const;</p>
<p>功能说明：获取从指定的起始位置开始，长度为n的子字符串</p>
<p>参数说明：pos为起始位置，n获取的1字符串长度</p>
<p>返回值：子字符串<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">string reverse_one_word(string str) &#123;</span><br><span class="line">	for(int i = 0; i &lt; str.length()/2; i ++) &#123;</span><br><span class="line">		char tmp;</span><br><span class="line">		tmp = str[i];</span><br><span class="line">		str[i] = str[ str.length() - i - 1 ];</span><br><span class="line">		str[ str.length() - i - 1 ] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	return str;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">vector&lt;string&gt;  split(const string&amp; str,const string&amp; delim) &#123; //将分割后的子字符串存储在vector中</span><br><span class="line">	vector&lt;string&gt; res;</span><br><span class="line">	if(&quot;&quot; == str) return  res;</span><br><span class="line">	</span><br><span class="line">	string strs = str + delim; //*****扩展字符串以方便检索最后一个分隔出的字符串</span><br><span class="line">	size_t pos;</span><br><span class="line">	size_t size = strs.size();</span><br><span class="line"> </span><br><span class="line">	for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">		pos = strs.find(delim, i); //pos为分隔符第一次出现的位置，从i到pos之前的字符串是分隔出来的字符串</span><br><span class="line">		if( pos &lt; size) &#123; //如果查找到，如果没有查找到分隔符，pos为string::npos</span><br><span class="line">			string s = strs.substr(i, pos - i);//*****从i开始长度为pos-i的子字符串</span><br><span class="line">			res.push_back(s);//两个连续空格之间切割出的字符串为空字符串，这里没有判断s是否为空，所以最后的结果中有空字符的输出，</span><br><span class="line">			i = pos + delim.size() - 1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return res;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void test1() &#123; //空字符串</span><br><span class="line">	cout &lt;&lt; &quot;******test1****** &quot;&lt;&lt;endl;</span><br><span class="line">	string s = &quot;&quot;;</span><br><span class="line">	</span><br><span class="line">	std::vector&lt;string&gt; res = split(s, &quot; &quot;);</span><br><span class="line">	for (int i = 0; i &lt; res.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void test2() &#123; //只有一个字符串</span><br><span class="line">	cout &lt;&lt; &quot;******test2****** &quot; &lt;&lt;endl;</span><br><span class="line">	string s = &quot;my&quot;;</span><br><span class="line">	</span><br><span class="line">	std::vector&lt;string&gt; res = split(s, &quot; &quot;);</span><br><span class="line">	for (int i = 0; i &lt; res.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void test3() &#123; //正常字符串</span><br><span class="line">	cout &lt;&lt; &quot;******test3****** &quot;&lt;&lt;endl;</span><br><span class="line">	string s = &quot;my name is  lmm   &quot;;</span><br><span class="line">	</span><br><span class="line">	std::vector&lt;string&gt; res = split(s, &quot; &quot;);</span><br><span class="line">	for (int i = 0; i &lt; res.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line"> </span><br><span class="line">	test1();</span><br><span class="line">	test2();</span><br><span class="line">	test3();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="https://blog.csdn.net/Mary19920410/article/details/77372828" target="_blank" rel="noopener">https://blog.csdn.net/Mary19920410/article/details/77372828</a> </p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title> C++ 读书笔记之 getline与cin.getline的区别</title>
    <url>/2018/11/06/C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B-getline%E4%B8%8Ecin-getline%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>cin.getline()函数是处理数组字符串的，其原型为cin.getline(char * , int)，第一个参数为一个char指针，第二个参数为数组字符串长度。</p>
<p>getline(cin,str)函数是处理string类的函数。第二个参数为string类型的变量。<br><a id="more"></a><br>实例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int SIZE=20;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str;</span><br><span class="line">cout&lt;&lt;&quot;string method:&quot;&lt;&lt;endl;</span><br><span class="line">getline(cin,str);</span><br><span class="line">cout&lt;&lt;&quot;the string is:&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">cin.get();//接受最后一个结束符</span><br><span class="line"></span><br><span class="line">char chs[SIZE];</span><br><span class="line">cout&lt;&lt;&quot;char * method:&quot;&lt;&lt;endl;</span><br><span class="line">cin.getline(chs,20);</span><br><span class="line">cout&lt;&lt;&quot;the string is:&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;chs&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string method:</span><br><span class="line">Hello String</span><br><span class="line"></span><br><span class="line">the string is:</span><br><span class="line">Hello String</span><br><span class="line">char * method:</span><br><span class="line">Hello Char *</span><br><span class="line">the string is:</span><br><span class="line">Hello Char *</span><br></pre></td></tr></table></figure></p>
<p>注：getline(cin,str);处理后还留有结束符在输入流中，故需要使用cin.get();//接受最后一个结束符，才能接受后面得输入值。</p>
<p><a href="https://blog.csdn.net/wangshihui512/article/details/8939317" target="_blank" rel="noopener">https://blog.csdn.net/wangshihui512/article/details/8939317</a><br><a href="https://blog.csdn.net/xumengxing/article/details/6664436" target="_blank" rel="noopener">https://blog.csdn.net/xumengxing/article/details/6664436</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>CCF201403-3 命令行选项</title>
    <url>/2019/03/04/CCF201403-3-%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<p>问题描述<br>　　请你写一个命令行分析程序,用以分析给定的命令行里包含哪些选项。每个命令行由若干个字符串组成,它们之间恰好由一个空格分隔。这些字符串中的第一个为该命令行工具的名字,由小写字母组成,你的程序不用对它进行处理。在工具名字之后可能会包含若干选项,然后可能会包含一 些不是选项的参数。<br>  <a id="more"></a><br>　　选项有两类:带参数的选项和不带参数的选项。一个合法的无参数选项的形式是一个减号后面跟单个小写字母,如”-a” 或”-b”。而带参数选项则由两个由空格分隔的字符串构成,前者的格式要求与无参数选项相同,后者则是该选项的参数,是由小写字母,数字和减号组成的非空字符串。<br>　　该命令行工具的作者提供给你一个格式字符串以指定他的命令行工具需要接受哪些选项。这个字符串由若干小写字母和冒号组成,其中的每个小写字母表示一个该程序接受的选项。如果该小写字母后面紧跟了一个冒号,它就表示一个带参数的选项,否则则为不带参数的选项。例如, “ab:m:” 表示该程序接受三种选项,即”-a”(不带参数),”-b”(带参数), 以及”-m”(带参数)。<br>　　命令行工具的作者准备了若干条命令行用以测试你的程序。对于每个命令行,你的工具应当一直向后分析。当你的工具遇到某个字符串既不是合法的选项,又不是某个合法选项的参数时,分析就停止。命令行剩余的未分析部分不构成该命令的选项,因此你的程序应当忽略它们。<br>输入格式<br>　　输入的第一行是一个格式字符串,它至少包含一个字符,且长度不超过 52。格式字符串只包含小写字母和冒号,保证每个小写字母至多出现一次,不会有两个相邻的冒号,也不会以冒号开头。<br>　　输入的第二行是一个正整数 N(1 ≤ N ≤ 20),表示你需要处理的命令行的个数。<br>　　接下来有 N 行,每行是一个待处理的命令行,它包括不超过 256 个字符。该命令行一定是若干个由单个空格分隔的字符串构成,每个字符串里只包含小写字母,数字和减号。<br>输出格式<br>　　输出有 N 行。其中第 i 行以”Case i:” 开始,然后应当有恰好一个空格,然后应当按照字母升序输出该命令行中用到的所有选项的名称,对于带参数的选项,在输出它的名称之后还要输出它的参数。如果一个选项在命令行中出现了多次,只输出一次。如果一个带参数的选项在命令行中出 现了多次,只输出最后一次出现时所带的参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入</span><br><span class="line">albw:x</span><br><span class="line">4</span><br><span class="line">ls -a -l -a documents -b</span><br><span class="line">ls</span><br><span class="line">ls -w 10 -x -w 15</span><br><span class="line">ls -a -b -c -d -e -l</span><br><span class="line">样例输出</span><br><span class="line">Case 1: -a -l</span><br><span class="line">Case 2:</span><br><span class="line">Case 3: -w 15 -x</span><br><span class="line">Case 4: -a -b</span><br></pre></td></tr></table></figure></p>
<p>用strtok切割或者用find和substr结合起来切割字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;string,string&gt; m;</span><br><span class="line">vector&lt;string&gt;  v;</span><br><span class="line">void split(vector&lt;string&gt; &amp;vec,string s)&#123;</span><br><span class="line">	int pos1,pos=0;</span><br><span class="line">	while((pos1=s.find(&apos; &apos;,pos))!=-1)&#123;</span><br><span class="line">		string t=s.substr(pos,pos1-pos);</span><br><span class="line">		vec.push_back(t);</span><br><span class="line">		pos=pos1+1;</span><br><span class="line">	&#125;</span><br><span class="line">	vec.push_back(s.substr(pos));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	//freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	getchar(); </span><br><span class="line">	string str;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">			v.clear();</span><br><span class="line">			m.clear();</span><br><span class="line">		getline(cin,str);</span><br><span class="line">		split(v,str);</span><br><span class="line">	//!!j=0错误的 </span><br><span class="line">		for(int j=1;j&lt;v.size();j++)&#123;</span><br><span class="line">			if(v[j][0]==&apos;-&apos;&amp;&amp;v[j].size()==2)&#123;</span><br><span class="line">				int pos=s.find(v[j][1]);</span><br><span class="line">				if(pos==-1)&#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				//如果map中没有该参数 </span><br><span class="line">				    if(m.find(v[j]) == m.end())</span><br><span class="line">                    m[v[j]] = &quot;&quot;;</span><br><span class="line">					if(s[pos+1]==&apos;:&apos;&amp;&amp;j+1&lt;v.size())&#123;</span><br><span class="line">						m[v[j]]=v[j+1];</span><br><span class="line">						j++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">					</span><br><span class="line">						else break;</span><br><span class="line">				&#125;</span><br><span class="line">					cout&lt;&lt;&quot;Case &quot;&lt;&lt;i+1&lt;&lt;&quot;:&quot;;</span><br><span class="line">		for(map&lt;string,string&gt;::iterator it=m.begin();it!=m.end();it++)&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;first;</span><br><span class="line">				if(it-&gt;second!=&quot;&quot;) cout&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void split(vector&lt;string&gt;&amp; vec,char *str,char *p)&#123;</span><br><span class="line">	char *ptr=strtok(str,p);</span><br><span class="line">	while(ptr!=NULL)&#123;</span><br><span class="line">		vec.push_back(ptr);</span><br><span class="line">		ptr=strtok(NULL,p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mygetline(char *p)&#123;</span><br><span class="line">	char c;</span><br><span class="line">	while((c=getchar())!=&apos;\n&apos;&amp;&amp;c!=EOF) *p++=c;</span><br><span class="line">	*p=&apos;\0&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	getchar(); </span><br><span class="line">	char str[257];</span><br><span class="line">	char par[]=&quot; &quot;;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">map&lt;string,string&gt; m;</span><br><span class="line">vector&lt;string&gt;  v;</span><br><span class="line">		mygetline(str);</span><br><span class="line"></span><br><span class="line">		split(v,str,par);</span><br><span class="line">	//!!j=0开始是错误的 从J=1开始才有参数 </span><br><span class="line">		for(int j=1;j&lt;v.size();j++)&#123;</span><br><span class="line">			if(v[j][0]==&apos;-&apos;&amp;&amp;v[j].size()==2)&#123;</span><br><span class="line">				int pos=s.find(v[j][1]);</span><br><span class="line">				if(pos==-1)&#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				//如果map中没有该参数 </span><br><span class="line">				    if(m.find(v[j]) == m.end())</span><br><span class="line">                    m[v[j]] = &quot;&quot;;</span><br><span class="line">                    //!!s[pos+1]==&apos;:&apos;&amp;&amp;pos+1&lt;s.size() 错的 </span><br><span class="line">                    //忘考虑需要匹配命令 后面有无参数 </span><br><span class="line">					if(s[pos+1]==&apos;:&apos;&amp;&amp;j+1&lt;v.size())&#123;</span><br><span class="line">						m[v[j]]=v[j+1];</span><br><span class="line">						j++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">					</span><br><span class="line">						else break;</span><br><span class="line">				&#125;</span><br><span class="line">					cout&lt;&lt;&quot;Case &quot;&lt;&lt;i+1&lt;&lt;&quot;:&quot;;</span><br><span class="line">		for(map&lt;string,string&gt;::iterator it=m.begin();it!=m.end();it++)&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;first;</span><br><span class="line">				if(it-&gt;second!=&quot;&quot;) cout&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf</category>
      </categories>
  </entry>
  <entry>
    <title>Day Day Up</title>
    <url>/2018/04/25/Day-Day-Up/</url>
    <content><![CDATA[<p>折腾了一天 打算换个地方写博客<br><a href="http://www.cnblogs.com/is-Tina/" target="_blank" rel="noopener">旧博客</a><br>上学期没怎么学 假期各种各样的事也置坚持写博客这件事拖了很久<br>这学期课相对不多（其实是相当闲）<br>but so many thing you want to do is always tough and full of challenges.<br><strong>Aims and Ambition</strong> </p>
<ul>
<li>坚持晨跑</li>
<li>每天做有效的时间管理</li>
<li>1个星期or2个星期看完一本编程的书</li>
<li>学js,css,python的Django框架 写一个网站</li>
<li>做大创项目<a id="more"></a>
写一个有价值的博客<br>just to encourage myself,<br>run towards your dreams<br>and share things with others<br>剩下的就交给坚持了</li>
</ul>
<p>The last but not the least:<br><strong>You should know where you go.With your devoted effort, commitment, patience, and perseverance, in time the universe will support you in making your dreams happen!</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Dijkstra算法</title>
    <url>/2018/12/01/Dijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>求单源最短路径<br>dis 保存第i点到源点的最短距离</p>
<a id="more"></a>
<h2 id="传统"><a href="#传统" class="headerlink" title="传统"></a>传统</h2><p>用数组flag 记录集合 S,V-S </p>
<p>dis 记录与源点的距离</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">#define MAX 100</span><br><span class="line">#define INF 1e7</span><br><span class="line">int dis[MAX];</span><br><span class="line">bool flag[MAX];</span><br><span class="line">int p[MAX];</span><br><span class="line">//用P数组记录了最短路径上每一个节点的前驱 </span><br><span class="line">int map[MAX][MAX];</span><br><span class="line">void dij(int u)&#123;</span><br><span class="line">	//初始化原点到其他路径最短长度 </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(map[u][i]!=INF) &#123;</span><br><span class="line">			dis[i]=map[u][i];</span><br><span class="line">			p[i]=u;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			p[i]=-1;</span><br><span class="line">			dis[i]=INF;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//初始化集合	</span><br><span class="line">	flag[u]=true;</span><br><span class="line">	dis[u]=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int tmp=INF,t=u; </span><br><span class="line">		for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line"></span><br><span class="line">		if(!flag[k]&amp;&amp;tmp&gt;dis[k]) &#123;//!!</span><br><span class="line">			</span><br><span class="line">			tmp=dis[i];</span><br><span class="line">			t=k;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		if(t==u) return;</span><br><span class="line">		flag[t]=true;</span><br><span class="line"></span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			</span><br><span class="line">			if(!flag[j]&amp;&amp;map[t][j]&lt;INF)//在图中 </span><br><span class="line">			&#123;</span><br><span class="line">				if(map[t][j]+dis[t]&lt;dis[j])</span><br><span class="line">				&#123;</span><br><span class="line">				 </span><br><span class="line">				dis[j]=map[t][j]+dis[t];</span><br><span class="line">				p[j]=t;</span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void findPath(int u)&#123;</span><br><span class="line">	stack&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			s.push(i);</span><br><span class="line">		int x=p[i];</span><br><span class="line">		</span><br><span class="line">		while(x!=-1)&#123;</span><br><span class="line">			s.push(x);</span><br><span class="line">			x=p[x];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;u&lt;&lt;&quot;到&quot;&lt;&lt;i&lt;&lt;&quot;的路径为:&quot;&lt;&lt;endl; </span><br><span class="line">		while(!s.empty())&#123;</span><br><span class="line">			cout&lt;&lt;s.top()&lt;&lt;&quot; &quot;; </span><br><span class="line">			s.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	int m,u,v,w;</span><br><span class="line">	freopen(&quot;11.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)</span><br><span class="line">		map[i][j]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	memset(flag,false,sizeof(flag));</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		//城市1 城市2 距离 </span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		map[u][v]=min(map[u][v],w);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	int src;</span><br><span class="line">	cin&gt;&gt;src;</span><br><span class="line">	dij(src);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;src&lt;&lt;&quot;到&quot;&lt;&lt;i&lt;&lt;&quot;点距离 &quot;&lt;&lt;dis[i]&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	findPath(src);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用优先队列"><a href="#使用优先队列" class="headerlink" title="使用优先队列"></a>使用优先队列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;string.h&gt; </span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;iostream&gt; </span><br><span class="line">#define MAX 100</span><br><span class="line">#define INF 1e7</span><br><span class="line">using namespace std;</span><br><span class="line">int dis[MAX];</span><br><span class="line">bool flag[MAX];</span><br><span class="line">int p[MAX];</span><br><span class="line">//用P数组记录了最短路径上每一个节点的前驱 </span><br><span class="line">int map[MAX][MAX];</span><br><span class="line">int n;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int c;</span><br><span class="line">	int v;</span><br><span class="line">	node(int cc,int vv):c(cc),v(vv)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &lt;(const node &amp;p)const&#123;</span><br><span class="line">		return v&gt;p.v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dij(int u)&#123;</span><br><span class="line">	//初始化原点到其他路径最短长度 </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(map[u][i]!=INF) &#123;</span><br><span class="line">			</span><br><span class="line">			p[i]=u;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			p[i]=-1;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">			dis[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">	dis[u]=0;</span><br><span class="line">	priority_queue&lt;node&gt; pq;</span><br><span class="line">	pq.push(node(u,0));</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line">		node t=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			if(map[t.c][i]!=INF)&#123;</span><br><span class="line">				if(map[t.c][i]+dis[t.c]&lt;dis[i])</span><br><span class="line">				&#123;</span><br><span class="line">					dis[i]=map[t.c][i]+dis[t.c];</span><br><span class="line">					p[i]=t.c;</span><br><span class="line">					pq.push(node(i,dis[i]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void findPath(int u)&#123;</span><br><span class="line">	stack&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			s.push(i);</span><br><span class="line">		int x=p[i];</span><br><span class="line">		</span><br><span class="line">		while(x!=-1)&#123;</span><br><span class="line">			s.push(x);</span><br><span class="line">			x=p[x];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;u&lt;&lt;&quot;到&quot;&lt;&lt;i&lt;&lt;&quot;的路径为:&quot;&lt;&lt;endl; </span><br><span class="line">		while(!s.empty())&#123;</span><br><span class="line">			cout&lt;&lt;s.top()&lt;&lt;&quot; &quot;; </span><br><span class="line">			s.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	int m,u,v,w;</span><br><span class="line">	freopen(&quot;11.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)</span><br><span class="line">		map[i][j]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	memset(flag,false,sizeof(flag));</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		//城市1 城市2 距离 </span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		map[u][v]=min(map[u][v],w);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	int src;</span><br><span class="line">	cin&gt;&gt;src;</span><br><span class="line">	dij(src);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;src&lt;&lt;&quot;到&quot;&lt;&lt;i&lt;&lt;&quot;点距离 &quot;&lt;&lt;dis[i]&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	findPath(src);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxrkhhznugj306y09o3yv.jpg" alt="image"></p>
<p>复习<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#define MAX 1000</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">bool vis[MAX];</span><br><span class="line">int n,m,st,ed;</span><br><span class="line">int p[MAX],ids;</span><br><span class="line">//用P数组记录了最短路径上每一个节点的前驱 </span><br><span class="line">int map[MAX][MAX],dis[MAX],w[MAX];</span><br><span class="line">struct node&#123;</span><br><span class="line">	int v,c;</span><br><span class="line">	node(int vv,int cc):c(cc),v(vv)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &lt;(const node&amp;p)const&#123;</span><br><span class="line">	return c&gt;p.c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void dij(int src,int ed)&#123;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dis[i]=INF;</span><br><span class="line">		p[i]=-1; </span><br><span class="line">	&#125;</span><br><span class="line">	dis[src]=0;</span><br><span class="line">	priority_queue&lt;node&gt; pq;</span><br><span class="line">	pq.push(node(src,0));</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line">		node t=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		if(dis[t.v]&lt;t.c) continue;</span><br><span class="line">		if(t.v==ed) break;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			if(map[t.v][i]!=INF)&#123;</span><br><span class="line">				if(map[t.v][i]+dis[t.v]&lt;dis[i])</span><br><span class="line">				&#123;</span><br><span class="line">					dis[i]=map[t.v][i]+dis[t.v];</span><br><span class="line">					p[i]=t.v;</span><br><span class="line">					pq.push(node(i,dis[i]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)</span><br><span class="line">		map[i][j]=INF; </span><br><span class="line">	 &#125; </span><br><span class="line">	 for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">	 	int a,b;</span><br><span class="line">	 	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	 	cin&gt;&gt;map[a][b];</span><br><span class="line">	 	map[b][a]=map[a][b];</span><br><span class="line">	 &#125;</span><br><span class="line">	dij(st,ed);</span><br><span class="line">	cout&lt;&lt;dis[ed]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br>用领接表 优先队列实现:<br><a href="http://www.voidcn.com/article/p-pwheyixu-te.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-pwheyixu-te.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>poj3104	Drying</title>
    <url>/2018/11/01/Drying/</url>
    <content><![CDATA[<p>有一些衣服，每件衣服有一定水量，有一个烘干机，每次可以烘一件衣服，每分钟可以烘掉k滴水。每件衣服没分钟可以自动蒸发掉一滴水，用烘干机烘衣服时不蒸发。问最少需要多少时间能烘干所有的衣服。<br><a id="more"></a></p>
<p>要知道如果想要晾干衣服的话，最好的方法就是使用机器冲干x1秒，然后等待风干x2秒。我们来二分答案mid，表示能在mid秒钟晒干。<br>机器烘干需要x1秒钟，自然烘干需要mid-x1秒钟，得到如下公式x1*k+(mid-x1) &gt;= a[i]所以：x &gt;= (a[i] – mid) / (k – 1)。</p>
<p>当k==1的时候,除数为0 单独讨论</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//二分一个答案，然后判断可行性</span><br><span class="line">//知道如果想要晾干衣服的话，最好的方法就是使用机器冲干x1秒，然后等待风干x2秒。我们来二分答案mid，表示能在mid秒钟晒干。</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">int n,a[10000],k;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	int maxValue=a[n-1];</span><br><span class="line">	int ans=0,L,R;</span><br><span class="line">	L=1;</span><br><span class="line">	R=maxValue;</span><br><span class="line">	if(k==1) cout&lt;&lt;maxValue&lt;&lt;endl;</span><br><span class="line">	else&#123;</span><br><span class="line"></span><br><span class="line">	while(L&lt;=R)&#123;</span><br><span class="line">		int mid=(L+R)/2;</span><br><span class="line">		int sum=0;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			if(a[i]&gt;mid)&#123;</span><br><span class="line">				int x=ceil((a[i]-mid)*1.0/(k-1));</span><br><span class="line">				sum+=x;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		if(sum&lt;=mid)//能完成晒干 </span><br><span class="line">		 &#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			R=mid-1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		else L=mid+1;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>double ceil (double x);</p>
<p>ceil返回不小于value 的下一个整数，value 如果有小数部分则进一位。ceil() 返回的类型仍然是float，因为float 值的范围通常比integer 要小。</p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>Eclipse快捷键</title>
    <url>/2018/06/29/Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>Eclipse中10个最有用的快捷键组合<br>一个Eclipse骨灰级开发者总结了他认为最有用但又不太为人所知的快捷键组合。通过这些组合可以更加容易的浏览源代码，使得整体的开发效率和质量得到提升。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1. ctrl+shift+r：打开资源</span><br><span class="line"></span><br><span class="line">    这可能是所有快捷键组合中最省时间的了。这组快捷键可以让你打开你的工作区中任何一个文件，而你只需要按下文件名或mask名中的前几个字母，比如applic*.xml。美中不足的是这组快捷键并非在所有视图下都能用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 2. ctrl+o：快速outline</span><br><span class="line"></span><br><span class="line">    如果想要查看当前类的方法或某个特定方法，但又不想把代码拉上拉下，也不想使用查找功能的话，就用ctrl+o吧。它可以列出当前类中的所有方法及属性，你只需输入你想要查询的方法名，点击enter就能够直接跳转至你想去的位置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. ctrl+e：快速转换编辑器</span><br><span class="line"></span><br><span class="line">    这组快捷键将帮助你在打开的编辑器之间浏览。使用ctrl+page down或ctrl+page up可以浏览前后的选项卡，但是在很多文件打开的状态下，ctrl+e会更加有效率。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eclipse快捷键 10个最有用的快捷键 </span><br><span class="line"></span><br><span class="line">4. ctrl+2，L：为本地变量赋值</span><br><span class="line"></span><br><span class="line">    开发过程中，我常常先编写方法，如Calendar.getInstance()，然后通过ctrl+2快捷键将方法的计算结果赋值于一个本地变量之上。 这样我节省了输入类名，变量名以及导入声明的时间。Ctrl+F的效果类似，不过效果是把方法的计算结果赋值于类中的域。</span><br><span class="line"></span><br><span class="line">    5. alt+shift+r：重命名</span><br><span class="line"></span><br><span class="line">    重命名属性及方法在几年前还是个很麻烦的事，需要大量使用搜索及替换，以至于代码变得零零散散的。今天的Java IDE提供源码处理功能，Eclipse也是一样。现在，变量和方法的重命名变得十分简单，你会习惯于在每次出现更好替代名称的时候都做一次重命名。要使 用这个功能，将鼠标移动至属性名或方法名上，按下alt+shift+r，输入新名称并点击回车。就此完成。如果你重命名的是类中的一个属性，你可以点击alt+shift+r两次，这会呼叫出源码处理对话框，可以实现get及set方法的自动重命名。</span><br><span class="line"></span><br><span class="line">    6. alt+shift+l以及alt+shift+m：提取本地变量及方法</span><br><span class="line"></span><br><span class="line">    源码处理还包括从大块的代码中提取变量和方法的功能。比如，要从一个string创建一个常量，那么就选定文本并按下alt+shift+l即可。如果同 一个string在同一类中的别处出现，它会被自动替换。方法提取也是个非常方便的功能。将大方法分解成较小的、充分定义的方法会极大的减少复杂度，并提 升代码的可测试性。</span><br><span class="line"></span><br><span class="line">    7. shift+enter及ctrl+shift+enter</span><br><span class="line"></span><br><span class="line">    Shift+enter在当前行之下创建一个空白行，与光标是否在行末无关。Ctrl+shift+enter则在当前行之前插入空白行。</span><br><span class="line"></span><br><span class="line">    8. Alt+方向键</span><br><span class="line"></span><br><span class="line">    这也是个节省时间的法宝。这个组合将当前行的内容往上或下移动。在try/catch部分，这个快捷方式尤其好使。</span><br><span class="line"></span><br><span class="line">    9. ctrl+m</span><br><span class="line"></span><br><span class="line">    大显示屏幕能够提高工作效率是大家都知道的。Ctrl+m是编辑器窗口最大化的快捷键。</span><br><span class="line"></span><br><span class="line">    10. ctrl+.及ctrl+1：下一个错误及快速修改</span><br><span class="line"></span><br><span class="line">    ctrl+.将光标移动至当前文件中的下一个报错处或警告处。这组快捷键我一般与ctrl+1一并使用，即修改建议的快捷键。新版Eclipse的修改建 议做的很不错，可以帮你解决很多问题，如方法中的缺失参数，throw/catch exception，未执行的方法等等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eclipse快捷键 10个最有用的快捷键 </span><br><span class="line"></span><br><span class="line">更多快捷键组合可在Eclipse按下ctrl+shift+L查看。</span><br><span class="line"></span><br><span class="line">让我们按照使用频率来看看我最爱用的一些热键组合。（注：以下内容在Eclipse3.02及一上版本通过测试）</span><br><span class="line"></span><br><span class="line">1. Control-Shift-T: 打开类型（Open type）。如果你不是有意磨洋工，还是忘记通过源码树（source tree）打开的方式吧。用eclipse很容易打开接口的实现类的，按ctrl+t会列出接口的实现类列表</span><br><span class="line"></span><br><span class="line">2. Control-Shift-R: 打开资源（不只是用来寻找Java文件）。小提示：利用Navigator视图的黄色双向箭头按钮让你的编辑窗口和导航器相关联。这会让你打开的文件对应显示在导航器的层级结构中，这样便于组织信息。如果这影响了速度，就关掉它。</span><br><span class="line"></span><br><span class="line">3. F3: 打开申明（Open declaration）。或者，利用Declaration Tab（在Java视图模式下，选择Windows --&gt; Show View -- &gt; Declaration）。当你选中代码中的一个方法，然后按这个按键，它会把整个方法在申明方框里显示出来。</span><br><span class="line"></span><br><span class="line">4. Alt-left arrow: 在导航历史记录（Navigation History）中后退。就像Web浏览器的后退按钮一样，在利用F3跳转之后，特别有用。（用来返回原先编译的地方）</span><br><span class="line"></span><br><span class="line">5. Alt-right arrow: 导航历史记录中向前。</span><br><span class="line"></span><br><span class="line">6. Control-Q: 回到最后一次编辑的地方。这个快捷键也是当你在代码中跳转后用的。特别是当你钻的过深，忘记你最初在做什么的时候。</span><br><span class="line"></span><br><span class="line">7. Control-Shift-G: 在workspace中搜索引用（reference）。这 是重构的前提。对于方法，这个热键的作用和F3恰好相反。它使你在方法的栈中，向上找出一个方法的所有调用者。一个与此相关的功能是开启“标记”功能 （occurrence marking） 。选择Windows-&gt;Preferences-&gt;Java-&gt; Editor-&gt; Mark Occurrences，勾选选项。这时，当你单击一个元素的时候，代码中所有该元素存在的地方都会被高亮显示。我个人只使用“标记本地变量”（Mark Local Variables）。注意：太多的高亮显示会拖慢Eclipse。</span><br><span class="line"></span><br><span class="line">8. Control-Shift-F: CodeàJavaàPreferencesà根据代码风格设定重新格式化代码。我 们的团队有统一的代码格式，我们把它放在我们的wiki上。要这么做，我们打开Eclipse，选择Window Style，然后设置Code Formatter，Code Style和Organize Imports。利用导出（Export）功能来生成配置文件。我们把这些配置文件放在wiki上，然后团队里的每个人都导入到自己的Eclipse中。</span><br><span class="line"></span><br><span class="line">9. Control-O: 快速概要(quick outline)。通过这个快捷键，你可以迅速的跳到一个方法或者属性，只需要输入名字的头几个字母。</span><br><span class="line"></span><br><span class="line">10. Control-/: 对一行注释或取消注释。对于多行也同样适用。</span><br><span class="line"></span><br><span class="line">11. Control-Alt-down arrow: 复制高亮显示的一行或多行。</span><br><span class="line"></span><br><span class="line">12. Alt-down arrow: 将一行或多行向下移动。Alt-up arrow会向上移动。</span><br><span class="line"></span><br><span class="line">其他的热键在菜单里有。你可以通过按下Control-Shift-L（从3.1版本开始）， 看到所有快捷键的列表。按下Control-Shift-L两次，会显示热键对话框（Keys Preferences dialog），你可以在这里自己设置热键。我欢迎你在Talkback部分发表你的Eclipse提示。</span><br><span class="line"></span><br><span class="line">其他的Eclipse窍门</span><br><span class="line"></span><br><span class="line">我总结了几个相关的小窍门：</span><br><span class="line"></span><br><span class="line">锁定命令行窗口：在命令行视图中（Window -&gt;Show View -&gt;Other -&gt;Basic -&gt;Console），试试看用滚动锁定按钮来锁定控制台输出不要滚屏。</span><br><span class="line"></span><br><span class="line">使用Ant视图： 在我的Java或Debug模式下，我喜欢显示出Ant视图，这样我就可以迅速的运行Ant任务。通过Window Ant可以找到该视图。把Ant视图放在屏幕的一角， 通过“添加编译文件（Addà Other à Show View à Buildfiles）”按钮来添加build.xml文件。在3.1版本中，甚至支持Ant调试脚本语言。</span><br><span class="line"></span><br><span class="line">自动遍历一个集合：for + Control-Space: 如果你还不知道，那么你应该记住Control-Space是自动完成功能。在Eclipse中，你还可以自动完成结构。在一个数组或集合范围内，试试看 输入“for”然后按下Control-Space键。Eclipse会问你你想要遍历哪一个集合然后自动完成循环代码。</span><br><span class="line"></span><br><span class="line">使用分级布局： 在包浏览视图（Package Explorer view）中默认的布局（扁平式）方式让我困惑，它把包的全名显示在导航树（navigation tree）中。我更喜欢我源码的包和文件系统视图，在Eclipse中叫做分级布局（Hierarchical Layout）。要切换到这种模式，点击包浏览视图中向下的按钮，选择布局（Layout），然后选择分级（Hierarchial）。</span><br><span class="line"></span><br><span class="line">一次显示多个文件：你可以一次浏览多个文件。把不在激活状态的编辑窗口拖到激活窗口的底部或侧边的滚动条上，就可以打开该编辑窗口。这是我能描述该窍门的最好方式了。</span><br><span class="line"></span><br><span class="line">同时打开两个Eclipse： 要将改动从一个CVS分支上合并到另外一个上，我喜欢通过同时打开两个工作目录（Workspace）不同Eclipse来实现。这样我可以通过比较 CVS上的最新版本看到所有的变化（右键单击工程，然后选择Compare Lastest from HEAD）然后把每一个变化都合并到另外一个CVS分支上。启动多个Eclipse的最简单的方法是利用Eclipseàwith Launcher。</span><br><span class="line"></span><br><span class="line">Implementors插件：安装一个能够跳到一个接口的实现的插件。如果你是个dependency injection 粉丝，或者正在基于编写优良的接口工作，那么你需要一个这样的插件来加速代码导航。 你可以在SourceForge找到这个插件。</span><br><span class="line"></span><br><span class="line">Ctrl+Alt+H</span><br><span class="line"></span><br><span class="line">如果你想知道一个类的方法到底被那些其他的类调用，那么请选中这个方法名，然后按“Ctrl+Alt+H”，</span><br><span class="line"></span><br><span class="line">Eclipse就会显示出这个方法被哪些方法调用，最终产生一个调用关系树。 </span><br><span class="line">1. Ctrl+左键</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这个是大多数人经常用到的，用来查看变量、方法、类的定义</span><br><span class="line"></span><br><span class="line">2. Ctrl+O</span><br><span class="line"></span><br><span class="line">查看一个类的纲要，列出其方法和成员变量。提示：再多按一次Ctrl+O，可以列出该类继承的方法和变量。</span><br><span class="line"></span><br><span class="line">助记：&quot;O&quot;---&gt;&quot;Outline&quot;---&gt;&quot;纲要&quot;</span><br><span class="line"></span><br><span class="line">3. Ctrl+T</span><br><span class="line"></span><br><span class="line">查看一个类的继承关系树，是自顶向下的，再多按一次Ctrl+T, 会换成自底向上的显示结构。</span><br><span class="line"></span><br><span class="line">提示：选中一个方法名，按Ctrl+T，可以查看到有这个同名方法的父类、子类、接口。</span><br><span class="line"></span><br><span class="line">助记：&quot;T&quot;-------&gt;&quot;Tree&quot;-----&gt;&quot;层次树&quot;</span><br><span class="line"></span><br><span class="line">4.Alt+左右方向键</span><br><span class="line"></span><br><span class="line">我们经常会遇到看代码时Ctrl+左键，层层跟踪，然后迷失在代码中的情况，这时只需要按“Alt+左方向键</span><br><span class="line"></span><br><span class="line">”就可以退回到上次阅读的位置，同理，按“Alt+右方向键”会前进到刚才退回的阅读位置，就像浏览器的</span><br></pre></td></tr></table></figure></p>
<p>前进和后退按钮一样。</p>
<p>导入包：Ctrl+Shift+O<br>编辑<br>作用域 功能 快捷键<br>全局 查找并替换 Ctrl+F<br>文本编辑器 查找上一个 Ctrl+Shift+K<br>文本编辑器 查找下一个 Ctrl+K<br>全局 撤销 Ctrl+Z<br>全局 复制 Ctrl+C<br>全局 恢复上一个选择 Alt+Shift+↓<br>全局 剪切 Ctrl+X<br>全局 快速修正 Ctrl1+1<br>全局 内容辅助 Alt+/<br>全局 全部选中 Ctrl+A<br>全局 删除 Delete<br>全局 上下文信息 Alt+？<br>Alt+Shift+?<br>Ctrl+Shift+Space<br>Java编辑器 显示工具提示描述 F2<br>Java编辑器 选择封装元素 Alt+Shift+↑<br>Java编辑器 选择上一个元素 Alt+Shift+←<br>Java编辑器 选择下一个元素 Alt+Shift+→<br>文本编辑器 增量查找 Ctrl+J<br>文本编辑器 增量逆向查找 Ctrl+Shift+J<br>全局 粘贴 Ctrl+V<br>全局 重做 Ctrl+Y<br>查看<br>作用域 功能 快捷键<br>全局 放大 Ctrl+=<br>全局 缩小 Ctrl+-<br>窗口<br>作用域 功能 快捷键<br>全局 激活编辑器 F12<br>全局 切换编辑器 Ctrl+Shift+W<br>全局 上一个编辑器 Ctrl+Shift+F6<br>全局 上一个视图 Ctrl+Shift+F7<br>全局 上一个透视图 Ctrl+Shift+F8<br>全局 下一个编辑器 Ctrl+F6<br>全局 下一个视图 Ctrl+F7<br>全局 下一个透视图 Ctrl+F8<br>文本编辑器 显示标尺上下文菜单 Ctrl+W<br>全局 显示视图菜单 Ctrl+F10<br>全局 显示系统菜单 Alt+-<br>导航<br>作用域 功能 快捷键<br>Java编辑器 打开结构 Ctrl+F3<br>全局 打开类型 Ctrl+Shift+T<br>全局 打开类型层次结构 F4<br>全局 打开声明 F3<br>全局 打开外部javadoc Shift+F2<br>全局 打开资源 Ctrl+Shift+R<br>全局 后退历史记录 Alt+←<br>全局 前进历史记录 Alt+→<br>全局 上一个 Ctrl+,<br>全局 下一个 Ctrl+.<br>Java编辑器 显示大纲 Ctrl+O<br>全局 在层次结构中打开类型 Ctrl+Shift+H<br>全局 转至匹配的括号 Ctrl+Shift+P<br>全局 转至上一个编辑位置 Ctrl+Q<br>Java编辑器 转至上一个成员 Ctrl+Shift+↑<br>Java编辑器 转至下一个成员 Ctrl+Shift+↓<br>文本编辑器 转至行 Ctrl+L<br>搜索<br>作用域 功能 快捷键<br>全局 出现在文件中 Ctrl+Shift+U<br>全局 打开搜索对话框 Ctrl+H<br>全局 工作区中的声明 Ctrl+G<br>全局 工作区中的引用 Ctrl+Shift+G<br>文本编辑<br>作用域 功能 快捷键<br>文本编辑器 改写切换 Insert<br>文本编辑器 上滚行 Ctrl+↑<br>文本编辑器 下滚行 Ctrl+↓<br>文件<br>作用域 功能 快捷键<br>全局 保存 Ctrl+X<br>Ctrl+S<br>全局 打印 Ctrl+P<br>全局 关闭 Ctrl+F4<br>全局 全部保存 Ctrl+Shift+S<br>全局 全部关闭 Ctrl+Shift+F4<br>全局 属性 Alt+Enter<br>全局 新建 Ctrl+N<br>项目<br>作用域 功能 快捷键<br>全局 全部构建 Ctrl+B<br>源代码<br>作用域 功能 快捷键<br>Java编辑器 格式化 Ctrl+Shift+F<br>Java编辑器 取消注释 Ctrl+/<br>Java编辑器 注释 Ctrl+/<br>Java编辑器 添加单个import Ctrl+Shift+M<br>Java编辑器 组织多个import Ctrl+Shift+O<br>Java编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。<br>也可以使用Ctrl+1自动修正。<br>调试/运行<br>作用域 功能 快捷键<br>全局 单步返回 F7<br>全局 单步跳过 F6<br>全局 单步跳入 F5<br>全局 单步跳入选择 Ctrl+F5<br>全局 调试上次启动 F11<br>全局 继续 F8<br>全局 使用过滤器单步执行 Shift+F5<br>全局 添加/去除断点 Ctrl+Shift+B<br>全局 显示 Ctrl+D<br>全局 运行上次启动 Ctrl+F11<br>全局 运行至行 Ctrl+R<br>全局 执行 Ctrl+U<br>重构<br>作用域 功能 快捷键<br>全局 撤销重构 Alt+Shift+Z<br>全局 抽取方法 Alt+Shift+M<br>全局 抽取局部变量 Alt+Shift+L<br>全局 内联 Alt+Shift+I<br>全局 移动 Alt+Shift+V<br>全局 重命名 Alt+Shift+R<br>全局 重做 Alt+Shift+Y</p>
<p>（1）Ctrl+M切换窗口的大小<br>（2）Ctrl+Q跳到最后一次的编辑处<br>（3）F2当鼠标放在一个标记处出现Tooltip时候按F2则把鼠标移开时Tooltip还会显示即Show Tooltip</p>
<p>Description。<br>F3跳到声明或定义的地方。<br>F5单步调试进入函数内部。<br>F6单步调试不进入函数内部，如果装了金山词霸2006则要把“取词开关”的快捷键改成其他的。<br>F7由函数内部返回到调用处。<br>F8一直执行到下一个断点。<br>（4）Ctrl+Pg~对于XML文件是切换代码和图示窗口<br>（5）Ctrl+Alt+I看Java文件中变量的相关信息<br>（6）Ctrl+PgUp对于代码窗口是打开“Show List”下拉框，在此下拉框里显示有最近曾打开的文件<br>（7）Ctrl+/ 在代码窗口中是这种//~注释。<br>Ctrl+Shift+/ 在代码窗口中是这种/<em>~</em>/注释，在JSP文件窗口中是〈!–~–〉。<br>（8）Alt+Shift+O(或点击工具栏中的Toggle Mark Occurrences按钮) 当点击某个标记时可使本页面中其他</p>
<p>地方的此标记黄色凸显，并且窗口的右边框会出现白色的方块，点击此方块会跳到此标记处。<br>（9）右击窗口的左边框即加断点的地方选Show Line Numbers可以加行号。<br>（10）Ctrl+I格式化激活的元素Format Active Elements。<br>Ctrl+Shift+F格式化文件Format Document。<br>（11）Ctrl+S保存当前文件。<br>Ctrl+Shift+S保存所有未保存的文件。<br>（12）Ctrl+Shift+M(先把光标放在需导入包的类名上) 作用是加Import语句。<br>Ctrl+Shift+O作用是缺少的Import语句被加入，多余的Import语句被删除。<br>（13）Ctrl+Space提示键入内容即Content Assist，此时要将输入法中Chinese(Simplified)IME-</p>
<p>Ime/Nonlme Toggle的快捷键（用于切换英文和其他文字）改成其他的。<br>Ctrl+Shift+Space提示信息即Context Information。<br>（14）双击窗口的左边框可以加断点。<br>（15）Ctrl+D删除当前行。</p>
<p>Eclipse快捷键大全<br>Ctrl+1 快速修复(最经典的快捷键,就不用多说了)<br>Ctrl+D: 删除当前行<br>Ctrl+Alt+↓ 复制当前行到下一行(复制增加)<br>Ctrl+Alt+↑ 复制当前行到上一行(复制增加)</p>
<p>Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)<br>Alt+↑ 当前行和上面一行交互位置(同上)<br>Alt+← 前一个编辑的页面<br>Alt+→ 下一个编辑的页面(当然是针对上面那条来说了)</p>
<p>Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性</p>
<p>Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后)<br>Shift+Ctrl+Enter 在当前行插入空行(原理同上条)</p>
<p>Ctrl+Q 定位到最后编辑的地方<br>Ctrl+L 定位在某行 (对于程序超过100的人就有福音了)<br>Ctrl+M 最大化当前的Edit或View (再按则反之)<br>Ctrl+/ 注释当前行,再按则取消注释<br>Ctrl+O 快速显示 OutLine<br>Ctrl+T 快速显示当前类的继承结构<br>Ctrl+W 关闭当前Editer<br>Ctrl+K 参照选中的Word快速定位到下一个<br>Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示)</p>
<p>Ctrl+/(小键盘) 折叠当前类中的所有代码</p>
<p>Ctrl+×(小键盘) 展开当前类中的所有代码</p>
<p>Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用</p>
<p>Alt+/来代替)</p>
<p>Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作)</p>
<p>Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有</p>
<p>,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了)</p>
<p>Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查)</p>
<p>Ctrl+Shift+F4 关闭所有打开的Editer</p>
<p>Ctrl+Shift+X 把当前选中的文本全部变味小写</p>
<p>Ctrl+Shift+Y 把当前选中的文本全部变为小写</p>
<p>Ctrl+Shift+F 格式化当前代码</p>
<p>Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之</p>
<p>)</p>
<p>下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift开</p>
<p>头的了)</p>
<p>Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力)</p>
<p>Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用)</p>
<p>Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定)</p>
<p>Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候)</p>
<p>Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能)</p>
<p>Alt+Shift+I 合并变量(可能这样说有点不妥Inline)<br>Alt+Shift+V 移动函数和变量(不怎么常用)<br>Alt+Shift+Z 重构的后悔药(Undo)</p>
]]></content>
      <categories>
        <category>软件和工具</category>
      </categories>
  </entry>
  <entry>
    <title>HDU1229 还是A+B【水题】</title>
    <url>/2018/12/10/HDU1229-%E8%BF%98%E6%98%AFA-B%E3%80%90%E6%B0%B4%E9%A2%98%E3%80%91/</url>
    <content><![CDATA[<p>Problem Description<br>读入两个小于10000的正整数A和B，计算A+B。需要注意的是：如果A和B的末尾K（不超过8）位数字相同，请直接输出-1。</p>
<a id="more"></a>
<p>Input<br>测试输入包含若干测试用例，每个测试用例占一行，格式为”A B K”，相邻两数字有一个空格间隔。当A和B同时为0时输入结束，相应的结果不要输出。</p>
<p>Output<br>对每个测试用例输出1行，即A+B的值或者是-1。</p>
<p>Sample Input<br>1 2 1 11 21 1 108 8 2 36 64 3 0 0 1</p>
<p>Sample Output<br>3 -1 -1 100</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int k,a,b,c,tmp,d;</span><br><span class="line">	while(cin&gt;&gt;a&gt;&gt;b&amp;&amp;a!=0&amp;&amp;b!=0)&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		int flag=1;</span><br><span class="line">		tmp=a+b;</span><br><span class="line">		for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">			c=a%10;</span><br><span class="line">			d=b%10;</span><br><span class="line">			if(c!=d) flag=0; </span><br><span class="line">			a/=10;</span><br><span class="line">			b/=10;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag==1) cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">		else cout&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/* HDU1229 还是A+B */</span><br><span class="line"> </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int power(int a, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 1L;</span><br><span class="line">    while(n) &#123;</span><br><span class="line">        if(n &amp; 1L)</span><br><span class="line">            res *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, k, temp;</span><br><span class="line"> </span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;k) != EOF) &#123;</span><br><span class="line">        if(a == 0 &amp;&amp; b == 0)</span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        temp = power(10, k);</span><br><span class="line">        if(k &gt; 0 &amp;&amp; a % temp == b % temp)</span><br><span class="line">            printf(&quot;-1\n&quot;);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;%d\n&quot;, a + b);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hdu</category>
      </categories>
  </entry>
  <entry>
    <title>HDU2017 字符串统计</title>
    <url>/2018/12/09/HDU2017-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>Problem Description<br>对于给定的一个字符串，统计其中数字字符出现的次数。</p>
<p>Input<br>输入数据有多行，第一行是一个整数n，表示测试实例的个数，后面跟着n行，每行包括一个由字母和数字组成的字符串。<br> <a id="more"></a></p>
<p>Output<br>对于每个测试实例，输出该串中数值的个数，每个输出占一行。</p>
<p>Sample Input</p>
<p>2</p>
<p>asdfasdf123123asdfasdf</p>
<p>asdf111111111asdfasdfasdf</p>
<p>Sample Output</p>
<p>6</p>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char s[100];</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	while(n--)&#123;</span><br><span class="line">		int cnt=0;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		for(int i=0;s[i]!=0;i++)</span><br><span class="line">		 if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;)</span><br><span class="line">		 cnt++;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	&#125;&#125;</span><br></pre></td></tr></table></figure>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	#include&lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char s[100];</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	while(n--)&#123;</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	char *t=s;</span><br><span class="line">		int cnt=0;</span><br><span class="line">	while(*t)&#123;</span><br><span class="line">		 if(*t&gt;=&apos;0&apos;&amp;&amp;*t&lt;=&apos;9&apos;)</span><br><span class="line">		 cnt++;</span><br><span class="line">		t++;</span><br><span class="line">	&#125;</span><br><span class="line">			cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</code></pre>]]></content>
      <categories>
        <category>hdu</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA 遍历List&lt;Object[]&gt;</title>
    <url>/2018/07/04/JAVA-List-Object-%E5%8F%96%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>三种遍历方法：<br>一：采用size()<br>for(int i = 0 ; i &lt;objListstaff.size(); i++ ){<br>Object[] tempObj = objListstaff.get(i);<br>system.out.print(tempObj[0] + “————“ +tempObj[1] );<br>}</p>
<a id="more"></a>
<p>二：采用迭代器</p>
<p>for (Iterator iterator = objListstaff.iterator(); iterator.hasNext();) {<br>Object[] tempObj = ( Object[]) iterator.next();<br>system.out.print(tempObj[0] + “————“ tempObj[1] );</p>
<p>}</p>
<p>三：采用foreach循环<br>for(Object[] tempObj : objListstaff){<br>system.out.printtempObj[0] + “————“ tempObj[1] );</p>
<p>}</p>
]]></content>
  </entry>
  <entry>
    <title>ImportError: No module named caffe </title>
    <url>/2018/05/23/ImportError-No-module-named-caffe/</url>
    <content><![CDATA[<p>在成功编译caffe的源码之后，可以在python环境中使用caffe。在Ubuntu环境下，打开python解释程序，输入import caffe时，可能会出现     ImportError: No module named caffe</p>
<blockquote>
<blockquote>
<blockquote>
<p>import caffe<br>   Traceback (most recent call last):<br>    File “<stdin>“, line 1, in <module><br>   ImportError: No module named caffe<br><a id="more"></a><br>这种情况一般是没有把caffe中的和python相关的内容的路径添加到python的编译路径中。可以使用以下方式解决问题：</module></stdin></p>
</blockquote>
</blockquote>
</blockquote>
<p>在Ubuntu中，按住ctrl+alt+t打开终端，输入“python”打开python解释器，输入：</p>
<p>import sys</p>
<p>sys.path.append(“/（你的caffe-master路径）/caffe-master/python”)</p>
<p>sys.path.append(“/（你的caffe-master路径）/caffe-master/python/caffe”)</p>
<p>提示：输入每一行之后都要按回车，让命令执行。三条命令执行之后一般就没问题了。因为python的编译路径“path”是模型“sys”的一个属性，所以要先使用命令“import sys”。</p>
<p>好吧，我承认上述方法治标不治本。在python解释器输入以上命令之后，使用import caffe木有问题，但是重启python解释器之后再import caffe还是会报同样的错误。只有在caffe-master/python这个文件夹之下打开python解释器使用import caffe才不会报错。<br>随后找到了一个不是解决办法的办法，使用python调用caffe时，在相应的.py文件的最前面加入以下四句：</p>
<p>#设置caffe源码所在的路径<br>caffe_root = ‘../../../caffe-master/(这是caffe-master文件夹路径，绝对路径和相对路径都可以。绝对路径写法：/../../caffe-master/)’  </p>
<p>import sys  </p>
<p>sys.path.insert(0, caffe_root + ‘python’)  </p>
<p>import caffe  </p>
<p>这样就没有问题了。当然，所有调用caffe框架的.py文件中都要包含这几句话。也可以把以上几句封装成一个python类，专门用来实现“import caffe”的操作。</p>
]]></content>
      <categories>
        <category>环境安装配置</category>
      </categories>
  </entry>
  <entry>
    <title>JQuery学习笔记</title>
    <url>/2018/05/30/JQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="JQuery与DOM之间的关系"><a href="#JQuery与DOM之间的关系" class="headerlink" title="JQuery与DOM之间的关系"></a>JQuery与DOM之间的关系</h2><p>JQuery对象就是用JQuery包装DOM之后产生的对象。JQuery对象是JQuery独有的，可以使用JQuery的各种方法。<br><a id="more"></a><br>$(“#test”).html();<br>意思是指：获取ID为test的元素内的html代码。其中html()是jQuery里的方法 。</p>
<p>这段代码的作用等同于用DOM实现代码：</p>
<p>document.getElementById(“id”).innerHTML;<br>虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法。</p>
<p><strong>另外，JQuery对象与DOM对象之间可以互相转换。</strong></p>
<p>参考链接</p>
<p><a href="https://www.cnblogs.com/Lands-ljk/p/6042630.html" target="_blank" rel="noopener">https://www.cnblogs.com/Lands-ljk/p/6042630.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>L1-Majority Element</title>
    <url>/2018/05/11/L1-Majority-Element/</url>
    <content><![CDATA[<p>Majority Element</p>
<p>描述<br>给定一个整型数组，找出主元素，它在数组中的出现次数严格大于数组元素个数的二分之一。</p>
<p>样例<br>给出数组[1,1,1,1,2,2,2]，返回 1</p>
<p>挑战<br>要求时间复杂度为O(n)，空间复杂度为O(1)<br><a id="more"></a></p>
<h2 id="对数组排序"><a href="#对数组排序" class="headerlink" title="对数组排序"></a>对数组排序</h2><p>一般的方法就是对数组排序，然后相同的元素就会聚集在一起，这样的算法复杂度介于O(nlgn) 和O(n^2)之间。<br>题目给出的数组没有说是排好序的，因此我们需要给它排序。。排序的时间复杂度是O(nlogn)，再加上遍历的时间复杂度O(n)，因此总的复杂度是O(nlogn)。</p>
<p>总结一句话：先排序，然后取nums[n/2]。</p>
<h2 id="对消法"><a href="#对消法" class="headerlink" title="对消法"></a>对消法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param nums: a list of integers</span></span><br><span class="line"><span class="comment">     * @return: find a  majority number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityNumber</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    	<span class="keyword">int</span> temp=nums.get(<span class="number">0</span>),count=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    	    <span class="keyword">if</span>(count==<span class="number">0</span>) temp=nums.get(i);</span><br><span class="line">    		<span class="keyword">if</span>(temp==nums.get(i)) count++;</span><br><span class="line">    		<span class="keyword">else</span> count--;</span><br><span class="line">    		</span><br><span class="line">    		&#125;</span><br><span class="line">    	<span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1。如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，我们需要保存下一个数字，并把次数设为1。由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时对应的数字。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>java中Arrays.sort使用了两种排序方法，快速排序和优化的合并排序。</p>
<p>快速排序主要是对哪些基本类型数据（int,short,long等）排序， 而合并排序用于对对象类型进行排序。<br>使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一直；另外一个原因是由于合并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。<br>补充一点合并排序的时间复杂度是n<em>logn, 快速排序的平均时间复杂度也是n</em>logn，但是合并排序的需要额外的n个引用的空间</p>
<p>可参考<br><a href="https://www.jianshu.com/p/73625dd9ac65" target="_blank" rel="noopener">https://www.jianshu.com/p/73625dd9ac65</a><br><a href="http://www.cnblogs.com/theskulls/p/4915270.html" target="_blank" rel="noopener">http://www.cnblogs.com/theskulls/p/4915270.html</a><br><a href="https://blog.csdn.net/lalor/article/details/7338497" target="_blank" rel="noopener">https://blog.csdn.net/lalor/article/details/7338497</a></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title> Java DecimalFormat 用法</title>
    <url>/2018/06/20/Java-DecimalFormat-%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>Java 提供 DecimalFormat类，将数字格式化为你需要的样子。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.text.DecimalFormat;  </span><br><span class="line">　　  </span><br><span class="line">publicclassTestNumberFormat&#123;  </span><br><span class="line">　　  </span><br><span class="line">　　publicstaticvoidmain(String[]args)&#123;  </span><br><span class="line">　　　　doublepi=3.1415927;　//圆周率  </span><br><span class="line">　　　　//取一位整数  </span><br><span class="line">　　　　System.out.println(newDecimalFormat(&quot;0&quot;).format(pi));　　　//3  </span><br><span class="line">　　　　//取一位整数和两位小数  </span><br><span class="line">　　　　System.out.println(newDecimalFormat(&quot;0.00&quot;).format(pi));　//3.14  </span><br><span class="line">　　　　//取两位整数和三位小数，整数不足部分以0填补。  </span><br><span class="line">　　　　System.out.println(new DecimalFormat(&quot;00.000&quot;).format(pi));// 03.142  </span><br><span class="line">　　　　//取所有整数部分  </span><br><span class="line">　　　　System.out.println(newDecimalFormat(&quot;#&quot;).format(pi));　　　//3  </span><br><span class="line">　　　　//以百分比方式计数，并取两位小数  </span><br><span class="line">　　　　System.out.println(new DecimalFormat(&quot;#.##%&quot;).format(pi));　//314.16%  </span><br><span class="line">　　  </span><br><span class="line">　　　　longc=299792458;　　//光速  </span><br><span class="line">　　　　//显示为科学计数法，并取五位小数  </span><br><span class="line">　　　　System.out.println(newDecimalFormat(&quot;#.#####E0&quot;).format(c));　//2.99792E8  </span><br><span class="line">　　　　//显示为两位整数的科学计数法，并取四位小数  </span><br><span class="line">　　　　System.out.println(newDecimalFormat(&quot;00.####E0&quot;).format(c));　//29.9792E7  </span><br><span class="line">　　　　//每三位以逗号进行分隔。  </span><br><span class="line">　　　　System.out.println(newDecimalFormat(&quot;,###&quot;).format(c));　　　//299,792,458  </span><br><span class="line">　　　　//将格式嵌入文本  </span><br><span class="line">　　　　System.out.println(newDecimalFormat(&quot;光速大小为每秒,###米。&quot;).format(c));  </span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>L1-o(1)检测2的幂次</title>
    <url>/2018/05/27/L1-o-1-%E6%A3%80%E6%B5%8B2%E7%9A%84%E5%B9%82%E6%AC%A1/</url>
    <content><![CDATA[<p>用 O(1) 时间检测整数 n 是否是 2 的幂次。</p>
<p>样例<br>n=4，返回 true;</p>
<p>n=5，返回 false.</p>
<p>挑战<br>O(1) time<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param n: An integer</span><br><span class="line">     * @return: True or false</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">    boolean checkPowerOf2(int n) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        if (n &lt; 1)</span><br><span class="line">            return false;</span><br><span class="line">        else </span><br><span class="line">            return (n &amp; (n - 1)) == 0;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用位操作。因为2的幂次数其二进制表示中1的个数只有一个而其他的数则没有这情况。而2的幂次减1除了那位为0其他位为1。<br>例如：<br>2 = (10)2 —-&gt; 1 = (01)2<br>4 = (100)2 —-&gt; 3 = (011)2<br>8 = (1000)2 —-&gt; 7 = (0111)2 </p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-两数之和</title>
    <url>/2018/05/14/L1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给一个整数数组，找到两个数使得他们的和等于一个给定的数 target。</p>
<p>你需要实现的函数twoSum需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 0 到 n-1。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers: An array of Integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target: target = numbers[index1] + numbers[index2]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: [index1 + 1, index2 + 1] (index1 &lt; index2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    	<span class="keyword">int</span> a[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;numbers.length;j++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">if</span>(numbers[i]+numbers[j]==target)</span><br><span class="line">    			&#123;</span><br><span class="line">    				a[<span class="number">0</span>]=i;</span><br><span class="line">    				a[<span class="number">1</span>]=j;</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    			</span><br><span class="line">    		&#125;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-中位数</title>
    <url>/2018/05/17/L1-%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p>问题描述：<br>给定一个未排序的整数数组，找到其中位数。<br>中位数是排序后数组的中间值，如果数组的个数是偶数个，则返回排序后数组的第N/2个数</p>
<p>思路一：<br>可以使用快速排序将数组排好序，然后返回中位数，这样做的时间复杂度是O(nlogn).</p>
<p>思路二：<br>使用“折半的快速排序”。就是每一次只对一边的数组进行排序。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: A list of integers.</span><br><span class="line">     * @return: An integer denotes the middle number of the array.</span><br><span class="line">     */</span><br><span class="line">    int Qsort(vector&lt;int&gt;&amp;nums,int low,int high)//这里需要用引用</span><br><span class="line">    &#123;</span><br><span class="line">        int i=low;</span><br><span class="line">        int j=high;</span><br><span class="line">        //int key=nums[0];</span><br><span class="line">    //刚开始快速排序我一直是这么写的，然后一直AC不了。</span><br><span class="line">//但是只测试快排又是可以运行出结果的，所以我一直以为是median函数里出错了。</span><br><span class="line">//一直调试了很久很久，几个小时。所以这件事情也让我明白了基础扎实是很重要的。</span><br><span class="line">        int key=nums[low];</span><br><span class="line">        while (i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            while (i&lt;j&amp;&amp;nums[j]&gt;=key)</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[i],nums[j]);</span><br><span class="line">            while (i&lt;j&amp;&amp;nums[i]&lt;=key)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        //nums[i]=key;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int median(vector&lt;int&gt; &amp;nums) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        int n=nums.size();</span><br><span class="line">        int key=0,k=0;</span><br><span class="line">        int left=0,right=n-1;</span><br><span class="line">        if(n%2==0) key=n/2-1;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            key=n/2;</span><br><span class="line">        &#125;</span><br><span class="line">        k=Qsort(nums,0,n-1);</span><br><span class="line">        while (k!=key)</span><br><span class="line">        &#123;</span><br><span class="line">            if(k&lt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                left=k+1;</span><br><span class="line">                k=Qsort(nums,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                right=k-1;</span><br><span class="line">                k=Qsort(nums,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return nums[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.jianshu.com/p/4ba7784723d4" target="_blank" rel="noopener">参考链接1</a></p>
<p><a href="https://www.jiuzhang.com/solutions/median/#tag-other" target="_blank" rel="noopener">参考链接2</a></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-二分查找,合并排序数组</title>
    <url>/2018/05/02/L1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE_%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>给定一个排序的整数数组（升序）和一个要查找的整数target，用O(logn)的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回-1。<br>在数组 [1, 2, 3, 3, 4, 5, 10] 中二分查找3，返回2。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: The integer array.</span><br><span class="line">     * @param target: Target to find.</span><br><span class="line">     * @return: The first position of target. Position starts from 0.</span><br><span class="line">     */</span><br><span class="line">    int binarySearch(vector&lt;int&gt; &amp;nums, int target) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        int start=0,end=len-1;</span><br><span class="line">        while(start &lt;= end)&#123;</span><br><span class="line">            int mid = start + (end - start) / 2;</span><br><span class="line">            if(nums[mid] == target)&#123;</span><br><span class="line">                for(int i = mid - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">                    if(nums[i] == target)&#123;</span><br><span class="line">                        mid = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;else if(nums[mid] &gt; target)&#123;</span><br><span class="line">                end =  mid - 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                start = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="合并排序数组"><a href="#合并排序数组" class="headerlink" title="合并排序数组"></a>合并排序数组</h2><p>给出A=[1,2,3,4]，B=[2,4,5,6]，返回 [1,2,2,3,4,4,5,6]</p>
<p>考虑 A,B has elements left<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param A: sorted integer array A</span><br><span class="line">     * @param B: sorted integer array B</span><br><span class="line">     * @return: A new sorted integer array</span><br><span class="line">     */</span><br><span class="line">vector&lt;int&gt; mergeSortedArray(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">            if (A.empty()) return B;</span><br><span class="line">        if (B.empty()) return A;</span><br><span class="line">    // write your code here</span><br><span class="line">    vector&lt;int&gt; c;</span><br><span class="line">    int aLen=A.size(),bLen=B.size();</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    while(i&lt;aLen&amp;&amp;j&lt;bLen)</span><br><span class="line">    &#123;</span><br><span class="line">        if(A[i]&lt;=B[j])</span><br><span class="line">        &#123;</span><br><span class="line">            c.push_back(A[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            c.push_back(B[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     // A has elements left</span><br><span class="line">        while (i &lt; aLen) &#123;</span><br><span class="line">            c.push_back(A[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">     // B has elements left</span><br><span class="line">    while(j&lt;bLen)</span><br><span class="line">    &#123;</span><br><span class="line">        c.push_back(B[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Fizz-Buzz-问题"><a href="#Fizz-Buzz-问题" class="headerlink" title="Fizz Buzz 问题"></a>Fizz Buzz 问题</h2><p>给你一个整数n. 从 1 到 n 按照下面的规则打印每个数：</p>
<p>如果这个数被3整除，打印fizz.<br>如果这个数被5整除，打印buzz.<br>如果这个数能同时被3和5整除，打印fizz buzz.</p>
<p>很简单 注意以下判断顺序，先判断是否能被15整除，再判断能被55整除，最后判断能否被3整除  若非限制，可以用vector,ArrayList,或者stringbuilder的追加方法返回字符串<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param n: An integer</span><br><span class="line">     * @return: A list of strings.</span><br><span class="line">     */</span><br><span class="line">    vector&lt;string&gt; fizzBuzz(int n) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        vector&lt;string&gt; c;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    if(i%3==0&amp;&amp;i%5==0) c.push_back(&quot;fizz buzz&quot;);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(i%3==0) c.push_back(&quot;fizz&quot;);</span><br><span class="line">        else if(i%5==0) c.push_back(&quot;buzz&quot;);</span><br><span class="line">        else c.push_back(to_string(i));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-二叉树层序遍历</title>
    <url>/2018/05/16/L1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>给出一棵二叉树，返回其节点值的层次遍历（逐层从左往右访问）</p>
<p>样例<br>给一棵二叉树 {3,9,20,#,#,15,7} ：</p>
<p>  3<br> / \<br>9  20<br>  /  \<br> 15   7<br>返回他的分层遍历结果：</p>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<a id="more"></a>
<p>每一次打印一个节点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的尾部。接下来到队列的头部取出最早进入队列的结点。</p>
<p>重复前面的打印操作，直到队列中所有的结点都被打印出来为止。</p>
<p>上面是层次打印所有节点，而不是对每一层的节点放在一个list中输出，所以队列保存当前层的元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of TreeNode:</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     public int val;</span><br><span class="line"> *     public TreeNode left, right;</span><br><span class="line"> *     public TreeNode(int val) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = this.right = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param root: The root of binary tree.</span><br><span class="line">     * @return: Level order a list of lists of integer</span><br><span class="line">     */</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; tree = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        if(root == null)</span><br><span class="line">            return tree;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode head = queue.poll();</span><br><span class="line">                list.add(head.val);</span><br><span class="line">                if(head.left!=null)&#123;</span><br><span class="line">                    queue.offer(head.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(head.right!=null)&#123;</span><br><span class="line">                    queue.offer(head.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tree.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Java Code</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/wutingyehe/article/details/51204141" target="_blank" rel="noopener">参考链接1</a></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-二叉树的最大深度</title>
    <url>/2018/05/23/L1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的距离。</p>
<p>样例<br>给出一棵如下的二叉树:</p>
<p>  1<br> / \<br>2   3<br>   / \<br>  4   5<br>这个二叉树的最大深度为3.</p>
<p>二叉树的题目，大部分都能用分治的思路来解题。<br><a id="more"></a></p>
<p>求二叉树的最大深度，就是求左、右子数的最大深度+1即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of TreeNode:</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     public int val;</span><br><span class="line"> *     public TreeNode left, right;</span><br><span class="line"> *     public TreeNode(int val) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = this.right = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param root: The root of binary tree.</span><br><span class="line">     * @return: An integer</span><br><span class="line">     */</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        if(root==null) return 0;</span><br><span class="line">        int left=maxDepth(root.left);  </span><br><span class="line">        int right=maxDepth(root.right);  </span><br><span class="line">        return Math.max(left,right)+1; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-二叉树的最小深度</title>
    <url>/2018/05/25/L1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>二叉树的最小深度为根节点到最近叶子节点的距离。<br>样例<br>给出一棵如下的二叉树:</p>
<pre><code>    1
 /     \ 
2       3
      /    \
     4      5  
</code></pre><p>这个二叉树的最小深度为 2<br><a id="more"></a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>1.空树 最小深度为0</p>
<p>2.左子树为空，右子树不为空 –&gt; 右子树的的叶子节点 （可以把左子树的节点Max_value）<br>或者 右子树为空，左子树不为空 —-&gt;左子树的的叶子节点</p>
<p>3.左右子树都不为空 —&gt;左右子树最近的叶子节点 （想到用min）</p>
<p>4.左右子树都空 最小深度为1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of TreeNode:</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     public int val;</span><br><span class="line"> *     public TreeNode left, right;</span><br><span class="line"> *     public TreeNode(int val) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = this.right = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param root: The root of binary tree</span><br><span class="line">     * @return: An integer</span><br><span class="line">     */</span><br><span class="line">    public int minDepth(TreeNode root) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        int a,b;</span><br><span class="line">        if(root==null) return 0;</span><br><span class="line">        if(root.left==null&amp;&amp;root.right==null) return 1;</span><br><span class="line">        if(root.left!=null)</span><br><span class="line">        a=minDepth(root.left);</span><br><span class="line">       else a=Integer.MAX_VALUE;</span><br><span class="line">       if(root.right!=null)</span><br><span class="line">       b=minDepth(root.right);</span><br><span class="line">  else b=Integer.MAX_VALUE;</span><br><span class="line">return Math.min(a,b)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://tinacristal.github.io/2018/05/23/L1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/" target="_blank" rel="noopener">注意:与L1-二叉树的最大深度的区别</a></p>
]]></content>
  </entry>
  <entry>
    <title>L1-二叉树遍历（先，中，后）</title>
    <url>/2018/05/14/L1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%EF%BC%88%E5%85%88%EF%BC%8C%E4%B8%AD%EF%BC%8C%E5%90%8E%EF%BC%89/</url>
    <content><![CDATA[<h2 id="先序遍历-递归"><a href="#先序遍历-递归" class="headerlink" title="先序遍历 递归"></a>先序遍历 递归</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">     public void preOrder(TreeNode root,List&lt;Integer&gt; res)&#123;</span><br><span class="line">         if(root==null) return;</span><br><span class="line">         res.add(root.val);</span><br><span class="line">         preOrder(root.left,res);</span><br><span class="line">         preOrder(root.right,res);  </span><br><span class="line">     &#125;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">       preOrder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="先序遍历-非递归"><a href="#先序遍历-非递归" class="headerlink" title="先序遍历 非递归"></a>先序遍历 非递归</h2><p><img src="https://upload-images.jianshu.io/upload_images/2405011-c0aa74a23a4d357d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">	public int val;</span><br><span class="line">	public TreeNode left, right;</span><br><span class="line"></span><br><span class="line">	public TreeNode(int val) &#123;</span><br><span class="line">		this.val = val;</span><br><span class="line">		this.left = this.right = null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">	 public static void preorderTraversal(TreeNode root) &#123;</span><br><span class="line">	       Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();</span><br><span class="line">	     while(!stack.isEmpty()||root!=null)</span><br><span class="line">	       &#123;</span><br><span class="line">	    	   while(root!=null)</span><br><span class="line">	    	   &#123;</span><br><span class="line">	    		   System.out.println(root.val);</span><br><span class="line">	    		   stack.push(root);</span><br><span class="line">	    		   root=root.left;  </span><br><span class="line">	    	   &#125;</span><br><span class="line">	    	   if(!stack.isEmpty())</span><br><span class="line">	    	   &#123;</span><br><span class="line">	    		   root=stack.pop();</span><br><span class="line">	    		   root=root.right;</span><br><span class="line">	    	   &#125;</span><br><span class="line">	    	   </span><br><span class="line">	       &#125;   </span><br><span class="line">	    &#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TreeNode node=new TreeNode(1);</span><br><span class="line">		node.left=null;</span><br><span class="line">		TreeNode node2=new TreeNode(2);</span><br><span class="line">		node.right=node2;</span><br><span class="line">		TreeNode node3=new TreeNode(3);</span><br><span class="line">		node2.left=node3;</span><br><span class="line">		node2.right=null;</span><br><span class="line">		node3.left=null;</span><br><span class="line">		node3.right=null;</span><br><span class="line">		preorderTraversal(node);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>s.empty()和s==null概念要区分，前者是判断栈空，后者null是表示一个空对象，有没有初始化。</strong></p>
<h2 id="中序遍历-递归"><a href="#中序遍历-递归" class="headerlink" title="中序遍历 递归"></a>中序遍历 递归</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">	public int val;</span><br><span class="line">	public TreeNode left, right;</span><br><span class="line"></span><br><span class="line">	public TreeNode(int val) &#123;</span><br><span class="line">		this.val = val;</span><br><span class="line">		this.left = this.right = null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param root: A Tree</span><br><span class="line">     * @return: Inorder in ArrayList which contains node values.</span><br><span class="line">     */</span><br><span class="line">      public void inOrder(TreeNode root,List&lt;Integer&gt; res)&#123;</span><br><span class="line">         if(root==null) return;</span><br><span class="line">        </span><br><span class="line">         inOrder(root.left,res);</span><br><span class="line">          res.add(root.val);</span><br><span class="line">        inOrder(root.right,res);  </span><br><span class="line">     &#125;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">       inOrder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历-非递归"><a href="#中序遍历-非递归" class="headerlink" title="中序遍历 非递归"></a>中序遍历 非递归</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">	public int val;</span><br><span class="line">	public TreeNode left, right;</span><br><span class="line"></span><br><span class="line">	public TreeNode(int val) &#123;</span><br><span class="line">		this.val = val;</span><br><span class="line">		this.left = this.right = null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    	public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">		TreeNode node = root;</span><br><span class="line">		List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();</span><br><span class="line">		while (!s.empty() || node != null) &#123;</span><br><span class="line">			while (node != null) &#123;</span><br><span class="line">				s.push(node);</span><br><span class="line">				//System.out.println(node.val);</span><br><span class="line">				</span><br><span class="line">				node = node.left;</span><br><span class="line">			&#125;</span><br><span class="line">			if (!s.empty()) &#123;</span><br><span class="line">				node = s.pop();</span><br><span class="line">				l.add(node.val);</span><br><span class="line">				node = node.right;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		return l;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历-递归"><a href="#后序遍历-递归" class="headerlink" title="后序遍历 递归"></a>后序遍历 递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of TreeNode:</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     public int val;</span></span><br><span class="line"><span class="comment"> *     public TreeNode left, right;</span></span><br><span class="line"><span class="comment"> *     public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root: A Tree</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Postorder in ArrayList which contains node values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root,List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">         postOrder(root.left,res);</span><br><span class="line">         postOrder(root.right,res);</span><br><span class="line">         res.add(root.val);</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       postOrder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>e.g. test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package a;</span><br><span class="line"></span><br><span class="line">import java.awt.print.Printable;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">	public int val;</span><br><span class="line">	public TreeNode left, right;</span><br><span class="line"></span><br><span class="line">	public TreeNode(int val) &#123;</span><br><span class="line">		this.val = val;</span><br><span class="line">		this.left = this.right = null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">	 static List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">	 public static void postorderTraversal(TreeNode root) &#123;</span><br><span class="line">	        // write your code here</span><br><span class="line">	        if(root==null) return;</span><br><span class="line">	        postorderTraversal(root.left);</span><br><span class="line">	        postorderTraversal(root.right);</span><br><span class="line">	         res.add(root.val);      </span><br><span class="line">	    &#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TreeNode node=new TreeNode(1);</span><br><span class="line">		node.left=null;</span><br><span class="line">		TreeNode node2=new TreeNode(2);</span><br><span class="line">		node.right=node2;</span><br><span class="line">		TreeNode node3=new TreeNode(3);</span><br><span class="line">		node2.left=node3;</span><br><span class="line">		node2.right=null;</span><br><span class="line">		node3.left=null;</span><br><span class="line">		node3.right=null;</span><br><span class="line">		postorderTraversal(node);</span><br><span class="line">		if(res==null||res.size()==0) System.out.println(&quot;11111&quot;); </span><br><span class="line">		/*for(Integer it:res)</span><br><span class="line">			System.out.println(it);</span><br><span class="line">	*/</span><br><span class="line">		 for(int    i=0;    i&lt;res.size();    i++)    &#123;   </span><br><span class="line">		      Integer value   =    res.get(i);   </span><br><span class="line">		      System.out.println(value); </span><br><span class="line">		   &#125;   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历非递归"><a href="#后序遍历非递归" class="headerlink" title="后序遍历非递归"></a>后序遍历非递归</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package a;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class postOr &#123;</span><br><span class="line">	public static List&lt;Integer&gt; postOrderTraversal(TreeNode root) &#123;</span><br><span class="line">		TreeNode curnode = root;</span><br><span class="line">		TreeNode lastnode = null;</span><br><span class="line">		List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();</span><br><span class="line">		//把currentNode移到左子树的最下边  </span><br><span class="line">		while (curnode != null) &#123;</span><br><span class="line">				s.push(curnode);</span><br><span class="line">				curnode = curnode.left;</span><br><span class="line">			&#125;</span><br><span class="line">		//进入右子树</span><br><span class="line">			while(!s.empty()) &#123;</span><br><span class="line">				curnode = s.pop();</span><br><span class="line">				// //一个根节点被访问的前提是：无右子树或右子树已被访问过  </span><br><span class="line">				if (curnode.right != null &amp;&amp; curnode.right != lastnode) &#123;</span><br><span class="line"></span><br><span class="line">					s.push(curnode);</span><br><span class="line">					curnode = curnode.right;</span><br><span class="line">					while (curnode != null) &#123;</span><br><span class="line">						s.push(curnode);</span><br><span class="line">						curnode = curnode.left;</span><br><span class="line">					&#125;</span><br><span class="line">					//走到右子树的最左边</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					//System.out.println(curnode.val);</span><br><span class="line">					l.add(curnode.val);</span><br><span class="line">					lastnode = curnode;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;		</span><br><span class="line">		return l;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TreeNode node = new TreeNode(1);</span><br><span class="line">		node.left = null;</span><br><span class="line">		TreeNode node2 = new TreeNode(2);</span><br><span class="line">		node.right = node2;</span><br><span class="line">		TreeNode node3 = new TreeNode(3);</span><br><span class="line">		node2.left = node3;</span><br><span class="line">		node2.right = null;</span><br><span class="line">		node3.left = null;</span><br><span class="line">		node3.right = null;</span><br><span class="line">		List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		l = postOrderTraversal(node);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充-Java中List集合的遍历"><a href="#补充-Java中List集合的遍历" class="headerlink" title="补充:Java中List集合的遍历"></a>补充:Java中List集合的遍历</h2><p> 一、对List的遍历有三种方式   </p>
<p>   List<string>    list    =    new    ArrayList<string>();<br>   list.add(“testone”);<br>   list.add(“testtwo”);<br>   …   </string></string></p>
<p>   第一种:<br>   for(Iterator<string>    it    =    list.iterator();    it.hasNext();    )    {<br>       ….<br>   }<br>   这种方式在循环执行过程中会进行数据锁定,    性能稍差,    同时,如果你想在循环过程中去掉某个元素,只能调用it.remove方法,    不能使用list.remove方法,    否则一定出现并发访问的错误.   </string></p>
<p>   第二种:<br>   for(String   data    :    list)    {<br>       …..<br>   }<br>   内部调用第一种,    换汤不换药,  因此比Iterator 慢,这种循环方式还有其他限制, 不建议使用它。</p>
<p>   第三种:<br>   for(int    i=0;    i&lt;list.size();    i++)    {<br>       A    a    =    list.get(i);<br>       …<br>   }<br>   内部不锁定,    效率最高,    但是当写多线程时要考虑并发操作的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MapTest &#123;</span><br><span class="line">    private static List&lt;String&gt; list= new ArrayList&lt;String&gt;();</span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        MapTest  mapTest = new  MapTest();</span><br><span class="line">        mapTest.initList(list);</span><br><span class="line">        mapTest.foreach(list);</span><br><span class="line">        mapTest.forlist(list);</span><br><span class="line">        mapTest.iteratorList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //list 集合中添加10万条数据</span><br><span class="line">    public List initList(List&lt;String&gt; list)&#123;</span><br><span class="line">        int i=0;</span><br><span class="line">        int num=6000000;</span><br><span class="line">        for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">            list.add(&quot;list&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    //list 集合遍历 foreach</span><br><span class="line">    </span><br><span class="line">    public void  foreach(List&lt;String&gt; list)&#123;</span><br><span class="line">        long start= System.currentTimeMillis();</span><br><span class="line">        for(String data:list)&#123;</span><br><span class="line">            String value=data;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        long end=System.currentTimeMillis();</span><br><span class="line">        long count=end-start;</span><br><span class="line">        System.out.println(&quot;foreach 循环时间&quot;+count);</span><br><span class="line">    &#125;</span><br><span class="line">    // list集合遍历  for</span><br><span class="line">    public void forlist(List&lt;String&gt; list)&#123;</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        int i=0;</span><br><span class="line">        for( i=0;i&lt;list.size();i++)&#123;</span><br><span class="line">            String value=list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        long end=System.currentTimeMillis();</span><br><span class="line">        long count=end-start;</span><br><span class="line">        System.out.println(&quot;for list.size() 遍历时间&quot;+count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Iterator 遍历循环</span><br><span class="line">    public void iteratorList(List&lt;String&gt; list)&#123;</span><br><span class="line">        long start= System.currentTimeMillis();</span><br><span class="line">        for(Iterator&lt;String&gt;  it=list.iterator();it.hasNext();)&#123;</span><br><span class="line">            String value=it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        long end=System.currentTimeMillis();</span><br><span class="line">        long count=end-start;</span><br><span class="line">        System.out.println(&quot;iterator 遍历时间&quot;+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：<br>（1）、第一次<br>foreach  遍历时间：55<br>for list.size()遍历时间：47<br>iterator 遍历时间：51<br>（2）、第二次<br>foreach  遍历时间：54<br>for list.size()遍历时间：44<br>iterator 遍历时间：50<br>（3）、第三次<br>foreach  遍历时间：48<br>for list.size()遍历时间：43<br>iterator 遍历时间：44</p>
<h2 id="补充-static"><a href="#补充-static" class="headerlink" title="补充:static"></a>补充:static</h2><p><a href="https://blog.csdn.net/weixin_36380516/article/details/58176759" target="_blank" rel="noopener">参考链接1</a></p>
<p><a href="https://blog.csdn.net/zhuqiuhui/article/details/51319165" target="_blank" rel="noopener">参考链接2</a></p>
<p><a href="http://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html" target="_blank" rel="noopener">参考链接3</a></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-删除元素</title>
    <url>/2018/06/19/L1-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>删除元素</p>
<p>给定一个数组和一个值，在原地删除与值相同的数字，返回新数组的长度。</p>
<p>元素的顺序可以改变，并且对新的数组不会有影响。</p>
<p>样例<br>给出一个数组 [0,4,4,0,0,2,4,4]，和值 4<br><a id="more"></a><br>返回 4 并且4个元素的新数组为[0,0,0,2]<br><!--more--><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param A: A list of integers</span><br><span class="line">     * @param elem: An integer</span><br><span class="line">     * @return: The new length after remove</span><br><span class="line">     */</span><br><span class="line">    public int removeElement(int[] A, int elem) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        int i=0;</span><br><span class="line">        int pointer=A.length-1;</span><br><span class="line">        while(i&lt;=pointer)&#123;</span><br><span class="line">            if(A[i]==elem)&#123;</span><br><span class="line">                A[i]=A[pointer];</span><br><span class="line">                pointer--;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pointer+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fsgrugnlz7j337k2eokjo.jpg" alt="image"></p>
<p>python实现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    @param A: A list of integers</span><br><span class="line">    @param elem: An integer</span><br><span class="line">    @return: The new length after remove</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def removeElement(self, A, elem):</span><br><span class="line">        # write your code here</span><br><span class="line">        j = len(A)-1</span><br><span class="line">        for i in range(len(A) - 1, -1, -1):</span><br><span class="line">            if A[i] == elem:</span><br><span class="line">                A[i], A[j] = A[j], A[i]</span><br><span class="line">                j -= 1</span><br><span class="line">        return j+1</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-删除排序数组中的重复数字</title>
    <url>/2018/05/30/L1-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>给定一个排序数组，在原数组中删除重复出现的数字，使得每个元素只出现一次，并且返回新的数组的长度。</p>
<p>不要使用额外的数组空间，必须在原地没有额外空间的条件下完成。</p>
<p>您在真实的面试中是否遇到过这个题？<br>样例<br>给出数组A =[1,1,2]，你的函数应该返回长度2，此时A=[1,2]。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param nums: An ineger array</span><br><span class="line">     * @return: An integer</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    	public static int removeDuplicates(int[] nums)&#123;</span><br><span class="line">			if(nums.length==0) return 0;</span><br><span class="line">			int i=0;</span><br><span class="line">			int index;</span><br><span class="line">			int count=1;</span><br><span class="line">			for(index=0;index&lt;nums.length;index++)</span><br><span class="line">			&#123;</span><br><span class="line">			if(nums[i]!=nums[index])</span><br><span class="line">				&#123;</span><br><span class="line">				   </span><br><span class="line">				nums[++i]=nums[index];</span><br><span class="line">             //注意++i,i++区别 ++i是先自增再赋值</span><br><span class="line">             //i++是先赋值再自增</span><br><span class="line">				count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		return count;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以使用快慢指针，当数字相同时快指针后移，当数字不同时先移动慢指针再赋值。</p>
<p>那么这道题的解题思路是，我们使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第一个数字，如果两个指针指的数字相同，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数</p>
]]></content>
  </entry>
  <entry>
    <title>L1-判断字符串是否没有重复字符</title>
    <url>/2018/05/25/L1-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>实现一个算法确定字符串中的字符是否均唯一出现</p>
<p>样例<br>给出”abc”，返回 true</p>
<p>给出”aab”，返回 false</p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>两层for循环 遍历后面的字符串<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param str: A string</span><br><span class="line">     * @return: a boolean</span><br><span class="line">     */</span><br><span class="line">    public boolean isUnique(String str) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">       if(str == null)&#123;  </span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid parameters&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">         //如果str的长度是0或者1，那么没有重复字符，返回true  </span><br><span class="line">        if(str.length() == 0 || str.length() == 1)&#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125; </span><br><span class="line">        boolean flag=true;</span><br><span class="line">        for(int i=0;i&lt;str.length()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=i+1;j&lt;str.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(str.charAt(i)==str.charAt(j))</span><br><span class="line">                flag=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>哈希表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param str: A string</span><br><span class="line">     * @return: a boolean</span><br><span class="line">     */</span><br><span class="line">    public boolean isUnique(String str) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">          if(str == null)&#123;  </span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid parameters&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">         //如果str的长度是0或者1，那么没有重复字符，返回true  </span><br><span class="line">        if(str.length() == 0 || str.length() == 1)&#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    HashSet&lt;Character&gt; hs=new HashSet&lt;Character&gt;();</span><br><span class="line">    for(int i=0;i&lt;str.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(hs.contains(str.charAt(i)))</span><br><span class="line">        return false;</span><br><span class="line">        hs.add(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="法三"><a href="#法三" class="headerlink" title="法三"></a>法三</h2><p>将字符串转成字符数组，遍历数组，看当前字符是否和后面字符相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param str: A string</span><br><span class="line">     * @return: a boolean</span><br><span class="line">     */</span><br><span class="line">    public boolean isUnique(String str) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">          if(str == null)&#123;  </span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid parameters&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">         //如果str的长度是0或者1，那么没有重复字符，返回true  </span><br><span class="line">        if(str.length() == 0 || str.length() == 1)&#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">     char[] ch = str.toCharArray(); </span><br><span class="line">     Arrays.sort(ch);</span><br><span class="line">     for(int i=0;i&lt;ch.length-1;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         if(ch[i]==ch[i+1])</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法四"><a href="#法四" class="headerlink" title="法四"></a>法四</h2><p>调用string.idexof(value)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param str: A string</span><br><span class="line">     * @return: a boolean</span><br><span class="line">     */</span><br><span class="line">    public boolean isUnique(String str) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">          if(str == null)&#123;  </span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid parameters&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">         //如果str的长度是0或者1，那么没有重复字符，返回true  </span><br><span class="line">        if(str.length() == 0 || str.length() == 1)&#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">     </span><br><span class="line">     for(int i=0;i&lt;str.length()-1;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         if(str.indexOf(str.charAt(i),i+1)!=-1)</span><br><span class="line">         //stringObject.indexOf(searchvalue,fromindex)</span><br><span class="line">         //如果要检索的字符串值没有出现，则该方法返回 -1。</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="补充：Java中字符串为什么不以-0结尾"><a href="#补充：Java中字符串为什么不以-0结尾" class="headerlink" title="补充：Java中字符串为什么不以\0结尾"></a>补充：Java中字符串为什么不以\0结尾</h2><p>Java里面一切都是对象，是对象的话，字符串肯定就有长度，即然有长度，编译器就可以确定要输出的字符个数，当然也就没有必要去浪费那1字节的空间用以标明字符串的结束了。<br>Java中：</p>
<p>char []str=”test”;//编译都通不过</p>
<p>char []str=new char[10];//这样才行，也就是直接指定了其大小</p>
<p>在java中数组其实就是一个对象，学习java时，我们都接触的一句话就是everythingis object,因此数组也不例外，数组对象里还有一个属性叫做length,就是数组的长度，因此对于输出函数来说，有直接的大小可以判断字符串的边界，编译器就没必要再去浪费一个空间标识字符串的结束。</p>
<p>参考链接：<a href="http://844604778.iteye.com/blog/1959495" target="_blank" rel="noopener">http://844604778.iteye.com/blog/1959495</a></p>
<p><a href="https://blog.csdn.net/upupday19/article/details/78975457" target="_blank" rel="noopener">https://blog.csdn.net/upupday19/article/details/78975457</a></p>
]]></content>
  </entry>
  <entry>
    <title>L1-合并两个排序链表</title>
    <url>/2018/06/01/L1-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>合并两个排序链表<br>将两个排序链表合并为一个新的排序链表</p>
<p>样例<br>给出 1-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null，2-&gt;null， 返回 1-&gt;2-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null。<br><a id="more"></a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Definition of ListNode</span><br><span class="line">class ListNode(object):</span><br><span class="line">    def __init__(self, val, next=None):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    @param l1: ListNode l1 is the head of the linked list</span><br><span class="line">    @param l2: ListNode l2 is the head of the linked list</span><br><span class="line">    @return: ListNode head of linked list</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def mergeTwoLists(self, l1, l2):</span><br><span class="line">        # write your code here</span><br><span class="line">        if l1 == None:</span><br><span class="line">            return l2</span><br><span class="line">        if l2==None:</span><br><span class="line">            return l1</span><br><span class="line">        if l1 == None and l2 == None:</span><br><span class="line">            return None</span><br><span class="line">        head=ListNode(0)</span><br><span class="line">        cur=head</span><br><span class="line">        while l1!=None and l2!=None:</span><br><span class="line">            if l1!=None and l2!=None:</span><br><span class="line">                if l1.val&lt;l2.val:</span><br><span class="line">                    cur.next=l1</span><br><span class="line">                    cur=cur.next</span><br><span class="line">                    l1=l1.next</span><br><span class="line">                else:</span><br><span class="line">                    cur.next=l2</span><br><span class="line">                    cur=cur.next</span><br><span class="line">                    l2=l2.next</span><br><span class="line">            if l1==None:</span><br><span class="line">                cur.next=l2</span><br><span class="line">                break</span><br><span class="line">            if l2==None:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                break</span><br><span class="line">        return head.next</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p> 异步的方式移动两个链表的指针，时间复杂度O(n+m)</p>
<p> 参考链接<br> <a href="http://www.cnblogs.com/theskulls/p/4870694.html" target="_blank" rel="noopener">http://www.cnblogs.com/theskulls/p/4870694.html</a></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-合并区间</title>
    <url>/2018/05/27/L1-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>给出若干闭合区间，合并所有重叠的部分。</p>
<p>样例 </p>
<p>给出的区间列表 =&gt; 合并后的区间列表：</p>
<p>[ [<br>[1, 3], [1, 6],<br>[2, 6], =&gt; [8, 10],<br>[8, 10], [15, 18]<br>[15, 18] ]<br>] </p>
<p>挑战<br>O(n log n) 的时间和 O(1) 的额外空间。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>贪心法，需要依赖链表每个节点的start进行排序，避免出现[2,3][3,6][5,9][1,10]这样的情况出现,排序的复杂度为nlogn，比较的复杂度为n<br><a id="more"></a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of Interval:</span><br><span class="line"> * public classs Interval &#123;</span><br><span class="line"> *     int start, end;</span><br><span class="line"> *     Interval(int start, int end) &#123;</span><br><span class="line"> *         this.start = start;</span><br><span class="line"> *         this.end = end;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param intervals: interval list.</span><br><span class="line">     * @return: A new interval list.</span><br><span class="line">     */</span><br><span class="line"> public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123;</span><br><span class="line">	        // write your code here</span><br><span class="line">	        	 </span><br><span class="line">	             Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">	                 @Override</span><br><span class="line">	                 public int compare(Interval o1, Interval o2) &#123;</span><br><span class="line">	                     return o1.start - o2.start;</span><br><span class="line">	                 &#125;</span><br><span class="line">	             &#125;);</span><br><span class="line"></span><br><span class="line">	        </span><br><span class="line">	    for(int i=0;i&lt;intervals.size()-1;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	        if(intervals.get(i+1).start&gt;intervals.get(i).end)</span><br><span class="line">	    	continue;</span><br><span class="line">	    	if(intervals.get(i+1).end&lt;intervals.get(i).start)</span><br><span class="line">	    	continue;</span><br><span class="line">	    	int newS=Math.min(intervals.get(i).start, intervals.get(i+1).start);</span><br><span class="line">	    	int newE=Math.max(intervals.get(i).end, intervals.get(i+1).end);</span><br><span class="line">	    	Interval temp=new Interval(newS, newE);</span><br><span class="line">	    	intervals.remove(i);</span><br><span class="line">	    	intervals.remove(i);//不能写成i+1</span><br><span class="line">	    	intervals.add(i,temp);</span><br><span class="line">	    	i--;</span><br><span class="line">	    &#125;</span><br><span class="line">	    return intervals;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个写得有点乱</p>
<p>改进了一下，建一个新链表，比较新链表当前位置的end和原链表interval的start大小，看是否要合并区间，把interval插入新链表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of Interval:</span><br><span class="line"> * public classs Interval &#123;</span><br><span class="line"> *     int start, end;</span><br><span class="line"> *     Interval(int start, int end) &#123;</span><br><span class="line"> *         this.start = start;</span><br><span class="line"> *         this.end = end;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param intervals: interval list.</span><br><span class="line">     * @return: A new interval list.</span><br><span class="line">     */</span><br><span class="line"> 	         public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123;</span><br><span class="line">	        // write your code here</span><br><span class="line">	        	 List&lt;Interval&gt; res=new ArrayList&lt;Interval&gt;();</span><br><span class="line">	             Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">	                 @Override</span><br><span class="line">	                 public int compare(Interval o1, Interval o2) &#123;</span><br><span class="line">	                     return o1.start - o2.start;</span><br><span class="line">	                 &#125;</span><br><span class="line">	             &#125;);</span><br><span class="line">res.add(intervals.get(0));</span><br><span class="line">int cur=0;</span><br><span class="line">	    for(int i=1;i&lt;intervals.size();i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	       </span><br><span class="line">	    	if(intervals.get(i).start&gt;res.get(cur).end)</span><br><span class="line">	    	&#123;res.add(intervals.get(i));</span><br><span class="line">	    	cur+=1;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	else&#123;</span><br><span class="line">	    	int newE=Math.max(intervals.get(i).end, res.get(cur).end);</span><br><span class="line">            res.get(cur).end=newE;</span><br><span class="line">	    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充：java-List中删除元素"><a href="#补充：java-List中删除元素" class="headerlink" title="补充：java List中删除元素"></a>补充：java List中删除元素</h2><p>删除 List 中的元素会产生两个问题：</p>
<ul>
<li>删除元素后 List 的元素数量会发生变化；</li>
<li>对 List 进行删除操作可能会产生并发问题；</li>
</ul>
<p><strong>List 删除元素的逻辑是将目标元素之后的元素往前移一个索引位置，最后一个元素置为 null，同时 size - 1；</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    list.add(1);</span><br><span class="line">    list.add(2);</span><br><span class="line">    list.add(3);</span><br><span class="line">    list.add(3);</span><br><span class="line">    list.add(4);</span><br><span class="line">         </span><br><span class="line">    for (int i=0; i&lt;list.size(); i++) &#123;</span><br><span class="line">        if (list.get(i) == 3) &#123;</span><br><span class="line">            list.remove(i--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建议使用iterator.remove方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (null != list &amp;&amp; list.size() &gt; 0) &#123;</span><br><span class="line">    Iterator it = list.iterator();  </span><br><span class="line">    while(it.hasNext())&#123;</span><br><span class="line">        Student stu = (Student)it.next(); </span><br><span class="line">        if (stu.getStudentId() == studentId) &#123;</span><br><span class="line">            it.remove(); //移除该对象</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接 </p>
<p><a href="https://my.oschina.net/xsh1208/blog/504526" target="_blank" rel="noopener">https://my.oschina.net/xsh1208/blog/504526</a><br><a href="https://blog.csdn.net/zzcblogs/article/details/79410002" target="_blank" rel="noopener">https://blog.csdn.net/zzcblogs/article/details/79410002</a><br><a href="https://blog.csdn.net/xiaowei132/article/details/48090241" target="_blank" rel="noopener">https://blog.csdn.net/xiaowei132/article/details/48090241</a><br><a href="https://blog.csdn.net/claram/article/details/53410175" target="_blank" rel="noopener">https://blog.csdn.net/claram/article/details/53410175</a></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-在二叉查找树中插入节点</title>
    <url>/2018/05/18/L1-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%A7%8D%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>描述<br>给定一棵二叉查找树和一个新的树节点，将节点插入到树中。</p>
<p>你需要保证该树仍然是一棵二叉查找树。</p>
<p>样例<br>给出如下一棵二叉查找树，在插入节点6之后这棵二叉查找树可以是这样的：</p>
<p>  2             2<br> / \           / \<br>1   4   –&gt;   1   4<br>   /             / \<br>  3             3   6</p>
<p>挑战<br>能否不使用递归？<br><a id="more"></a></p>
<h2 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h2><p>让一个节点指向root，比根节点的值小往左走，否则往右走。<br>注意走的时候 先判断根左边或右边的节点是否为空 如果为空则直接插入 否则继续走。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * @param root: The root of the binary search tree.</span><br><span class="line">	 * </span><br><span class="line">	 * @param node: insert this node into the binary search tree</span><br><span class="line">	 * </span><br><span class="line">	 * @return: The root of the new binary search tree.</span><br><span class="line">	 */</span><br><span class="line">	public TreeNode insertNode(TreeNode root, TreeNode node) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			return node;</span><br><span class="line">		TreeNode t = root;</span><br><span class="line">		while (t != null) &#123;</span><br><span class="line">			if (node.val &lt; t.val) &#123;</span><br><span class="line">				if (t.left == null)</span><br><span class="line">				&#123;</span><br><span class="line">				    t.left = node;</span><br><span class="line">					return root;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					t = t.left;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (node.val &gt; t.val) &#123;</span><br><span class="line">				if (t.right == null)</span><br><span class="line">					&#123;</span><br><span class="line">					    t.right = node;</span><br><span class="line">			            return root;</span><br><span class="line">					&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					t = t.right;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>利用二叉查找树的特性，根据插入节点的值和根节点的值进行比较，若比根节点的值小则在根的左子树上插入，否则在右子树上插入。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of TreeNode:</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     public int val;</span><br><span class="line"> *     public TreeNode left, right;</span><br><span class="line"> *     public TreeNode(int val) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = this.right = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param root: The root of the binary search tree.</span><br><span class="line">     * @param node: insert this node into the binary search tree</span><br><span class="line">     * @return: The root of the new binary search tree.</span><br><span class="line">     */</span><br><span class="line">    public TreeNode insertNode(TreeNode root, TreeNode node) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        if(root==null) root=node;</span><br><span class="line">        if(node.val&lt;root.val)</span><br><span class="line">        root.left=insertNode(root.left,node);</span><br><span class="line">        if(node.val&gt;root.val)</span><br><span class="line">        root.right=insertNode(root.right,node);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-平衡二叉树</title>
    <url>/2018/05/28/L1-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>平衡二叉树<br>给定一个二叉树,确定它是高度平衡的。对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过1。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例</span><br><span class="line">给出二叉树 A=&#123;3,9,20,#,#,15,7&#125;, B=&#123;3,#,20,15,7&#125;</span><br><span class="line"></span><br><span class="line">A)  3            B)    3 </span><br><span class="line">   / \                  \</span><br><span class="line">  9  20                 20</span><br><span class="line">    /  \                / \</span><br><span class="line">   15   7              15  7</span><br><span class="line">二叉树A是高度平衡的二叉树，但是B不是</span><br></pre></td></tr></table></figure></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition of TreeNode:</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     public int val;</span><br><span class="line"> *     public TreeNode left, right;</span><br><span class="line"> *     public TreeNode(int val) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = this.right = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param root: The root of binary tree.</span><br><span class="line">     * @return: True if this Binary tree is Balanced, or false.</span><br><span class="line">     */</span><br><span class="line">    public boolean isBalanced(TreeNode root) </span><br><span class="line">    &#123;</span><br><span class="line">        if(root == null)</span><br><span class="line">            return true;</span><br><span class="line">        // write your code here</span><br><span class="line">        int left=maxHeight(root.left);</span><br><span class="line">        int right=maxHeight(root.right);</span><br><span class="line">        if(Math.abs(left-right)&gt;1)</span><br><span class="line">        return false;</span><br><span class="line">        else </span><br><span class="line">        return isBalanced(root.left)&amp;&amp;isBalanced(root.right);</span><br><span class="line">        //注意不是return true; 必须每个节点都平衡</span><br><span class="line">    &#125;</span><br><span class="line">    public int maxHeight(TreeNode root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root==null) return 0;</span><br><span class="line">      int  h_left=maxHeight(root.left)+1;</span><br><span class="line">       int h_right=maxHeight(root.right)+1;</span><br><span class="line">        int ma=Math.max(h_left,h_right);</span><br><span class="line">        System.out.println(ma);</span><br><span class="line">        return ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先求左子树和右子树的最大深度，然后判断是否相差大于1，如果是，则不可能是，如果相差小于，继续递归调用判断左子树和右子树是否都是平衡二叉树。</p>
<p>参考链接<br><a href="https://www.jiuzhang.com/solutions/balanced-binary-tree/" target="_blank" rel="noopener">https://www.jiuzhang.com/solutions/balanced-binary-tree/</a></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-恢复旋转排序数组</title>
    <url>/2018/05/18/L1-%E6%81%A2%E5%A4%8D%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>题目描述：</p>
<p>给定一个旋转排序数组，在原地恢复其排序。</p>
<p>什么是旋转数组？</p>
<p>比如，原始数组为[1,2,3,4], 则其旋转数组可以是[1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]</p>
<p>挑战：使用O(1)的额外空间和O(n)时间复杂度<br><a id="more"></a></p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>假设1前面有k个数,找到1的位置后, 将其前面的k个数增加到数组末尾,然后数据统一前移一次,再去除后面的k个位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: An integer array</span><br><span class="line">     * @return: nothing</span><br><span class="line">     */</span><br><span class="line">    public void recoverRotatedSortedArray(List&lt;Integer&gt; nums) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        int temp=nums.get(0);</span><br><span class="line">        int length=nums.size();</span><br><span class="line">        int i;</span><br><span class="line">        for( i=0;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums.get(i)&lt;temp)</span><br><span class="line">                break;  </span><br><span class="line">        &#125;</span><br><span class="line">         for(int j=0;j&lt;i;j++)</span><br><span class="line">        nums.add(nums.get(j));</span><br><span class="line">   nums.subList(0, i).clear();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二：三步翻转法"><a href="#法二：三步翻转法" class="headerlink" title="法二：三步翻转法"></a>法二：三步翻转法</h2><p>三步翻转法：以{4,5,6,7,1,2,3}为例</p>
<ol>
<li><p>先找到1的位置.然后翻转{4,5,6,7}得到{7,6,5,4}</p>
</li>
<li><p>翻转{1,2,3}得到{3,2,1}</p>
</li>
<li><p>此时数组为：{7,6,5,4,3,2,1}, 将其翻转即得{1,2,3,4,5,6,7}</p>
</li>
</ol>
<p>即前半部分逆序，后半部分逆序，整体再逆序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: An integer array</span><br><span class="line">     * @return: nothing</span><br><span class="line">     */</span><br><span class="line">	public void reverse(List&lt;Integer&gt; nums,int start,int end)</span><br><span class="line">	&#123;</span><br><span class="line">		while(start&lt;end)</span><br><span class="line">		&#123;</span><br><span class="line">		int temp=nums.get(start);</span><br><span class="line">		nums.set(start, nums.get(end));</span><br><span class="line">		nums.set(end, temp);</span><br><span class="line">		start++;</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    public void recoverRotatedSortedArray(List&lt;Integer&gt; nums) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        int temp=nums.get(0);</span><br><span class="line">        int length=nums.size();</span><br><span class="line">        int i;</span><br><span class="line">        for( i=0;i&lt;length-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums.get(i)&gt;nums.get(i+1))</span><br><span class="line">            	break;</span><br><span class="line">        &#125;</span><br><span class="line">         reverse(nums, 0, i);</span><br><span class="line">         reverse(nums, i+1, length-1);</span><br><span class="line">         reverse(nums, 0, length-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-插入区间</title>
    <url>/2018/05/06/L1-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>Given a non-overlapping interval list which is sorted by start point.</p>
<p>Insert a new interval into it, make sure the list is still in order and non-overlapping (merge intervals if necessary).<br><a id="more"></a><br>样例<br>Insert (2, 5) into [(1,2), (5,9)], we get [(1,9)].</p>
<p>Insert (3, 4) into [(1,2), (5,9)], we get [(1,2), (3,4), (5,9)].<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> start, end;</span><br><span class="line">     Interval(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">          <span class="keyword">this</span>.start = start;</span><br><span class="line">          <span class="keyword">this</span>.end = end;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Insert newInterval into intervals.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intervals: Sorted interval list.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newInterval: A new interval.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: A new sorted interval list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ArrayList&lt;Interval&gt; list=<span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">	list.add(<span class="keyword">new</span> Interval(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">	list.add(<span class="keyword">new</span> Interval(<span class="number">4</span>,<span class="number">6</span>));</span><br><span class="line">	ArrayList&lt;Interval&gt; newlist=insert(list,<span class="keyword">new</span> Interval(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">	<span class="keyword">for</span>(Interval interval:newlist)</span><br><span class="line">	&#123;</span><br><span class="line">	System.out.println(interval.start+<span class="string">"   "</span>+interval.end);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Interval&gt; <span class="title">insert</span><span class="params">(ArrayList&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Interval&gt; result = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.add(newInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> insertPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Interval interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newInterval.end &lt; interval.start) &#123;</span><br><span class="line">            <span class="comment">// case 1: [new], [old]</span></span><br><span class="line">            result.add(interval);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval.end &lt; newInterval.start) &#123;</span><br><span class="line">            <span class="comment">// case 2: [old], [new]</span></span><br><span class="line">            result.add(interval);</span><br><span class="line">            insertPos++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// case 3, 4: [old, new] or [new, old]</span></span><br><span class="line">            newInterval.start = Math.min(newInterval.start, interval.start);</span><br><span class="line">            newInterval.end = Math.max(newInterval.end, interval.end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.add(insertPos, newInterval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有四种情况，<br> 遍历intervals的interval</p>
<ul>
<li>[N][I] &lt;==&gt;newInterval.end&lt;interval.start,直接插入就好</li>
<li>[I], [N] &lt;==&gt;newInterval.start&gt;interval.end,记录插入的位置,newInterval有可能在此处插入，也有可能在其后面的间隔插入。故遍历时需要在这种情况下做一些标记以确定最终插入位置。</li>
<li>[NI] &lt;==&gt; newInterval.end == interval.start，这种情况下需要进行合并操作。</li>
<li>[IN] &lt;==&gt; newInterval.start == interval.end, 这种情况下也需要进行合并. </li>
</ul>
<p>难点在于产生了新的间隔，且这种情况一旦发生，原来的newInterval即被新的合并间隔取代，这是一个非常关键的突破口。</p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-搜索二维矩阵</title>
    <url>/2018/05/10/L1-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h2><p>写出一个高效的算法来搜索 m × n矩阵中的值。</p>
<p>这个矩阵具有以下特性：</p>
<p>每行中的整数从左到右是排序的。<br>每行的第一个数大于上一行的最后一个整数。<br>样例<br>考虑下列矩阵：</p>
<p>[<br>  [1, 3, 5, 7],</p>
<p>  [10, 11, 16, 20],</p>
<p>  [23, 30, 34, 50]<br>]</p>
<p>给出 target = 3，返回 true<br><a id="more"></a></p>
<p>挑战</p>
<p>O(log(n) + log(m)) 时间复杂度</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>二分查找<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix: matrix, a list of lists of integers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target: An integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: a boolean, indicate whether matrix contains target*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		<span class="keyword">int</span> m = matrix.length;</span><br><span class="line">		<span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> endIndex = m * n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">while</span> (startIndex&lt;=endIndex) &#123;</span><br><span class="line">			<span class="keyword">int</span> midIndex = (startIndex + endIndex) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">int</span> i = midIndex / n;</span><br><span class="line">			<span class="keyword">int</span> j = midIndex % n;</span><br><span class="line">			<span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target)</span><br><span class="line">					startIndex = midIndex + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				endIndex = midIndex - <span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> flag;</span><br><span class="line">	</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>根据题中给出的排序状态，就可以避免无用的搜索操作啦<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * @param matrix</span><br><span class="line">	 *            : matrix, a list of lists of integers</span><br><span class="line">	 * @param target</span><br><span class="line">	 *            : An integer</span><br><span class="line">	 * @return: a boolean, indicate whether matrix contains target</span><br><span class="line">	 */</span><br><span class="line">	public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">		// write your code here</span><br><span class="line">		if (matrix == null || matrix.length == 0)</span><br><span class="line">			return false;</span><br><span class="line">		int m = matrix.length;</span><br><span class="line">		int n = matrix[0].length;</span><br><span class="line">		boolean flag = false;</span><br><span class="line">		for (int i = 0; i &lt; m &amp;&amp; matrix[0][i] &lt;= target; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; n &amp;&amp; matrix[i][j] &lt;= target; j++) &#123;</span><br><span class="line">				if (matrix[i][j] == target)</span><br><span class="line">					flag = true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		return flag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-搜索插入位置</title>
    <url>/2018/05/14/L1-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>描述<br>给定一个排序数组和一个目标值，如果在数组中找到目标值则返回索引。如果没有，返回到它将会被按顺序插入的位置。</p>
<p>你可以假设在数组中无重复元素。</p>
<a id="more"></a>
<p>样例<br>[1,3,5,6]，5 → 2</p>
<p>[1,3,5,6]，2 → 1</p>
<p>[1,3,5,6]， 7 → 4</p>
<p>[1,3,5,6]，0 → 0</p>
<p>挑战<br>O(log(n)) time<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param A: an integer sorted array</span><br><span class="line">     * @param target: an integer to be inserted</span><br><span class="line">     * @return: An integer</span><br><span class="line">     */</span><br><span class="line">    public static int searchInsert(int[] A, int target) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">    	int i; </span><br><span class="line">    	for( i=0;i&lt;A.length;i++)</span><br><span class="line">    	 &#123;</span><br><span class="line">    		 if(A[i]&gt;=target)</span><br><span class="line">    			 break;</span><br><span class="line">    	 &#125;</span><br><span class="line">    	return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为数组为有序数组，通过循环判断程序中的元素找到相同的返回，如果循环到比target数据大的元素，即返回第一个比他大的元素下标。</p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-数字三角形</title>
    <url>/2018/06/17/L1-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<p>题目</p>
<p>给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。<br><strong> 注意事项<br>如果你只用额外空间复杂度O(n)的条件下完成可以获得加分，其中n是数字三角形的总行数。</strong></p>
<p>样例<br>比如，给出下列数字三角形：<br>[</p>
<pre><code> [2],

[3,4],

[6,5,7],

[4,1,8,3]
</code></pre><p>]</p>
<p>从顶到底部的最小路径和为11 ( 2 + 3 + 5 + 1 = 11)。<br><a id="more"></a><br>复杂度o(n^2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param triangle: a list of lists of integers</span><br><span class="line">     * @return: An integer, minimum path sum</span><br><span class="line">     */</span><br><span class="line">   </span><br><span class="line">      public int minimumTotal(int[][] triangle) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        if(triangle.length==1&amp;&amp;triangle[0].length==1)</span><br><span class="line">            return triangle[0][0];</span><br><span class="line">        int minnum = Integer.MAX_VALUE;</span><br><span class="line">      </span><br><span class="line">        for(int i=1;i&lt;triangle.length;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;triangle[i].length;j++)&#123;</span><br><span class="line">                if(j==0)&#123;</span><br><span class="line">                    triangle[i][j]+=triangle[i-1][j];</span><br><span class="line">                &#125;else if(j==triangle[i].length-1)&#123;</span><br><span class="line">                    triangle[i][j]+=triangle[i-1][j-1];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    triangle[i][j]+=Math.min(triangle[i-1][j],triangle[i-1][j-1]);</span><br><span class="line">                &#125;</span><br><span class="line">              //把每一行的元素改为其下一行能与之相加的两个数得到的和的最小值</span><br><span class="line">                if(i==triangle.length-1)</span><br><span class="line">                    minnum = Math.min(minnum,triangle[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>常规的动态规划解法，求出从顶点到底部所有节点的路径，在选取最小的路径和.这里给的是下三角矩阵</p>
<p>走到i，j就只有两种情况，一种是从i-1,j-1过来，一种是从i-1,j过来。<br>找到状态转移方程：</p>
<p>dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j];</p>
<p>然后初始化dp，利用状态转移方程算出结果</p>
<h2 id="动态规划例题"><a href="#动态规划例题" class="headerlink" title="动态规划例题"></a>动态规划例题</h2><p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fsel2a8r6zj30pu0ga44z.jpg" alt="image"></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fsel3dyzncj30if0cx0vv.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fsel2w2fg4j30k30dmgp8.jpg" alt="image"></p>
]]></content>
  </entry>
  <entry>
    <title>L1-数组剔除元素后的乘积</title>
    <url>/2018/05/11/L1-%E6%95%B0%E7%BB%84%E5%89%94%E9%99%A4%E5%85%83%E7%B4%A0%E5%90%8E%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<p>描述<br>给定一个整数数组A。</p>
<p>定义 B[i] = A[0] <em> … </em> A[i-1] <em> A[i+1] </em> … * A[n-1]， 计算B的时候请不要使用除法。</p>
<p>样例<br>给出A=[1, 2, 3]，返回 B为[6, 3, 2]<br><a id="more"></a></p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * @param nums: Given an integers array A</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ...</span></span><br><span class="line"><span class="comment">	 * * A[n-1]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Long&gt; <span class="title">productExcludeItself</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		List&lt;Long&gt; newNums = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">			<span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j == i)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					sum *= nums.get(j);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			newNums.add(sum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newNums;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>  </span><br><span class="line">    <span class="string">""" </span></span><br><span class="line"><span class="string">    @param: nums: Given an integers array A </span></span><br><span class="line"><span class="string">    @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1] </span></span><br><span class="line"><span class="string">    """</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExcludeItself</span><span class="params">(self, nums)</span>:</span>  </span><br><span class="line">        <span class="comment"># write your code here  </span></span><br><span class="line">        result = []  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):  </span><br><span class="line">            temp = <span class="number">1</span>  </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):  </span><br><span class="line">                <span class="keyword">if</span> j != i:  </span><br><span class="line">                    temp *= nums[j]  </span><br><span class="line">            result.append(temp)  </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>java<br>前后遍历 把左右的积都算一下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param nums: Given an integers array A</span></span><br><span class="line"><span class="comment">     * @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Long&gt; <span class="title">productExcludeItself</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		<span class="keyword">int</span> n=nums.size();</span><br><span class="line">		List&lt;Long&gt; newNums = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		Long[] left=<span class="keyword">new</span> Long[n];</span><br><span class="line">		Long[] right=<span class="keyword">new</span> Long[n];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			&#123;left[i]=(<span class="keyword">long</span>) <span class="number">1</span>;</span><br><span class="line">			right[i]=(<span class="keyword">long</span>) <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">			left[i]=left[i-<span class="number">1</span>]*nums.get(i-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">			right[i]=right[i+<span class="number">1</span>]*nums.get(i+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			newNums.add(left[i]*right[i]);</span><br><span class="line">		<span class="keyword">return</span> newNums;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-旋转字符串,计算n阶乘中尾部零的个数,编程团体赛</title>
    <url>/2018/04/27/L1-%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2_%E8%AE%A1%E7%AE%97n%E9%98%B6%E4%B9%98%E4%B8%AD%E5%B0%BE%E9%83%A8%E9%9B%B6%E7%9A%84%E4%B8%AA%E6%95%B0_%E7%BC%96%E7%A8%8B%E5%9B%A2%E4%BD%93%E8%B5%9B_string_char/</url>
    <content><![CDATA[<h2 id="Problem-1-旋转字符串"><a href="#Problem-1-旋转字符串" class="headerlink" title="Problem 1 旋转字符串"></a>Problem 1 旋转字符串</h2><p>法一 效率不高 提交的时候居然还超时了<br>忘记考虑了旋转的个数大于字符串的长度的情况<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Compute &#123;</span><br><span class="line">     public static void rotateString(char[] str, int offset) &#123;</span><br><span class="line">            // write your code here</span><br><span class="line">            char[] str1=new char[100];</span><br><span class="line">          int  L=str.length;</span><br><span class="line">       int j=0;</span><br><span class="line">       for(int i=L-offset;i&lt;L;i++)</span><br><span class="line">       str1[j++]=str[i];</span><br><span class="line">       str1[j]=&apos;\0&apos;;</span><br><span class="line">       for(int i=L-1;i&gt;=offset;i--)</span><br><span class="line">        str[i]=str[i-offset];</span><br><span class="line">       for(int i=0;i&lt;offset;i++)</span><br><span class="line">            str[i]=str1[i];</span><br><span class="line">      System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s=&quot;abcdef&quot;;</span><br><span class="line">    char[] c=new char[100];</span><br><span class="line">    c=s.toCharArray();</span><br><span class="line">rotateString(c,3); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>法二 处理一下旋转的个数大于字符串的长度的情况<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void rotateString(string &amp;str,int offset)</span><br><span class="line">&#123;</span><br><span class="line">    //wirte your code here</span><br><span class="line">    if (str == &quot;&quot;) return;</span><br><span class="line">    if (offset == 0) return;</span><br><span class="line">    if (offset &gt; str.size()) offset %= str.size();</span><br><span class="line">    for (int i = 0; i &lt; offset; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str.insert(str.begin(),str[str.size()-1]);</span><br><span class="line">        str.erase(str.size()-1,1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;abcd&quot;;</span><br><span class="line">    rotateString(s,3);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>法三 栈的方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void rotateString(string &amp;str, int offset)</span><br><span class="line">&#123;</span><br><span class="line">    // write your code here</span><br><span class="line">    if(str.size()==0) //字符串为空</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    if(offset==0) //位移量为零</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    if (offset &gt; str.size()) offset %= str.size();</span><br><span class="line">    stack &lt;char&gt; ss;</span><br><span class="line">    for(int i=str.size()-1; i&gt;=str.size()-offset; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ss.push(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    string li;</span><br><span class="line">    for(int i=i=0; i&lt;str.size()-offset; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        li[i]=str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0; i&lt;offset; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i]=ss.top();</span><br><span class="line">        ss.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=offset; i&lt;str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i]=li[i-offset];</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;abcd&quot;;</span><br><span class="line">    rotateString(s,3);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Probelm-2-计算n阶乘中尾部零的个数"><a href="#Probelm-2-计算n阶乘中尾部零的个数" class="headerlink" title="Probelm 2 计算n阶乘中尾部零的个数"></a>Probelm 2 计算n阶乘中尾部零的个数</h2><p>计算n阶乘中尾部零的个数<br>样例<br>11! = 39916800，因此应该返回 2</p>
<p><strong>解法一 效率低  O(N/5)</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>  count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">long</span> m=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> temp=<span class="number">5</span>;temp&lt;=n;temp+=<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// for循环内部的temp都是5的倍数，因此首先进行+1操作</span></span><br><span class="line">        <span class="keyword">long</span> pwr=<span class="number">25</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//判断是不是25、125、625...的倍数，并根据每次pwr的变化进行+1操作</span></span><br><span class="line">        <span class="keyword">while</span>(temp%pwr==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            pwr*=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二 时间复杂度o(logN)</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>  count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">long</span> m=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(m&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        count+=n/m;</span><br><span class="line">        m*=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Probelm-3-编程团体赛"><a href="#Probelm-3-编程团体赛" class="headerlink" title="Probelm 3 编程团体赛"></a>Probelm 3 编程团体赛</h2><p>编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。</p>
<p>现给定所有队员的比赛成绩，请你编写程序找出冠军队。<br>输入格式：<br>输入第一行给出一个正整数N（&lt;=10000），即所有参赛队员总数。随后N行，每行给出一位队员的成绩，格式为：“队伍编号-队员编号 成绩”，其中“队伍编号”为1到1000的正整数，“队员编号”为1到10的正整数，“成绩”为0到100的整数。</p>
<p>输出格式：<br>在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。</p>
<p>输入样例：<br>6<br>3-10 99<br>11-5 87<br>102-1 0<br>102-3 100<br>11-9 89<br>3-2 61</p>
<p>输出样例：<br>11 176<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组下标存储队伍编号，数组的值存成绩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,num[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,scoreTeam,y,score,max=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d-%d %d"</span>,&amp;scoreTeam,&amp;y,&amp;score);</span><br><span class="line">        num[scoreTeam]+=score;</span><br><span class="line">        <span class="keyword">if</span>(num[scoreTeam]&gt;num[max])</span><br><span class="line">            max=scoreTeam;<span class="comment">//记录下最大的编号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;max&lt;&lt;<span class="string">" "</span>&lt;&lt;num[max]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="c-中char数组与字符串String类型的转换"><a href="#c-中char数组与字符串String类型的转换" class="headerlink" title="c++中char数组与字符串String类型的转换"></a>c++中char数组与字符串String类型的转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char str[100];</span><br><span class="line">   string s;</span><br><span class="line">   strcpy(str,&quot;abc&quot;);</span><br><span class="line">   s=string(str);//char数组转string</span><br><span class="line">   strcpy(str,s.c_str());//string转char数组</span><br><span class="line">   printf(&quot;%s&quot;,str);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;  </span><br><span class="line">#include &lt;list&gt;  </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">char str[100];  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    scanf(&quot;%s&quot;,str);  </span><br><span class="line">    list&lt;string&gt; li;  </span><br><span class="line">    li.push_front(str);//char数组自动转化成string  </span><br><span class="line">    printf(&quot;%s&quot;,li.front().c_str());//string转char数组  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java中char数组与字符串String类型的转换"><a href="#java中char数组与字符串String类型的转换" class="headerlink" title="java中char数组与字符串String类型的转换"></a>java中char数组与字符串String类型的转换</h3><p>String strStringType=”my string”; //创建一个字符串变量strStringType<br>char[] chrCharArray; //创建一个字符数组chrCharArray<br>chrCharArray = strStringType.toCharArray(); //将字符串变量转换为字符数组<br>strStringType= String.valueOf(chrCharArray ); //将字符数组转换为字符串<br>这里，关键是两个方法。<br>（1）String类的toCharArray()方法，将字符串转换为字符数组<br>（2）String类的valueOf()方法，将char类型的数组转换为字符串</p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>STL</tag>
        <tag>char数组与字符串String类型的转换 &#39;</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-最大子数组,最小子数组</title>
    <url>/2018/05/10/L1-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="最大子数组"><a href="#最大子数组" class="headerlink" title="最大子数组"></a>最大子数组</h1><h2 id="暴力求解法-时间复杂度O（n-3）"><a href="#暴力求解法-时间复杂度O（n-3）" class="headerlink" title="暴力求解法 时间复杂度O（n^3）"></a>暴力求解法 时间复杂度O（n^3）</h2><p>暴力枚举，时间复杂度O（n3）<br>1、找出子数组的最左端点     for i&lt;- 1 to n</p>
<p>2、找出子数组的最右端点     for j&lt;- i  to n</p>
<p>3、求和，找出最大值<br><a id="more"></a><br>sum = nums[i] +……+nums[j];  ans = max(ans, sum)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: A list of integers</span><br><span class="line">     * @return: A integer indicate the sum of max subarray</span><br><span class="line">     */</span><br><span class="line">	public int maxSubArray(int[] nums)</span><br><span class="line">	&#123;</span><br><span class="line">		int n=nums.length;</span><br><span class="line">		int max=nums[0],sum;</span><br><span class="line">		for(int i=0;i&lt;n;i++)//找出子数组的最左端点</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j=i;j&lt;n;j++)//找出子数组的最右端点</span><br><span class="line">			&#123;</span><br><span class="line">			sum=0;</span><br><span class="line">				for(int k=i;k&lt;=j;k++)</span><br><span class="line">				&#123;</span><br><span class="line">					sum+=nums[k];</span><br><span class="line">					if(sum&gt;=max)</span><br><span class="line">					max=sum;</span><br><span class="line">					</span><br><span class="line">					</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		return max;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fr6ek9jlgcj30e30aldhz.jpg" alt="image"><br>时间复杂度O（n3） 求和操作被执行了很多次，有很多是重复计算的。</p>
<h2 id="优化枚举-时间复杂度O（n-2）"><a href="#优化枚举-时间复杂度O（n-2）" class="headerlink" title="优化枚举 时间复杂度O（n^2）"></a>优化枚举 时间复杂度O（n^2）</h2><p>算是半个暴力吧</p>
<p>原理：左端点相同的子数组，随着长度的增加，排在前面的元素被不断重复相加。如果我们记录下之前的求和结果，</p>
<p>就不需要对前面的元素再进行计算，比上面的少了一重循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) </span><br><span class="line">			 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"array is null or empty."</span>);</span><br><span class="line">		<span class="keyword">int</span> n=nums.length;</span><br><span class="line">		<span class="keyword">int</span> ans=Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//找出子数组的最左端点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)<span class="comment">//找出子数组的最右端点</span></span><br><span class="line">			&#123;</span><br><span class="line">				sum+=nums[j];</span><br><span class="line">				<span class="keyword">if</span>(sum&gt;ans)</span><br><span class="line">				ans=sum;</span><br><span class="line">				</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划-时间复杂度O（n）"><a href="#动态规划-时间复杂度O（n）" class="headerlink" title="动态规划  时间复杂度O（n）"></a>动态规划  时间复杂度O（n）</h2><p>【只有子数组“前半部分”的和为正数时，子数组的求和才有可能最大】，在这个trick条件下，只需要遍历一次数组就可以。算法是：当从头开始遍历的元素的求和为正数时，继续向后遍历。当求和为负数时，重新开始计算求和，子数组的开始重置为下一个元素。</p>
<p>即对于任意一个子数组和，如果大于0，那么它再添加一个数，他的贡献是正值，如果子数组和小于0，再添加一个数，它的贡献则为负值，这时候不如将当前子数组舍掉，新数成为一个新数组。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package a;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * @param matrix</span><br><span class="line">	 *            : matrix, a list of lists of integers</span><br><span class="line">	 * @param target</span><br><span class="line">	 *            : An integer</span><br><span class="line">	 * @return: a boolean, indicate whether matrix contains target</span><br><span class="line">	 */</span><br><span class="line">	public static int maxSubArray(int[] nums)</span><br><span class="line">	&#123;</span><br><span class="line">		if(nums==null||nums.length==0) </span><br><span class="line">			 throw new IllegalArgumentException(&quot;array is null or empty.&quot;);</span><br><span class="line">		int n=nums.length;</span><br><span class="line">		int max=Integer.MIN_VALUE;</span><br><span class="line">		int sum=0;</span><br><span class="line">		for(int i=0;i&lt;n;i++)//找出子数组的最左端点</span><br><span class="line">		&#123;</span><br><span class="line">	    sum=sum&lt;0?nums[i]:sum+nums[i];</span><br><span class="line">		if(sum&gt;max)</span><br><span class="line">			max=sum;</span><br><span class="line">	    </span><br><span class="line">		&#125;</span><br><span class="line">       return max;</span><br><span class="line">	&#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int maxSum = maxSubArray(new int[]&#123;-100, -3, -10, -1, -7, -2, -5&#125;);</span><br><span class="line">        System.out.println(maxSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>其实虽然原题中指出数组里有正数和负数，经过实践和思考，这个算法同样适用于全是正数，或者全是负数的情况。当全为正数时，最大的和自然就是所有元素的和，当全为负数时，最大和自然就是其中最大的那个负数的值。通过此算法都能得到相应的结果。</strong></p>
<h1 id="最小子数组"><a href="#最小子数组" class="headerlink" title="最小子数组"></a>最小子数组</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param nums: a list of integers</span><br><span class="line">     * @return: A integer indicate the sum of minimum subarray</span><br><span class="line">     */</span><br><span class="line">    public int minSubArray(List&lt;Integer&gt; nums) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">     	</span><br><span class="line">		if(nums==null||nums.size()==0) </span><br><span class="line">			 throw new IllegalArgumentException(&quot;array is null or empty.&quot;);</span><br><span class="line">		int n=nums.size();</span><br><span class="line">		int min=nums.get(0);</span><br><span class="line">		int sum=0;</span><br><span class="line">		for(int i=0;i&lt;n;i++)//找出子数组的最左端点</span><br><span class="line">		&#123;</span><br><span class="line">	    sum=sum&gt;0?nums.get(i):sum+nums.get(i);</span><br><span class="line">		if(sum&lt;min)</span><br><span class="line">			min=sum;</span><br><span class="line">	    </span><br><span class="line">		&#125;</span><br><span class="line">		return min;</span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可参考<br><a href="https://blog.csdn.net/wwe4023/article/details/72953559" target="_blank" rel="noopener">https://blog.csdn.net/wwe4023/article/details/72953559</a><br><a href="http://www.cnblogs.com/theskulls/p/4886531.html" target="_blank" rel="noopener">http://www.cnblogs.com/theskulls/p/4886531.html</a></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-最短路径和</title>
    <url>/2018/08/21/L1-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。<br><a id="more"></a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grid: a list of lists of integers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: An integer, minimizes the sum of all numbers along its path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    	<span class="keyword">int</span> m=grid.length;</span><br><span class="line">    	<span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">    	<span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    	dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m-<span class="number">1</span>;i++)</span><br><span class="line">        	dp[i+<span class="number">1</span>][<span class="number">0</span>]=grid[i+<span class="number">1</span>][<span class="number">0</span>]+dp[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-<span class="number">1</span>;j++)</span><br><span class="line">        	dp[<span class="number">0</span>][j+<span class="number">1</span>]=grid[<span class="number">0</span>][j+<span class="number">1</span>]+dp[<span class="number">0</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m-<span class="number">1</span>;i++)</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-<span class="number">1</span>;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=grid[i+<span class="number">1</span>][j+<span class="number">1</span>]+min(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">        	&#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">return</span> i&lt;j?i:j;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>dp[ i+1 ][ j+1 ] = min( dp [ i+1 ][ j ] , dp[ i ][ j+1 ] ) + grid[ i ][ j ]</p>
<p>  时间复杂度 O（n<em>m）， 空间复杂度 O（n</em>m）</p>
<p>  参考链接 </p>
<p><a href="https://blog.csdn.net/chan15/article/details/48914325" target="_blank" rel="noopener">https://blog.csdn.net/chan15/article/details/48914325</a></p>
]]></content>
  </entry>
  <entry>
    <title>L1-比较字符串</title>
    <url>/2018/05/13/L1-%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>比较两个字符串A和B，确定A中是否包含B中所有的字符。字符串A和B中的字符都是 大写字母</p>
<p>样例</p>
<p>给出 A = “ABCD” B = “ACD”，返回 true</p>
<p>给出 A = “ABCD” B = “AABC”， 返回 false</p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>比较B字符串在A中出现的次数<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * @param matrix</span><br><span class="line">	 *            : matrix, a list of lists of integers</span><br><span class="line">	 * @param target</span><br><span class="line">	 *            : An integer</span><br><span class="line">	 * @return: a boolean, indicate whether matrix contains target</span><br><span class="line">	 */</span><br><span class="line">	public static boolean compareStrings(String A, String B) &#123;</span><br><span class="line">		// write your code here</span><br><span class="line">		int count = 0;</span><br><span class="line">		StringBuilder sb = new StringBuilder(A);</span><br><span class="line">		for (int i = 0; i &lt; B.length(); i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; sb.length(); j++) &#123;</span><br><span class="line">				if (B.charAt(i) == sb.charAt(j)) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					sb.setCharAt(j, &apos;0&apos;);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (count == B.length())</span><br><span class="line">			return true;</span><br><span class="line">		else</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s1 = &quot;ABCD&quot;, s2 = &quot;ACC&quot;;</span><br><span class="line">		if (compareStrings(s1, s2) == true)</span><br><span class="line">			System.out.println(&quot;true&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>定义一个大小为26的数组（因为大写字母有26个），遍历字符串A，将字符串A中出现的字符记录到数组中，出现一次加1；遍历字符串B，将出现的字符记录到数组中，出现一次减1。如果字符串B中的字符位置的数组大小小于0则字符串B不包含于字符串A。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param A: A string</span><br><span class="line">     * @param B: A string</span><br><span class="line">     * @return: if string A contains all of the characters in B return true else return false</span><br><span class="line">     */</span><br><span class="line">	public static boolean compareStrings(String A, String B) &#123;</span><br><span class="line">		// write your code here</span><br><span class="line">		int [] index=new int[26];</span><br><span class="line">		for(int i=0;i&lt;A.length();i++)</span><br><span class="line">			index[A.charAt(i)-&apos;A&apos;]++;</span><br><span class="line">		for(int i=0;i&lt;B.length();i++)</span><br><span class="line">			&#123;index[B.charAt(i)-&apos;A&apos;]--;</span><br><span class="line">			if(index[B.charAt(i)-&apos;A&apos;]&lt;0) return false;&#125;</span><br><span class="line">		 return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>实质上利用的是哈希表的思想。只有大写字母，一共26个，遍历A的时候，往里面压，遍历B的时候，往外边弹，如果不够弹，则不包含</strong></p>
<h2 id="hashmap实现"><a href="#hashmap实现" class="headerlink" title="hashmap实现"></a>hashmap实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * @param matrix</span><br><span class="line">	 *            : matrix, a list of lists of integers</span><br><span class="line">	 * @param target</span><br><span class="line">	 *            : An integer</span><br><span class="line">	 * @return: a boolean, indicate whether matrix contains target</span><br><span class="line">	 */</span><br><span class="line">	public static boolean compareStrings(String A, String B) &#123;</span><br><span class="line">	Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">	for(int i=0;i&lt;26;i++)</span><br><span class="line">	map.put((char)(i+&apos;A&apos;)+&quot;&quot;, 0);	</span><br><span class="line">	for(int i=0;i&lt;A.length();i++)</span><br><span class="line">		&#123;</span><br><span class="line">	int count=map.get(A.charAt(i)+&quot;&quot;);</span><br><span class="line">	map.put(A.charAt(i)+&quot;&quot;, count++);</span><br><span class="line">		&#125;</span><br><span class="line">	for(int j=0;j&lt;B.length();j++)</span><br><span class="line">	&#123;</span><br><span class="line">		String key=B.charAt(j)+&quot;&quot;;</span><br><span class="line">		int integer=map.get(key);</span><br><span class="line">		if(map.containsKey(key))</span><br><span class="line">		&#123;</span><br><span class="line">			map.put(key, --integer);</span><br><span class="line">		&#125;</span><br><span class="line">		if(integer&lt;0) return false;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	return true;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s1 = &quot;ABCD&quot;, s2 = &quot;ACC&quot;;</span><br><span class="line">		if (compareStrings(s1, s2) == true)</span><br><span class="line">			System.out.println(&quot;true&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考博客</p>
<p>关于hashmap <a href="https://www.cnblogs.com/lchzls/p/6714474.html" target="_blank" rel="noopener">https://www.cnblogs.com/lchzls/p/6714474.html</a></p>
<p>其他思路<br><a href="https://blog.csdn.net/u012664191/article/details/76060513" target="_blank" rel="noopener">https://blog.csdn.net/u012664191/article/details/76060513</a><br><a href="https://blog.csdn.net/ivanmerlin/article/details/48315349" target="_blank" rel="noopener">https://blog.csdn.net/ivanmerlin/article/details/48315349</a></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-翻转字符串</title>
    <url>/2018/05/12/L1-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>题目<br>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>说明<br>单词的构成：无空格字母构成一个单词<br>输入字符串是否包括前导或者尾随空格？可以包括，但是反转后的字符不能包括<br>如何处理两个单词间的多个空格？在反转字符串中间空格减少到只含一个</p>
<p>样例<br>给出s = “the sky is blue”，返回“blue is sky the”<br><a id="more"></a></p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>先直接用split函数将单词分割出来，然后存到list里，最后取出来依次添加并加上空格就行了。记得在末尾去掉最后的空格。<br>split函数是字符串处理中很重要的一个函数，需要熟练掌握</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * @param matrix</span><br><span class="line">	 *            : matrix, a list of lists of integers</span><br><span class="line">	 * @param target</span><br><span class="line">	 *            : An integer</span><br><span class="line">	 * @return: a boolean, indicate whether matrix contains target</span><br><span class="line">	 */</span><br><span class="line">	public static String reverseWords(String s)</span><br><span class="line">	&#123;</span><br><span class="line">		if(s==null||s.length()==0)//字符串为空</span><br><span class="line">			return &quot;&quot;;</span><br><span class="line">		String[] array=s.split(&quot; &quot;);</span><br><span class="line">		StringBuilder sb=new StringBuilder();</span><br><span class="line">		for(int i=array.length-1;i&gt;=0;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			if(!array[i].equals(&quot;&quot;))</span><br><span class="line">				sb.append(array[i]).append(&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return sb.length()==0?&quot;&quot;:sb.substring(0,sb.length()-1);//判断&quot;   &quot;返回也为&quot;&quot;</span><br><span class="line">					</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      String s1=reverseWords(&quot;  the   sky is blue&quot;);</span><br><span class="line">      System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>基本思路：<br>1）第一趟遍历<br>将每个单词翻转，且去掉连续空格中多余的空格（两端空格早已去掉）。<br>2）第二趟遍历<br>将整个字符串完全翻转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment">	 *            : matrix, a list of lists of integers</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">	 *            : An integer</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>: a boolean, indicate whether matrix contains target</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(s.trim());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length(); i++)</span><br><span class="line">			<span class="keyword">if</span> (sb.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">				<span class="keyword">while</span> (sb.charAt(i) == sb.charAt(i + <span class="number">1</span>))</span><br><span class="line">					sb.deleteCharAt(i + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length();) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (sb.charAt(i) != <span class="string">' '</span>) &#123;<span class="comment">//单词,将单词翻转</span></span><br><span class="line">				<span class="keyword">int</span> j = i;</span><br><span class="line">				<span class="keyword">while</span> (j + <span class="number">1</span> &lt; sb.length() &amp;&amp; sb.charAt(j + <span class="number">1</span>) != <span class="string">' '</span>)</span><br><span class="line">					j++;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (j - i + <span class="number">1</span>) / <span class="number">2</span>; k++) &#123;</span><br><span class="line">					<span class="keyword">char</span> c = sb.charAt(k + i);</span><br><span class="line">					sb.setCharAt(k + i, sb.charAt(j - k));</span><br><span class="line">					sb.setCharAt(j - k, c);</span><br><span class="line">				&#125;</span><br><span class="line">				i = j + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// if(sb.charAt(i)==' ') i++;</span></span><br><span class="line">			<span class="comment">// 不能写成上面的判断 原因 如果判断到最后一个字母 它会访问下一个加以判断 而不是结束循环 超出数组范围</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// eht yks si eulb</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length() / <span class="number">2</span>; i++) &#123;<span class="comment">// 从两端开始，前后互换</span></span><br><span class="line">			<span class="keyword">char</span> c = sb.charAt(i);</span><br><span class="line">			sb.setCharAt(i, sb.charAt(sb.length() - <span class="number">1</span> - i));</span><br><span class="line">			sb.setCharAt(sb.length() - <span class="number">1</span> - i, c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String s1 = reverseWords(<span class="string">"  the   sky is blue"</span>);</span><br><span class="line">		System.out.println(s1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-翻转链表</title>
    <url>/2018/05/10/L1-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>翻转一个链表</p>
<p>样例<br>给出一个链表1-&gt;2-&gt;3-&gt;null，这个翻转后的链表为3-&gt;2-&gt;1-&gt;null</p>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><a id="more"></a>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for ListNode</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head: n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The new head of reversed linked list.</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    	<span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    	ListNode second=head.next;</span><br><span class="line">    	head.next=<span class="keyword">null</span>;</span><br><span class="line">    	ListNode rs=reverse(second);</span><br><span class="line">    	second.next=head;</span><br><span class="line">    	<span class="keyword">return</span>  rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of ListNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class ListNode(object):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self, val, next=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param head: The first node of the linked list.</span></span><br><span class="line"><span class="string">    @return: You should return the head of the reversed linked list. </span></span><br><span class="line"><span class="string">                  Reverse it in-place.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line">        second = head.next;</span><br><span class="line">        head.next = <span class="literal">None</span> </span><br><span class="line">        res = self.reverse(second)</span><br><span class="line">        second.next = head</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h2><p>定义三个节点：</p>
<p>newhead翻转后的头节点</p>
<p>p向前走的节点</p>
<p>prev要插入节点的前一个节点，同时在循环中还有一个节点pNext临时保存p的下一个节点</p>
<p>初始值：p=head,prev = null,newead = null</p>
<p>在循环中：</p>
<p>先pNext = p.next 临时保存p的下一个节点，防止链表断链</p>
<p>p.next = prev p的下一个节点直线prev节点，就是翻转，链接到其前面的一个节点，为了保持每次都能这样链接</p>
<p>prev = p  prev节点向后移动一个节点</p>
<p>最后p = pNext 循环下去</p>
<p>同时要找到链表的头节点</p>
<p>当p.next==null的时候 newHead = p p就是头节点,其实运行结束时候的prev节点就是指向头节点的，单独搞个头节点，看着舒服点</p>
<h3 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for ListNode</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head: n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The new head of reversed linked list.</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        	ListNode p=head,pre=<span class="keyword">null</span>,pnext=<span class="keyword">null</span>,newHead=<span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(p.next==<span class="keyword">null</span>)newHead=p;</span><br><span class="line">    		pnext=p.next;</span><br><span class="line">    		p.next=pre;</span><br><span class="line">    		pre=p;</span><br><span class="line">    		p=pnext;</span><br><span class="line">    		</span><br><span class="line">    	&#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of ListNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class ListNode(object):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self, val, next=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param head: The first node of the linked list.</span></span><br><span class="line"><span class="string">    @return: You should return the head of the reversed linked list. </span></span><br><span class="line"><span class="string">                  Reverse it in-place.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        p = head </span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        revHead = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p!=<span class="literal">None</span>:</span><br><span class="line">            pNext = p.next</span><br><span class="line">            <span class="keyword">if</span> pNext ==<span class="literal">None</span>:</span><br><span class="line">                revHead = p</span><br><span class="line">            p.next = prev</span><br><span class="line">            prev = p</span><br><span class="line">            p = pNext</span><br><span class="line">        <span class="keyword">return</span> revHead</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-落单的数</title>
    <url>/2018/05/18/L1-%E8%90%BD%E5%8D%95%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<p>描述<br>给出2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。<br>样例<br>给出 [1,2,2,1,3,4,3]，返回 4<br><a id="more"></a><br>挑战<br>一次遍历，常数级的额外空间复杂度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param A: An integer array</span><br><span class="line">     * @return: An integer</span><br><span class="line">     */</span><br><span class="line">    public int singleNumber(int[] A) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">         if (null == A || A.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;A.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res^=A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将数组的数全部做异或，最后得到的数就是要找的数，因为和一个数做两次异或不会改变。</p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-链表划分</title>
    <url>/2018/05/23/L1-%E9%93%BE%E8%A1%A8%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。</p>
<p>你应该保留两部分内链表节点原有的相对顺序。</p>
<p>示例：</p>
<p>给定链表 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2-&gt;null，并且 x=3</p>
<p>返回 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5-&gt;null<br><a id="more"></a></p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>(1)遍历链表，将值大于给定值得结点插入新链表new_head<br>(2)将new_head与原链表连接<br><strong>注意判断头结点是否为空  什么时候指针要后移</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	ListNode next;</span><br><span class="line"></span><br><span class="line">	ListNode(int x) &#123;</span><br><span class="line">		val = x;</span><br><span class="line">		next = null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param head: The first node of linked list</span><br><span class="line">     * @param x: An integer</span><br><span class="line">     * @return: A ListNode</span><br><span class="line">     */</span><br><span class="line">		public ListNode partition(ListNode head, int x) &#123;</span><br><span class="line">		// write your code here</span><br><span class="line">		ListNode p_cur = head, p_pre = null;</span><br><span class="line">		ListNode new_head = null, new_end = null;</span><br><span class="line">		while (p_cur != null) &#123;</span><br><span class="line">			if (p_cur.val &gt;= x) &#123;</span><br><span class="line">				if (p_cur == head)</span><br><span class="line">					head = head.next;</span><br><span class="line">				else</span><br><span class="line">					p_pre.next = p_cur.next;</span><br><span class="line">				if (new_head == null)</span><br><span class="line">					&#123;new_head = p_cur;</span><br><span class="line">					  new_end=p_cur;</span><br><span class="line">					&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					new_end.next = p_cur;</span><br><span class="line">					new_end = new_end.next;</span><br><span class="line">				&#125;</span><br><span class="line">				 p_cur = p_cur.next; //注意不能少</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				p_pre = p_cur;</span><br><span class="line">				p_cur = p_cur.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(new_head!=null)</span><br><span class="line">		&#123;</span><br><span class="line">			if(head!=null)</span><br><span class="line">				p_pre.next=new_head;</span><br><span class="line">			else head=new_head;</span><br><span class="line">			new_end.next=null;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>参考链接:<a href="https://blog.csdn.net/supermuscleman/article/details/79330643" target="_blank" rel="noopener">https://blog.csdn.net/supermuscleman/article/details/79330643</a></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>L1-链表求和</title>
    <url>/2018/06/05/L1/</url>
    <content><![CDATA[<p>你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。</p>
<p>样例<br>给出两个链表 3-&gt;1-&gt;5-&gt;null 和 5-&gt;9-&gt;2-&gt;null，返回 8-&gt;0-&gt;8-&gt;null<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # @param l1: the first list</span><br><span class="line">    # @param l2: the second list</span><br><span class="line">    # @return: the sum list of l1 and l2</span><br><span class="line">    def addLists(self, l1, l2):</span><br><span class="line">        # write your code here</span><br><span class="line">        #判断是否某一链表为None，是返回另一条</span><br><span class="line">        if l1==None:return l2</span><br><span class="line">        if l2 == None:return l1</span><br><span class="line">        h1=l1</span><br><span class="line">        h2=l2</span><br><span class="line">        #只有两个链表的下一个节点数都为None,退出循环</span><br><span class="line">        while h1.next is not None or h2.next is not None:</span><br><span class="line">            #若只有一条链表的下一个节点为None，补充为0,不影响后续的加法结果</span><br><span class="line">            if h1.next ==None:h1.next=ListNode(0)</span><br><span class="line">            if h2.next ==None:h2.next=ListNode(0)</span><br><span class="line">            h1.val=h1.val+h2.val</span><br><span class="line">            #当加结果&gt;=10,当前结果节点为个位数，下一个节点+1</span><br><span class="line">            if h1.val&gt;=10:</span><br><span class="line">                h1.val=h1.val%10</span><br><span class="line">                h1.next.val+=1</span><br><span class="line">            h1=h1.next</span><br><span class="line">            h2=h2.next</span><br><span class="line">        else:</span><br><span class="line">            h1.val=h1.val+h2.val</span><br><span class="line">            #链表尾部的计算，如果&gt;=10，则在尾部再添加一个节点</span><br><span class="line">            if h1.val&gt;=10:</span><br><span class="line">                h1.val=h1.val%10</span><br><span class="line">                h1.next=ListNode(1)</span><br><span class="line">        return l1</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>取整函数</title>
    <url>/2018/12/01/Math-%E5%8F%96%E6%95%B4/</url>
    <content><![CDATA[<p>对于运算</p>
<p>向下取整：</p>
<p>a/b</p>
<p>向上取整：</p>
<p>(a+b-1)/b</p>
<p>四舍五入：<br><a id="more"></a><br>int(float(a)/b+0.5)</p>
<p>编程语言内置的floor和ceil函数。floor(x)返回的是小于或等于x的最大整数。ceil(x)返回的是大于x的最小整数。</p>
<p>1.问题<br>A,B都是整数并且A&gt;1,B&gt;1</p>
<p>求┌A/B┐即A/B的上取整。</p>
<p>当A/B整除，往上取整返回值为A/B。</p>
<p>当不整除，返回值是int(A/B)+1</p>
<p>2.算法<br>(A+B-1)/B</p>
<p>3.算法证明<br>由于A&gt;1、B&gt;1，且A、B都是整数，所以可以设A=NB+M</p>
<p>其中N为非负整数，M为0到B-1的数，则</p>
<p>A/B=N+M/B</p>
<p>(A+B-1)/B=N+1+(M-1)/B;</p>
<p>当M为0时，</p>
<p>int(A/B)=N，</p>
<p>int((A+B-1)/B)=N+int(1-1/B)=N</p>
<p>当M为1到B-1的数时，0&lt;=M-1&lt;=B-2</p>
<p>UP(A/B)=N+1，</p>
<p>int((A+B-1)/B)=N+1+int((M-1)/B)=N+1</p>
<p>所以对A&gt;1、B&gt;1的整数A、B都有：</p>
<p>UP(A/B)=int((A+B-1)/B)</p>
<p>4、应用<br>这个算法的一个应用：如果你有一个动态增长的缓冲区，增长的步长是B,</p>
<p>某一次缓冲区申请的大小是A，这个时候，就可以用这个算法，计算出缓冲区的一个合</p>
<p>适大小了，正好可以容纳A，并且不会过于得多，多余部分不会比B多。</p>
<p>参考链接</p>
<p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80626348" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/80626348</a></p>
<p><a href="https://blog.csdn.net/zjccsg/article/details/51926096" target="_blank" rel="noopener">https://blog.csdn.net/zjccsg/article/details/51926096</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode-394.字符串解码</title>
    <url>/2020/04/18/LeetCode-python-394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p>给定一个经过编码的字符串，返回它解码后的字符串。<br><a id="more"></a><br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br><!--mroe--><br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<p>示例</p>
<p>s = “3[a]2[bc]”, 返回 “aaabcbc”.<br>s = “3[a2[c]]”, 返回 “accaccacc”.<br>s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”.</p>
<p>解题思路<br>用[s, k]的list存储括号内部的数字及重复的次数，以该结构存入stack，已解决括号嵌套的问题<br>每次遇到数字的时候，开始记录数字，遇到’[‘的时候结束记录数字，将[‘’,int(num)]存入stack<br>每次遇到‘]’再解码，解码的结果存储在上一层括号的s处<br>stack初始化为[[‘’,1]]，相当于在整体的外面加一层括号<br>最后返回stack[0][0]*stack[0][1]</p>
<p>代码实现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># class Solution:</span><br><span class="line">#     def decodeString(self, s: str) -&gt; str:</span><br><span class="line">#         stack = [[&apos;&apos;, 1]]</span><br><span class="line">#         num = &apos;&apos;</span><br><span class="line">#         for c in s:</span><br><span class="line">#             if c.isdigit():</span><br><span class="line">#                 num += c</span><br><span class="line">#             elif c == &apos;[&apos;:</span><br><span class="line">#                 stack.append([&apos;&apos;, int(num)])</span><br><span class="line">#                 num = &apos;&apos;</span><br><span class="line">#             elif c == &apos;]&apos;:</span><br><span class="line">#                 subs, k = stack.pop()</span><br><span class="line">#                 stack[-1][0] += subs*k</span><br><span class="line">#             else:</span><br><span class="line">#                 stack[-1][0] += c</span><br><span class="line">#         return stack[0][0]*stack[0][1]</span><br><span class="line"># s=Solution()</span><br><span class="line"># t=s.decodeString(&quot;3[a2[c]]&quot;)</span><br><span class="line">class Solution:</span><br><span class="line">    def decodeString(self, s: str) -&gt; str:</span><br><span class="line">        stack=[[&apos;&apos;,1]]</span><br><span class="line">        num=&quot;&quot;</span><br><span class="line">        for c in s:</span><br><span class="line">            if c==&apos;[&apos;:</span><br><span class="line">                stack.append([&apos;&apos;,int(num)])</span><br><span class="line">                num=&apos;&apos;</span><br><span class="line">            elif c.isdigit():</span><br><span class="line">                num+=c</span><br><span class="line">            elif c.isalpha():</span><br><span class="line">                stack[-1][0]+=c</span><br><span class="line">            elif c==&apos;]&apos;:</span><br><span class="line">                al,k=stack.pop()</span><br><span class="line">                stack[-1][0]+=al*k</span><br><span class="line">        return stack[0][0]*stack[0][1]</span><br><span class="line">s=Solution()</span><br><span class="line">t=s.decodeString(&quot;3[a2[c]]&quot;)</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>fastRCNN</title>
    <url>/2018/04/26/My-First-Post/</url>
    <content><![CDATA[<h2 id="fastRCNN-编译配置"><a href="#fastRCNN-编译配置" class="headerlink" title="fastRCNN 编译配置"></a>fastRCNN 编译配置</h2><p>FastRCNN是Ross Girshick在RCNN的基础上增加了Multi task training整个的训练过程和测试过程比RCNN快了许多。别的一些细节不展开，过几天会上传Fast RCNN的论文笔记。FastRCNN mAP性能上略有上升。Fast RCNN中，提取OP的过程和训练过程仍然是分离的。因此我们在训练过程中，需要用OP的方法先把图像OP提取好，再送入Fast RCNN中训练，在检测过程中也是如此需要先把相应的测试图像的OP提取出来送入检测。<br><a id="more"></a><br>首先我要说的是如何安装Fast RCNN环境，具体的流程在Ross Girshick的Github上有，他里面主要是讲解了如何安装和使用。我会稍微提到这一部分内容，主要讲解，如果要训练自己的数据，应该修改那些地方，并把我自己训练的过程跟大家分享一下。</p>
<p>1.当然是Git clone一下Ross的工程啦</p>
<p>这里给出Github的链接<a href="https://github.com/rbgirshick/fast-rcnn" target="_blank" rel="noopener">https://github.com/rbgirshick/fast-rcnn</a><br>首先根据他的提示</p>
<p>Make sure to clone with –recursive<br>git clone –recursive <a href="https://github.com/rbgirshick/fast-rcnn.git" target="_blank" rel="noopener">https://github.com/rbgirshick/fast-rcnn.git</a></p>
<p>这里不要忘了加–recursive</p>
<p>2.在这里简单介绍一下工程目录</p>
<p>首先工程的根目录简单的称为 FRCN_ROOT，可以看到根目录下有以下几个文件夹</p>
<p>caffe-fast-rcnn</p>
<p>这里是caffe框架目录</p>
<p>data</p>
<p>用来存放pretrained模型 比如imagenet上的，以及读取文件的cache缓存</p>
<p>experiments</p>
<p>存放配置文件以及运行的log文件，另外这个目录下有scripts 用来获取imagenet的模型，以及作者训练好的fast rcnn模型，以及相应的pascal-voc数据集</p>
<p>lib</p>
<p>用来存放一些python接口文件，如其下的datasets主要负责数据库读取 config负责cnn一些训练的配置选项</p>
<p>matlab</p>
<p>放置matlab与python的接口，用matlab来调用实现detection</p>
<p>models</p>
<p>里面存放了三个模型文件，小型网络的CaffeNet 大型网络VGG16 中型网络VGG_CNN_M_1024</p>
<p>output</p>
<p>这里存放的是训练完成后的输出目录，默认会在default文件夹下</p>
<p>tools</p>
<p>里面存放的是训练和测试的Python文件</p>
<p>3.编译Cython module</p>
<p>cd $FRCN_ROOT/lib<br>make</p>
<p>进入lib目录直接make就可以了</p>
<p>4.编译Caffe and pycaffe</p>
<p>cd $FRCN_ROOT/caffe-fast-rcnn<br>make -j8 &amp;&amp; make pycaffe</p>
<p>这里需要注意的是你直接make -j8 &amp;&amp; make pycaffe是会报错的，</p>
<p>可以看到图中是是没有Makefile.config文件，但是作者有一个Makefile.config.example文件，你需要复制它一下然后重命名为Makefile.config</p>
<p>需要注意的是里面还有几个配置需要添加</p>
<p>打开 USE_CUDNN = 1，这个选项默认情况下时关闭的，让CUDA支持DNN</p>
<p>打开 WITH_PYTHON_LAYER = 1,这个在默认情况下也是关闭的，FastRCNN需要支持Python接口，因此需要打开</p>
<p>Fast RCNN需要hdf5的支持，这个根据自己的Linux里的库文件安装路径添加，不清楚的可以find一下，不过一般情况下，INCLUDE_DIRS 应该添加上 /usr/include/hdf5/serial LIBRARY_DIRS 添加上 /usr/lib/x86_x64-linux-gnu/hdf5/serial<br>另外把USE_PKG_CONFIG = 1 记得打开，要不然会找不到一些库文件，PKG是linux用来管理库文件</p>
<p>这几个是需要在Makefile.config.example中修改的，最好直接copy一个再修改。<br>另外还有一个需要注意的地方是，当初楼主的linux版本太高，ubuntu这玩意更新太快了，boost库的版本太高，Fast RCNN里面用的是1.55版本的boost库，当时我电脑上是1.59，会出现接口不兼容，记得是废弃了几个接口，编译报错，装回1.55的就可以了</p>
<p>5.下载相应的模型文件</p>
<p>Ross给出的操作是这样的，其实我不推荐这么弄，因为直接用wget去下载的速度比较慢，我们可以打开里面的shell文件，把url粘贴出来，到迅雷里面下载，几分钟就好了</p>
<p>cd $FRCN_ROOT<br>./data/scripts/fetch_fast_rcnn_models.sh<br>这里以相应的 imagenet_model为例，你到目录下可以看到3个shell文件，分别是fetch_fast_rcnn_models.s h,fetch_imagenet_models.sh,fetch_selective_search_data.sh，第一是作者训练好的fast_rcnn模型，第二个是imagenet_model上预训练好的模型，第三个对应着的是作者基于Pascal VOC数据集提取的selective_search预选框。如果想要看一下fast rcnn的效果，可以直接加载Ross训练好的fast_rcnn模型，如果要自己训练的话，记得加载imagenet模型</p>
<p>这里是imagenet_model的shell文件，看家里面的URL了没，最后的URL链接就是这个链接再加上FILE变量，链接，你直接把它链接起来，复制到迅雷中下载就可以了，速度灰常快，直接下载的话炒鸡慢啊。<br>下在之后记得放到data/目录下去解压哦，</p>
<p>6.运行网络和加载模型文件</p>
<p>在tools下面有个demo.py文件</p>
<p>cd $FRCN_ROOT<br>./tools/demo.py<br>就可以直接运行，记得看一下里面的参数，这里对显卡有一定的要求，Ross说必须是3G的显存以上才可以跑的动哦，里面有3个大小的网络caffenet是最小的，有显卡应该就能跑起来，vgg_cnn_m_1024是一个中型网络，vgg16是大型网络，后两个得看显卡的显存大小才能跑起，显存不够启动会报错的。</p>
<p>如果在cpu模式下的话速度是灰常慢的，GPU模式下大概0.2秒左右。</p>
<p>对了demo里面都是有显示的函数的，如果你是在linux终端下没有输出设备运行是会报错的</p>
<p>正确运行的结果如下<br>里面有两个图片检测效果，这里放一张</p>
<h2 id="Fast-RCNN训练自己的数据集"><a href="#Fast-RCNN训练自己的数据集" class="headerlink" title="Fast RCNN训练自己的数据集"></a>Fast RCNN训练自己的数据集</h2><blockquote>
<p>讲解了如何修改Fast RCNN训练自己的数据集，首先请确保你已经安装好了Fast RCNN的环境，具体的编配编制操作请参考我的上一篇文章。首先可以看到fast rcnn的工程目录下有个Lib目录<br>这里下面存在3个目录分别是：<br>datasets<br>fast_rcnn<br>roi_data_layer<br>utils<br>在这里修改读写数据的接口主要是datasets目录下，fast_rcnn下面主要存放的是python的训练和测试脚本，以及训练的配置文件，roi_data_layer下面存放的主要是一些ROI处理操作,utils下面存放的是一些通用操作比如非极大值nms，以及计算bounding box的重叠率等常用功能</p>
</blockquote>
<p>==修改读写数据的接口主要是datasets目录下，fast_rcnn下面主要存放的是python的训练和测试脚本，以及训练的配置文件，roi_data_layer下面存放的主要是一些ROI处理操作,utils下面存放的是一些通用操作比如非极大值nms，以及计算bounding box的重叠率等常用功能==</p>
<h3 id="构建自己的IMDB子类"><a href="#构建自己的IMDB子类" class="headerlink" title="构建自己的IMDB子类"></a>构建自己的IMDB子类</h3><p>datasets目录下主要有三个文件</p>
<ul>
<li>factory.py</li>
<li>imdb.py</li>
<li>pascal_voc.py</li>
</ul>
<p>factory.py 学过设计模式的应该知道这是个工厂类，用类生成imdb类并且返回数据库共网络训练和测试使用</p>
<p>imdb.py 这里是数据库读写类的基类，分装了许多db的操作，但是具体的一些文件读写需要继承继续读写</p>
<p>pascal_voc.py Ross在这里用pascal_voc.py这个类来操作</p>
<p>1.2 读取文件函数分析</p>
<p>接下来我来介绍一下pasca_voc.py这个文件，我们主要是基于这个文件进行修改，里面有几个重要的函数需要修改</p>
<p>def init(self, image_set, year, devkit_path=None)<br>这个是初始化函数，它对应着的是pascal_voc的数据集访问格式，其实我们将其接口修改的更简单一点<br>def image_path_at(self, i)<br>根据第i个图像样本返回其对应的path，其调用了image_path_from_index(self, index)作为其具体实现<br>def image_path_from_index(self, index)<br>实现了 image_path的具体功能<br>def _load_image_set_index(self)<br>加载了样本的list文件<br>def _get_default_path(self)<br>获得数据集地址<br>def gt_roidb(self)<br>读取并返回ground_truth的db<br>def selective_search_roidb<br>读取并返回ROI的db<br>def _load_selective_search_roidb(self, gt_roidb)<br>加载预选框的文件<br>def selective_search_IJCV_roidb(self)<br>在这里调用读取Ground_truth和ROI db并将db合并<br>def _load_selective_search_IJCV_roidb(self, gt_roidb)<br>这里是专门读取作者在IJCV上用的dataset<br>def _load_pascal_annotation(self, index)<br>这个函数是读取gt的具体实现<br>def _write_voc_results_file(self, all_boxes)<br>voc的检测结果写入到文件<br>def _do_matlab_eval(self, comp_id, output_dir=’output’)<br>根据matlab的evluation接口来做结果的分析<br>def evaluate_detections<br>其调用了_do_matlab_eval<br>def competition_mode<br>设置competitoin_mode，加了一些噪点</p>
<h3 id="训练数据集格式"><a href="#训练数据集格式" class="headerlink" title="训练数据集格式"></a>训练数据集格式</h3><p>在我的检测任务里，我主要是从道路卡口数据中检测车，因此我这里只有background 和car两类物体，为了操作方便，我不像pascal_voc数据集里面一样每个图像用一个xml来标注多类，先说一下我的数据格式</p>
<h3 id="修改读取接口"><a href="#修改读取接口" class="headerlink" title="修改读取接口"></a>修改读取接口</h3><p>原始初始化函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def __init__(self, image_set, year, devkit_path=None):</span><br><span class="line">    datasets.imdb.__init__(self, &apos;voc_&apos; + year + &apos;_&apos; + image_set)</span><br><span class="line">    self._year = year</span><br><span class="line">    self._image_set = image_set</span><br><span class="line">    self._devkit_path = self._get_default_path() if devkit_path is None \</span><br><span class="line">                        else devkit_path</span><br><span class="line">    self._data_path = os.path.join(self._devkit_path, &apos;VOC&apos; + self._year)</span><br><span class="line">    self._classes = (&apos;__background__&apos;, # always index 0</span><br><span class="line">                     &apos;aeroplane&apos;, &apos;bicycle&apos;, &apos;bird&apos;, &apos;boat&apos;,</span><br><span class="line">                     &apos;bottle&apos;, &apos;bus&apos;, &apos;car&apos;, &apos;cat&apos;, &apos;chair&apos;,</span><br><span class="line">                     &apos;cow&apos;, &apos;diningtable&apos;, &apos;dog&apos;, &apos;horse&apos;,</span><br><span class="line">                     &apos;motorbike&apos;, &apos;person&apos;, &apos;pottedplant&apos;,</span><br><span class="line">                     &apos;sheep&apos;, &apos;sofa&apos;, &apos;train&apos;, &apos;tvmonitor&apos;)</span><br><span class="line">    self._class_to_ind = dict(zip(self.classes, xrange(self.num_classes)))</span><br><span class="line">    self._image_ext = &apos;.jpg&apos;</span><br><span class="line">    self._image_index = self._load_image_set_index()</span><br><span class="line">    # Default to roidb handler</span><br><span class="line">    self._roidb_handler = self.selective_search_roidb</span><br><span class="line"></span><br><span class="line">    # PASCAL specific config options</span><br><span class="line">    self.config = &#123;&apos;cleanup&apos;  : True,</span><br><span class="line">                   &apos;use_salt&apos; : True,</span><br><span class="line">                   &apos;top_k&apos;    : 2000&#125;</span><br><span class="line"></span><br><span class="line">    assert os.path.exists(self._devkit_path), \</span><br><span class="line">            &apos;VOCdevkit path does not exist: &#123;&#125;&apos;.format(self._devkit_path)</span><br><span class="line">    assert os.path.exists(self._data_path), \</span><br><span class="line">            &apos;Path does not exist: &#123;&#125;&apos;.format(self._data_path)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>物体检测</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1655 Balancing Act【树的重心】</title>
    <url>/2019/03/13/OJ-1655-Balancing-Act%E3%80%90%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%E3%80%91/</url>
    <content><![CDATA[<p>Description</p>
<p>Consider a tree T with N (1 &lt;= N &lt;= 20,000) nodes numbered 1…N. Deleting any node from the tree yields a forest: a collection of one or more trees. Define the balance of a node to be the size of the largest tree in the forest T created by deleting that node from T.<br>For example, consider the tree:<br><a id="more"></a></p>
<p>Deleting node 4 yields two trees whose member nodes are {5} and {1,2,3,6,7}. The larger of these two trees has five nodes, thus the balance of node 4 is five. Deleting node 1 yields a forest of three trees of equal size: {2,6}, {3,7}, and {4,5}. Each of these trees has two nodes, so the balance of node 1 is two. </p>
<p>For each input tree, calculate the node that has the minimum balance. If multiple nodes have equal balance, output the one with the lowest number.<br>Input</p>
<p>The first line of input contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. The first line of each test case contains an integer N (1 &lt;= N &lt;= 20,000), the number of congruence. The next N-1 lines each contains two space-separated node numbers that are the endpoints of an edge in the tree. No edge will be listed twice, and all edges will be listed.<br>Output</p>
<p>For each test case, print a line containing two integers, the number of the node with minimum balance and the balance of that node.<br>Sample Input<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">7</span><br><span class="line">2 6</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">4 5</span><br><span class="line">3 7</span><br><span class="line">3 1</span><br><span class="line">Sample Output</span><br><span class="line"></span><br><span class="line">1 2</span><br></pre></td></tr></table></figure></p>
<p>题目很好理解，就是去掉树上的一个节点，看看剩下的子树中最大的是多少，然后在这些最大值中求一个最小值，如果有多个点都是最小值，那么找一个序号最小的节点。输出节点号，和最小值。</p>
<p>经过简单分析，DFS深度优先搜索可以解决，只需要求出每个节点下子树的总结点个数即可。</p>
<p>这题其实是求重心的裸题！</p>
<p>举例说明：</p>
<p>设有一棵树20个节点，其中有一个节点为u，u有两个孩子节点，设u以下有10个节点，两个孩子分别有6和4个节点，那么对于u来说，最大是多少，应该是20 - 10,6,4中的最大的也就是10.这样等把所有节点的最大值求出后，再求1-n中的最小值，输出该点以及最小值即可。</p>
<p>算法就是DFS，计算出每个节点下的总数，然后保留本节点下的孩子节点子树中的最大值，然后和自己的祖先节点比较求出最大值，最后枚举最小值。</p>
<p>这题一定要建一个双向图，因为树是无向的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX 20010</span><br><span class="line">using namespace std;</span><br><span class="line">int cnt;</span><br><span class="line">		int n;</span><br><span class="line">int head[MAX];//head[i] 表示以 i为起点的第一条边 </span><br><span class="line">int dp[MAX],num[MAX];</span><br><span class="line">struct edge&#123;</span><br><span class="line">	int to;</span><br><span class="line">	int next;</span><br><span class="line">	edge(int tt,int nn):to(tt),next(nn)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	edge()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line">edge e[MAX&lt;&lt;1];</span><br><span class="line">void addEdge(int u,int v)&#123;</span><br><span class="line">	e[cnt].to=v;</span><br><span class="line">	e[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int pre)&#123;</span><br><span class="line">	dp[u]=0;//以u为节点(除去u)最大子树节点数</span><br><span class="line">	num[u]=1;//以u为根的子树总节点数</span><br><span class="line">	for(int i=head[u];i!=-1;i=e[i].next)&#123;</span><br><span class="line">		int v=e[i].to;</span><br><span class="line">		if(v==pre) continue;</span><br><span class="line">		dfs(v,u);</span><br><span class="line">		dp[u]=max(dp[u],num[v]);</span><br><span class="line">		num[u]+=num[v];</span><br><span class="line">	&#125; </span><br><span class="line">	dp[u]=max(n-num[u],dp[u]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line"></span><br><span class="line">	//n条边 </span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	memset(head,-1,sizeof(head));</span><br><span class="line">	cnt=0;</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">		int a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		addEdge(a,b);</span><br><span class="line">		addEdge(b,a);</span><br><span class="line">	&#125; 	</span><br><span class="line">	dfs(1,0);	</span><br><span class="line">	int ans1=1,ans2=dp[1];</span><br><span class="line">	for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">		if(ans2&gt;dp[i])&#123;</span><br><span class="line">			ans1=i;</span><br><span class="line">			ans2=dp[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">		cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="http://www.cnblogs.com/ECJTUACM-873284962/p/7279062.html" target="_blank" rel="noopener">http://www.cnblogs.com/ECJTUACM-873284962/p/7279062.html</a></p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2373 灌溉草场</title>
    <url>/2018/11/12/OJ2373-%E7%81%8C%E6%BA%89%E8%8D%89%E5%9C%BA/</url>
    <content><![CDATA[<p>在一片草场上:有一条长度为L (1 &lt;= L &lt;= 1,000,000，L为偶数)的线<br>段。 John的N (1 &lt;= N &lt;= 1000) 头奶牛都沿着草场上这条线段吃草，每头<br>牛的活动范围是一个开区间(S,E)，S，E都是整数。不同奶牛的活动范围可以<br>有重叠。</p>
<p>John要在这条线段上安装喷水头灌溉草场。每个喷水头的喷洒半径可以随<br>意调节，调节范围是 <a href="1 &lt;= A &lt;= B &lt;= 1000">[ A  B ]</a>，A,B都是整数。要求<br>线段上的每个整点恰好位于一个喷水头的喷洒范围内<br>每头奶牛的活动范围要位于一个喷水头的喷洒范围内<br>任何喷水头的喷洒范围不可越过线段的两端(左端是0,右端是L )<br>请问， John 最少需要安装多少个喷水头</p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx5iv3fet7j30kq0af76e.jpg" alt="image"><br><a id="more"></a><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx5iu076y5j30pu0cu41o.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx5iryq7p2j30p80bx436.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx5islj2k5j30o909bmzp.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx5itcnzrpj30p60ao790.jpg" alt="image"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;queue&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1000</span><br><span class="line">int cowsThere[MAX];</span><br><span class="line">int F[MAX];</span><br><span class="line">const int INFINITE = 1&lt;&lt;31;</span><br><span class="line">struct fx&#123;</span><br><span class="line">	int x,f;</span><br><span class="line">	fx(int xx,int ff):x(xx),f(ff)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	fx()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator&lt;(const fx&amp;ff)const&#123;</span><br><span class="line">	return f&gt;ff.f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int L,N,s,e,A,B;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;L;</span><br><span class="line">	cin&gt;&gt;A&gt;&gt;B;</span><br><span class="line">	A=A&lt;&lt;1;</span><br><span class="line">	B=B&lt;&lt;1;</span><br><span class="line">	priority_queue&lt;fx&gt; qfx;</span><br><span class="line">	memset(cowsThere,0,sizeof(cowsThere)); </span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		cin&gt;&gt;s&gt;&gt;e;</span><br><span class="line">		 ++cowsThere[s+1]; //!!</span><br><span class="line">		 --cowsThere[e];</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">	int ncows=0;</span><br><span class="line">	//从前往后累加到那个点  </span><br><span class="line">	for(int i=0;i&lt;=L;i++)&#123;</span><br><span class="line">		ncows+=cowsThere[i];</span><br><span class="line">		cowsThere[i]=ncows&gt;0;</span><br><span class="line">		 F[i]=INFINITE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=A;i&lt;B;i+=2)&#123;</span><br><span class="line">		if(!cowsThere[i]) &#123;</span><br><span class="line">		</span><br><span class="line">				F[i]=1;</span><br><span class="line">			//与其相距太近，会与下一次花洒范围重叠 </span><br><span class="line">			//先把与其相近2a(A)的点 不加入队列 </span><br><span class="line">			if(i&gt;B+2-A) continue;</span><br><span class="line">		else 	qfx.push(fx(i,1));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=B+2;i&lt;=L;i+=2)//!!</span><br><span class="line">	&#123;</span><br><span class="line">		fx ff;</span><br><span class="line">		if(!cowsThere[i])&#123;</span><br><span class="line">			while(!qfx.empty())&#123;</span><br><span class="line">				ff=qfx.top();</span><br><span class="line">				if(ff.x&gt;=i-B) break;//!! 等于时也成立 </span><br><span class="line">				else qfx.pop();//!!</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			if(!qfx.empty()) &#123;</span><br><span class="line">				F[i]=ff.f+1;</span><br><span class="line">			//	qfx.push(fx(i,F[i]));</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line">	//之前舍去的点可能对后续求F(X)有用 所以如果值不为无穷大 还需要加入队列 </span><br><span class="line">	//当要遍历下一个点时考虑把与下一点点相距2a(A)的点加入队列 </span><br><span class="line">	if(F[i+2-A]!=INFINITE) qfx.push(fx(i-A+2,F[i-A+2]));</span><br><span class="line">	&#125;</span><br><span class="line">	if( F[L] == INFINITE )</span><br><span class="line">		cout &lt;&lt; -1 &lt;&lt;endl;</span><br><span class="line">		else</span><br><span class="line">	cout &lt;&lt; F[L] &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>POJ1011 拯救少林神棍</title>
    <url>/2018/11/15/POJ1011-%E6%8B%AF%E6%95%91%E5%B0%91%E6%9E%97%E7%A5%9E%E6%A3%8D-1/</url>
    <content><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>少林寺的宝贝“少林神棍”断成了n根长短不一的小木棒，现在要把这些小木棒重新拼若干跟等长的棍子，求棍长最短是多少？<br><a id="more"></a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1，要选择简合适的搜索顺序，如果一个人物分成多步，要优先尝试可能性少的。  （优先尝试长的木棒）</p>
<p>2，要发现表面上的不同，实质上等效的重复状态，避免重复。</p>
<p>3，根据实际问题，发现剪枝方案。</p>
<p><strong>重在剪枝</strong></p>
<p>用程序解决：</p>
<p>输入：N节木棒的长度。</p>
<p>输出：能拼成的最小的棍子长度。</p>
<p>Sample Input</p>
<p>9 </p>
<p>5 2 1 5 2 1 5 2 1 </p>
<p>4 </p>
<p>1 2 3 4 </p>
<p>0</p>
<p>Sample Output</p>
<p>6 </p>
<p>5</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[MAX];</span><br><span class="line">int stick[MAX];</span><br><span class="line">int m;</span><br><span class="line">int n;</span><br><span class="line">bool cmp(int &amp;a,int &amp;b)&#123;</span><br><span class="line">	return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">//r:还没用到的木棒数目 l:仍缺少的棍子长度 返回值:能否拼成一个棍子 </span><br><span class="line">bool dfs(int r,int l)&#123;</span><br><span class="line">	if(r==0&amp;&amp;l==0) return true;</span><br><span class="line">    if(l==0) l=m;</span><br><span class="line">    int last,start=0;</span><br><span class="line">   //剪枝4：多根木棒组成一根木棍，让木棒按长度由大到小排列组成，不必搜索当前木棒比上一根木棒长的情况，因为如果此种情况可以的话</span><br><span class="line">    //只是相当于将组成情况不按长度大小排序，不按长度大小排序可成功那么按长度大小排序也可成功。</span><br><span class="line"></span><br><span class="line">    if(l!=m) start=last+1;</span><br><span class="line">	for(int i=start;i&lt;n;i++)&#123;</span><br><span class="line">		if(!vis[i]&amp;&amp;stick[i]&lt;=l) //尝试第i根木棍 </span><br><span class="line">		&#123;</span><br><span class="line">			//剪枝1：上次没拼成功，这次不尝试相同长度的木棒。</span><br><span class="line">			if(i&gt;0)&#123;</span><br><span class="line">					if(vis[i-1]==0&amp;&amp;stick[i]==stick[i-1]) continue; </span><br><span class="line">			&#125;</span><br><span class="line">			last=i;</span><br><span class="line">			vis[i]=1;</span><br><span class="line">			if(dfs(r-1,l-stick[i])) return true;//找到一个就return true  不继续尝试其他木棍 </span><br><span class="line">			else &#123;</span><br><span class="line">				////明本次不能用第i根木棒 ,即没拼成功，换下一根。</span><br><span class="line">			vis[i]=0;</span><br><span class="line">            ////剪枝2：len[i]为第一根木棒的情况下没拼成功，则这根木棒永远不能再被用上，所以不可能全部木棒被使用，</span><br><span class="line">                //后续搜索全部放弃。</span><br><span class="line">			if(l==m||l==stick[i])	 return  false;</span><br><span class="line">			//如果正在拼的棍子用的第一根木棒拼不成 剩下的木棒也不用考虑 </span><br><span class="line">		 //剪枝3：假设len[i]为最后一根木棒，被更小木棒替换后最终能够成功，那么3必然出现在后面的某个棍子k里。</span><br><span class="line">                    //将棍子k中的len[i]和棍子i中用来替换3的几根木棒对调，结果当然一样是成功的。这就和i原来的拼法会导致不成功矛盾。 </span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line">	 </span><br><span class="line">	&#125;</span><br><span class="line">		return false;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">int main()&#123;</span><br><span class="line">//	freopen(&quot;11-15.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		if(n==0) break;</span><br><span class="line">	int totalLen=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;stick[i];</span><br><span class="line">		totalLen+=stick[i];</span><br><span class="line">	&#125;</span><br><span class="line">	// 要从长到短进行尝试</span><br><span class="line">	sort(stick,stick+n,cmp);</span><br><span class="line"></span><br><span class="line">	for(m=stick[0];m&lt;=totalLen/2;m++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(totalLen%m) continue;</span><br><span class="line">		memset( vis, 0,sizeof(vis));</span><br><span class="line">		if(dfs(n,m))  &#123;</span><br><span class="line">			cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(m&gt;totalLen/2) cout&lt;&lt;totalLen&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://blog.csdn.net/tp7309/article/details/53447343" target="_blank" rel="noopener">https://blog.csdn.net/tp7309/article/details/53447343</a></p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(18)</title>
    <url>/2018/11/17/POJ1011-%E6%8B%AF%E6%95%91%E5%B0%91%E6%9E%97%E7%A5%9E%E6%A3%8D-3/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>没有完成预定的计划 刷完算法基础 给自己延迟两三天吧 感觉写过的题也要经常复习它的思路<br>因为再看一遍 发现还是有点卡壳<a id="more"></a>
</li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>起床发现越来越不规律了 大概还是要养成早睡早起的作息 有点佩服室友6点起床的自制力 </li>
<li>想开始养成回宿舍读半个小时到1个小时书的习惯 </li>
<li>放下了一些事 发现成熟就是在于之前看不开的事有那么一瞬间觉得无足轻重，然后试着去原谅，去包容 而长大的意义就在于你发现你再不是那个天真的孩子 而是去开始承担一些责任 试着每次买东西前三思而后行 平时的时候时不时地去问候 关切下父母（没有谁比你更知道他们肩上的责任与心累了）</li>
<li>一日之计在于晨 似乎有很多事都做不完 很多plan 但其实专注下来都能做完 而且会比想象得要好</li>
<li>多学习 多看书 多打代码 大半学期过去了 加油 做自己想做的事 为了以后可以不用选择自己不喜欢的职业 可以在大城市里立住脚跟 可以有机会出去见见外面的世界 享受学习的喜悦和对探索未知事物的热爱</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>算法基础(ccf简单题刷完）</li>
<li>字符串刷题(看视频)</li>
<li>找题练 每天刷3-4题 看2个视频</li>
<li>准备软件工程考试</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>POJ1505誊抄书籍</title>
    <url>/2018/11/15/POJ1011-%E6%8B%AF%E6%95%91%E5%B0%91%E6%9E%97%E7%A5%9E%E6%A3%8D/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>• 有 m 本书需要誊抄, 每本书的页数分别是 (p1, p2, …, pm)</p>
<p>• 有 k (k &lt;= m) 个抄写员负责誊抄这些书籍<br><a id="more"></a><br>• 任 务</p>
<p>• 将这些书分成 k 份, 每本书必须只分给一个抄写员</p>
<p>• 每个抄写员至少分到一本</p>
<p>• 要求每个抄写员分到的书的编号是连续的</p>
<p>• 即存在一个连续升序数列 0=b0＜b1＜b2＜…＜bk-1＜bk=m</p>
<p>这样, 第 i 号抄写员得到的书稿是从 bi-1+1 到第 bi 本书</p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxbz8s8bqnj30oj0cfqb1.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxbz8bimcjj30pa0d3qbz.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxbz7txm1oj30mn0ds0xo.jpg" alt="iamge"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxbz7caigfj30op0dpdox.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxbz6tdxp6j30n10byjvs.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxbz63pvb3j30k60e3ak5.jpg" alt="image"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m,k;</span><br><span class="line">int a[1000];</span><br><span class="line">////当前处理到第book本书, 第scriber堆, 当前堆的页数为now, 每堆页数不能超过ans</span><br><span class="line">void print(int book,int ans,int scriber,long long now)&#123;</span><br><span class="line">	bool spec=false;</span><br><span class="line">	if(book&lt;0) return;</span><br><span class="line">    //当前处理到第sriber堆，还剩book(scriber-1)本书</span><br><span class="line">    //因为每个抄写员至少分得一本 所以要新建一堆</span><br><span class="line">    //如果没有book=scriber-1这句 </span><br><span class="line">    //输出情况会是100 100/ 100 100 /100</span><br><span class="line">    //而不会有 100 / 100 /100 /100 100</span><br><span class="line">		if(book==scriber-1||now+a[book]&gt;ans)&#123;</span><br><span class="line">			print(book-1,ans,scriber-1,a[book]);</span><br><span class="line">			spec=true;</span><br><span class="line">		&#125;	</span><br><span class="line">		else print(book-1,ans,scriber,now+a[book]);</span><br><span class="line">	</span><br><span class="line">	if(book==0) printf(&quot;%d&quot;,a[book]);</span><br><span class="line">	else printf(&quot; %d&quot;,a[book]);</span><br><span class="line">	if(spec) printf(&quot; /&quot;);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">bool check(long long x)&#123;</span><br><span class="line">	long long now=0;</span><br><span class="line">	int s=0;</span><br><span class="line">	for(int i=m-1;i&gt;=0;i--)&#123;</span><br><span class="line">		if(a[i]+now&gt;x) &#123;</span><br><span class="line">			s++;</span><br><span class="line">			now=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		else now+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	if(now&gt;0) s++;//别忘了最后一堆</span><br><span class="line">	if(s&gt;k) return false;</span><br><span class="line">	else return true; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">	//m本书，k个抄写员 </span><br><span class="line">	 scanf(&quot;%d%d&quot;,&amp;m,&amp;k);</span><br><span class="line">	int sum=0;</span><br><span class="line">	long long left=0;</span><br><span class="line">	for(int i=0;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		sum+=a[i];</span><br><span class="line">		if(a[i]&gt;left) left=a[i];//!! left不能写成a[m-1]最多页的一本书不一定是最后一本 </span><br><span class="line">	&#125;</span><br><span class="line">//不能写sort(a,a+m) left=a[m-1] 这样会改变原来书的连续性 违反题意 </span><br><span class="line">	long long right=sum,ans;</span><br><span class="line">	while(left&lt;=right)&#123;</span><br><span class="line"> long long mid=(left+right)/2;</span><br><span class="line">	if(check(mid))&#123;</span><br><span class="line">		ans=mid;</span><br><span class="line">		right=mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">	else left=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">	print(m-1,left,k-1,0);	</span><br><span class="line">	cout&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>POJ2456 Aggressive cows</title>
    <url>/2018/11/01/POJ2456-Aggressive-cows/</url>
    <content><![CDATA[<p>有N个<br>牛棚在x轴上,已知他们的坐标.FJ有C只奶牛,每只都必须安排在一个牛棚里,一个牛棚只能容纳一只.但是他们会互相攻击,所以要求距离最近的两个牛棚间的距离最大.</p>
<p>2 &lt;= N &lt;= 100,000</p>
<p>0 &lt;= xi &lt;= 1,000,000,000</p>
<p>2 &lt;= C &lt;= N</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">逆向思维：</span><br><span class="line">注意问题中的“最小最大”(“最大最小”),这是使用二分求解的重要标志.</span><br><span class="line">最小最大</span><br><span class="line">最小距离为x时,放置的总牛数大于等于C</span><br><span class="line">找最大的yes(循环结束后的R)</span><br><span class="line">一个建议：如果你自己也搞不清最后结果是L还是R，可以保存满足的答案</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">int n,c; </span><br><span class="line">int a[100000];</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool isValid(int dis)&#123;</span><br><span class="line">	int last=0;</span><br><span class="line">	for(int i=1;i&lt;c;i++)</span><br><span class="line">&#123;int next=last+1;</span><br><span class="line">while(next&lt;n&amp;&amp;a[next]-a[last]&lt;dis) next++;</span><br><span class="line">if(next&gt;=n) return false;</span><br><span class="line">last=next;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125; </span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	int ans=0,mid;</span><br><span class="line">	int L=0,R=a[n-1]+1;</span><br><span class="line">	while(L&lt;=R)&#123;</span><br><span class="line">		mid=(L+R)/2; </span><br><span class="line">		if(isValid(mid))  &#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			L=mid+1; </span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			R=mid-1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fwssr8t5k2j30ea063aas.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>POJ1222 熄灯问题</title>
    <url>/2018/11/07/POJ2811-%E7%86%84%E7%81%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>问题描述<br>一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。<br><img src="http://poj.org/images/1222_1.jpg" alt="image"><br><a id="more"></a></p>
<p>在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。<br>![image](<a href="http://poj.org/images/1222_2.jpg）" target="_blank" rel="noopener">http://poj.org/images/1222_2.jpg）</a></p>
<p>请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道：</p>
<p>(1)第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次；</p>
<p>(2)各个按钮被按下的顺序对最终的结果没有影响；</p>
<p>(3)对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的灯。</p>
<p>输入数据</p>
<p>第一行是一个正整数N，表示需要解决的案例数。每个案例由5行组成，每一行包括6个数字。这些数字以空格隔开，可以是0或1。0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。</p>
<p>输出要求</p>
<p>对每个案例，首先输出一行，输出字符串“PUZZLE #m”，其中m是该案例的序号。接着按照该案例的输入格式输出5行，其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。每个数字以一个空格隔开。</p>
<p>输入样例</p>
<p>2 </p>
<p>0 1 1 0 1 0</p>
<p>1 0 0 1 1 1 </p>
<p>0 0 1 0 0 1 </p>
<p>1 0 0 1 0 1 </p>
<p>0 1 1 1 0 0 </p>
<p>0 0 1 0 1 0 </p>
<p>1 0 1 0 1 1 </p>
<p>0 0 1 0 1 1 </p>
<p>1 0 1 1 0 0 </p>
<p>0 1 0 1 0 0</p>
<p>输出样例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUZZLE #1</span><br><span class="line">1 0 1 0 0 1</span><br><span class="line">1 1 0 1 0 1</span><br><span class="line">0 0 1 0 1 1</span><br><span class="line">1 0 0 1 0 0</span><br><span class="line">0 1 0 0 0 0</span><br><span class="line">PUZZLE #2</span><br><span class="line">1 0 0 1 1 1</span><br><span class="line">1 1 0 0 0 0</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">1 1 0 1 0 1</span><br><span class="line">1 0 1 1 0 1</span><br></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>枚举第一行的按钮情况<br>第一行的按钮确定（状态A），则只有按下第二行的开关才能使第一行灯全熄灭<br>同理 第3,4,5行按钮状态也确定，对于第一行的按钮每种状态（A）判断能否使最后一行的灯是否全熄灭</p>
<p><strong>找一个局部状态去枚举</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">int puzzle[6][8];</span><br><span class="line">int press[6][8];</span><br><span class="line">bool guess()&#123;</span><br><span class="line">	int c,r;</span><br><span class="line">	for(int r=1;r&lt;5;r++)&#123;//!!</span><br><span class="line">		for(int c=1;c&lt;7;c++)&#123;</span><br><span class="line">			press[r+1][c]=(puzzle[r][c]+press[r][c]+press[r-1][c]+press[r][c-1]+press[r][c+1])%2;//!!</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	//看最后一行灯是否全熄灭</span><br><span class="line">	for(int j=1;j&lt;7;j++)&#123;</span><br><span class="line">		if(puzzle[5][j]!=(press[4][j]+press[5][j-1]+press[5][j+1]+press[5][j])%2) &#123;</span><br><span class="line">		return false;//!!!</span><br><span class="line">	</span><br><span class="line">	&#125;&#125; </span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">void enumerate()&#123;</span><br><span class="line">	int c;</span><br><span class="line">	for(c=1;c&lt;7;c++) press[1][c]=0;</span><br><span class="line">	while(guess()!=true)&#123;</span><br><span class="line">		press[1][1]++;</span><br><span class="line">		c=1;</span><br><span class="line">		while(press[1][c]&gt;1)&#123;</span><br><span class="line">			press[1][c]=0;</span><br><span class="line">			c++;</span><br><span class="line">			press[1][c]++;</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">//	freopen(&quot;25.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;7;i++) press[0][i]=0;</span><br><span class="line">	for(int j=0;j&lt;6;j++)  &#123;</span><br><span class="line">	press[j][0]= press[j][7]=0;</span><br><span class="line">	//puzzle[j][0]= puzzle[j][7]=0;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int k=0;k&lt;n;k++)&#123;</span><br><span class="line">		for(int i=1;i&lt;6;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;7;j++)&#123;</span><br><span class="line">			cin&gt;&gt;puzzle[i][j];</span><br><span class="line">		&#125; &#125;</span><br><span class="line">		enumerate();</span><br><span class="line">		cout&lt;&lt;&quot;PUZZLE #&quot;&lt;&lt;k+1&lt;&lt;endl;</span><br><span class="line">		for(int i=1;i&lt;6;i++)&#123;</span><br><span class="line">			for(int j=1;j&lt;7;j++)</span><br><span class="line">			cout&lt;&lt;press[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">			cout&lt;&lt;endl; 		</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>POJ3258 River Hopscotch</title>
    <url>/2018/11/02/POJ3258/</url>
    <content><![CDATA[<p>以条河长度为 L，河的起点(Start)和终点(End)分别有2块石头，S到E的距离就是L。</p>
<p>河中有n块石头，每块石头到S都有唯一的距离</p>
<p>问现在要移除m块石头（S和E除外），每次移除的是与当前最短距离相关联的石头，要求移除m块石头后，使得那时的最短距离尽可能大，输出那个最短距离。<br><a id="more"></a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于每个给定的距离dis 摘掉与其大于dis的石块 看摘掉的石块数量&lt;=m</p>
<p>典型的最大化最小值题</p>
<p>贪心二分的思想</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt; </span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">ll m,n,d;</span><br><span class="line">int a[100000];</span><br><span class="line">//函式明顯有單調性，相鄰石頭間的最短距離 d 越小越容易達成。</span><br><span class="line">bool check(int mid)&#123;</span><br><span class="line">	ll cnt=0;</span><br><span class="line">	int pre=0;/// 前一個石頭是誰，初使值為起點 rocks[0]</span><br><span class="line">	for(int i=1;i&lt;n+2;i++)&#123;</span><br><span class="line">		if(a[i]-a[pre]&lt;mid) cnt++;</span><br><span class="line">		else pre=i;//!!!不能写pre++ </span><br><span class="line">	&#125;</span><br><span class="line">	if(cnt&gt;m) return false;</span><br><span class="line">	else return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;d,&amp;n,&amp;m);</span><br><span class="line">		a[0]=0;</span><br><span class="line">	for(int i=1;i&lt;n+1;i++)&#123;//!!!</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	a[n+1]=d;</span><br><span class="line"></span><br><span class="line">	sort(a,a+n+2);</span><br><span class="line">// for(int i=0;i&lt;n+2;i++)</span><br><span class="line">//	cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	int L,R,ans=0;</span><br><span class="line">	L=0;</span><br><span class="line">	R=d;</span><br><span class="line">	while(L&lt;=R)&#123;</span><br><span class="line">		int mid=(L+R)/2;</span><br><span class="line">		if(check(mid))&#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			L=mid+1;</span><br><span class="line">		&#125;</span><br><span class="line">		else R=mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可参考</p>
<p><a href="http://www.hankcs.com/program/cpp/poj-3258-river-hopscotch.html" target="_blank" rel="noopener">http://www.hankcs.com/program/cpp/poj-3258-river-hopscotch.html</a></p>
<p><a href="https://amoshyc.github.io/ojsolution-build/poj/p3258.html" target="_blank" rel="noopener">https://amoshyc.github.io/ojsolution-build/poj/p3258.html</a></p>
]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ3232 Acclerator</title>
    <url>/2018/11/02/POJ3232-Acclerator/</url>
    <content><![CDATA[<p>有一个含有n辆车的车队，当前距离终点的距离已知，有m个加速器，每个加速器在一个时刻只能给一辆车用，一旦使用就会使得其速度由1变成k，加速器可以重复使用，问最快所有车辆到达终点的时间。</p>
<p>思路：二分枚举所需的最短时间。<br><a id="more"></a><br>对于1辆车要用num个加速器<br>num*k+(ans-num)&gt;=a[i]</p>
<p>num&gt;=(a[i)-ans)/(k-1)</p>
<p>限制条件</p>
<p>1.加速器最多使用次数ans*m;</p>
<p>2.对于每辆车而言单位时间内只能用一次加速器 所以num&lt;=ans</p>
<p>3.题意 单位时间内只能有m个加速器，由1.2知条件3成立</p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fwtkylvchij30is0afq81.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef long long LL;</span><br><span class="line">LL n,m,k,left,right;</span><br><span class="line">LL a[100000];</span><br><span class="line">using namespace std;</span><br><span class="line">bool check(LL ans) &#123;</span><br><span class="line">	LL sum=ans*m;</span><br><span class="line">	LL num;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(a[i]&lt;=ans) num=0;</span><br><span class="line">		else&#123;</span><br><span class="line">			if((a[i]-ans)%(k-1)==0)</span><br><span class="line">			num=(a[i]-ans)/(k-1);</span><br><span class="line">			else//注意整除不了的时候 还要用1个加速器 </span><br><span class="line">			num=(a[i]-ans)/(k-1)+1;		</span><br><span class="line">			if(num&gt;ans) return false;	</span><br><span class="line">			sum-=num;</span><br><span class="line">			if(sum&lt;0) return false;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;m,&amp;k);</span><br><span class="line">	LL maxn=-1;</span><br><span class="line">	LL t=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	maxn=max(maxn,a[i]);</span><br><span class="line">	if(k==1) &#123;</span><br><span class="line">		printf(&quot;%d\n&quot;,maxn);</span><br><span class="line">		continue;//!!!</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">	</span><br><span class="line">	LL left=0,right=maxn;</span><br><span class="line">	while(left&lt;=right)&#123;</span><br><span class="line">		LL mid=(left+right)/2;</span><br><span class="line">		if(check(mid)) &#123;</span><br><span class="line">			t=mid;</span><br><span class="line">			right=mid-1;</span><br><span class="line">		&#125;</span><br><span class="line">		else left=mid+1;</span><br><span class="line">	&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始一直Time Limit Exceeded<br>对比了网上的代码 发现逻辑基本差不多（<a href="https://www.cnblogs.com/fanminghui/p/3993539.html）" target="_blank" rel="noopener">https://www.cnblogs.com/fanminghui/p/3993539.html）</a></p>
<p>后来偶然看到<a href="https://blog.csdn.net/barry283049/article/details/42679317" target="_blank" rel="noopener">https://blog.csdn.net/barry283049/article/details/42679317</a> 把cin,cout全部替换后accepted！</p>
<h2 id="time-limited-可能的原因"><a href="#time-limited-可能的原因" class="headerlink" title="time limited 可能的原因"></a>time limited 可能的原因</h2><ul>
<li>检查一下什么地方在什么数据下出现了死循环</li>
<li>否则还是考虑换个思路解题的好。TLE除了死循环就是算法问题。</li>
</ul>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>POJ3273 Monthly Expense</title>
    <url>/2018/11/02/POJ3273-Monthly-Expense/</url>
    <content><![CDATA[<p>分期：将N个账款分割成M个财务期，使得每个分期账款和的最大值最小。<br><a id="more"></a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>bool C(int d) = 分解成 M 個區間後，最大的區間和 s &lt;= d<br>盡量把一個區間的值塞滿，直到塞不下。<br>也就是說，從左至右迭代 A[i]，如果前一個區間的總和再加上 A[i] 會大於 d 的話，<br>則 A[i] 就是下個區間的起始點。最後看區間的數量是否 &lt;= M</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt; </span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">ll m,n,d;</span><br><span class="line">int a[100000];</span><br><span class="line">//bool check(int mid)&#123;</span><br><span class="line">//	ll cnt=1;</span><br><span class="line">//	int sum=0;</span><br><span class="line">//	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">//		sum+=a[i];</span><br><span class="line">//		if(sum&gt;mid) &#123;</span><br><span class="line">//			cnt++;</span><br><span class="line">//			sum=a[i];</span><br><span class="line">//		&#125;</span><br><span class="line">//		if(cnt&gt;m) return false;</span><br><span class="line">//	&#125;</span><br><span class="line">//	return true;</span><br><span class="line">//&#125;</span><br><span class="line">bool check(int mid)&#123;</span><br><span class="line">	ll cnt=1;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">        if (a[i] &gt; mid)</span><br><span class="line">            return false;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	</span><br><span class="line">		if(sum+a[i]&gt;mid) &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			sum=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		else 	sum+=a[i];</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	if(cnt&gt;m) return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;//!!!</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//	sort(a,a+n); 不用排序 连续挑选月份 </span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	int L,R,ans=0;</span><br><span class="line">	L=0;</span><br><span class="line">	R=sum;</span><br><span class="line">	while(L&lt;=R)&#123;</span><br><span class="line">		int mid=(L+R)/2;</span><br><span class="line">		if(check(mid))&#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			R=mid-1;</span><br><span class="line">		&#125;</span><br><span class="line">		else L=mid+1;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>Python numpy中np_r和np_c</title>
    <url>/2018/09/10/Python-numpy%E4%B8%ADnp-r%E5%92%8Cnp-c/</url>
    <content><![CDATA[<p>np.r_是按行连接两个矩阵，就是把两矩阵上下相加，要求行数相等，类似于pandas中的concat()</p>
<p>np.c_是按列连接两个矩阵，就是把两矩阵左右相加，要求列数相等，类似于pandas中的merge()<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"> </span><br><span class="line">def test():</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    numpy函数np.c_和np.r_学习使用</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    data_list1=[4,6,12,6,0,3,7]</span><br><span class="line">    data_list2=[1,5,2,65,6,7,3]</span><br><span class="line">    data_list3=[1,5,2,65,6,6,8]</span><br><span class="line">    print u&apos;np.r_  data_list1和data_list2合并&apos;</span><br><span class="line">    print np.r_[data_list1,data_list2]</span><br><span class="line">    print u&apos;np.r_  data_list1和data_list3合并&apos;</span><br><span class="line">    print np.r_[data_list1,data_list3]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    print u&apos;np.c_ data_list1和data_list2合并&apos;</span><br><span class="line">    print np.c_[data_list1,data_list2]</span><br><span class="line">    print u&apos;np.c_ data_list1和data_list3合并&apos;</span><br><span class="line">    print np.c_[data_list1,data_list3]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">	test()</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fv47c4oq4rj30bj0awweo.jpg" alt></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>Python中获得当前目录和上级目录</title>
    <url>/2018/06/07/Python%E4%B8%AD%E8%8E%B7%E5%BE%97%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E5%92%8C%E4%B8%8A%E7%BA%A7%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>在使用python的时候总会遇到路径切换的使用情况，如想从文件夹test下的test.py调用data文件夹下的data.txt文件：<br><a id="more"></a></p>
<p>.<br>└── folder<br>    ├── data<br>    │   └── data.txt<br>    └── test<br>        └── test.py</p>
<p>一种方法可以在data文件下加入<strong>init</strong>.py 然后在test.py 中import data 就可以调用data.txt文件；</p>
<p>另一种方法可以借助python os模块<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">print &apos;***获取当前目录***&apos;</span><br><span class="line">print os.getcwd()</span><br><span class="line">print os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"></span><br><span class="line">print &apos;***获取上级目录***&apos;</span><br><span class="line">print os.path.abspath(os.path.dirname(os.path.dirname(__file__)))</span><br><span class="line">print os.path.abspath(os.path.dirname(os.getcwd()))</span><br><span class="line">print os.path.abspath(os.path.join(os.getcwd(), &quot;..&quot;))</span><br><span class="line"></span><br><span class="line">print &apos;***获取上上级目录***&apos;</span><br><span class="line">print os.path.abspath(os.path.join(os.getcwd(), &quot;../..&quot;))</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>tensorFlow 图像翻转，图像色彩调整</title>
    <url>/2018/05/07/TensorFlow-%E5%9B%BE%E5%83%8F%E7%BF%BB%E8%BD%AC%EF%BC%8C%E5%9B%BE%E5%83%8F%E8%89%B2%E5%BD%A9%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<h2 id="图像翻转"><a href="#图像翻转" class="headerlink" title="图像翻转"></a>图像翻转</h2><p>tf.image.flip_up_down：上下翻转<br>tf.image.flip_left_right：左右翻转<br>tf.image.transpose_image：对角线翻转<br>除此之外，TensorFlow还提供了随机翻转的函数，保证了样本的样本的随机性：<br>tf.image.random_flip_up_down：随机上下翻转图片<br>tf.image.random_flip_left_right：随机左右翻转图片<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">image_raw_data = tf.gfile.FastGFile(&quot;C:/Users/admin/Desktop/fish-bike.jpg&quot;,&quot;r&quot;).read();</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    img_data = tf.image.decode_jpeg(image_raw_data)</span><br><span class="line">    plt.imshow(img_data.eval())</span><br><span class="line">    plt.show()</span><br><span class="line">     # 上下翻转</span><br><span class="line">    flipped1 = tf.image.flip_up_down(img_data)</span><br><span class="line">    plt.imshow(flipped1.eval())</span><br><span class="line">    plt.show()</span><br><span class="line">    # 左右翻转</span><br><span class="line">    flipped2 = tf.image.flip_left_right(img_data)</span><br><span class="line">    plt.imshow(flipped2.eval())</span><br><span class="line">    plt.show()</span><br><span class="line">    #对角线翻转</span><br><span class="line">    transposed = tf.image.transpose_image(img_data)</span><br><span class="line">    plt.imshow(transposed.eval())</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p>
<h2 id="图像色彩调整"><a href="#图像色彩调整" class="headerlink" title="图像色彩调整"></a>图像色彩调整</h2><p>f.image.adjust_brightness：调整图片亮度<br>tf.image.random_brightness：在某范围随机调整图片亮度<br>对比度：<br>tf.image.adjust_contrast：调整图片对比度<br>tf.image.random_contrast：在某范围随机调整图片对比度<br>色相：<br>tf.image.adjust_hue：调整图片色相<br>tf.image.random_hue：在某范围随机调整图片色相<br>饱和度：<br>tf.image.adjust_saturation：调整图片饱和度<br>tf.image.random_saturation：在某范围随机调整图片饱和度<br>归一化：<br>per_image_standardization：三维矩阵中的数字均值变为0，方差变为1。在以前的版本中，它其实叫做per_image_whitening，也就是白化操作。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">image_raw_data = tf.gfile.FastGFile(&quot;C:/Users/admin/Desktop/fish-bike.jpg&quot;,&quot;r&quot;).read();</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">     img_data = tf.image.decode_jpeg(image_raw_data)</span><br><span class="line">     plt.imshow(img_data.eval())</span><br><span class="line">     plt.show()</span><br><span class="line"></span><br><span class="line">     # 将图片的亮度-0.5。</span><br><span class="line">     adjusted = tf.image.adjust_brightness(img_data, -0.5)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()</span><br><span class="line"></span><br><span class="line">     # 将图片的亮度0.5</span><br><span class="line">     adjusted = tf.image.adjust_brightness(img_data, 0.5)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()</span><br><span class="line">     # 在[-max_delta, max_delta)的范围随机调 整图片的亮度。</span><br><span class="line">     adjusted = tf.image.random_brightness(img_data, max_delta=0.5)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()</span><br><span class="line">     # 将图片的对比度-5</span><br><span class="line">     adjusted = tf.image.adjust_contrast(img_data, -5)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()</span><br><span class="line">     # 将图片的对比度+5</span><br><span class="line">     adjusted = tf.image.adjust_contrast(img_data, 5)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()</span><br><span class="line">     # 在[lower, upper]的范围随机调整图的对比度。</span><br><span class="line">     adjusted = tf.image.random_contrast(img_data, 0.1, 0.6)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()</span><br><span class="line"></span><br><span class="line">     #调整图片的色相</span><br><span class="line">     adjusted = tf.image.adjust_hue(img_data, 0.1)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()</span><br><span class="line"></span><br><span class="line">     # 在[-max_delta, max_delta]的范围随机调整图片的色相。max_delta的取值在[0, 0.5]之间。</span><br><span class="line">     adjusted = tf.image.random_hue(img_data, 0.5)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     # 将图片的饱和度-5。</span><br><span class="line">     adjusted = tf.image.adjust_saturation(img_data, -5)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     # 在[lower, upper]的范围随机调整图的饱和度。</span><br><span class="line">     adjusted = tf.image.random_saturation(img_data, 0, 5)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()  </span><br><span class="line"></span><br><span class="line">     # 将代表一张图片的三维矩阵中的数字均值变为0，方差变为1。</span><br><span class="line">     adjusted = tf.image.per_image_standardization(img_data)</span><br><span class="line">     plt.imshow(adjusted.eval())</span><br><span class="line">     plt.show()</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>图像预处理</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu上Caffe的安装及配置</title>
    <url>/2018/05/23/Ubuntu%E4%B8%8ACaffe%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-安装依赖项"><a href="#1-安装依赖项" class="headerlink" title="1.安装依赖项"></a>1.安装依赖项</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler</span><br><span class="line">sudo apt-get install --no-install-recommends libboost-all-dev</span><br><span class="line">sudo apt-get install libopenblas-dev liblapack-dev libatlas-base-dev</span><br><span class="line">sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2-安装必要的库"><a href="#2-安装必要的库" class="headerlink" title="2.安装必要的库"></a>2.安装必要的库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev  </span><br><span class="line">sudo apt-get install libatlas-base-dev</span><br></pre></td></tr></table></figure>
<h2 id="3-下载caffe"><a href="#3-下载caffe" class="headerlink" title="3.下载caffe"></a>3.下载caffe</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~   </span><br><span class="line">git clone https://github.com/BVLC/caffe.git #克隆caffe到本地,并命名为caffe</span><br></pre></td></tr></table></figure>
<h2 id="4-配置caffe"><a href="#4-配置caffe" class="headerlink" title="4.配置caffe"></a>4.配置caffe</h2><h3 id="4-1生成Makefile-config文件"><a href="#4-1生成Makefile-config文件" class="headerlink" title="4.1生成Makefile.config文件"></a>4.1生成Makefile.config文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd caffe/</span><br><span class="line">cp Makefile.config.example Makefile.config</span><br></pre></td></tr></table></figure>
<h3 id="4-2修改Makefile-config文件中的配置"><a href="#4-2修改Makefile-config文件中的配置" class="headerlink" title="4.2修改Makefile.config文件中的配置"></a>4.2修改Makefile.config文件中的配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit Makefile.config</span><br><span class="line">#第一步</span><br><span class="line">#去掉CPU_ONLY:=1的注释</span><br><span class="line"></span><br><span class="line">#第二步</span><br><span class="line">#将下面第一行代码改为第二行代码</span><br><span class="line">#INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include</span><br><span class="line"></span><br><span class="line">#INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial/</span><br></pre></td></tr></table></figure>
<h2 id="5-编译caffe"><a href="#5-编译caffe" class="headerlink" title="5.编译caffe"></a>5.编译caffe</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make all</span><br><span class="line"></span><br><span class="line">make pycaffe</span><br><span class="line"></span><br><span class="line">make distribute</span><br><span class="line"></span><br><span class="line">make test</span><br></pre></td></tr></table></figure>
<p><strong>若出现错误“fatal error: hdf5.h: 没有那个文件或目录”，4.1.2中第二步为解决方法。</strong></p>
<h2 id="6-配置caffe的pyhton接口pycaffe"><a href="#6-配置caffe的pyhton接口pycaffe" class="headerlink" title="6.配置caffe的pyhton接口pycaffe"></a>6.配置caffe的pyhton接口pycaffe</h2><h3 id="6-1安装接口依赖库"><a href="#6-1安装接口依赖库" class="headerlink" title="6.1安装接口依赖库"></a>6.1安装接口依赖库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br><span class="line">sudo atp-get install python-dev python-numpy</span><br><span class="line">sudo apt-get install gfortran</span><br><span class="line"> </span><br><span class="line">sudo pip install –r python/requirements.txt</span><br><span class="line">sudo pip install pydot</span><br><span class="line">numpy scipy matplotlib sklearn skimage h5py protobuf leveldb networkx nose pandas gflags cython ipython gfortran</span><br></pre></td></tr></table></figure>
<h3 id="验证"><a href="#验证" class="headerlink" title="# 验证"></a># 验证</h3><p>安装结束后，可以执行如下语句验证：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install -r requirements.txt</span><br></pre></td></tr></table></figure></p>
<p>如果显示<code>Requirement already satisfied</code>，则安装成功，否则会继续进行安装。</p>
<h3 id="6-2将caffe根目录下的python文件夹加入到环境变量中"><a href="#6-2将caffe根目录下的python文件夹加入到环境变量中" class="headerlink" title="6.2将caffe根目录下的python文件夹加入到环境变量中"></a>6.2将caffe根目录下的python文件夹加入到环境变量中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line">export PYTHONPATH=/usr/caffe/python:$PYTHONPATH</span><br><span class="line">#在打开的文档中加入以下代码</span><br><span class="line">export PYTHONPATH=/home/dlnu/caffe/python:$PYTHONPATH</span><br><span class="line"></span><br><span class="line">#执行更新配置</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<h3 id="6-3编译Python接口"><a href="#6-3编译Python接口" class="headerlink" title="6.3编译Python接口"></a>6.3编译Python接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/caffe/</span><br><span class="line">sudo make pycaffe</span><br></pre></td></tr></table></figure>
<p>如果出现找不到numpy/arrayobject.h这种问题，则检查Makefile.config文件中的PYTHON路径（Python.h、<br>    numpy/arrayobject.h的路径）：<br>    PYTHON_INCLUDE := /usr/include/python2.7  /usr/lib/python2.7/dist-packages/numpy/core/include</p>
<h3 id="6-4验证python接口-进行python环境，引入caffe包，如果没有报错，则安装成功！"><a href="#6-4验证python接口-进行python环境，引入caffe包，如果没有报错，则安装成功！" class="headerlink" title="6.4验证python接口 进行python环境，引入caffe包，如果没有报错，则安装成功！"></a>6.4验证python接口 进行python环境，引入caffe包，如果没有报错，则安装成功！</h3><p>参考链接<br><a href="https://blog.csdn.net/losteng/article/details/50809753" target="_blank" rel="noopener">https://blog.csdn.net/losteng/article/details/50809753</a><br><a href="https://blog.csdn.net/u010167269/article/details/50703923" target="_blank" rel="noopener">https://blog.csdn.net/u010167269/article/details/50703923</a></p>
]]></content>
      <categories>
        <category>环境安装配置</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu下如何解压缩zip,tar,tar.gz,tar.bz2文件</title>
    <url>/2018/05/20/Ubuntu%E4%B8%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%8E%8B%E7%BC%A9zip-tar-tar-gz-tar-bz2%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>通过SSH访问服务器，难免会要用到压缩，解压缩，打包，解包等，这时候tar命令就是是必不可少的一个功能强大的工具。linux中最流行的tar是麻雀虽小，五脏俱全，功能强大。<br><a id="more"></a><br>tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。</p>
<p>首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p>
<p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p>
<p>linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。</p>
<p>1．命令格式：</p>
<p>tar[必要参数][选择参数][文件] </p>
<p>2．命令功能：</p>
<p>用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的 </p>
<p>3．命令参数：</p>
<p>必要参数有如下：</p>
<p>-A 新增压缩文件到已存在的压缩</p>
<p>-B 设置区块大小</p>
<p>-c 建立新的压缩文件</p>
<p>-d 记录文件的差别</p>
<p>-r 添加文件到已经压缩的文件</p>
<p>-u 添加改变了和现有的文件到已经存在的压缩文件</p>
<p>-x 从压缩的文件中提取文件</p>
<p>-t 显示压缩文件的内容</p>
<p>-z 支持gzip解压文件</p>
<p>-j 支持bzip2解压文件</p>
<p>-Z 支持compress解压文件</p>
<p>-v 显示操作过程</p>
<p>-l 文件系统边界设置</p>
<p>-k 保留原有文件不覆盖</p>
<p>-m 保留文件不被覆盖</p>
<p>-W 确认压缩文件的正确性</p>
<p>可选参数如下：</p>
<p>-b 设置区块数目</p>
<p>-C 切换到指定目录</p>
<p>-f 指定压缩文件</p>
<p>–help 显示帮助信息</p>
<p>–version 显示版本信息</p>
<p>4．常见解压/压缩命令</p>
<p>tar </p>
<p>解包：tar xvf FileName.tar</p>
<p>打包：tar cvf FileName.tar DirName<br>（注：tar是打包，不是压缩！）</p>
<p>.gz</p>
<p>解压1：gunzip FileName.gz</p>
<p>解压2：gzip -d FileName.gz</p>
<p>压缩：gzip FileName</p>
<p>.tar.gz 和 .tgz</p>
<p>解压：tar zxvf FileName.tar.gz</p>
<p>压缩：tar zcvf FileName.tar.gz DirName</p>
<p>.bz2</p>
<p>解压1：bzip2 -d FileName.bz2</p>
<p>解压2：bunzip2 FileName.bz2</p>
<p>压缩： bzip2 -z FileName</p>
<p>.tar.bz2</p>
<p>解压：tar jxvf FileName.tar.bz2</p>
<p>压缩：tar jcvf FileName.tar.bz2 DirName</p>
<p>.bz</p>
<p>解压1：bzip2 -d FileName.bz</p>
<p>解压2：bunzip2 FileName.bz</p>
<p>压缩：未知</p>
<p>.tar.bz</p>
<p>解压：tar jxvf FileName.tar.bz</p>
<p>压缩：未知</p>
<p>.Z</p>
<p>解压：uncompress FileName.Z</p>
<p>压缩：compress FileName</p>
<p>.tar.Z</p>
<p>解压：tar Zxvf FileName.tar.Z</p>
<p>压缩：tar Zcvf FileName.tar.Z DirName</p>
<p>.zip</p>
<p>解压：unzip FileName.zip</p>
<p>压缩：zip FileName.zip DirName</p>
<p>.rar</p>
<p>解压：rar x FileName.rar</p>
<p>压缩：rar a FileName.rar DirName </p>
<p>5．使用实例</p>
<p>实例1：将文件全部打包成tar包</p>
<p>命令：</p>
<p>tar -cvf log.tar log2012.log</p>
<p>tar -zcvf log.tar.gz log2012.log</p>
<p>tar -jcvf log.tar.bz2 log2012.log</p>
<p>输出：</p>
<p>[root@localhost test]# ls -al log2012.log</p>
<p>—xrw-r– 1 root root 302108 11-13 06:03 log2012.log</p>
<p>[root@localhost test]# tar -cvf log.tar log2012.log </p>
<p>log2012.log</p>
<p>[root@localhost test]# tar -zcvf log.tar.gz log2012.log</p>
<p>log2012.log</p>
<p>[root@localhost test]# tar -jcvf log.tar.bz2 log2012.log </p>
<p>log2012.log</p>
<p>[root@localhost test]# ls -al <em>.tar</em></p>
<p>-rw-r–r– 1 root root 307200 11-29 17:54 log.tar</p>
<p>-rw-r–r– 1 root root   1413 11-29 17:55 log.tar.bz2</p>
<p>-rw-r–r– 1 root root   1413 11-29 17:54 log.tar.gz</p>
<p>说明：</p>
<p>tar -cvf log.tar log2012.log    仅打包，不压缩！ </p>
<p>tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 </p>
<p>tar -zcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 </p>
<p>在参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包； 如果加 j 参数，则以 .tar.bz2 来作为tar包名。</p>
<p>实例2：查阅上述 tar包内有哪些文件</p>
<p>命令：</p>
<p>tar -ztvf log.tar.gz</p>
<p>输出：</p>
<p>[root@localhost test]# tar -ztvf log.tar.gz</p>
<p>—xrw-r– root/root    302108 2012-11-13 06:03:25 log2012.log</p>
<p>说明：</p>
<p>由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上 z 这个参数了。</p>
<p>实例3：将tar 包解压缩</p>
<p>命令：</p>
<p>tar -zxvf /opt/soft/test/log.tar.gz</p>
<p>输出：</p>
<p>[root@localhost test3]# ll</p>
<p>总计 0[root@localhost test3]# tar -zxvf /opt/soft/test/log.tar.gz</p>
<p>log2012.log</p>
<p>[root@localhost test3]# ls</p>
<p>log2012.log</p>
<p>[root@localhost test3]#</p>
<p>说明：</p>
<p>在预设的情况下，我们可以将压缩档在任何地方解开的</p>
<p>实例4：只将 /tar 内的 部分文件解压出来</p>
<p>命令：</p>
<p>tar -zxvf /opt/soft/test/log30.tar.gz log2013.log</p>
<p>输出：</p>
<p>[root@localhost test]# tar -zcvf log30.tar.gz log2012.log log2013.log </p>
<p>log2012.log</p>
<p>log2013.log</p>
<p>[root@localhost test]# ls -al log30.tar.gz </p>
<p>-rw-r–r– 1 root root 1512 11-30 08:19 log30.tar.gz</p>
<p>[root@localhost test]# tar -zxvf log30.tar.gz log2013.log</p>
<p>log2013.log</p>
<p>[root@localhost test]# ll</p>
<p>-rw-r–r– 1 root root   1512 11-30 08:19 log30.tar.gz</p>
<p>[root@localhost test]# cd test3</p>
<p>[root@localhost test3]# tar -zxvf /opt/soft/test/log30.tar.gz log2013.log</p>
<p>log2013.log</p>
<p>[root@localhost test3]# ll</p>
<p>总计 4</p>
<p>-rw-r–r– 1 root root 61 11-13 06:03 log2013.log</p>
<p>[root@localhost test3]#</p>
<p>说明：</p>
<p>我可以透过 tar -ztvf 来查阅 tar 包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！</p>
<p>实例5：文件备份下来，并且保存其权限</p>
<p>命令：</p>
<p>tar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log </p>
<p>输出：</p>
<p>[root@localhost test]# ll</p>
<p>总计 0</p>
<p>-rw-r–r– 1 root root      0 11-13 06:03 log2014.log</p>
<p>-rw-r–r– 1 root root      0 11-13 06:06 log2015.log</p>
<p>-rw-r–r– 1 root root      0 11-16 14:41 log2016.log</p>
<p>[root@localhost test]# tar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log </p>
<p>log2014.log</p>
<p>log2015.log</p>
<p>log2016.log</p>
<p>[root@localhost test]# cd test6</p>
<p>[root@localhost test6]# ll</p>
<p>[root@localhost test6]# tar -zxvpf /opt/soft/test/log31.tar.gz </p>
<p>log2014.log</p>
<p>log2015.log</p>
<p>log2016.log</p>
<p>[root@localhost test6]# ll</p>
<p>总计 0</p>
<p>-rw-r–r– 1 root root 0 11-13 06:03 log2014.log</p>
<p>-rw-r–r– 1 root root 0 11-13 06:06 log2015.log</p>
<p>-rw-r–r– 1 root root 0 11-16 14:41 log2016.log</p>
<p>[root@localhost test6]#</p>
<p>说明：</p>
<p>这个 -p 的属性是很重要的，尤其是当您要保留原本文件的属性时</p>
<p>实例6：在 文件夹当中，比某个日期新的文件才备份</p>
<p>命令：</p>
<p>tar -N “2012/11/13” -zcvf log17.tar.gz test</p>
<p>输出：</p>
<p>[root@localhost soft]# tar -N “2012/11/13” -zcvf log17.tar.gz test</p>
<p>tar: Treating date `2012/11/13’ as 2012-11-13 00:00:00 + 0 nanoseconds</p>
<p>test/test/log31.tar.gz</p>
<p>test/log2014.log</p>
<p>test/linklog.log</p>
<p>test/log2015.log</p>
<p>test/log2013.log</p>
<p>test/log2012.log</p>
<p>test/log2017.log</p>
<p>test/log2016.log</p>
<p>test/log30.tar.gz</p>
<p>test/log.tar</p>
<p>test/log.tar.bz2</p>
<p>test/log.tar.gz</p>
<p>说明：</p>
<p>实例7：备份文件夹内容是排除部分文件</p>
<p>命令：</p>
<p>tar –exclude scf/service -zcvf scf.tar.gz scf/*</p>
<p>输出：</p>
<p>[root@localhost test]# tree scf</p>
<p>scf</p>
<p>|– bin</p>
<p>|– doc</p>
<p>|– lib</p>
<p>`– service</p>
<pre><code>`-- deploy

        |-- info

        `-- product
</code></pre><p>7 directories, 0 files</p>
<p>[root@localhost test]# tar –exclude scf/service -zcvf scf.tar.gz scf/* </p>
<p>scf/bin/</p>
<p>scf/doc/</p>
<p>scf/lib/</p>
<p>参考链接：<a href="https://blog.csdn.net/zhongnanjun_3/article/details/6312678" target="_blank" rel="noopener">https://blog.csdn.net/zhongnanjun_3/article/details/6312678</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu设置和查看环境变量</title>
    <url>/2018/05/20/Ubuntu%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><p>env</p>
<p>env命令是environment的缩写，用于列出所有的环境变量<br><a id="more"></a></p>
<p>export</p>
<p>单独使用export命令也可以像env列出所有的环境变量，不过export命令还有其他额外的功能</p>
<p>echo $PATH</p>
<p>echo $PATH用于列出变量PATH的值，里面包含了已添加的目录</p>
<h2 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h2><h3 id="把你的路径加入PATH"><a href="#把你的路径加入PATH" class="headerlink" title="把你的路径加入PATH"></a>把你的路径加入PATH</h3><p>这种方法需要注意路径的顺序，如果遇到有同名的命令，那么PATH里面哪个目录先被查询，则那个目录下的命令就会被先执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 加到PATH末尾</span><br><span class="line">export PATH=$PATH:/path/to/your/dir</span><br><span class="line"></span><br><span class="line"># 加到PATH开头</span><br><span class="line">export PATH=/path/to/your/dir:$PATH</span><br></pre></td></tr></table></figure>
<p>可以在此文件末尾加入PATH的设置如下：<br>export PATH=”$PATH:your path1:your path2 …” </p>
<h3 id="命名一个新的环境变量"><a href="#命名一个新的环境变量" class="headerlink" title="命名一个新的环境变量"></a>命名一个新的环境变量</h3><p>直接命名一个新的环境变量，用于其它程序引用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export VAR_NAME=value</span><br></pre></td></tr></table></figure></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="用于当前终端"><a href="#用于当前终端" class="headerlink" title="用于当前终端"></a>用于当前终端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CLASS_PATH=./JAVA_HOME/lib:$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure>
<h3 id="用于当前用户"><a href="#用于当前用户" class="headerlink" title="用于当前用户"></a>用于当前用户</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>添加语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure></p>
<p>注销或者重启可以使修改生效，如果要使添加的环境变量马上生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="用于所有用户"><a href="#用于所有用户" class="headerlink" title="用于所有用户"></a>用于所有用户</h3><p>要使环境变量对所有用户有效，可以修改profile文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>添加语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3215628-ebb9a88905b45465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/543" alt="image"></p>
<p>注销或者重启可以使修改生效，如果要使添加的环境变量马上生效<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>1.如果是系统已有变量，如PATH，那么采用例2的连接方法。用$PATH调用已有的设置，一个冒号后添加自己的路径，如果不连接原来的$PATH，那么PATH被覆盖，后果很严重。</p>
<p>2.变量名和变量值之间的等号=两侧不能有空格，否则报错！</p>
<p>3。等号右侧的变量值可以加双引号也可以不加</p>
<p>4.执行source .bashrc或source .profile更新系统设置。调用echo $JAVA_HOME或echo$PATH查看更新效果！</p>
<p>参考链接</p>
<p><a href="https://blog.csdn.net/cnctloveyu/article/details/5075128" target="_blank" rel="noopener">https://blog.csdn.net/cnctloveyu/article/details/5075128</a></p>
<p><a href="https://blog.csdn.net/lixiaoguang20/article/details/53814020" target="_blank" rel="noopener">https://blog.csdn.net/lixiaoguang20/article/details/53814020</a></p>
<p><a href="https://blog.csdn.net/netwalk/article/details/9455893" target="_blank" rel="noopener">https://blog.csdn.net/netwalk/article/details/9455893</a></p>
<p><a href="https://my.oschina.net/qinlinwang/blog/30471" target="_blank" rel="noopener">https://my.oschina.net/qinlinwang/blog/30471</a></p>
<p>`</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Unable to determine SOCKS version from socks://127.0.0.1:1080/</title>
    <url>/2018/05/22/Unable-to-determine-SOCKS-version-from-socks-127-0-0-1-1080/</url>
    <content><![CDATA[<p>Unable to determine SOCKS version from socks://127.0.0.1:1080/</p>
<p>File “/home/dlnu/.virtualenvs/python2.7/local/lib/python2.7/site-packages/pip/_vendor/requests/packages/urllib3/contrib/socks.py”, line 154, in <strong>init</strong><br>    “Unable to determine SOCKS version from %s” % proxy_url<br>ValueError: Unable to determine SOCKS version from socks://127.0.0.1:1080/<br><a id="more"></a><br>解决方案一(分为两种场景)：<br>——————–场景一，google能上，pip不能用————————————————-<br>连接google时</p>
<p>sslocal -c /etc/shadowsocks.json -d start<br>chmod 777 /var/run/shadowsocks.pid<br>开启network-manager中的手动代理（也就是等效于/etc/environment中增加socks_proxy=”socks://127.0.0.1:1080/“），<br>再重启终端，此时pip失效<br>会报错<br>ValueError: Unable to determine SOCKS version from socks://127.0.0.1:1080/</p>
<p>——————–场景二，pip能用，google不能上————————————————-<br>如果要修复pip，那么可以让代理先失效，办法是：<br>network-manager中的代理改为“无”（也就是等效于/etc/environment中删除socks_proxy=”socks://127.0.0.1:1080/“），然后注销重新登录系统即可</p>
<p>所以解决方案一就是来回在两种场景中切换，十分麻烦。</p>
<p>解决方案二：<br>在shadowsocks生效的情况下<br>删除~/.pip下面的pip.conf文件即可<br>因为这个时候已经是在访问国外的网站了，所以删除pip.conf,pip就会使用默认的pypi.python.org/simple了</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>python学习笔记(七)</title>
    <url>/2020/02/04/Untitled-1/</url>
    <content><![CDATA[<h2 id="求两具体日期间差的天数"><a href="#求两具体日期间差的天数" class="headerlink" title="求两具体日期间差的天数"></a>求两具体日期间差的天数</h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">month=[0,31,28,31,30,31,30,31,31,30,31,30,31]</span><br><span class="line">def isLeap(year):</span><br><span class="line">    if year%4==0 and year%100!=0 or year%400!=0:</span><br><span class="line">        return 1</span><br><span class="line">    return 0</span><br><span class="line">day1=int(input())</span><br><span class="line">day2=int(input())</span><br><span class="line">y1=day1//10000</span><br><span class="line">m1=day1//100%100</span><br><span class="line">d1=day1%100</span><br><span class="line">y2=day2//10000</span><br><span class="line">m2=day2//100%100</span><br><span class="line">d2=day2%100</span><br><span class="line">ans=0</span><br><span class="line"># if day1&lt;day2:</span><br><span class="line">#     swap(day1,day2)</span><br><span class="line">while y1&lt;y2 or m1&lt;m2 or d1&lt;d2:</span><br><span class="line">    d1+=1</span><br><span class="line">    if isLeap(y1):</span><br><span class="line">        month[2]=29</span><br><span class="line">    else:</span><br><span class="line">        month[2]=28</span><br><span class="line">    if d1==month[m1]+1:</span><br><span class="line">        m1+=1</span><br><span class="line">        d1=1</span><br><span class="line">    if m1==13:</span><br><span class="line">        y1+=1</span><br><span class="line">        m1=1</span><br><span class="line">    ans+=1</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>
<h2 id="具体日期的后n天"><a href="#具体日期的后n天" class="headerlink" title="具体日期的后n天"></a>具体日期的后n天</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">month=[0,31,28,31,30,31,30,31,31,30,31,30,31]</span><br><span class="line">def isLeap(year):</span><br><span class="line">    if year%4==0 and year%100!=0 or year%400!=0:</span><br><span class="line">        return 1</span><br><span class="line">    return 0</span><br><span class="line">day1=int(input(&quot;日期&quot;))</span><br><span class="line">sum=int(input(&quot;后几天&quot;))</span><br><span class="line">y1=day1//10000</span><br><span class="line">m1=day1//100%100</span><br><span class="line">d1=day1%100</span><br><span class="line">while sum&gt;0:</span><br><span class="line">    d1+=1</span><br><span class="line">    if isLeap(y1):</span><br><span class="line">        month[2]=29</span><br><span class="line">    else:</span><br><span class="line">        month[2]=28</span><br><span class="line">    if d1==month[m1]+1:</span><br><span class="line">        m1+=1</span><br><span class="line">        d1=1</span><br><span class="line">    if m1==13:</span><br><span class="line">        y1+=1</span><br><span class="line">        m1=1</span><br><span class="line">    sum-=1</span><br><span class="line">print(y1,m1,d1)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>201509-1 数列分段</title>
    <url>/2018/11/21/Untitled-2/</url>
    <content><![CDATA[<p>问题描述</p>
<p>给定一个整数数列，数列中连续相同的最长整数序列算成一段，问数列中共有多少段？<br><a id="more"></a><br>输入格式</p>
<p>输入的第一行包含一个整数n，表示数列中整数的个数。<br>　　第二行包含n个整数a1, a2, …, an，表示给定的数列，相邻的整数之间用一个空格分隔。</p>
<p>输出格式<br>　　输出一个整数，表示给定的数列有多个段。</p>
<p>样例输入</p>
<p>8</p>
<p>8 8 8 0 12 12 8 0</p>
<p>样例输出</p>
<p>5</p>
<p>样例说明</p>
<p>8 8 8是第一段，0是第二段，12 12是第三段，倒数第二个整数8是第四段，最后一个0是第五段。</p>
<p>评测用例规模与约定</p>
<p>1 ≤ n ≤ 1000，0 ≤ ai ≤ 1000。</p>
<p>用k来记录数组中重复的元素</p>
<!--more-->
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define MAX 1000+10</span><br><span class="line">int a[MAX];</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	int k=a[0];</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		if(k!=a[i])&#123;</span><br><span class="line">			sum++;</span><br><span class="line">			k=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sum++;//最后一堆</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>算法提高 盾神与条状项链  </title>
    <url>/2018/12/17/Untitled-3/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　有一天，盾神捡到了好多好多五颜六色的珠子！他心想这些珠子这么漂亮，可以做成一条项链然后送给他心仪的女生~于是他用其中一些珠子做成了长度为n的项链。当他准备把项链首尾相接的时候，土方进来了。<br><a id="more"></a><br>“哇这么恶心的项链你也做得出来！！！”</p>
<p>盾神自知审美不是他的长项，于是他很谦虚地请教土方，怎么才能把项链做得漂亮。<br>　　“这个嘛~首先你要在这里加上一个这种颜色的珠子，然后在这里去掉这个珠子，然后……，最后你看看是不是漂亮很多咧~”土方一下子说出了m个修改步骤。</p>
<p>盾神觉得这个用人工做太麻烦了，于是交给了你。</p>
<p>输入格式</p>
<p>第一行两个数，分别为n，m。</p>
<p>第二行n个数，表示盾神一开始的项链。第i个数表示第i颗珠子的颜色。</p>
<p>接下来m行，为以下形式之一：</p>
<p>ADD P Q：表示在颜色为P的珠子前面加上一个颜色为Q的珠子。</p>
<p>DEL P：表示把颜色为P的珠子去掉，如果它不在端点处，则需要把它旁边的两颗珠子连起来。例如某时刻项链状态为1 4 5 8，则执行DEL 4会变成1 5 8，执行DEL 1会变成4 5 8。</p>
<p>输入保证在每次操作之前，项链有颜色为P的珠子，且任意时刻珠子颜色互不相同。</p>
<p>输出格式</p>
<p>第一行为一个数len，为做完所有操作后，项链的长度。</p>
<p>第二行len个数，表示此时项链的状态。第i个数表示第i颗珠子的颜色。<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入</span><br><span class="line">10 5</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">DEL 5</span><br><span class="line">ADD 7 5</span><br><span class="line">DEL 10</span><br><span class="line">ADD 4 20</span><br><span class="line">ADD 20 12</span><br><span class="line">样例输出</span><br><span class="line">11</span><br><span class="line">1 2 3 12 20 4 6 5 7 8 9</span><br><span class="line">数据规模和约定</span><br><span class="line">　　表示颜色的数字不超过10^5的正数，1&lt;=n&lt;=10^4，1&lt;=m&lt;=10^4。</span><br><span class="line">```</span><br></pre></td></tr></table></figure></p>
<p>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>list<int> l;</int></p>
<p>int main(){<br>    int n,m;<br>    int t;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    for(int i=0;i&lt;n;i++)<br>    {<br>        cin&gt;&gt;t;<br>            l.push_back(t);<br>    }</p>
<pre><code>string s;
int pos,a,b;
for(int j=0;j&lt;m;j++){
    cin&gt;&gt;s;
    if(s[0]==&apos;D&apos;){
        cin&gt;&gt;a;
            for(list&lt;int&gt;::iterator it=l.begin();it!=l.end();it++){
        if(*it==a) {
        l.erase(it);    
                    break;    
        }
    }

    }
    else if(s[0]==&apos;A&apos;){
        cin&gt;&gt;a&gt;&gt;b;
    for(list&lt;int&gt;::iterator it=l.begin();it!=l.end();it++){
        if(*it==a) {
        l.insert(it,b);
        break;    
        }

    }


}
</code></pre><p>}<br>    cout&lt;&lt;l.size()&lt;&lt;endl;<br>    if(l.size()==0) return 0;<br>    else{<br>        for(list<int>::iterator it=l.begin();it!=l.end();it++){<br>            cout&lt;&lt;*it;<br>            if(it!=l.end()) cout&lt;&lt;” “;<br>        }<br>    }</int></p>
<p>}<br><code>`</code></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>201312-5 i&#39;m stuck</title>
    <url>/2018/11/18/Untitled2-1/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个R行C列的地图，地图的每一个方格可能是’#’, ‘+’, ‘-‘, ‘|’, ‘.’, ‘S’, ‘T’七个字符中<br>的一个，分别表示如下意思：</p>
<p>‘#’: 任何时候玩家都不能移动到此方格；</p>
<p>‘+’: 当玩家到达这一方格后，下一步可以向上下左右四个方向相邻的任意一个非’#’方格移动一格；<br><a id="more"></a><br>‘-‘: 当玩家到达这一方格后，下一步可以向左右两个方向相邻的一个非’#’方格移动一格；</p>
<p>‘|’: 当玩家到达这一方格后，下一步可以向上下两个方向相邻的一个非’#’方格移动一格；</p>
<p>‘.’: 当玩家到达这一方格后，下一步只能向下移动一格。如果下面相邻的方格为’#’，则玩家不能再移动；</p>
<p>‘S’: 玩家的初始位置，地图中只会有一个初始位置。玩家到达这一方格后，下一步可以向上下左右四个方向相邻的任意一个非’#’方格移动一格；</p>
<p>‘T’: 玩家的目标位置，地图中只会有一个目标位置。玩家到达这一方格后，可以选择完成任务，也可以选择不完成任务继续移动。如果继续移动下一步可以向上下左右四个方向相邻的任意一个非’#’方格移动一格。</p>
<p>此外，玩家不能移动出地图。<br>　　请找出满足下面两个性质的方格个数：</p>
<ol>
<li><p>玩家可以从初始位置移动到此方格；</p>
</li>
<li><p>玩家不可以从此方格移动到目标位置。</p>
</li>
</ol>
<p>输入格式</p>
<p>输入的第一行包括两个整数R 和C，分别表示地图的行和列数。(1 ≤ R, C ≤ 50)。</p>
<p>接下来的R行每行都包含C个字符。它们表示地图的格子。地图上恰好有一个’S’和一个’T’。</p>
<p>输出格式</p>
<p>如果玩家在初始位置就已经不能到达终点了，就输出“I’m stuck!”（不含双引号）。否则的话，输出满足性质的方格的个数。<br>样例输入<br>5 5</p>
<p>–+-+</p>
<p>..|#.</p>
<p>..|##</p>
<p>S-+-T</p>
<p>####.</p>
<p>样例输出</p>
<p>2</p>
<p>样例说明</p>
<p>如果把满足性质的方格在地图上用’X’标记出来的话，地图如下所示：</p>
<p>–+-+</p>
<p>..|#X</p>
<p>..|##</p>
<p>S-+-T</p>
<p>####X</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 100+10</span><br><span class="line">struct direct&#123;</span><br><span class="line">	int rx,ry;</span><br><span class="line">&#125;;</span><br><span class="line">char grid[MAX][MAX];</span><br><span class="line">int vis[MAX][MAX];</span><br><span class="line">int vis2[MAX][MAX];</span><br><span class="line">int r,c;</span><br><span class="line">direct d[4]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;</span><br><span class="line">bool isBound(int x,int l,int h)&#123;</span><br><span class="line">	return x&gt;=l&amp;&amp;x&lt;=h;</span><br><span class="line">&#125;</span><br><span class="line">bool isLegal(int x,int y)&#123;</span><br><span class="line">	if(grid[x][y]!=&apos;#&apos;&amp;&amp;!vis[x][y]&amp;&amp;isBound(x,0,r-1)&amp;&amp;isBound(y,0,c-1))&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line"></span><br><span class="line">	vis[x][y]=1;</span><br><span class="line">	char t=grid[x][y];</span><br><span class="line">	switch(t)&#123;</span><br><span class="line">		case &apos;T&apos;:&#123;</span><br><span class="line">			for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">				int newx=x+d[i].rx,newy=y+d[i].ry;</span><br><span class="line">				if(isLegal(newx,newy)) &#123;</span><br><span class="line">					//vis[newx][newy]=1;</span><br><span class="line">					dfs(newx,newy);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		case &apos;S&apos;:&#123;</span><br><span class="line">			for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">				int newx=x+d[i].rx,newy=y+d[i].ry;</span><br><span class="line">				if(isLegal(newx,newy)) &#123;</span><br><span class="line">					//vis[newx][newy]=1;</span><br><span class="line">					dfs(newx,newy);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		case &apos;+&apos;:&#123;</span><br><span class="line">			for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">				int newx=x+d[i].rx,newy=y+d[i].ry;</span><br><span class="line">				if(isLegal(newx,newy)) &#123;</span><br><span class="line">					//vis[newx][newy]=1;</span><br><span class="line">					dfs(newx,newy);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		case &apos;-&apos;:&#123;</span><br><span class="line">				for(int i=2;i&lt;4;i++)&#123;</span><br><span class="line">				int newx=x+d[i].rx,newy=y+d[i].ry;</span><br><span class="line">				if(isLegal(newx,newy)) &#123;</span><br><span class="line">				//	vis[newx][newy]=1;</span><br><span class="line">					dfs(newx,newy);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		case &apos;|&apos;:&#123;</span><br><span class="line">				for(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">				int newx=x+d[i].rx,newy=y+d[i].ry;</span><br><span class="line">				if(isLegal(newx,newy)) &#123;</span><br><span class="line">				////	vis[newx][newy]=1;</span><br><span class="line">					dfs(newx,newy);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		case &apos;.&apos;:&#123;</span><br><span class="line">				int newx=x+d[1].rx,newy=y+d[1].ry;</span><br><span class="line">				if(isLegal(newx,newy)) &#123;</span><br><span class="line">				//	vis[newx][newy]=1;</span><br><span class="line">					dfs(newx,newy);</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line">	for(int i=0;i&lt;r;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;c;j++)&#123;</span><br><span class="line">			cin&gt;&gt;grid[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	int sr,sc,er,ec;</span><br><span class="line">	for(int i=0;i&lt;r;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;c;j++)&#123;</span><br><span class="line">			if(grid[i][j]==&apos;S&apos;) &#123;</span><br><span class="line">			sr=i;sc=j;</span><br><span class="line">			&#125;</span><br><span class="line">			if(grid[i][j]==&apos;T&apos;)</span><br><span class="line">			&#123;</span><br><span class="line">				er=i,ec=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">	dfs(sr,sc);</span><br><span class="line">	memcpy(vis2,vis,sizeof(vis));</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	if(vis2[er][ec]==0) </span><br><span class="line">        cout &lt;&lt; &quot;I&apos;m stuck!&quot; &lt;&lt; endl;</span><br><span class="line">	else&#123;</span><br><span class="line">		int cnt=0;</span><br><span class="line">		for(int i=0;i&lt;r;i++)&#123;</span><br><span class="line">			for(int j=0;j&lt;c;j++)&#123;</span><br><span class="line">				if(vis2[i][j])&#123;</span><br><span class="line">						memset(vis,0,sizeof(vis));//!!</span><br><span class="line">					dfs(i,j);</span><br><span class="line">					if(!vis[er][ec]) cnt++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 848. Shifting Letters</title>
    <url>/2018/11/18/Untitled2/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>We have a string S of lowercase letters, and an integer array shifts.</p>
<p>Call the shift of a letter, the next letter in the alphabet, (wrapping around so that ‘z’ becomes ‘a’).<br><a id="more"></a><br>For example, shift(‘a’) = ‘b’, shift(‘t’) = ‘u’, and shift(‘z’) = ‘a’.</p>
<p>Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times.</p>
<p>Return the final string after all such shifts to S are applied.</p>
<p>Example 1:</p>
<p>Input: S = “abc”, shifts = [3,5,9]</p>
<p>Output: “rpl”</p>
<p>Explanation: </p>
<p>We start with “abc”.</p>
<p>After shifting the first 1 letters of S by 3, we have “dbc”.</p>
<p>After shifting the first 2 letters of S by 5, we have “igc”.</p>
<p>After shifting the first 3 letters of S by 9, we have “rpl”, the answer.</p>
<p>Note:</p>
<p>1 &lt;= S.length = shifts.length &lt;= 20000</p>
<p>0 &lt;= shifts[i] &lt;= 10 ^ 9</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>shift一个字符：<br>s[i]=(s[i]-‘a’+shift)%26+’a’</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string shiftingLetters(string S, vector&lt;int&gt;&amp; shifts) &#123;</span><br><span class="line">        long long c=0;</span><br><span class="line">        for(int i=shifts.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">            c+=shifts[i];</span><br><span class="line">            S[i]=(S[i]-&apos;a&apos;+c)%26+&apos;a&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string shiftingLetters(string S, vector&lt;int&gt;&amp; shifts) &#123;</span><br><span class="line">        int c=0;</span><br><span class="line">        for(int i=shifts.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">            //把移动次数转到0-25 防止shift的int数组溢出</span><br><span class="line">            c+=(shifts[i])%26;</span><br><span class="line">		  //如果是s[i]=&apos;z&apos; c=1 所以还得取一次余</span><br><span class="line">            S[i]=(S[i]-&apos;a&apos;+c)%26+&apos;a&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>201703-2 学生排队</title>
    <url>/2018/12/01/Untitledc/</url>
    <content><![CDATA[<p>　　体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。<br><a id="more"></a><br>例如，下面给出了一组移动的例子，例子中学生的人数为8人。</p>
<p>0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8；</p>
<p>1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8；</p>
<p>2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7；</p>
<p>3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。</p>
<p>小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？</p>
<p>请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。</p>
<p>输入格式</p>
<p>输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。</p>
<p>第二行包含一个整数m，表示调整的次数。</p>
<p>接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。</p>
<p>输出格式</p>
<p>输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。</p>
<p>样例输入</p>
<p>8</p>
<p>3</p>
<p>3 2</p>
<p>8 -3</p>
<p>3 -2</p>
<p>样例输出</p>
<p>1 2 4 3 5 8 6 7</p>
<p>评测用例规模与约定<br>　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，所有移动均合法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	int p,q;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	v.push_back(i);</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;p&gt;&gt;q;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			if(v[i]==p) &#123;</span><br><span class="line">			v.erase(v.begin()+i);	</span><br><span class="line">	 		v.insert(v.begin()+q+i,p);</span><br><span class="line">			break;	</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">				for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>c++ vector 实现二维数组</title>
    <url>/2018/11/28/Untitledd-1/</url>
    <content><![CDATA[<p>C++ 构建二维动态数组<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int **p;</span><br><span class="line">p = new int*[10];    //注意，int*[10]表示一个有10个元素的指针数组</span><br><span class="line">for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = new int[5];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>1.初始化<br>（1）利用Vector的push_back函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; a;</span><br><span class="line">a.push_back(1);</span><br><span class="line">a.push_back(2);</span><br><span class="line">a.push_back(3);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; b;</span><br><span class="line">b.push_back(4);</span><br><span class="line">b.push_back(5);</span><br><span class="line">b.push_back(6);</span><br><span class="line"></span><br><span class="line">vec.push_back(a);</span><br><span class="line">vec.push_back(b);</span><br></pre></td></tr></table></figure></p>
<p>（2）先定义好二维数组结构，在直接赋值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//得到一个5行3列的数组</span><br><span class="line">//由vector实现的二维数组，可以通过resize()的形式改变行、列值</span><br><span class="line">int i,j;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; array(5);</span><br><span class="line">for (i = 0; i &lt; array.size(); i++)</span><br><span class="line">    array[i].resize(3);</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; array.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (j = 0; j &lt; array[0].size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        array[i][j] = (i+1)*(j+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.遍历<br>（1）利用迭代器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void reverse_with_iterator(vector&lt;vector&lt;int&gt;&gt; vec)</span><br><span class="line">&#123;</span><br><span class="line">    if (vec.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;The vector is empty!&quot; &lt;&lt; endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;::iterator it;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;::iterator iter;</span><br><span class="line">    vector&lt;int&gt; vec_tmp;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Use iterator : &quot; &lt;&lt; endl;</span><br><span class="line">    for(iter = vec.begin(); iter != vec.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        vec_tmp = *iter;</span><br><span class="line">        for(it = vec_tmp.begin(); it != vec_tmp.end(); it++)</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）得到行、列大小，利用下标进行遍历<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void reverse_with_index(vector&lt;vector&lt;int&gt;&gt; vec)</span><br><span class="line">&#123;</span><br><span class="line">    if (vec.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;The vector is empty!&quot; &lt;&lt; endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int i,j;</span><br><span class="line">    cout &lt;&lt; &quot;Use index : &quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; vec.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0; j &lt; vec[0].size(); j++)</span><br><span class="line">            cout &lt;&lt; vec[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>Runtime Error(ACCESS_VIOLATION)</title>
    <url>/2018/12/13/Untitledd/</url>
    <content><![CDATA[<p>runtime  error （运行时错误）就是程序运行到一半，程序就崩溃了。<br>比如说：<br>①除以零</p>
<p>②数组越界：int a[3]; a[10000000]=10;</p>
<p>③指针越界：int <em> p; p=(int </em>)malloc(5 <em> sizeof(int)); </em>(p+1000000)=10;</p>
<p>④使用已经释放的空间：int <em> p; p=(int </em>)malloc(5 <em> sizeof(int));free(p); </em>p=10;</p>
<p>⑤数组开得太大，超出了栈的范围，造成栈溢出：int a[100000000];</p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 399. Evaluate Division</title>
    <url>/2018/12/05/Untitledf/</url>
    <content><![CDATA[<p>Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.<br><a id="more"></a><br>Example:<br>Given a / b = 2.0, b / c = 3.0.<br>queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .<br>return [6.0, 0.5, -1.0, 1.0, -1.0 ].</p>
<p>The input is: vector&lt;pair&lt;string, string&gt;&gt; equations, </p>
<p>vector<double>&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector<double>.</double></double></p>
<p>According to the example above:</p>
<p>equations = [ [“a”, “b”], [“b”, “c”] ],</p>
<p>values = [2.0, 3.0],</p>
<p>queries = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ]. </p>
<p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>dfs<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    string num;</span><br><span class="line">    double v;</span><br><span class="line">    node(string nn,double vv):num(nn),v(vv)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    map&lt;string,vector&lt;node&gt; &gt;g;</span><br><span class="line">    vector&lt;double&gt; calcEquation(vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries) &#123;</span><br><span class="line">        set&lt;string&gt; ss;</span><br><span class="line">        for(int i=0;i&lt;equations.size();i++)&#123;</span><br><span class="line">            pair&lt;string,string&gt; p=equations[i];</span><br><span class="line">            g[p.first].push_back(node(p.second,values[i]));</span><br><span class="line">            g[p.second].push_back(node(p.first,1/values[i]));           </span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;double&gt; answer;</span><br><span class="line">        set&lt;string&gt; vis;</span><br><span class="line">        for(auto b:queries)</span><br><span class="line">        &#123;</span><br><span class="line">            vis.clear();</span><br><span class="line">            </span><br><span class="line">         if(!g.count(b.first)&amp;&amp;!g.count(b.second)) answer.push_back(-1);</span><br><span class="line">          else answer.push_back(dfs(b.first,b.second,vis));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">    double dfs(string cur,string target,set&lt;string&gt; &amp;vis)&#123;</span><br><span class="line">        if(cur==target) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        vis.insert(cur);</span><br><span class="line">        for(int i=0;i&lt;g[cur].size();i++)&#123;</span><br><span class="line">            node t=g[cur][i];</span><br><span class="line">            if(!vis.count(t.num)) &#123;</span><br><span class="line">               double d=dfs(t.num,target,vis);//!!</span><br><span class="line">          if(d&gt;0) return t.v*d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    string num;</span><br><span class="line">    double v;</span><br><span class="line">    node(string nn,double vv):num(nn),v(vv)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    map&lt;string,vector&lt;node&gt; &gt;g;</span><br><span class="line">    vector&lt;double&gt; calcEquation(vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries) &#123;</span><br><span class="line">        set&lt;string&gt; ss;</span><br><span class="line">        for(int i=0;i&lt;equations.size();i++)&#123;</span><br><span class="line">            pair&lt;string,string&gt; p=equations[i];</span><br><span class="line">            g[p.first].push_back(node(p.second,values[i]));</span><br><span class="line">            g[p.second].push_back(node(p.first,1/values[i]));</span><br><span class="line">            ss.insert(p.first);</span><br><span class="line">            ss.insert(p.second);            </span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;double&gt; answer;</span><br><span class="line">        set&lt;string&gt; vis;</span><br><span class="line">        for(auto b:queries)</span><br><span class="line">        &#123;</span><br><span class="line">            vis.clear();</span><br><span class="line">            double ans=1;</span><br><span class="line">         if(!ss.count(b.first)&amp;&amp;!ss.count(b.second)) answer.push_back(-1);</span><br><span class="line">         else if(!dfs(b.first,b.second,vis,ans,answer)) answer.push_back(-1);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(string cur,string target,set&lt;string&gt; &amp;vis,double &amp;ans,vector&lt;double&gt; &amp;answer)&#123;</span><br><span class="line">        if(vis.count(cur)) return false;</span><br><span class="line">        if(cur==target) &#123;</span><br><span class="line">            answer.push_back(ans);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        vis.insert(cur);</span><br><span class="line">        for(int i=0;i&lt;g[cur].size();i++)&#123;</span><br><span class="line">            node t=g[cur][i];</span><br><span class="line">            if(!vis.count(t.num)) &#123;</span><br><span class="line">           double tmp=ans*t.v;                </span><br><span class="line">            if(dfs(t.num,target,vis,tmp,answer)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>包子凑数 蓝桥杯</title>
    <url>/2019/03/22/Untitleds/</url>
    <content><![CDATA[<p>小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。小明想知道一共有多少种数目是包子大叔凑不出来的。输入—-第一行包含一个整数N。(1 &lt;= N &lt;= 100)以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100) 输出—-一个整数代表答案。如果凑不出的数目有无限多个，输出INF。例如，输入：2 4 5 程序应该输出：6 再例如，输入：2 4 6 程序应该输出：INF样例解释：对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。 对于样例2，所有奇数都凑不出来，所以有无限多个<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 0x3f3f3f </span><br><span class="line">int dp[MAX];</span><br><span class="line">//读懂题 a,b,c 日月年 月日年 年月日 </span><br><span class="line">int tmp[MAX]; </span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">	if(a%b==0) return b;</span><br><span class="line">	return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">	int k=tmp[0];</span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		k=gcd(k,tmp[i]);</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	if(k!=1) cout&lt;&lt;&quot;INF&quot;&lt;&lt;endl;</span><br><span class="line">	else&#123;</span><br><span class="line">		dp[0]=1;//0个包子肯定能凑起来;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			for(int j=tmp[i];j&lt;MAX;j++)&#123;</span><br><span class="line">				if(dp[j-tmp[i]]==1) dp[j]=1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int cnt=0;</span><br><span class="line">		for(int k=1;k&lt;MAX;k++)&#123;</span><br><span class="line">			if(dp[k]!=1) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="https://www.veryarm.com/46854.html" target="_blank" rel="noopener">https://www.veryarm.com/46854.html</a><br><a href="https://blog.csdn.net/jinglelia/article/details/79657530" target="_blank" rel="noopener">https://blog.csdn.net/jinglelia/article/details/79657530</a></p>
]]></content>
  </entry>
  <entry>
    <title>HDU2037 今年暑假不AC</title>
    <url>/2018/12/13/Untitledw/</url>
    <content><![CDATA[<p>Problem Description<br>“今年暑假不AC？”<br>“是的。”<br>“那你干什么呢？”<br>“看世界杯呀，笨蛋！”<br>“@#$%^&amp;*%…”<br><a id="more"></a><br>确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。<br>作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）</p>
<p>Input<br>输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。</p>
<p>Output<br>对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。</p>
<p>Sample Input<br>12</p>
<p>1 3</p>
<p>3 4</p>
<p>0 7</p>
<p>3 8</p>
<p>15 19</p>
<p>15 20</p>
<p>10 15</p>
<p>8 18</p>
<p>6 12</p>
<p>5 10</p>
<p>4 14</p>
<p>2 9</p>
<p>0</p>
<p>Sample Output</p>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	node(int xx,int yy):x(xx),y(yy)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	node()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &lt;(const node p)const&#123;</span><br><span class="line">	return y&lt;p.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(cin&gt;&gt;n)&#123;</span><br><span class="line">		  if(n == 0) break;</span><br><span class="line">			int x,y;</span><br><span class="line">	node p[n];</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">	p[i].x=x;</span><br><span class="line">	p[i].y=y;	</span><br><span class="line">&#125;</span><br><span class="line">	sort(p,p+n);</span><br><span class="line">	int cnt=0,lend=-1;</span><br><span class="line">	for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">		if(p[j].x&gt;=lend)&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			lend=p[j].y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hdu</category>
      </categories>
  </entry>
  <entry>
    <title>A1085 Perfect Sequence </title>
    <url>/2019/03/26/a-1/</url>
    <content><![CDATA[<p>Given a sequence of positive integers and another positive integer p. The sequence is said to be a perfect sequence if M≤m×p where M and m are the maximum and minimum numbers in the sequence, respectively.</p>
<p>Now given a sequence and a parameter p, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. For each case, the first line contains two positive integers N and p, where N (≤10<br>​5<br>​​ ) is the number of integers in the sequence, and p (≤10<br>​9<br>​​ ) is the parameter. In the second line there are N positive integers, each is no greater than 10 9</p>
<p>Output Specification:<br>For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.</p>
<p>Sample Input:<br>10 8<br>2 3 20 4 5 1 6 7 8 9<br>Sample Output:<br>8<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">#define MAX 100010</span><br><span class="line">int a[MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,p;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;p; </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a,a+n);//忘记sort </span><br><span class="line">	int ans=1;</span><br><span class="line">	for(int k=0;k&lt;n;k++)&#123;</span><br><span class="line">		</span><br><span class="line">		int t=upper_bound(a+k+1,a+n,(long long)a[k]*p)-a; </span><br><span class="line">		ans=max(ans,t-k);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>201409-4  最优配餐</title>
    <url>/2018/11/21/Untitlred/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　栋栋最近开了一家餐饮连锁店，提供外卖服务。随着连锁店越来越多，怎么合理的给客户送餐成为了一个急需解决的问题。<br>　　栋栋的连锁店所在的区域可以看成是一个n×n的方格图（如下图所示），方格的格点上的位置上可能包含栋栋的分店（绿色标注）或者客户（蓝色标注），有一些格点是不能经过的（红色标注）。<br> <a id="more"></a><br>　　方格图中的线表示可以行走的道路，相邻两个格点的距离为1。栋栋要送餐必须走可以行走的道路，而且不能经过红色标注的点。</p>
<p>　　送餐的主要成本体现在路上所花的时间，每一份餐每走一个单位的距离需要花费1块钱。每个客户的需求都可以由栋栋的任意分店配送，每个分店没有配送总量的限制。<br>　　现在你得到了栋栋的客户的需求，请问在最优的送餐方式下，送这些餐需要花费多大的成本。</p>
<p>输入格式</p>
<p>输入的第一行包含四个整数n, m, k, d，分别表示方格图的大小、栋栋的分店数量、客户的数量，以及不能经过的点的数量。</p>
<p>接下来m行，每行两个整数xi, yi，表示栋栋的一个分店在方格图中的横坐标和纵坐标。</p>
<p>接下来k行，每行三个整数xi, yi, ci，分别表示每个客户在方格图中的横坐标、纵坐标和订餐的量。（注意，可能有多个客户在方格图中的同一个位置）</p>
<p>接下来d行，每行两个整数，分别表示每个不能经过的点的横坐标和纵坐标。</p>
<p>输出格式</p>
<p>输出一个整数，表示最优送餐方式下所需要花费的成本。</p>
<p>样例输入</p>
<p>10 2 3 3</p>
<p>1 1</p>
<p>8 8</p>
<p>1 5 1</p>
<p>2 3 3</p>
<p>6 7 2</p>
<p>1 2</p>
<p>2 2</p>
<p>6 8</p>
<p>样例输出</p>
<p>29</p>
<p>评测用例规模与约定<br>　　前30%的评测用例满足：1&lt;=n &lt;=20。<br>　　前60%的评测用例满足：1&lt;=n&lt;=100。<br>　　所有评测用例都满足：1&lt;=n&lt;=1000，1&lt;=m, k, d&lt;=n^2。可能有多个客户在同一个格点上。每个客户的订餐量不超过1000，每个客户所需要的餐都能被送到。</p>
<h2 id="40分-程序"><a href="#40分-程序" class="headerlink" title="40分 程序"></a>40分 程序</h2><p>一个一个分店bfs 会导致超时<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define MAX 1000+10</span><br><span class="line">#define  ll long long </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int vis[MAX][MAX];</span><br><span class="line">int road[MAX][MAX];</span><br><span class="line">int N;</span><br><span class="line">struct point&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	point(int xx,int yy):x(xx),y(yy)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool inBound(int x,int m,int n)&#123;</span><br><span class="line">	return x&gt;=m&amp;&amp;x&lt;=n;</span><br><span class="line">&#125;</span><br><span class="line">int mini[MAX];</span><br><span class="line">int dis[MAX][MAX];</span><br><span class="line">int dire[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">void bfs(int x,int y,int destx,int desty)&#123;</span><br><span class="line">	queue&lt;point&gt; q;</span><br><span class="line">	</span><br><span class="line">	dis[x][y]=0;</span><br><span class="line">	q.push(point(x,y));</span><br><span class="line">	vis[x][y]=1;</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		point p=q.front();</span><br><span class="line">		if(p.x==destx&amp;&amp;p.y==desty) &#123;</span><br><span class="line">		</span><br><span class="line">			return ;</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		q.pop();</span><br><span class="line">		for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int newx=p.x+dire[i][0];</span><br><span class="line">		int newy=p.y+dire[i][1];</span><br><span class="line">		//!!</span><br><span class="line">		</span><br><span class="line">		if(inBound(newx,1,N)&amp;&amp;inBound(newy,1,N)&amp;&amp;!vis[newx][newy]&amp;&amp;!road[newx][newy])&#123;</span><br><span class="line">		q.push(point(newx,newy));</span><br><span class="line">		vis[newx][newy]=1;</span><br><span class="line">		dis[newx][newy]=dis[p.x][p.y]+1;</span><br><span class="line">			 </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,k,t;</span><br><span class="line">	memset(road,0,sizeof(road));</span><br><span class="line">	int va[MAX];</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;n&gt;&gt;k&gt;&gt;t;</span><br><span class="line">	int x,y;</span><br><span class="line">	vector&lt;point&gt; shop,client;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		shop.push_back(point(x,y));</span><br><span class="line">		road[x][y]=1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		client.push_back(point(x,y)); </span><br><span class="line">		cin&gt;&gt;va[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;k;i++)</span><br><span class="line">		mini[i]=0xffff;</span><br><span class="line">	</span><br><span class="line">for(int j=0;j&lt;k;j++) </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		memset(dis,0,sizeof(dis));</span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">	bfs(shop[i].x,shop[i].y,client[j].x,client[j].y);</span><br><span class="line">		if(mini[j]&gt;dis[client[j].x][client[j].y])</span><br><span class="line">		&#123;</span><br><span class="line">			mini[j]=dis[client[j].x][client[j].y];</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;	</span><br><span class="line">	ll sum=0;	</span><br><span class="line">	for(int i=0;i&lt;k;i++)</span><br><span class="line"> 	sum+=va[i]*mini[i];</span><br><span class="line"> 	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="修改后-100分"><a href="#修改后-100分" class="headerlink" title="修改后 100分"></a>修改后 100分</h2><p>用vis记录走过的点 开始把所有的分店数都进入队列 (bfs能求得最短路径)</p>
<p>用 Buyer数组来记录客户所在的点 存放的值是购买的数量</p>
<p>bfs函数返回条件是 buyer数减到0 而不是一个客户的点已送达</p>
<p><strong>注意时间和空间复杂度</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define MAX 1000+10</span><br><span class="line">#define  ll long long </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int vis[MAX][MAX];</span><br><span class="line">int N;</span><br><span class="line">struct point&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	point(int xx,int yy):x(xx),y(yy)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;point&gt; q;</span><br><span class="line">bool inBound(int x,int m,int n)&#123;</span><br><span class="line">	return x&gt;=m&amp;&amp;x&lt;=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dis[MAX][MAX];</span><br><span class="line">ll ans=0;</span><br><span class="line">int buyercount=0;</span><br><span class="line">int buyer[MAX][MAX];</span><br><span class="line">int dire[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">void bfs()&#123;</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		point p=q.front();</span><br><span class="line">		if(buyer[p.x][p.y] &gt; 0) &#123;</span><br><span class="line">                ans += buyer[p.x][p.y] *dis[p.x][p.y];</span><br><span class="line">                if(--buyercount == 0)</span><br><span class="line">                    return;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		q.pop();</span><br><span class="line">		for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int newx=p.x+dire[i][0];</span><br><span class="line">		int newy=p.y+dire[i][1];</span><br><span class="line">		//!!</span><br><span class="line">		if(inBound(newx,1,N)&amp;&amp;inBound(newy,1,N)&amp;&amp;!vis[newx][newy])&#123;</span><br><span class="line">		q.push(point(newx,newy));</span><br><span class="line">		vis[newx][newy]=1;</span><br><span class="line">		dis[newx][newy]=dis[p.x][p.y]+1;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,k,t;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;n&gt;&gt;k&gt;&gt;t;</span><br><span class="line">	int x,y;</span><br><span class="line">		memset(dis,0,sizeof(dis));</span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">		memset(buyer,0,sizeof(buyer));</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">	q.push(point(x,y));</span><br><span class="line">	dis[x][y]=0;</span><br><span class="line">	vis[x][y]=1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		cin&gt;&gt;buyer[x][y];</span><br><span class="line">		buyercount++;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">	vis[x][y]=1;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	bfs();</span><br><span class="line"> 	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>algorithm的find函数</title>
    <url>/2018/11/04/algorithm%E7%9A%84find%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>1、algorithm中的函数</p>
<p>其调用形式为</p>
<p>find（start,end,value）</p>
<p>start搜寻的起点，end搜寻的终点，要寻找的value值<br><a id="more"></a><br>容器的表示方法</p>
<p>find（a.begin(),a.end(),value）</p>
<p>数组的表示方法</p>
<p>find（a,a+length,val）</p>
<p>所有的返回，均是迭代器（容器）或指针（数组），而非是直观感觉上的索引下标。如果在查找范围内不存在，返回a.end()，这里需要注意的是，a.end()不在查找范围内。</p>
<p>我们可以进一步思考，为什么返回的不是索引下标？这是因为索引下标是在数组这种连续存储的数据结构里面常见的，是一种顺序索引；而很多数据结构的存储并非连续的，不能实现顺序索引，为了兼顾所有的数据结构，所以返回的仅仅是指针或是迭代器。</p>
<p>2、各个容器自己实现的成员函数</p>
<p>vector没有实现find函数，除此之外，常见容器都实现了自己的find函数。</p>
<p>String是这一种顺序存储结构，其find函数返回的是下标索引。set,map,multiset,multimap都不是顺序索引的数据结构，所以返回的是迭代器。</p>
<p>3、如果元素不在</p>
<p>对于返回迭代器的查找，通过判断find（a.begin(),a.end(),value）==a.end()，来判断元素是否存在</p>
<p>对于string，通过a.find(val)==string::npos判断</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>C语言itoa()函数和atoi()函数详解(整数转字符C实现)</title>
    <url>/2018/12/10/atpi/</url>
    <content><![CDATA[<p>1.int/float to string/array:</p>
<p>C语言提供了几个标准库函数，可以将任意类型(整型、长整型、浮点型等)的数字转换为字符串，下面列举了各函数的方法及其说明。<br>● itoa()：将整型值转换为字符串。<br>● ltoa()：将长整型值转换为字符串。<br>● ultoa()：将无符号长整型值转换为字符串。<br>● gcvt()：将浮点型数转换为字符串，取四舍五入。</p>
<a id="more"></a>
<p>● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。<br>● fcvt()：指定位数为转换精度，其余同ecvt()。</p>
<p>除此外，还可以使用sprintf系列函数把数字转换成字符串，其比itoa()系列函数运行速度慢</p>
<ol start="2">
<li>string/array to int/float</li>
</ol>
<p>C/C++语言提供了几个标准库函数，可以将字符串转换为任意类型(整型、长整型、浮点型等)。<br>● atof()：将字符串转换为双精度浮点型值。<br>● atoi()：将字符串转换为整型值。<br>● atol()：将字符串转换为长整型值。<br>● strtod()：将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字。<br>● strtol()：将字符串转换为长整值，并报告不能被转换的所有剩余数字。<br>● strtoul()：将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字。</p>
<p>以下是用itoa()函数将整数转换为字符串的一个例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line">void main (void)</span><br><span class="line">&#123;</span><br><span class="line">int num = 100;</span><br><span class="line">char str[25];</span><br><span class="line">itoa(num, str, 10);</span><br><span class="line">printf(&quot;The number &apos;num&apos; is %d and the string &apos;str&apos; is %s. \n&quot; ,</span><br><span class="line">num, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>itoa()函数有3个参数：第一个参数是要转换的数字，第二个参数是要写入转换结果的目标字符串，第三个参数是转移数字时所用 的基数。在上例中，转换基数为10。10：十进制；2：二进制…</p>
<p>itoa并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用sprintf。是Windows平台下扩展的，标准库中有sprintf，功能比这个更强，用法跟printf类似：</p>
<p>char str[255];<br>sprintf(str, “%x”, 100); //将100转为16进制表示的字符串。</p>
<p>下列函数可以将整数转换为字符串：</p>
<p>itoa() 将整型值转换为字符串<br>itoa() 将长整型值转换为字符串<br>ultoa() 将无符号长整型值转换为字符串</p>
<p>一、atoi()——把字符串转换成整型数<br>考点：字符串转换为数字时，对相关ASCII码的理解。</p>
<p>C实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int atoi (char s[]);</span><br><span class="line">int main(void )</span><br><span class="line">&#123;</span><br><span class="line">char s[100];</span><br><span class="line">gets(s);</span><br><span class="line">printf(&quot;integer=%d\n&quot;,atoi(s));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int atoi (char s[])</span><br><span class="line">&#123;</span><br><span class="line">int i,n,sign;</span><br><span class="line">for(i=0;isspace(s[i]);i++)//跳过空白符;</span><br><span class="line">sign=(s[i]==&apos;-&apos;)?-1:1;</span><br><span class="line">if(s[i]==&apos;+&apos;||s[i]==&apos; -&apos;)//跳过符号</span><br><span class="line">  i++;</span><br><span class="line">for(n=0;isdigit(s[i]);i++)</span><br><span class="line">       n=10*n+(s[i]-&apos;0&apos;);//将数字字符转换成整形数字</span><br><span class="line">return sign *n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1    #include &lt;iostream&gt;</span><br><span class="line">2    using namespace std;</span><br><span class="line">3  </span><br><span class="line">4    int str2int(const char *str)</span><br><span class="line">5    &#123;</span><br><span class="line">6        int temp = 0;</span><br><span class="line">7        const char *ptr = str;  //ptr保存str字符串开头</span><br><span class="line">8  </span><br><span class="line">9        if (*str == &apos;-&apos; || *str == &apos;+&apos;)  //如果第一个字符是正负号，</span><br><span class="line">10       &#123;                      //则移到下一个字符</span><br><span class="line">11           str++;</span><br><span class="line">12       &#125;</span><br><span class="line">13       while(*str != 0)</span><br><span class="line">14       &#123;</span><br><span class="line">15           if ((*str &lt; &apos;0&apos;) || (*str &gt; &apos;9&apos;))  //如果当前字符不是数字</span><br><span class="line">16           &#123;                       //则退出循环</span><br><span class="line">17               break;</span><br><span class="line">18           &#125;</span><br><span class="line">19           temp = temp * 10 + (*str - &apos;0&apos;); //如果当前字符是数字则计算数值</span><br><span class="line">20           str++;      //移到下一个字符</span><br><span class="line">21       &#125;  </span><br><span class="line">22       if (*ptr == &apos;-&apos;)     //如果字符串是以“-”开头，则转换成其相反数</span><br><span class="line">23       &#123;</span><br><span class="line">24           temp = -temp;</span><br><span class="line">25       &#125;</span><br><span class="line">26 </span><br><span class="line">27       return temp;</span><br><span class="line">28   &#125;</span><br><span class="line">29 </span><br><span class="line">30   int main()</span><br><span class="line">31   &#123;</span><br><span class="line">32       int n = 0;  </span><br><span class="line">33       char p[10] = &quot;&quot;;</span><br><span class="line">34 </span><br><span class="line">35       cin.getline(p, 20);   //从终端获取一个字符串</span><br><span class="line">36       n = str2int(p);      //把字符串转换成整型数</span><br><span class="line">37      </span><br><span class="line">38       cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">39 </span><br><span class="line">40       return 0;</span><br><span class="line">41   &#125;</span><br></pre></td></tr></table></figure></p>
<p>二、itoa()——把一整数转换为字符串</p>
<p>通过把整数的各位上的数字加“0”转换成char类型并存到字符数组中。但是要注意，需要采用字符串逆序的方法</p>
<p>C语言实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void      itoa (int n,char s[]);</span><br><span class="line">//atoi 函数：将ｓ转换为整形数</span><br><span class="line">int main(void )</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">char s[100];</span><br><span class="line">printf(&quot;Input n:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">printf(&quot;the string : \n&quot;);</span><br><span class="line">itoa (n,s);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">void itoa (int n,char s[])</span><br><span class="line">&#123;</span><br><span class="line">int i,j,sign;</span><br><span class="line">if((sign=n)&lt;0)//记录符号</span><br><span class="line">n=-n;//使n成为正数</span><br><span class="line">i=0;</span><br><span class="line">do&#123;</span><br><span class="line">       s[i++]=n%10+&apos;0&apos;;//取下一个数字</span><br><span class="line">&#125;</span><br><span class="line">while ((n/=10)&gt;0);//删除该数字</span><br><span class="line">if(sign&lt;0)</span><br><span class="line">s[i++]=&apos;-&apos;;</span><br><span class="line">s[i]=&apos;\0&apos;;</span><br><span class="line">for(j=i;j&gt;=0;j--)//生成的数字是逆序的，所以要逆序输出</span><br><span class="line">       printf(&quot;%c&quot;,s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">是int 转string类型的一个函数</span><br></pre></td></tr></table></figure></p>
<p>C++实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    #include &lt;iostream&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">   </span><br><span class="line">    void int2str(int n, char *str)</span><br><span class="line">    &#123;</span><br><span class="line">        char buf[10] = &quot;&quot;;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int len = 0;</span><br><span class="line">        int temp = n &lt; 0 ? -n: n;  // temp为n的绝对值</span><br><span class="line"></span><br><span class="line">          if (str == NULL)</span><br><span class="line">          &#123;</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">          while(temp)</span><br><span class="line">          &#123;</span><br><span class="line">              buf[i++] = (temp % 10) + &apos;0&apos;;  //把temp的每一位上的数存入buf</span><br><span class="line">              temp = temp / 10;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          len = n &lt; 0 ? ++i: i;  //如果n是负数，则多需要一位来存储负号</span><br><span class="line">          str[i] = 0;            //末尾是结束符0</span><br><span class="line">          while(1)</span><br><span class="line">          &#123;</span><br><span class="line">              i--;</span><br><span class="line">              if (buf[len-i-1] ==0)</span><br><span class="line">              &#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">         str[i] = buf[len-i-1];  //把buf数组里的字符拷到字符串</span><br><span class="line">          &#125;</span><br><span class="line">          if (i == 0 )</span><br><span class="line">          &#123;</span><br><span class="line">              str[i] = &apos;-&apos;;          //如果是负数，添加一个负号</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      int main()</span><br><span class="line">      &#123;</span><br><span class="line">     int nNum;</span><br><span class="line">          char p[10];</span><br><span class="line">     </span><br><span class="line">          cout &lt;&lt; &quot;Please input an integer:&quot;;</span><br><span class="line">          cin &gt;&gt; nNum;</span><br><span class="line">          cout &lt;&lt; &quot;output: &quot; ;</span><br><span class="line">          int2str(nNum, p);        //整型转换成字符串</span><br><span class="line">          cout&lt;&lt; p &lt;&lt; endl;</span><br><span class="line">     </span><br><span class="line">          return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考博客</p>
<p><a href="https://blog.csdn.net/gao1440156051/article/details/50729691" target="_blank" rel="noopener">https://blog.csdn.net/gao1440156051/article/details/50729691</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>BFS求解迷宫</title>
    <url>/2018/10/31/bfs%E8%BF%B7%E5%AE%AB/</url>
    <content><![CDATA[<p>bfs 广度优先遍历<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxN = 105;</span><br><span class="line">int n, m;</span><br><span class="line">int maze[MaxN][MaxN];</span><br><span class="line">bool vis[MaxN][MaxN];</span><br><span class="line">int fa[MaxN][MaxN], dist[MaxN][MaxN], last_dir[MaxN][MaxN];</span><br><span class="line"></span><br><span class="line">///u, d, l, r</span><br><span class="line">int dx[4] = &#123;0, 0, -1, 1&#125;;</span><br><span class="line">int dy[4] = &#123;1, -1, 0, 0&#125;;</span><br><span class="line">char name[4] = &#123;&apos;r&apos;, &apos;l&apos;, &apos;u&apos;, &apos;d&apos;&#125;;</span><br><span class="line"></span><br><span class="line">bool inbound(int x, int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">	if (x &gt;= l)</span><br><span class="line">		if (x &lt; r)</span><br><span class="line">			return true;</span><br><span class="line">		else</span><br><span class="line">			return false;</span><br><span class="line">	else</span><br><span class="line">		return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int d = 0;</span><br><span class="line">    int u = x * m + y;</span><br><span class="line">    vis[x][y] = 1;</span><br><span class="line">    fa[x][y] = u;</span><br><span class="line">    dist[x][y] = 0;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    while (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        u = q.front(); q.pop();</span><br><span class="line">        x = u / m; y = u % m;</span><br><span class="line">        for (d = 0; d &lt; 4; d++)</span><br><span class="line">        &#123;</span><br><span class="line">            int nx = x + dx[d];</span><br><span class="line">            int ny = y + dy[d];</span><br><span class="line">            if (inbound(nx, 0, n) &amp;&amp; inbound(ny, 0, m)</span><br><span class="line">                &amp;&amp; maze[nx][ny] &amp;&amp; !vis[nx][ny])</span><br><span class="line">            &#123;</span><br><span class="line">                int v = nx * m + ny;</span><br><span class="line">                q.push(v);</span><br><span class="line">                vis[nx][ny] = 1;</span><br><span class="line">                fa[nx][ny] = u;</span><br><span class="line">                //cout&lt;&lt;&quot;fa:&quot;&lt;&lt;&quot; nx:&quot;&lt;&lt;nx&lt;&lt;&quot; ny:&quot;&lt;&lt;ny&lt;&lt;&quot;  u:&quot;&lt;&lt;u&lt;&lt;endl; </span><br><span class="line">                dist[nx][ny] = dist[x][y] + 1;</span><br><span class="line">                last_dir[nx][ny] = d;</span><br><span class="line">               // cout&lt;&lt;&quot;dir: &quot;&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;maze.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        for (int j = 0; j &lt; m; j++)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;maze[i][j]);</span><br><span class="line">    puts(&quot;打印迷宫：&quot;);</span><br><span class="line">    printf(&quot;i \\ j   &quot;);</span><br><span class="line">    for (int j = 0; j &lt; m; j++)</span><br><span class="line">        printf(&quot;%7d:&quot;, j);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%4d:   &quot;, i);</span><br><span class="line">        for (int j = 0; j &lt; m - 1; j++)</span><br><span class="line">            printf(&quot;%8d&quot;, maze[i][j]);</span><br><span class="line">        printf(&quot;%8d\n&quot;, maze[i][m - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;输入终点坐标&quot;);</span><br><span class="line">    bfs(0, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;int&gt; dir;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        int fx = fa[x][y] / m;</span><br><span class="line">        int fy = fa[x][y] % m;</span><br><span class="line">       // cout&lt;&lt;&quot; fx:&quot;&lt;fx&lt;&lt;&quot; fy:&quot;&lt;&lt;fy&lt;&lt;endl;</span><br><span class="line">        //cout&lt;&lt;&quot; x:&quot;&lt;&lt;x&lt;&lt;&quot; y:&quot;&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">        if (fx == x &amp;&amp; fy == y) break;</span><br><span class="line">        dir.push(last_dir[x][y]);</span><br><span class="line">        x = fx; y = fy;</span><br><span class="line">    &#125;</span><br><span class="line">    while (!dir.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%c&quot;, name[dir.top()]);</span><br><span class="line">        dir.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    freopen(&quot;CON&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    int sx, sy;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;sx, &amp;sy);</span><br><span class="line">//    sx=3;</span><br><span class="line">//    sy=3;</span><br><span class="line">	print(sx, sy);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fwr5ru8ijfj30ca09s3zg.jpg" alt="image"><br>参考链接<br><a href="https://blog.csdn.net/s_lisheng/article/details/73799880" target="_blank" rel="noopener">https://blog.csdn.net/s_lisheng/article/details/73799880</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ bitset类用法</title>
    <url>/2018/11/07/bitset/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using std::bitset;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>1.bitset定义和初始化<br>          以下列出了bitset的构造函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitset&lt;n&gt; b;	          //b有n位，每位都为0</span><br><span class="line">bitset&lt;n&gt; b(u);	          //b是unsigned long型u的一个副本</span><br><span class="line">bitset&lt;n&gt; b(s);	          //b是string对象s中含有的位串的副本</span><br><span class="line">bitset&lt;n&gt; b(s, pos, n);	  //b是s中从位置pos开始的n个位的副本</span><br></pre></td></tr></table></figure></p>
<pre><code>类似于vector，bitset类是一种类模板；而与vector不一样的是bitset类型对象的区别仅在其长度而不在其类型。在定义bitset时，要明确bitset含有多少位，须在尖括号内给出它的长度值：
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitset&lt;32&gt; bitvec; //32位，全为0。</span><br></pre></td></tr></table></figure>
<pre><code>  给出的长度值必须是常量表达式。正如这里给出的，长度值必须定义为整型字面值常量或是已用常量值初始化的整数类型的const对象。
这条语句把bitvec定义为含有32个位的bitset对象。和vector的元素一样，bitset中的位是没有命名的，程序员只能按位置来访问它们。位集合的位置编号从0开始，因此，bitvec的位序是从0到31。以0位开始的位串是低阶位（low-order bit），以31位结束的位串是高阶位(high-order bit)。
</code></pre><h2 id="1-1用unsigned值初始化bitset对象"><a href="#1-1用unsigned值初始化bitset对象" class="headerlink" title="1.1用unsigned值初始化bitset对象"></a>1.1用unsigned值初始化bitset对象</h2><pre><code>  当用unsigned long值作为bitset对象的初始值时，该值将转化为二进制的位模式。而bitset对象中的位集作为这种位模式的副本。如果bitset类型长度大于unsigned long值的二进制位数，则其余的高阶位置为0；如果bitet类型长度小于unsigned long值的二进制位数，则只使用unsigned值中的低阶位，超过bitet类型长度的高阶位将被丢弃。
在32位unsigned long的机器上，十六进制值0xffff表示为二进制位就是十六个1和十六个0（每个0xf可表示为1111）。可以用0xffff初始化bitset对象：
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bitvec1 is smaller than the initializer</span><br><span class="line">bitset&lt;16&gt; bitvec1(0xffff);          // bits 0 ... 15 are set to 1</span><br><span class="line">// bitvec2 same size as initializer</span><br><span class="line">bitset&lt;32&gt; bitvec2(0xffff);          // bits 0 ... 15 are set to 1; 16 ... 31 are 0</span><br><span class="line">// on a 32-bit machine, bits 0 to 31 initialized from 0xffff</span><br><span class="line">bitset&lt;128&gt; bitvec3(0xffff);         // bits 32 through 127 initialized to</span><br></pre></td></tr></table></figure>
<p>zero<br>         上面的三个例子中，0到15位都置为1。由于bitvec1位数少于unsigned long的位数，因此bitvec1的初始值的高阶位被丢弃。bitvec2和unsigned long长度相同，因此所有位正好放置了初始值。bitvec3长度大于32，31位以上的高阶位就被置为0。</p>
<h2 id="1-2用string对象初始化bitset对象"><a href="#1-2用string对象初始化bitset对象" class="headerlink" title="1.2用string对象初始化bitset对象"></a>1.2用string对象初始化bitset对象</h2><pre><code>当用string对象初始化bitset对象时，string对象直接表示为位模式。从string对象读入位集的顺序是从右向左：
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string strval(&quot;1100&quot;);</span><br><span class="line">bitset&lt;32&gt; bitvec4(strval);</span><br></pre></td></tr></table></figure>
<pre><code>  bitvec4的位模式中第2和3的位置为1，其余位置都为0。如果string对象的字符个数小于bitset类型的长度，则高阶位将置为0。
string对象和bitset对象之间是反向转化的：string对象的最右边字符（即下标最大的那个字符）用来初始化bitset对象的低阶位（即下标为0的位）。当用string对象初始化bitset对象时，记住这一差别很重要。
不一定要把整个string对象都作为bitset对象的初始值。相反，可以只用某个子串作为初始值：
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string str(&quot;1111111000000011001101&quot;);</span><br><span class="line">bitset&lt;32&gt; bitvec5(str, 5, 4); // 4 bits starting at str[5], 1100</span><br><span class="line">bitset&lt;32&gt; bitvec6(str, str.size() - 4);     // use last 4 characters</span><br></pre></td></tr></table></figure>
<pre><code>这里用str中从str[5]开始包含四个字符的子串来初始化bitvec5。照常，初始化bitset对象时总是从子串最右边结尾字符开始的，bitvec5的从0到3的二进制位置为1100，其他二进制位都置为0。如果省略第三个参数则意味着取从开始位置一直到string末尾的所有字符。本例中，取出str末尾的四位来对bitvec6的低四位进行初始化。bitvec6其余的位初始化为0。这些初始化过程的图示如下：
</code></pre><p><img src="http://hi.csdn.net/attachment/201110/24/0_1319464074Ub9a.gif" alt="image"></p>
<h2 id="2-bitset的上的操作"><a href="#2-bitset的上的操作" class="headerlink" title="2.bitset的上的操作"></a>2.bitset的上的操作</h2><pre><code>多种bitset操作用来测试或设置bitset对象中的单个或多个二进制位：
</code></pre><p><img src="http://hi.csdn.net/attachment/201110/24/0_13194642802a48.gif" alt="image"></p>
<h3 id="2-1测试整个bitset对象"><a href="#2-1测试整个bitset对象" class="headerlink" title="2.1测试整个bitset对象"></a>2.1测试整个bitset对象</h3><pre><code>如果bitset对象中有一个或多个二进制位置为1，则any操作返回true，也就是说，其返回值等于1;相反，如果bitset对象中的二进制位全为0,则none操作返回true。
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitset&lt;32&gt; bitvec; // 32 bits, all zero</span><br><span class="line">bool is_set = bitvec.any();            // false, all bits are zero</span><br><span class="line">bool is_not_set = bitvec.none();      // true, all bits are zero</span><br><span class="line">          如果需要知道置为1的二进制位的个数，可以使用count操作，该操作返回置为1的二进制位的个数：</span><br><span class="line">size_t bits_set = bitvec.count(); // returns number of bits that are on</span><br><span class="line">          count操作的返回类型是标准库中命名为size_t的类型。size_t类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版本。它是一个与机器相关的unsigned类型，大小可以保证存储内存中对象。</span><br><span class="line">        与vector和string中的size操作一样，bitset的size操作返回bitset对象中二进制位的个数，返回值的类型是size_t:</span><br><span class="line">size_t sz = bitvec.size(); // returns 32</span><br></pre></td></tr></table></figure>
<h3 id="2-2访问bitset对象中的位"><a href="#2-2访问bitset对象中的位" class="headerlink" title="2.2访问bitset对象中的位"></a>2.2访问bitset对象中的位</h3><pre><code>可以用下标操作符来读或写某个索引位置的二进制位，同样地，也可以用下标操作符测试给定二进制位的值或设置某个二进制位的值：
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// assign 1 to even numbered bits</span><br><span class="line">for (int index = 0; index != 32; index += 2)</span><br><span class="line">	bitvec[index] = 1;</span><br><span class="line">         上面的循环把bitvec中的偶数下标的位都置为1。</span><br><span class="line">       除了用下标操作符，还可以用set、test和reset操作来测试或设置给定二进制位的值：</span><br><span class="line">// equivalent loop using set operation</span><br><span class="line">for (int index = 0; index != 32; index += 2)</span><br><span class="line">	bitvec.set(index);</span><br><span class="line">         为了测试某个二进制位是否为1，可以用test操作或者测试下标操作符的返回值：</span><br><span class="line">if (bitvec.test(i))</span><br><span class="line">    // bitvec[i] is on</span><br><span class="line">// equivalent test using subscript</span><br><span class="line">if (bitvec[i])</span><br><span class="line">    // bitvec[i] is on</span><br><span class="line">           如果下标操作符测试的二进制位为1，则返回的测试值的结果为true，否则返回false。</span><br><span class="line">2.3对整个bitset对象进行设置</span><br><span class="line">          set和reset操作分别用来对整个bitset对象的所有二进制位全置1和全置0：</span><br><span class="line"></span><br><span class="line">bitvec.reset();    // set all the bits to 0.</span><br><span class="line">bitvec.set();      // set all the bits to 1</span><br><span class="line">          flip操作可以对bitset对象的所有位或个别位按位取反：</span><br><span class="line">bitvec.flip(0);   // reverses value of first bit</span><br><span class="line">bitvec[0].flip(); // also reverses the first bit</span><br><span class="line">bitvec.flip();    // reverses value of all bits</span><br></pre></td></tr></table></figure>
<h3 id="2-4获取bitset对象的值"><a href="#2-4获取bitset对象的值" class="headerlink" title="2.4获取bitset对象的值"></a>2.4获取bitset对象的值</h3><pre><code>to_ulong操作返回一个unsigned long值，该值与bitset对象的位模式存储值相同。仅当bitset类型的长度小于或等于unsigned long的长度时，才可以使用to_ulong操作：
</code></pre><p>unsigned long ulong = bitvec3.to_ulong();<br>cout &lt;&lt; “ulong = “ &lt;&lt; ulong &lt;&lt; endl;<br>           to_ulong操作主要用于把bitset对象转到C风格或标准C++之前风格的程序上。如果bitset对象包含的二进制位数超过unsigned long的长度，将会产生运行时异常。</p>
<h3 id="2-5输出二进制位"><a href="#2-5输出二进制位" class="headerlink" title="2.5输出二进制位"></a>2.5输出二进制位</h3><pre><code>可以用输出操作符输出bitset对象中的位模式：
</code></pre><p>bitset<32> bitvec2(0xffff); // bits 0 … 15 are set to 1; 16 … 31 are 0<br>cout &lt;&lt; “bitvec2: “ &lt;&lt; bitvec2 &lt;&lt; endl;<br>           输出结果为：<br>bitvec2: 00000000000000001111111111111111</32></p>
<h3 id="2-6使用位操作符"><a href="#2-6使用位操作符" class="headerlink" title="2.6使用位操作符"></a>2.6使用位操作符</h3><pre><code>bitset类也支持内置的位操作符。C++定义的这些操作符都只适用于整型操作数，它们所提供的操作类似于本节所介绍的bitset操作。
</code></pre><h2 id="3-程序实例"><a href="#3-程序实例" class="headerlink" title="3.程序实例"></a>3.程序实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">	//bitset 使用整数初始化bitset</span><br><span class="line">	bitset&lt;3&gt; bs(7);</span><br><span class="line">	//输出bs各个位的值</span><br><span class="line">	cout&lt;&lt;&quot;bs[0] is &quot;&lt;&lt;bs[0]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;bs[1] is &quot;&lt;&lt;bs[1]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;bs[2] is &quot;&lt;&lt;bs[2]&lt;&lt;endl;</span><br><span class="line">	//下面的语句会抛出outofindexexception</span><br><span class="line">	//cout&lt;&lt;&quot;bs[3] is &quot;&lt;&lt;bs[3]&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">	//使用字符串初始化bitset</span><br><span class="line">	//注意：使用string初始化时从右向左处理，如下初始化的各个位的值将是110，而非011</span><br><span class="line">	string strVal(&quot;011&quot;);</span><br><span class="line">	bitset&lt;3&gt; bs1(strVal);</span><br><span class="line">	//输出各位	</span><br><span class="line">	cout&lt;&lt;&quot;bs1[0] is &quot;&lt;&lt;bs1[0]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;bs1[1] is &quot;&lt;&lt;bs1[1]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;bs1[2] is &quot;&lt;&lt;bs1[2]&lt;&lt;endl;</span><br><span class="line">	//cout输出时也是从右边向左边输出</span><br><span class="line">	cout&lt;&lt;bs1&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">	//bitset的方法</span><br><span class="line">	//any()方法如果有一位为1，则返回1</span><br><span class="line">	cout&lt;&lt;&quot;bs1.any() = &quot;&lt;&lt;bs1.any()&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">	//none()方法，如果有一个为1none则返回0，如果全为0则返回1</span><br><span class="line">	bitset&lt;3&gt; bsNone;</span><br><span class="line">	cout&lt;&lt;&quot;bsNone.none() = &quot; &lt;&lt;bsNone.none()&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">	//count()返回几个位为1</span><br><span class="line">	cout&lt;&lt;&quot;bs1.count() = &quot;&lt;&lt;bs1.count()&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">	//size()返回位数</span><br><span class="line">	cout&lt;&lt;&quot;bs1.size() = &quot;&lt;&lt;bs1.size()&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">	//test()返回某一位是否为1</span><br><span class="line">	//flip()诸位取反</span><br><span class="line">	bitset&lt;3&gt; bsFlip = bs1.flip();</span><br><span class="line">	cout&lt;&lt;&quot;bsFlip = &quot;&lt;&lt;bsFlip&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">	//to_ulong</span><br><span class="line">	unsigned long val = bs1.to_ulong();</span><br><span class="line">	cout&lt;&lt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cppblog.com/ylfeng/archive/2010/03/26/110592.html" target="_blank" rel="noopener">http://www.cppblog.com/ylfeng/archive/2010/03/26/110592.html</a><br><a href="https://blog.csdn.net/qll125596718/article/details/6901935" target="_blank" rel="noopener">https://blog.csdn.net/qll125596718/article/details/6901935</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>bootstrap学习笔记（一）</title>
    <url>/2018/05/30/bookstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Bootstrap:响应式框架,它会根据你的屏幕的大小来调整HTML元素的大小 —— 强调 响应式设计的概念</p>
<h1 id="常用APIs"><a href="#常用APIs" class="headerlink" title="常用APIs"></a>常用APIs</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;//maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="使图片适配手机显示"><a href="#使图片适配手机显示" class="headerlink" title="使图片适配手机显示"></a>使图片适配手机显示</h2><h2 id="使文本居中"><a href="#使文本居中" class="headerlink" title="使文本居中"></a>使文本居中</h2><p>可以用空格和已有的class区别开<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h2 class=&quot;red-text text-center&quot;&gt;your text&lt;/h2&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加一个按钮"><a href="#添加一个按钮" class="headerlink" title="添加一个按钮"></a>添加一个按钮</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button class=&quot;btn&quot;&gt;Like&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h2 id="添加块级元素-block-按钮"><a href="#添加块级元素-block-按钮" class="headerlink" title="添加块级元素(block)按钮"></a>添加块级元素(block)按钮</h2><p>匹配父容器的按钮<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button class=&quot;btn btn-block&quot;&gt;Like&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="给按钮添加颜色"><a href="#给按钮添加颜色" class="headerlink" title="给按钮添加颜色"></a>给按钮添加颜色</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(深蓝色)&lt;button class=&quot;btn btn-block btn-primary&quot;&gt;Like&lt;/button&gt;</span><br><span class="line">(浅蓝色)&lt;button class=&quot;btn btn-block btn-info&quot;&gt;Info&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h2 id="添加一个Bootstrap警告按钮"><a href="#添加一个Bootstrap警告按钮" class="headerlink" title="添加一个Bootstrap警告按钮"></a>添加一个Bootstrap警告按钮</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button class=&quot;btn btn-block btn-danger&quot;&gt;Delete&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h1 id="使用Bootstrap做页面布局"><a href="#使用Bootstrap做页面布局" class="headerlink" title="使用Bootstrap做页面布局"></a>使用Bootstrap做页面布局</h1><p><strong>响应式网格布局——可轻松实现将多个元素放入一行并指定各个元素的相对宽度的需求。Bootstrap 中大多数的class属性都可以设置于 div 元素中。</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div class=&quot;col-xs-4&quot;&gt;&lt;button class=&quot;btn btn-block btn-primary&quot;&gt;Like&lt;/button&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;col-xs-4&quot;&gt;&lt;button class=&quot;btn btn-block btn-info&quot;&gt;Info&lt;/button&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;col-xs-4&quot;&gt;&lt;button class=&quot;btn btn-block btn-danger&quot;&gt;Delete&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>c++STL中Stack</title>
    <url>/2018/04/26/c++Stack/</url>
    <content><![CDATA[<h2 id="c-stl栈stack的头文件为"><a href="#c-stl栈stack的头文件为" class="headerlink" title="c++stl栈stack的头文件为:"></a>c++stl栈stack的头文件为:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="c-stl栈stack的成员函数介绍"><a href="#c-stl栈stack的成员函数介绍" class="headerlink" title="c++stl栈stack的成员函数介绍"></a>c++stl栈stack的成员函数介绍</h2><p>操作 比较和分配堆栈<br>empty() 堆栈为空则返回真<br>pop() 移除栈顶元素<br>push() 在栈顶增加元素<br>size() 返回栈中元素数目<br>top() 返回栈顶元素<br><a id="more"></a></p>
<h3 id="stack-empty"><a href="#stack-empty" class="headerlink" title="stack::empty"></a>stack::empty</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>  </span>&#123;  </span><br><span class="line">       <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;    <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) mystack.push(i);       <span class="keyword">while</span> (!mystack.empty())    &#123;       sum += mystack.top();       mystack.pop();    &#125;       <span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;         <span class="keyword">return</span> <span class="number">0</span>;  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="stack-push-pop"><a href="#stack-push-pop" class="headerlink" title="stack::push/pop"></a>stack::push/pop</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;  </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) mystack.push(i);  </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">while</span> (!mystack.empty())  </span><br><span class="line">  &#123;  </span><br><span class="line">     sum += mystack.top();  </span><br><span class="line">     mystack.pop();  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">     </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="判断字符串回文"><a href="#判断字符串回文" class="headerlink" title="判断字符串回文"></a>判断字符串回文</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">   <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str[i]!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(str[i])</span><br><span class="line">        &#123;</span><br><span class="line">        case'(': s.push(str[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        case'[':s.push(str[i]);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">        case'&#123;':s.push(str[i]);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">'</span>]<span class="string">':</span></span><br><span class="line">            if(!s.empty()&amp;&amp;s.top()=='[')</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">else</span> flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">'</span>)<span class="string">':</span></span><br><span class="line">            if(!s.empty()&amp;&amp;s.top()=='(')</span><br><span class="line">                s.pop();</span><br><span class="line">          <span class="keyword">else</span> flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">            <span class="keyword">if</span>(!s.empty()&amp;&amp;s.top()==<span class="string">'&#123;'</span>)</span><br><span class="line">                s.pop();</span><br><span class="line">            <span class="keyword">else</span> flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty())</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">bool</span> flag=isMatch(s);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">   <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str[i]!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(str[i])</span><br><span class="line">        &#123;</span><br><span class="line">        case'(': s.push(str[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        case'[':s.push(str[i]);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">        case'&#123;':s.push(str[i]);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">'</span>]<span class="string">':</span></span><br><span class="line">            if(!s.empty()&amp;&amp;s.top()=='[')</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">else</span> flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">'</span>)<span class="string">':</span></span><br><span class="line">            if(!s.empty()&amp;&amp;s.top()=='(')</span><br><span class="line">                s.pop();</span><br><span class="line">          <span class="keyword">else</span> flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">            <span class="keyword">if</span>(!s.empty()&amp;&amp;s.top()==<span class="string">'&#123;'</span>)</span><br><span class="line">                s.pop();</span><br><span class="line">            <span class="keyword">else</span> flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty())</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">bool</span> flag=isMatch(s);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="表达式计算器"><a href="#表达式计算器" class="headerlink" title="表达式计算器"></a>表达式计算器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#define MAXSIZE   10</span><br><span class="line">//定义存储整型的栈</span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">    double data[MAXSIZE];</span><br><span class="line">    int top;</span><br><span class="line">&#125; SeqStack;</span><br><span class="line">//定义存储字符型的栈</span><br><span class="line">typedef struct nodeChar</span><br><span class="line">&#123;</span><br><span class="line">    char data[MAXSIZE];</span><br><span class="line">    int top;//栈顶指针</span><br><span class="line">&#125; SeqStackchar;</span><br><span class="line">//创建整型栈</span><br><span class="line">SeqStack *creat_num()</span><br><span class="line">&#123;</span><br><span class="line">    SeqStack *s;</span><br><span class="line">    s = (SeqStack *)malloc(sizeof(SeqStack));</span><br><span class="line">    s-&gt;top = -1;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">//创建字符串栈</span><br><span class="line">SeqStackchar *creat_char()</span><br><span class="line">&#123;</span><br><span class="line">    SeqStackchar *s;</span><br><span class="line">    s = (SeqStackchar *)malloc(sizeof(SeqStackchar));</span><br><span class="line">    s-&gt;top = -1;</span><br><span class="line">    return  s;</span><br><span class="line">&#125;</span><br><span class="line">int isEmpty(SeqStackchar *s)</span><br><span class="line">&#123;</span><br><span class="line">    if(s-&gt;top==-1) return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br><span class="line">char GetTop_char(SeqStackchar *s)</span><br><span class="line">&#123;</span><br><span class="line">    if(s-&gt;top==-1) exit(1);</span><br><span class="line">    if(s-&gt;top!=-1)</span><br><span class="line">        return s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line">double GetTop_num(SeqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">    if(s-&gt;top==-1) exit(1);</span><br><span class="line">    if(s-&gt;top!=-1)</span><br><span class="line">        return s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line">int isOperator(char op)</span><br><span class="line">&#123;</span><br><span class="line">    if(op==&apos;+&apos;||op==&apos;-&apos;||op==&apos;*&apos;||op==&apos;/&apos;||op==&apos;^&apos;) return 1;</span><br><span class="line">    else return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void push_num(SeqStack *S,double e)</span><br><span class="line">&#123;</span><br><span class="line">    if(MAXSIZE-1==S-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error!\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //栈顶指向的元素有值</span><br><span class="line">    ++(S-&gt;top);</span><br><span class="line">    S-&gt;data[S-&gt;top]=e;</span><br><span class="line">&#125;</span><br><span class="line">void push_char(SeqStackchar *S,char e)</span><br><span class="line">&#123;</span><br><span class="line">    if(MAXSIZE-1==S-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //栈顶指向的元素有值</span><br><span class="line">    ++(S-&gt;top);</span><br><span class="line">    S-&gt;data[S-&gt;top]=e;</span><br><span class="line">&#125;</span><br><span class="line">// 出栈</span><br><span class="line">char pop_char(SeqStackchar *S)</span><br><span class="line">&#123;</span><br><span class="line">    char e;</span><br><span class="line">//将栈顶元素出栈，传给e</span><br><span class="line">    if(-1==S-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error！\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    e=S-&gt;data[S-&gt;top];</span><br><span class="line">    --(S-&gt;top);</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br><span class="line">double pop_num(SeqStack *S)</span><br><span class="line">&#123;</span><br><span class="line">    double e;</span><br><span class="line">//将栈顶元素出栈，传给e</span><br><span class="line">    if(-1==S-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error！\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    e=S-&gt;data[S-&gt;top];</span><br><span class="line">    --(S-&gt;top);</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br><span class="line">int priority(char op)</span><br><span class="line">&#123;</span><br><span class="line">    switch(op)</span><br><span class="line">    &#123;</span><br><span class="line">    case &apos;\0&apos;:</span><br><span class="line">        return -1;</span><br><span class="line">    case &apos;(&apos;:</span><br><span class="line">        return 0;</span><br><span class="line">    case &apos;+&apos;:</span><br><span class="line">    case &apos;-&apos;:</span><br><span class="line">        return 1;</span><br><span class="line">    case &apos;*&apos;:</span><br><span class="line">    case &apos;/&apos;:</span><br><span class="line">    case &apos;^&apos;:</span><br><span class="line">        return 2;</span><br><span class="line">    default :</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">double read_number(char str[],int *i)</span><br><span class="line">&#123;</span><br><span class="line">    double x=0.0;</span><br><span class="line">    int k = 0;</span><br><span class="line">    while(str[*i] &gt;=&apos;0&apos; &amp;&amp; str[*i]&lt;=&apos;9&apos;)  // 处理整数部分</span><br><span class="line">    &#123;</span><br><span class="line">        x = x*10+(str[*i]-&apos;0&apos;);</span><br><span class="line">        (*i)++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(str[*i]==&apos;.&apos;) // 处理小数部分</span><br><span class="line">    &#123;</span><br><span class="line">        (*i)++;</span><br><span class="line">        while(str[*i] &gt;= &apos;0&apos;&amp;&amp;str[*i] &lt;=&apos;9&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            x = x * 10 + (str[*i]-&apos;0&apos;);</span><br><span class="line">            (*i)++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(k!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        x /= 10.0;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">//   把中缀表达式转换为后缀表达式，返回后缀表达式的长度（包括空格）</span><br><span class="line">void posttoFix(char pre[],char post[],int *n)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0 ,j=0,q=0;</span><br><span class="line">    SeqStackchar *stack=creat_char();     // 初始化存储操作符的栈</span><br><span class="line">    push_char(stack,&apos;\0&apos;);    // 首先把结束标志‘\0’放入栈底</span><br><span class="line">    while(pre[i]!=&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if((pre[i]&gt;=&apos;0&apos; &amp;&amp; pre[i] &lt;=&apos;9&apos;)||pre[i] ==&apos;.&apos;) // 遇到数字和小数点直接写入后缀表达式</span><br><span class="line">        &#123;</span><br><span class="line">            post[j++] = pre[i];</span><br><span class="line">            (*n)++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(pre[i]==&apos;s&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            (*n)++;</span><br><span class="line">            if(pre[i]==&apos;i&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                (*n)++;</span><br><span class="line">                if(pre[i]==&apos;n&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    (*n)++;</span><br><span class="line">                    if(pre[i]==&apos;(&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                        (*n)++;</span><br><span class="line">                        post[j++]=&apos;s&apos;;</span><br><span class="line">                        post[j++]=&apos;i&apos;;</span><br><span class="line">                        post[j++]=&apos;n&apos;;</span><br><span class="line">                        post[j++]=&apos;(&apos;;</span><br><span class="line">                        while(pre[i]!=&apos;)&apos;&amp;&amp;pre[i]!=&apos;\0&apos;)</span><br><span class="line">                        &#123;</span><br><span class="line">                            post[j++]=pre[i];</span><br><span class="line">                            i++;</span><br><span class="line">                            (*n)++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if(pre[i]!=&apos;)&apos;) &#123;printf(&quot;error!\n&quot;);exit(1);&#125;</span><br><span class="line">                        post[j++]=&apos;)&apos;;//为了赋给后面的操作数</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(pre[i]==&apos;c&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            (*n)++;</span><br><span class="line">            if(pre[i]==&apos;o&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                (*n)++;</span><br><span class="line">                if(pre[i]==&apos;s&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    (*n)++;</span><br><span class="line">                    if(pre[i]==&apos;(&apos;)</span><br><span class="line">                    &#123;           i++;</span><br><span class="line">                            (*n)++;</span><br><span class="line">                        post[j++]=&apos;c&apos;;</span><br><span class="line">                        post[j++]=&apos;o&apos;;</span><br><span class="line">                        post[j++]=&apos;s&apos;;</span><br><span class="line">                        post[j++]=&apos;(&apos;;</span><br><span class="line">                         while(pre[i]!=&apos;)&apos;&amp;&amp;pre[i]!=&apos;\0&apos;)</span><br><span class="line">                        &#123;</span><br><span class="line"></span><br><span class="line">                            post[j++]=pre[i];</span><br><span class="line">                            i++;</span><br><span class="line">                            (*n)++;</span><br><span class="line">                        &#125;      if(pre[i]!=&apos;)&apos;) &#123;printf(&quot;error!\n&quot;);exit(1);&#125;</span><br><span class="line">                        post[j++]=&apos;)&apos;;//为了赋给后面的操作数</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(pre[i]==&apos;t&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            (*n)++;</span><br><span class="line">            if(pre[i]==&apos;a&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                (*n)++;</span><br><span class="line">                if(pre[i]==&apos;n&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    (*n)++;</span><br><span class="line">                    if(pre[i]==&apos;(&apos;)</span><br><span class="line">                    &#123;     i++;</span><br><span class="line">                        (*n)++;</span><br><span class="line">                        post[j++]=&apos;t&apos;;</span><br><span class="line">                        post[j++]=&apos;a&apos;;</span><br><span class="line">                        post[j++]=&apos;n&apos;;</span><br><span class="line">                        post[j++]=&apos;(&apos;;</span><br><span class="line">                         while(pre[i]!=&apos;)&apos;&amp;&amp;pre[i]!=&apos;\0&apos;)</span><br><span class="line">                        &#123;</span><br><span class="line"></span><br><span class="line">                            post[j++]=pre[i];</span><br><span class="line">                            i++;</span><br><span class="line">                            (*n)++;</span><br><span class="line">                        &#125;      if(pre[i]!=&apos;)&apos;) &#123;printf(&quot;error!\n&quot;);exit(1);&#125;</span><br><span class="line">                        post[j++]=&apos;)&apos;;//为了赋给后面的操作数</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (pre[i]==&apos;(&apos;)   // 遇到“（”不用比较直接入栈</span><br><span class="line">            push_char(stack,pre[i]);</span><br><span class="line">        else if(pre[i] ==&apos;)&apos;)  // 遇到右括号将其对应左括号后的操作符（操作符栈中的）全部写入后缀表达式</span><br><span class="line">        &#123;</span><br><span class="line">            while(GetTop_char(stack)!=&apos;(&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                post[j++]=pop_char(stack);</span><br><span class="line">                (*n)++;</span><br><span class="line">            &#125;</span><br><span class="line">            pop_char(stack); // 将“（”出栈，后缀表达式中不含小括号</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isOperator(pre[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            post[j++]=&apos; &apos;; // 用空格分开操作数(</span><br><span class="line">            (*n)++;</span><br><span class="line">            while(priority(pre[i]) &lt;= priority(GetTop_char(stack)))</span><br><span class="line">            &#123;</span><br><span class="line">                // 当前的操作符小于等于栈顶操作符的优先级时，将栈顶操作符写入到后缀表达式，重复此过程</span><br><span class="line">                post[j++] = pop_char(stack);</span><br><span class="line">                (*n)++;</span><br><span class="line">            &#125;</span><br><span class="line">            push_char(stack,pre[i]); // 当前操作符优先级大于栈顶操作符的优先级，将该操作符入栈</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(stack-&gt;top!=-1)// 将所有的操作符加入后缀表达式</span><br><span class="line">    &#123;</span><br><span class="line">        post[j++] =pop_char(stack);</span><br><span class="line">        (*n)++;</span><br><span class="line">    &#125;</span><br><span class="line">    post[j]=&apos;\0&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Operate(double a,char op,double b)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    double result=1;</span><br><span class="line">    switch(op)</span><br><span class="line">    &#123;</span><br><span class="line">    case &apos;+&apos;:</span><br><span class="line">        result=a+b;</span><br><span class="line">        break;</span><br><span class="line">    case &apos;-&apos;:</span><br><span class="line">        result=a-b;</span><br><span class="line">        break;</span><br><span class="line">    case &apos;*&apos;:</span><br><span class="line">        result=a*b;</span><br><span class="line">        break;</span><br><span class="line">    case &apos;/&apos;:</span><br><span class="line">        result=a/b*1.0;</span><br><span class="line">        break;</span><br><span class="line">    case &apos;^&apos;:</span><br><span class="line">        for(i=0; i&lt;b; i++)</span><br><span class="line">            result*=a;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">double postfix_value(char post[])</span><br><span class="line">&#123;</span><br><span class="line">    SeqStack *stack=creat_num();    // 操作数栈</span><br><span class="line">    int i=0,q;</span><br><span class="line">    double temp;</span><br><span class="line">    double result;</span><br><span class="line">    double x1,x2;</span><br><span class="line">    char str[20];</span><br><span class="line">    int k;</span><br><span class="line">    while(post[i] !=&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(post[i] &gt;=&apos;0&apos; &amp;&amp; post[i] &lt;=&apos;9&apos;)</span><br><span class="line">            push_num(stack,read_number(post,&amp;i));</span><br><span class="line">        else if(post[i] == &apos; &apos;)</span><br><span class="line">            i++;</span><br><span class="line">        else if(post[i]==&apos;s&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            k=0;</span><br><span class="line">            i++;</span><br><span class="line">            if(post[i]==&apos;i&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                if(post[i]==&apos;n&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    if(post[i]==&apos;(&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                        while(post[i]!=&apos;)&apos;)</span><br><span class="line">                        &#123;</span><br><span class="line">                            str[k++]=post[i];</span><br><span class="line">                            i++;</span><br><span class="line">                        &#125;</span><br><span class="line">                       i++;</span><br><span class="line">                        str[k]=&apos;\0&apos;;</span><br><span class="line">                        q=0;</span><br><span class="line">                        result=read_number(str,&amp;q);</span><br><span class="line">                        push_num(stack,sin(result));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(post[i]==&apos;c&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            k=0;</span><br><span class="line">            i++;</span><br><span class="line">            if(post[i]==&apos;o&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                if(post[i]==&apos;s&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    if(post[i]==&apos;(&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                        while(post[i]!=&apos;)&apos;)</span><br><span class="line">                        &#123;</span><br><span class="line">                            str[k++]=post[i];</span><br><span class="line">                            i++;</span><br><span class="line">                        &#125;</span><br><span class="line">                      i++;</span><br><span class="line">                        str[k]=&apos;\0&apos;;</span><br><span class="line">                        q=0;</span><br><span class="line">                        result=read_number(str,&amp;q);</span><br><span class="line">                        push_num(stack,sin(result));</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(post[i]==&apos;t&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            k=0;</span><br><span class="line">            i++;</span><br><span class="line">            if(post[i]==&apos;a&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                if(post[i]==&apos;n&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    if(post[i]==&apos;(&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                        while(post[i]!=&apos;)&apos;)</span><br><span class="line">                        &#123;</span><br><span class="line">                            str[k++]=post[i];</span><br><span class="line">                            i++;</span><br><span class="line">                        &#125;</span><br><span class="line">                         i++;</span><br><span class="line">                        str[k]=&apos;\0&apos;;</span><br><span class="line">                        q=0;</span><br><span class="line">                        result=read_number(str,&amp;q);</span><br><span class="line">                        push_num(stack,sin(result));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            x2=pop_num(stack);</span><br><span class="line">            x1=pop_num(stack);</span><br><span class="line">            temp=Operate(x1,post[i],x2);</span><br><span class="line">            push_num(stack,temp);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return GetTop_num(stack);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char exp[100];</span><br><span class="line">    printf(&quot;表达式：&quot;);</span><br><span class="line">    char post[100] ;</span><br><span class="line">    gets(exp);</span><br><span class="line">    fflush(stdin);</span><br><span class="line">    int i,n=0;           // 返回后缀表达式的长度</span><br><span class="line">    posttoFix(exp,post,&amp;n);</span><br><span class="line">    printf(&quot;后缀表达式为：&quot;);</span><br><span class="line">    for(i =0 ; post[i]!=&apos;\0&apos;; i++)</span><br><span class="line">        printf(&quot;%c&quot;,post[i]);</span><br><span class="line">    printf(&quot;\n由后缀表达式计算出的数值结果:\n&quot;);</span><br><span class="line">    printf(&quot;%f&quot;,postfix_value(post));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ string</title>
    <url>/2018/11/28/c-string/</url>
    <content><![CDATA[<p>声明和初始化方法：<br>想使用string首先要在头文件当中加入&lt; string &gt;<br>声明方式也很简单<br><a id="more"></a><br>声明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s;//声明一个string 对象</span><br><span class="line">string ss[10];//声明一个string对象的数组</span><br></pre></td></tr></table></figure></p>
<p>初始化：<br>使用等号的初始化叫做拷贝初始化，不使用等号的初始化叫做直接初始化。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s;//默认初始化，一个空字符串</span><br><span class="line">    string s1(&quot;ssss&quot;);//s1是字面值“ssss”的副本</span><br><span class="line">    string s2(s1);//s2是s1的副本</span><br><span class="line">    string s3=s2;//s3是s2的副本</span><br><span class="line">    string s4(10,&apos;c&apos;);//把s4初始化</span><br><span class="line">    string s5=&quot;hiya&quot;;//拷贝初始化</span><br><span class="line">    string s6=string(10,&apos;c&apos;);//拷贝初始化，生成一个初始化好的对象，拷贝给s6</span><br><span class="line"></span><br><span class="line">    //string s(cp,n)</span><br><span class="line">    char cs[]=&quot;12345&quot;;</span><br><span class="line">    string s7(cs,3);//复制字符串cs的前3个字符到s当中</span><br><span class="line"></span><br><span class="line">    //string s(s2,pos2)</span><br><span class="line">    string s8=&quot;asac&quot;;</span><br><span class="line">    string s9(s8,2);//从s2的第二个字符开始拷贝，不能超过s2的size</span><br><span class="line"></span><br><span class="line">    //string s(s2,pos2,len2)</span><br><span class="line">    string s10=&quot;qweqweqweq&quot;;</span><br><span class="line">    string s11(s10,3,4);//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>字符串处理：<br>substr操作：<br>注意substr没有迭代器作为参数的操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s=&quot;abcdefg&quot;;</span><br><span class="line"></span><br><span class="line">    //s.substr(pos1,n)返回字符串位置为pos1后面的n个字符组成的串</span><br><span class="line">    string s2=s.substr(1,5);//bcdef</span><br><span class="line"></span><br><span class="line">    //s.substr(pos)//得到一个pos到结尾的串</span><br><span class="line">    string s3=s.substr(4);//efg</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果输入的位置超过字符的长度，会抛出一个out_of_range的异常</p>
<p>insert操作:<br>代码来自cpp官网，经过自己的整理<br>注意用迭代器当参数和无符号数当参数的区别<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string str=&quot;to be question&quot;;</span><br><span class="line">    string str2=&quot;the &quot;;</span><br><span class="line">    string str3=&quot;or not to be&quot;;</span><br><span class="line">    string::iterator it;</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,str)//在s的pos位置插入str</span><br><span class="line">    str.insert(6,str2);                 // to be the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,str,a,n)在s的pos位置插入str中插入位置a到后面的n个字符</span><br><span class="line">    str.insert(6,str3,3,4);             // to be not the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符</span><br><span class="line">    str.insert(10,&quot;that is cool&quot;,8);    // to be not that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,cstr)在s的pos位置插入cstr</span><br><span class="line">    str.insert(10,&quot;to be &quot;);            // to be not to be that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,n,ch)在s.pos位置上面插入n个ch</span><br><span class="line">    str.insert(15,1,&apos;:&apos;);               // to be not to be: that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(s.it,ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器</span><br><span class="line">    it = str.insert(str.begin()+5,&apos;,&apos;); // to be, not to be: that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(s.it,n,ch)//在s的it所指向位置的前面插入n个ch</span><br><span class="line">    str.insert (str.end(),3,&apos;.&apos;);       // to be, not to be: that is the question...</span><br><span class="line"></span><br><span class="line">    //s.insert(it,str.ita,str.itb)在it所指向的位置的前面插入[ita,itb)的字符串</span><br><span class="line">    str.insert (it+2,str3.begin(),str3.begin()+3); // to be, or not to be: that is the question...</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>erase操作：<br>用来执行删除操作<br>删除操作有三种</p>
<p>指定pos和len，其中pos为为起始位置，pos以及后面len-1个字符串都删除<br>迭代器，删除迭代器指向的字符<br>迭代器范围，删除这一范围的字符串，范围左闭右开<br>代码来自cpp官网<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::string str (&quot;This is an example sentence.&quot;);</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                          // &quot;This is an example sentence.&quot;</span><br><span class="line">  str.erase (10,8);       //            ^^^^^^^^</span><br><span class="line">  //直接指定删除的字符串位置第十个后面的8个字符</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                            // &quot;This is an sentence.&quot;</span><br><span class="line">  str.erase (str.begin()+9);//           ^</span><br><span class="line">  //删除迭代器指向的字符</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                            // &quot;This is a sentence.&quot;</span><br><span class="line">                            //       ^^^^^</span><br><span class="line">  str.erase (str.begin()+5, str.end()-9);</span><br><span class="line">  //删除迭代器范围的字符</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                            // &quot;This sentence.&quot;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>append和replace操作:<br>append函数可以用来在字符串的末尾追加字符和字符串。由于string重载了运算符，也可以用+=操作实现<br>repalce顾名思义，就是替换的意思，先删除，后增加。<br>代码来自cpp官网，附上自己的解释<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    std::string str2=&quot;Writing &quot;;</span><br><span class="line">    std::string str3=&quot;print 10 and then 5 more&quot;;</span><br><span class="line"></span><br><span class="line">    //直接追加一个str2的字符串</span><br><span class="line">    str.append(str2);                       // &quot;Writing &quot;</span><br><span class="line">    //后面追加str3第6个字符开始的3个字符串</span><br><span class="line">    str.append(str3,6,3);                   // &quot;10 &quot;</span><br><span class="line">    //追加字符串形参的前5个字符</span><br><span class="line">    str.append(&quot;dots are cool&quot;,5);          // &quot;dots &quot;</span><br><span class="line">    //直接添加</span><br><span class="line">    str.append(&quot;here: &quot;);                   // &quot;here: &quot;</span><br><span class="line">    //添加10个&apos;.&apos;</span><br><span class="line">    str.append(10u,&apos;.&apos;);                    // &quot;..........&quot;</span><br><span class="line">    //添加str3迭代器范围的字符串</span><br><span class="line">    str.append(str3.begin()+8,str3.end());  // &quot; and then 5 more&quot;</span><br><span class="line">    //最后这个比较特殊，意思是添加5个&apos;A&apos;，实际上参数里面的65对应的asc码就是65</span><br><span class="line">    str.append&lt;int&gt;(5,65);                // &quot;.....&quot;</span><br><span class="line">    //字符串追加也可以用重载运算符实现</span><br><span class="line">    str+=&quot;lalala&quot;;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>replace的使用方法，replace支持使用无符号整数寻找位置，也支持用迭代器寻找位置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::string base=&quot;this is a test string.&quot;;</span><br><span class="line">    std::string str2=&quot;n example&quot;;</span><br><span class="line">    std::string str3=&quot;sample phrase&quot;;</span><br><span class="line">    std::string str4=&quot;useful.&quot;;</span><br><span class="line"></span><br><span class="line">    // replace signatures used in the same order as described above:</span><br><span class="line"></span><br><span class="line">    // Using positions:          0123456789*123456789*12345</span><br><span class="line">    std::string str=base;           // &quot;this is a test string.&quot;</span><br><span class="line">    //第9个字符以及后面的4个字符被str2代替</span><br><span class="line">    str.replace(9,5,str2);          // &quot;this is an example string.&quot; (1)</span><br><span class="line">    //第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替</span><br><span class="line">    str.replace(19,6,str3,7,6);     // &quot;this is an example phrase.&quot; (2)</span><br><span class="line">    //第8个字符以及后面的9个字符用字符串参数代替</span><br><span class="line">    str.replace(8,10,&quot;just a&quot;);     // &quot;this is just a phrase.&quot;     (3)</span><br><span class="line">    //第8个字符以及后面的5个字符用字符串参数的前7个字符替换</span><br><span class="line">    str.replace(8,6,&quot;a shorty&quot;,7);  // &quot;this is a short phrase.&quot;    (4)</span><br><span class="line">    //第22以及后面的0个字符用3个叹号替换</span><br><span class="line">    str.replace(22,1,3,&apos;!&apos;);        // &quot;this is a short phrase!!!&quot;  (5)</span><br><span class="line">    //迭代器的原理同上</span><br><span class="line">    // Using iterators:                                               0123456789*123456789*</span><br><span class="line">    str.replace(str.begin(),str.end()-3,str3);                    // &quot;sample phrase!!!&quot;      (1)</span><br><span class="line">    str.replace(str.begin(),str.begin()+6,&quot;replace&quot;);             // &quot;replace phrase!!!&quot;     (3)</span><br><span class="line">    str.replace(str.begin()+8,str.begin()+14,&quot;is coolness&quot;,7);    // &quot;replace is cool!!!&quot;    (4)</span><br><span class="line">    str.replace(str.begin()+12,str.end()-4,4,&apos;o&apos;);                // &quot;replace is cooool!!!&quot;  (5)</span><br><span class="line">    str.replace(str.begin()+11,str.end(),str4.begin(),str4.end());// &quot;replace is useful.&quot;    (6)</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上的replace操作可以用insert和erase的操作组合替换，但是replace操作更加方便。</p>
<p>assign操作：<br>assign操作在一起列容器当中都存在，比如vector等等。是一个很基本的操作函数，string使用assign可以灵活的对其进行赋值。<br>代码来自cpp官网<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    std::string base=&quot;The quick brown fox jumps over a lazy dog.&quot;;</span><br><span class="line"></span><br><span class="line">    // used in the same order as described above:</span><br><span class="line">    //直接把base赋值给str</span><br><span class="line">    str.assign(base);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //把base第10个字符以及后面的8个字符赋给str</span><br><span class="line">    str.assign(base,10,9);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;brown fox&quot;</span><br><span class="line">    //把参数中的0到6个字符串赋给str</span><br><span class="line">    str.assign(&quot;pangrams are cool&quot;,7);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;pangram&quot;</span><br><span class="line">    //直接使用参数赋值</span><br><span class="line">    str.assign(&quot;c-string&quot;);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;c-string&quot;</span><br><span class="line">    //给str赋值10个&apos;*&apos;字符</span><br><span class="line">    str.assign(10,&apos;*&apos;);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;**********&quot;</span><br><span class="line">    //赋值是10个&apos;-&apos;</span><br><span class="line">    str.assign&lt;int&gt;(10,0x2D);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;----------&quot;</span><br><span class="line">    //指定base迭代器范围的字符串</span><br><span class="line">    str.assign(base.begin()+16,base.end()-12);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;fox jumps over&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>string的搜索操作:<br>string类中提供了很多性能优秀，使用方便的成员方法。而且在泛型算法当中也有很多实用的技巧。</p>
<p>find和rfind函数:<br>find函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。<br>代码来自cpp官网<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    std::string str (&quot;There are two needles in this haystack with needles.&quot;);</span><br><span class="line">    std::string str2 (&quot;needle&quot;);</span><br><span class="line"></span><br><span class="line">    // different member versions of find in the same order as above:</span><br><span class="line">    //在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾</span><br><span class="line">    std::size_t found = str.find(str2);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;first &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //在str当中，从第found+1的位置开始查找参数字符串的前6个字符</span><br><span class="line">    found=str.find(&quot;needles are small&quot;,found+1,6);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;second &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //在str当中查找参数中的字符串</span><br><span class="line">    found=str.find(&quot;haystack&quot;);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;&apos;haystack&apos; also found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //查找一个字符</span><br><span class="line">    found=str.find(&apos;.&apos;);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;Period found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //组合使用，把str2用参数表中的字符串代替</span><br><span class="line">    // let&apos;s replace the first needle:</span><br><span class="line">    str.replace(str.find(str2),str2.length(),&quot;preposition&quot;);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>rfind函数就是找最后一个出现的匹配字符串，返回的位置仍然是从前往后数的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    std::string str (&quot;The sixth sick sheik&apos;s sixth sheep&apos;s sick.&quot;);</span><br><span class="line">    std::string key (&quot;sixth&quot;);//                    ^</span><br><span class="line">    //rfind是找最后一个出现的匹配字符串</span><br><span class="line">    std::size_t found = str.rfind(key);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;found&lt;&lt;endl;//输出23</span><br><span class="line">        str.replace (found,key.length(),&quot;seventh&quot;);//找到的sixth替换成seventh</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查找的效率非常高，我没看过stl源码剖析，但是感觉是用kmp实现的。呵呵，可以自己写一个。</p>
<p>find_….of函数:<br>find_first_of(args) 查找args中任何一个字符第一次出现的位置<br>find_last_of(args) 最后一个出现的位置<br>find_fist_not_of(args) 查找第一个不在args中的字符<br>find_last_not_of 查找最后一个不在args中出现的字符</p>
<p>#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    std::string str1 (&quot;Please, replace the vowels in this sentence by asterisks.&quot;);</span><br><span class="line">    std::size_t found1 = str1.find_first_of(&quot;aeiou&quot;);</span><br><span class="line">    //把所有元音找出来用*代替</span><br><span class="line">    while (found1!=std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        str1[found1]=&apos;*&apos;;</span><br><span class="line">        found1=str1.find_first_of(&quot;aeiou&quot;,found1+1);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; str1 &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">    //在str2中找到第一个不是消协英文字母和空格的字符</span><br><span class="line">    std::string str2 (&quot;look for non-alphabetic characters...&quot;);</span><br><span class="line">    std::size_t found2 = str2.find_first_not_of(&quot;abcdefghijklmnopqrstuvwxyz &quot;);</span><br><span class="line">    if (found2!=std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;The first non-alphabetic character is &quot; &lt;&lt; str2[found2];</span><br><span class="line">        std::cout &lt;&lt; &quot; at position &quot; &lt;&lt; found2 &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>find_last_of和find_last_not_of与first基本相同，就不写例子代码了。</p>
<p>比较与转换:<br>类似c语言的字符串比较函数strcmp函数一样，支持字符串比较操作，同时也类似python、C#语言中的函数一样，支持把数字和字符串转换。有些特性是C++11当中才有。<br>注意编译器bug：<br>在MinGW编译器当中如果版本低于3.8，虽然支持c++11但是里面有一个bug，就是不支持字符串和数组的转换！要更新MinGW的版本才可以，或者直接使用g++。</p>
<p>compare函数:<br>和strcmp函数一样，如果两个字符串相等，那么返回0，调用对象大于参数返回1，小于返回-1。<br>在compare当中还支持部分比较，里面有6个参数可以设置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s1=&quot;123&quot;,s2=&quot;123&quot;;</span><br><span class="line">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//0</span><br><span class="line"></span><br><span class="line">    s1=&quot;123&quot;,s2=&quot;1234&quot;;</span><br><span class="line">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//-1</span><br><span class="line"></span><br><span class="line">    s1=&quot;1234&quot;,s2=&quot;123&quot;;</span><br><span class="line">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//1</span><br><span class="line"></span><br><span class="line">    std::string str1 (&quot;green apple&quot;);</span><br><span class="line">    std::string str2 (&quot;red apple&quot;);</span><br><span class="line"></span><br><span class="line">    if (str1.compare(str2) != 0)</span><br><span class="line">    std::cout &lt;&lt; str1 &lt;&lt; &quot; is not &quot; &lt;&lt; str2 &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //str1的第6个字符以及后面的4个字符和参数比较</span><br><span class="line">    if (str1.compare(6,5,&quot;apple&quot;) == 0)</span><br><span class="line">    std::cout &lt;&lt; &quot;still, &quot; &lt;&lt; str1 &lt;&lt; &quot; is an apple\n&quot;;</span><br><span class="line"></span><br><span class="line">    if (str2.compare(str2.size()-5,5,&quot;apple&quot;) == 0)</span><br><span class="line">    std::cout &lt;&lt; &quot;and &quot; &lt;&lt; str2 &lt;&lt; &quot; is also an apple\n&quot;;</span><br><span class="line">    //str1的第6个字符以及后面的4个字符和str2的第4个字符以及后面的4个字符比较</span><br><span class="line">    if (str1.compare(6,5,str2,4,5) == 0)</span><br><span class="line">    std::cout &lt;&lt; &quot;therefore, both are apples\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于string重载了运算符，可以直接用&gt;,&lt;，==来进行比较，也很方便。</p>
<p>数值转换：<br>在io的部分有过数值和字符串相互转换的例子，使用的是stringstream函数，在c++11当中有定义好的现成的函数取调用，非常方便。</p>
<p>string和数值转换<br>to_string(val)    把val转换成string<br>stoi(s,p,b)    把字符串s从p开始转换成b进制的int<br>stol(s,p,b)    long<br>stoul(s,p,b)    unsigned long<br>stoll(s,p,b)    long long<br>stoull(s,p,b)    unsigned long long<br>stof(s,p)    float<br>stod(s,p)    double<br>stold(s,p)    long double<br>//注意，下段代码在MinGw中会报错！即使使用c++11编译也一样，无法识别to_string！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s1;</span><br><span class="line">    s1=to_string(100);</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    int a=stoi(s1,0,10)+1;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考博客</p>
<p><a href="https://blog.csdn.net/tengfei461807914/article/details/52203202" target="_blank" rel="noopener">https://blog.csdn.net/tengfei461807914/article/details/52203202</a> </p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>c++string的append方法</title>
    <url>/2018/11/28/c-string%E7%9A%84append%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>C++ string append()添加文本</p>
<p>使用append()添加文本常用方法:<br><a id="more"></a><br>直接添加另一个完整的字符串:</p>
<p>如str1.append(str2);</p>
<p>添加另一个字符串的某一段子串:</p>
<p>如str1.append(str2, 11, 7);</p>
<p>添加几个相同的字符:</p>
<p>如str1.append(5, ‘.’);</p>
<p>注意,个数在前字符在后.上面的代码意思为在str1后面添加5个”.”.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    string str1=&quot;I like C++&quot;;</span><br><span class="line"> </span><br><span class="line">    string str2=&quot;,I like the world.&quot;;</span><br><span class="line"> </span><br><span class="line">    string str3=&quot;Hello&quot;;</span><br><span class="line"> </span><br><span class="line">    string str4(&quot;Hi&quot;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    str1.append(str2);</span><br><span class="line"> </span><br><span class="line">    str3.append(str2, 11, 7);</span><br><span class="line"> </span><br><span class="line">    str4.append(5, &apos;.&apos;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;str3&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;str4&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"> </span><br><span class="line">    return 0;   </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为</p>
<p>I like C++,I like the world.</p>
<p>Hello World.</p>
<p>Hi…..</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>c++ unique_ptr</title>
    <url>/2018/11/25/c-unique-ptr/</url>
    <content><![CDATA[<p><code>`</code><br>我们知道auto_ptr通过复制构造或者通过=赋值后,原来的auto_ptr对象就报废了.所有权转移到新的对象中去了.而通过shared_ptr可以让多个智能指针对象同时拥有某一块内存的访问权.但假如我们不希望多个内存块被多个智能指针对象共享,同时又不会像auto_ptr那样不知不觉的就让原来的auto_ptr对象失效,可咋整呢?<br><a id="more"></a><br>这个时候就要使用unique_ptr了,顾名思义嘛,unique是唯一的意思.说明它跟auto_ptr有点类似,就是同时只能有一个智能指针对象指向某块内存.但它还有些其他特性.</p>
<p>1.无法进行复制构造与赋值操作.<br>比如auto_ptr<int> ap(new int(88 );</int></p>
<pre><code>auto_ptr&lt;int&gt; one (ap) ; // ok

auto_ptr&lt;int&gt; two = one; //ok
</code></pre><p>但unique_ptr不支持上述操作</p>
<p>  unique_ptr<int> ap(new int(88 );</int></p>
<p>  unique_ptr<int> one (ap) ; // 会出错</int></p>
<p>  unique_ptr<int> two = one; //会出错</int></p>
<p>2.可以进行移动构造和移动赋值操作<br>就是像上面这样一般意义上的复制构造和赋值或出错.但在函数中作为返回值却可以用.</p>
<p>unique_ptr<int> GetVal( ){</int></p>
<p>unique_ptr<int> up(new int(88 );</int></p>
<p>return up;</p>
<p>}</p>
<p>unique_ptr<int> uPtr = GetVal();   //ok</int></p>
<p>实际上上面的的操作有点类似于如下操作</p>
<p>unique_ptr<int> up(new int(88 );</int></p>
<p>unique_ptr<int> uPtr2 = std:move( up) ; //这里是显式的所有权转移. 把up所指的内存转给uPtr2了,而up不再拥有该内存.另外注意如果你使用vs2008是没有std:move这函数的.</int></p>
<p>//vs2010开始才有,是c++ 11标准出现的内容.</p>
<p>3.可做为容器元素<br>我们知道auto_ptr不可做为容器元素.而unique_ptr也同样不能直接做为容器元素,但可以通过一点间接的手段</p>
<p>例如:</p>
<p>unique_ptr<int> sp(new int(88) );</int></p>
<p>vector&lt;unique_ptr<int> &gt; vec;</int></p>
<p>vec.push_back(std::move(sp));</p>
<p>//vec.push_back( sp ); 这样不行,会报错的.</p>
<p>//cout&lt;&lt;*sp&lt;&lt;endl;但这个也同样出错,说明sp添加到容器中之后,它自身报废了.</p>
<p>总结:<br>从上面的例子可以看出,unique_ptr和auto_ptr真的非常类似.其实你可以这样简单的理解,auto_ptr是可以说你随便赋值,但赋值完了之后原来的对象就不知不觉的报废.搞得你莫名其妙.而unique就干脆不让你可以随便去复制,赋值.如果实在想传个值就哪里,显式的说明内存转移std:move一下.然后这样传值完了之后,之前的对象也同样报废了.只不过整个move你让明显的知道这样操作后会导致之前的unique_ptr对象失效.</p>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://blog.csdn.net/weiwenhp/article/details/8708281" target="_blank" rel="noopener">https://blog.csdn.net/weiwenhp/article/details/8708281</a> </p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>c++复习（set，lambada表达式）</title>
    <url>/2018/10/29/c-%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h2><p>set容器；（有个小知识点，set容器，元素只能出现一次，并且插入可以从小到大排序）<br>set是一个集合 和康托前辈的一样 集合中的元素不重复 且集合中的元素是有序的（自动有序化） TY菌介绍说其内部实质是一个平衡树</p>
<p>set不是数组 只能通过迭代器（iterator）把里面的元素倒出来 迭代器相当于是指针 扫描的是地址 因此输出的时候需要用*variation<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool cmp(int a, int b) &#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a[] = &#123;7, 3, 5, 9, 1&#125;;</span><br><span class="line">	sort(a, a + 5, cmp);</span><br><span class="line">	for (int i = 0; i &lt; 5; i++)</span><br><span class="line">		cout &lt;&lt;setfill(&apos;*&apos;)&lt;&lt;setw(6)&lt;&lt; a[i] &lt;&lt; &quot;, &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fwowdmzoj2j30eu034glv.jpg" alt="image"></p>
<h2 id="lambada表达式"><a href="#lambada表达式" class="headerlink" title="lambada表达式"></a>lambada表达式</h2><p>闲话少说，归入正题，捕获的方式可以是引用也可以是复制，但是具体说来会有以下几种情况来捕获其所在作用域中的变量：</p>
<p>[]：默认不捕获任何变量；<br>[=]：默认以值捕获所有变量；</p>
<p>[&amp;]：默认以引用捕获所有变量；</p>
<p>[x]：仅以值捕获x，其它变量不捕获；</p>
<p>[&amp;x]：仅以引用捕获x，其它变量不捕获；</p>
<p>[=, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；</p>
<p>[&amp;, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；</p>
<p>[this]：通过引用捕获当前对象（其实是复制指针）；</p>
<p>[*this]：通过传值方式捕获当前对象；</p>
<p>在上面的捕获方式中，注意最好不要使用[=]和[&amp;]默认捕获所有变量。首先说默认引用捕获所有变量，你有很大可能会出现悬挂引用（Dangling references），因为引用捕获不会延长引用的变量的声明周期：</p>
<p>std::function&lt;int(int)&gt; add_x(int x)<br>{<br>    return <a href="int a">&amp;</a> { return x + a; };<br>}</p>
<p>因为参数x仅是一个临时变量，函数调用后就被销毁，但是返回的lambda表达式却引用了该变量，但调用这个表达式时，引用的是一个垃圾值，所以会产生没有意义的结果。你可能会想，可以通过传值的方式来解决上面的问题：</p>
<p>std::function&lt;int(int)&gt; add_x(int x)<br>{<br>    return <a href="int a">=</a> { return x + a; };<br>}</p>
<p>是的，使用默认传值方式可以避免悬挂引用问题。但是采用默认值捕获所有变量仍然有风险，看下面的例子：</p>
<p>class Filter<br>{<br>public:<br>    Filter(int divisorVal):<br>        divisor{divisorVal}<br>    {}</p>
<pre><code>std::function&lt;bool(int)&gt; getFilter() 
{
    return [=](int value) {return value % divisor == 0; };
}
</code></pre><p>private:<br>    int divisor;<br>};</p>
<p>这个类中有一个成员方法，可以返回一个lambda表达式，这个表达式使用了类的数据成员divisor。而且采用默认值方式捕捉所有变量。你可能认为这个lambda表达式也捕捉了divisor的一份副本，但是实际上大错特错。问题出现在哪里呢？因为数据成员divisor对lambda表达式并不可见，你可以用下面的代码验证：</p>
<p>// 类的方法，下面无法编译，因为divisor并不在lambda捕捉的范围<br>std::function&lt;bool(int)&gt; getFilter()<br>{<br>    return <a href="int value">divisor</a> {return value % divisor == 0; };<br>}</p>
<p>那么原来的代码为什么能够捕捉到呢？仔细想想，原来每个非静态方法都有一个this指针变量，利用this指针，你可以接近任何成员变量，所以lambda表达式实际上捕捉的是this指针的副本，所以原来的代码等价于：</p>
<p>std::function&lt;bool(int)&gt; getFilter()<br>{<br>    return <a href="int value">this</a> {return value % this-&gt;divisor == 0; };<br>}</p>
<p>尽管还是以值方式捕获，但是捕获的是指针，其实相当于以引用的方式捕获了当前类对象，所以lambda表达式的闭包与一个类对象绑定在一起了，这也很危险，因为你仍然有可能在类对象析构后使用这个lambda表达式，那么类似“悬挂引用”的问题也会产生。所以，采用默认值捕捉所有变量仍然是不安全的，主要是由于指针变量的复制，实际上还是按引用传值。</p>
<p>lambda表达式还用于对象的排序准则：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person(const string&amp; first, const string&amp; last):</span><br><span class="line">        firstName&#123;first&#125;, lastName&#123;last&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person() = default;</span><br><span class="line"></span><br><span class="line">    string first() const &#123; return firstName; &#125;</span><br><span class="line">    string last() const &#123; return lastName; &#125;</span><br><span class="line">private:</span><br><span class="line">    string firstName;</span><br><span class="line">    string lastName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;Person&gt; vp;</span><br><span class="line">    // ... 添加Person信息</span><br><span class="line"></span><br><span class="line">    // 按照姓名排序</span><br><span class="line">    std::sort(vp.begin(), vp.end(), [](const Person&amp; p1, const Person&amp; p2)</span><br><span class="line">    &#123; return p1.last() &lt; p2.last() || (p1.last() == p2.last() &amp;&amp; p1.first() &lt; p2.first()); &#125;);</span><br><span class="line">        // ...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="參考博客"><a href="#參考博客" class="headerlink" title="參考博客"></a>參考博客</h2><p>链接：<a href="https://www.jianshu.com/p/d686ad9de817" target="_blank" rel="noopener">https://www.jianshu.com/p/d686ad9de817</a></p>
]]></content>
  </entry>
  <entry>
    <title>例题7-8 Fill倒水问题</title>
    <url>/2018/11/08/c-%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84-1/</url>
    <content><![CDATA[<p>题意：三个杯子容量分别为a，b，c，现在c是满的，a和b是空的，两个杯子 i 向 j 倒水，要么 i 倒完了 j 还没满，要么 j 满了 i 还有剩余，问达到某个杯子水量为d时总共倒得最小水量是多少？如果不能达到d，找一个小于d并且离d最近的一个解。</p>
<p>思路：倒水问题，但题目要求的是总的到水量，所以在bfs时到达过的状态还要检查更新，可能当前我确实到达d了用了sum水量，但可能后面还有比sum更小的解。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int ans[1000];</span><br><span class="line">int vis[100][100];</span><br><span class="line">struct Node&#123;</span><br><span class="line">	int v[3];</span><br><span class="line">	int dis;</span><br><span class="line">	bool operator &lt; (const Node&amp; nhs)const&#123;</span><br><span class="line">		return dis&gt;nhs.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void update(const Node &amp;u)&#123;</span><br><span class="line">	for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">		int volume=u.v[i];</span><br><span class="line">		if(ans[volume]&lt;0||ans[volume]&gt;u.dis)</span><br><span class="line">		ans[volume]=u.dis;&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void solve(int a,int b,int c,int d)&#123;</span><br><span class="line">	memset(ans,-1,sizeof(ans));//!!!</span><br><span class="line">	memset(vis,0,sizeof(ans));//!!!</span><br><span class="line">	priority_queue&lt;Node&gt; queue;</span><br><span class="line">	int cap[3];</span><br><span class="line">	cap[0]=a;</span><br><span class="line">	cap[1]=b;</span><br><span class="line">	cap[2]=c;</span><br><span class="line">	Node start;</span><br><span class="line">	start.v[0]=0;</span><br><span class="line">	start.v[1]=0;</span><br><span class="line">	start.v[2]=c;</span><br><span class="line">	start.dis=0;</span><br><span class="line">	vis[0][0]=1;//!!</span><br><span class="line">	queue.push(start);</span><br><span class="line">	while(!queue.empty())	&#123;</span><br><span class="line">		Node u=queue.top();</span><br><span class="line">		queue.pop();</span><br><span class="line">		update(u);</span><br><span class="line">		if(ans[d]&gt;=0) break;</span><br><span class="line">		for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">			for(int j=0;j&lt;3;j++)&#123;</span><br><span class="line">				if(i!=j)&#123;</span><br><span class="line">					if(u.v[i]==0||u.v[j]==cap[j]) continue;</span><br><span class="line">					int dis=min(u.v[i]+u.v[j],cap[j])-u.v[j];</span><br><span class="line">					Node u2;</span><br><span class="line">					memcpy(&amp;u2,&amp;u,sizeof(u));</span><br><span class="line">					u2.v[i]-=dis;</span><br><span class="line">					u2.v[j]+=dis;</span><br><span class="line">					u2.dis=u.dis+dis;</span><br><span class="line">					if(!vis[u2.v[0]][u2.v[1]])&#123;</span><br><span class="line">						vis[u2.v[0]][u2.v[1]]=1;</span><br><span class="line">						queue.push(u2);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">			while(d&gt;=0)&#123;</span><br><span class="line">			if(ans[d]&gt;=0) &#123;</span><br><span class="line">				cout&lt;&lt;ans[d]&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			d--;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,a,b,c,d;</span><br><span class="line">	//freopen(&quot;t.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	while(n--)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">		solve(a,b,c,d);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>caffe可视化总结</title>
    <url>/2018/05/22/caffe%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>有时候无法直接观察和查看多层网络,可视化是一个很重要的方法</p>
<h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import struct </span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import Image</span><br><span class="line"></span><br><span class="line">filename = &apos;t10k-images-idx3-ubyte&apos;</span><br><span class="line">binfile = open(filename, &apos;rb&apos;)</span><br><span class="line">    buf = binfile.read()</span><br><span class="line"></span><br><span class="line">    index = 0</span><br><span class="line">    magic, numImages, numRows, numColumns = struct.unpack_from(&apos;&gt;IIII&apos;, buf, index)</span><br><span class="line">    index += struct.calcsize(&apos;&gt;IIII&apos;)</span><br><span class="line"></span><br><span class="line">    for image in range(0, numImages):</span><br><span class="line">        im = struct.unpack_from(&apos;&gt;784B&apos;, buf, index)</span><br><span class="line">        index += struct.calcsize(&apos;&gt;784B&apos;)</span><br><span class="line"></span><br><span class="line">        im = np.array(im, dtype=&apos;uint8&apos;)</span><br><span class="line">        im = im.reshape(28, 28)</span><br><span class="line"></span><br><span class="line">        im = Image.fromarray(im)</span><br><span class="line">        im.save(&apos;data/mnist/mnist_train/train_%s.bmp&apos; % image, &apos;bmp&apos;)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe01/testData.png" alt><br><a id="more"></a></p>
<h2 id="模型可视化"><a href="#模型可视化" class="headerlink" title="模型可视化"></a>模型可视化</h2><p>cifar10的网络模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd python</span><br><span class="line">python draw_net.py ../examples/cifar10/cifar10_quick.prototxt cifar10.png</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe02/cifar10.png" alt></p>
<h2 id="网络权值可视化"><a href="#网络权值可视化" class="headerlink" title="网络权值可视化"></a>网络权值可视化</h2><p>​    对训练后的网络权值进行可视化可以判断模型的优劣及是否欠(过)拟合</p>
<p>经过良好的训练的网络权值通常美观,光滑;反之为噪声图像,或者图案相关性太高,或者缺乏结构性…</p>
<p>进行可视化的代码只需要读取训练后的网络结构和权值文件,将各层的权值数据投影到像素空间.</p>
<p>主程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line">addpath(&apos;matlab&apos;);</span><br><span class="line"></span><br><span class="line">caffe.set_mode_cpu();</span><br><span class="line">model_dir = &apos;models/bvlc_reference_caffenet/&apos;;</span><br><span class="line">net_model = [model_dir &apos;deploy.prototxt&apos;];</span><br><span class="line">net_weights = [model_dir &apos;bvlc_reference_caffenet.caffemodel&apos;];</span><br><span class="line">phase = &apos;test&apos;; % run with phase test (so that dropout isn&apos;t applied)</span><br><span class="line"></span><br><span class="line">% Initialize a network</span><br><span class="line">net = caffe.Net(net_model, net_weights, phase);</span><br><span class="line"></span><br><span class="line">param_names=&#123;&apos;conv1&apos;,&apos;conv2&apos;,&apos;conv3&apos;,&apos;conv4&apos;,&apos;conv5&apos;&#125;;</span><br><span class="line">for i=1:length(param_names)</span><br><span class="line">    visualize_weight(net,param_names&#123;i&#125;,1);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>可视化函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function visualize_weight(net,param_name,space)</span><br><span class="line">w=net.params(param_name,1).get_data();</span><br><span class="line">size(w)</span><br><span class="line">nums=size(w,4);</span><br><span class="line">channels=size(w,3);</span><br><span class="line">width=size(w,2);</span><br><span class="line">count=nums*channels;</span><br><span class="line">n=ceil(sqrt(count));</span><br><span class="line">weight_map=zeros(n*(width+space),n*(width+space),&apos;uint8&apos;);</span><br><span class="line">w=w-min(w(:));</span><br><span class="line">w=w/max(w(:))*255;</span><br><span class="line">w=uint8(w);</span><br><span class="line">for i=0:count-1</span><br><span class="line">    c=mod(i,n);</span><br><span class="line">    r=floor(i/n);</span><br><span class="line">    j=mod(i,channels)+1;</span><br><span class="line">    k=floor(i/channels)+1;</span><br><span class="line">    weight_map(r*(width+space)+(1:width),c*(width+space)+(1:width))=w(:,:,j,k);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">imshow(weight_map);</span><br><span class="line">title(param_name);</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view01.png" alt></p>
<p>当然每一个卷积层都可以进行可视化</p>
<h2 id="层的特征可视化"><a href="#层的特征可视化" class="headerlink" title="层的特征可视化"></a>层的特征可视化</h2><p>在ipython notebook环境下运行</p>
<p>设置环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.rcParams[&apos;figure.figsize&apos;] = (10, 10)      </span><br><span class="line">plt.rcParams[&apos;image.interpolation&apos;] = &apos;nearest&apos;</span><br><span class="line">plt.rcParams[&apos;image.cmap&apos;] = &apos;gray&apos;  </span><br><span class="line">import sys</span><br><span class="line">caffe_root=&apos;./caffe/&apos; </span><br><span class="line">sys.path.insert(0, caffe_root + &apos;python&apos;)</span><br><span class="line"></span><br><span class="line">import caffe</span><br></pre></td></tr></table></figure>
<p>下载模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">if os.path.isfile(caffe_root + &apos;models/bvlc_reference_caffenet/bvlc_reference_caffenet.caffemodel&apos;):</span><br><span class="line">    print &apos;CaffeNet found.&apos;</span><br><span class="line">else:</span><br><span class="line">    print &apos;Downloading pre-trained CaffeNet model...&apos;</span><br><span class="line">    !../scripts/download_model_binary.py ../models/bvlc_reference_caffenet</span><br></pre></td></tr></table></figure>
<p>下载网络和输入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">caffe.set_mode_cpu()</span><br><span class="line">model_def = caffe_root + &apos;models/bvlc_reference_caffenet/deploy.prototxt&apos;</span><br><span class="line">model_weights = caffe_root + &apos;models/bvlc_reference_caffenet/bvlc_reference_caffenet.caffemodel&apos;</span><br><span class="line"></span><br><span class="line">net = caffe.Net(model_def,      </span><br><span class="line">                model_weights,  </span><br><span class="line">                caffe.TEST)</span><br></pre></td></tr></table></figure>
<p>下载处理图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># load the mean ImageNet image (as distributed with Caffe) for subtraction</span><br><span class="line">mu = np.load(caffe_root + &apos;python/caffe/imagenet/ilsvrc_2012_mean.npy&apos;)</span><br><span class="line">mu = mu.mean(1).mean(1)  # average over pixels to obtain the mean (BGR) pixel values</span><br><span class="line">print &apos;mean-subtracted values:&apos;, zip(&apos;BGR&apos;, mu)</span><br><span class="line"></span><br><span class="line"># create transformer for the input called &apos;data&apos;</span><br><span class="line">transformer = caffe.io.Transformer(&#123;&apos;data&apos;: net.blobs[&apos;data&apos;].data.shape&#125;)</span><br><span class="line"></span><br><span class="line">transformer.set_transpose(&apos;data&apos;, (2,0,1))  # move image channels to outermost dimension</span><br><span class="line">transformer.set_mean(&apos;data&apos;, mu)            # subtract the dataset-mean value in each channel</span><br><span class="line">transformer.set_raw_scale(&apos;data&apos;, 255)      # rescale from [0, 1] to [0, 255]</span><br><span class="line">transformer.set_channel_swap(&apos;data&apos;, (2,1,0))  # swap channels from RGB to BGR</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print net.blobs[&apos;data&apos;].data.shape</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1, 3, 227, 227)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># set the size of the input (we can skip this if we&apos;re happy</span><br><span class="line"># with the default; we can also change it later, e.g., for different batch sizes)</span><br><span class="line">net.blobs[&apos;data&apos;].reshape(1,         # batch size</span><br><span class="line">                          3,         # 3-channel (BGR) images</span><br><span class="line">                          227, 227)  # image size is 227x227</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Load an image (that comes with Caffe) and perform the preprocessing we&apos;ve set up.</span><br><span class="line">image = caffe.io.load_image(caffe_root + &apos;examples/images/cat.jpg&apos;)</span><br><span class="line">transformed_image = transformer.preprocess(&apos;data&apos;, image)</span><br><span class="line">plt.imshow(image)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view02.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">net.blobs[&apos;data&apos;].data[...] = transformed_image</span><br><span class="line">output = net.forward()</span><br><span class="line"></span><br><span class="line">output_prob = output[&apos;prob&apos;][0]  # the output probability vector for the first image in the batch</span><br><span class="line"></span><br><span class="line">print &apos;predicted class is:&apos;, output_prob.argmax()</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">predicted class is: 281</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载标签</span><br><span class="line">labels_file = caffe_root + &apos;data/ilsvrc12/synset_words.txt&apos;</span><br><span class="line">if not os.path.exists(labels_file):</span><br><span class="line">    !../data/ilsvrc12/get_ilsvrc_aux.sh</span><br><span class="line"></span><br><span class="line">labels = np.loadtxt(labels_file, str, delimiter=&apos;\t&apos;)</span><br><span class="line"></span><br><span class="line">print &apos;output label:&apos;, labels[output_prob.argmax()]</span><br></pre></td></tr></table></figure>
<p>output label: n02123045 tabby, tabby cat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># for each layer, show the output shape</span><br><span class="line">for layer_name, blob in net.blobs.iteritems():</span><br><span class="line">    print layer_name + &apos;\t&apos; + str(blob.data.shape)</span><br></pre></td></tr></table></figure>
<p>data (1, 3, 227, 227)<br>conv1 (1, 96, 55, 55)<br>pool1 (1, 96, 27, 27)<br>norm1 (1, 96, 27, 27)<br>conv2 (1, 256, 27, 27)<br>pool2 (1, 256, 13, 13)<br>norm2 (1, 256, 13, 13)<br>conv3 (1, 384, 13, 13)<br>conv4 (1, 384, 13, 13)<br>conv5 (1, 256, 13, 13)<br>pool5 (1, 256, 6, 6)<br>fc6 (1, 4096)<br>fc7 (1, 4096)<br>fc8 (1, 1000)<br>prob (1, 1000)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for layer_name, param in net.params.iteritems():</span><br><span class="line">    print layer_name + &apos;\t&apos; + str(param[0].data.shape), str(param[1].data.shape)</span><br></pre></td></tr></table></figure>
<p>conv1 (96, 3, 11, 11) (96,)<br>conv2 (256, 48, 5, 5) (256,)<br>conv3 (384, 256, 3, 3) (384,)<br>conv4 (384, 192, 3, 3) (384,)<br>conv5 (256, 192, 3, 3) (256,)<br>fc6 (4096, 9216) (4096,)<br>fc7 (4096, 4096) (4096,)<br>fc8 (1000, 4096) (1000,)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def vis_square(data):</span><br><span class="line">    &quot;&quot;&quot;Take an array of shape (n, height, width) or (n, height, width, 3) and visualize each (height, width) thing in a grid of size approx. sqrt(n) by sqrt(n)&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # normalize data for display</span><br><span class="line">    data = (data - data.min()) / (data.max() - data.min())</span><br><span class="line"></span><br><span class="line">    # force the number of filters to be square</span><br><span class="line">    n = int(np.ceil(np.sqrt(data.shape[0])))</span><br><span class="line">    padding = (((0, n ** 2 - data.shape[0]),</span><br><span class="line">               (0, 1), (0, 1))                 # add some space between filters</span><br><span class="line">               + ((0, 0),) * (data.ndim - 3))  # don&apos;t pad the last dimension (if there is one)</span><br><span class="line">    data = np.pad(data, padding, mode=&apos;constant&apos;, constant_values=1)  # pad with ones (white)</span><br><span class="line"></span><br><span class="line">    # tile the filters into an image</span><br><span class="line">    data = data.reshape((n, n) + data.shape[1:]).transpose((0, 2, 1, 3) + tuple(range(4, data.ndim + 1)))</span><br><span class="line">    data = data.reshape((n * data.shape[1], n * data.shape[3]) + data.shape[4:])</span><br><span class="line"></span><br><span class="line">    plt.imshow(data); plt.axis(&apos;off&apos;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># the parameters are a list of [weights]</span><br><span class="line">filters = net.params[&apos;conv1&apos;][0].data</span><br><span class="line">vis_square(filters.transpose(0, 2, 3, 1))</span><br><span class="line"># The first layer output, conv1 (rectified responses of the filters above, first 96 only)</span><br><span class="line"># conv1 (96, 3, 11, 11) (96,)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view03.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vis_square(filters[:96].reshape(96**3, 11, 11))</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view04.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># the parameters are a list of biases</span><br><span class="line">filters_b = net.params[&apos;conv1&apos;][1].data</span><br><span class="line"># The first layer output, conv1 (rectified responses of the filters above, first 96 only)</span><br><span class="line"># the params in conv1 is (96, 3, 11, 11) (96,)</span><br><span class="line">print filters_b</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view05.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the output after conv1 layer</span><br><span class="line"># conv1 (1, 96, 55, 55)</span><br><span class="line">feat = net.blobs[&apos;conv1&apos;].data[0]</span><br><span class="line">vis_square(feat)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view06.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the output after pool1 layer</span><br><span class="line"># pool1 (1, 96, 27, 27)</span><br><span class="line">feat = net.blobs[&apos;pool1&apos;].data[0]</span><br><span class="line">vis_square(feat)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view07.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the output after norm1 layer</span><br><span class="line"># norm1 (1, 96, 27, 27)</span><br><span class="line">feat = net.blobs[&apos;norm1&apos;].data[0]</span><br><span class="line">vis_square(feat)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view08.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># the parameters are a list of weights in conv2 layer</span><br><span class="line">filters = net.params[&apos;conv2&apos;][0].data</span><br><span class="line">vis_square(filters[:256].reshape(256*48, 5, 5))</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view09.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># the parameters are a list of biases.</span><br><span class="line">filters_b = net.params[&apos;conv2&apos;][1].data</span><br><span class="line"># vis_square(filters.transpose(0, 2, 3, 1))</span><br><span class="line"></span><br><span class="line"># The first layer output, conv1 (rectified responses of the filters above, first 96 only)</span><br><span class="line">print filters_b</span><br><span class="line">conv2   (256, 48, 5, 5) (256,)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view10.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after conv2</span><br><span class="line">feat = net.blobs[&apos;conv2&apos;].data[0]</span><br><span class="line">vis_square(feat)</span><br><span class="line"># conv2 (1, 256, 27, 27)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view11.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after pooling2</span><br><span class="line">feat = net.blobs[&apos;pool2&apos;].data[0]</span><br><span class="line">vis_square(feat)</span><br><span class="line"># pool2 (1, 256, 13, 13)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view12.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after LRN </span><br><span class="line">feat = net.blobs[&apos;norm2&apos;].data[0]</span><br><span class="line">vis_square(feat)</span><br><span class="line"># norm2 (1, 256, 13, 13)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view13.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after conv3</span><br><span class="line">feat = net.blobs[&apos;conv3&apos;].data[0]</span><br><span class="line">vis_square(feat)</span><br><span class="line"># conv3 (1, 384, 13, 13)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view14.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after conv4</span><br><span class="line">feat = net.blobs[&apos;conv4&apos;].data[0]</span><br><span class="line">vis_square(feat)</span><br><span class="line"># conv4 (1, 384, 13, 13)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view15.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after conv5</span><br><span class="line">feat = net.blobs[&apos;conv5&apos;].data[0]</span><br><span class="line">vis_square(feat)</span><br><span class="line"># conv5 (1, 256, 13, 13)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view16.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after pooling layer 5</span><br><span class="line">feat = net.blobs[&apos;pool5&apos;].data[0]</span><br><span class="line">vis_square(feat)</span><br><span class="line"># pool5 (1, 256, 6, 6)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view18.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after fc6 layer</span><br><span class="line">feat = net.blobs[&apos;fc6&apos;].data[0]</span><br><span class="line">plt.subplot(2, 1, 1)</span><br><span class="line">plt.plot(feat.flat)</span><br><span class="line">plt.subplot(2, 1, 2)</span><br><span class="line">_ = plt.hist(feat.flat[feat.flat &gt; 0], bins=100)</span><br><span class="line"># fc6   (1, 4096)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view19.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after fc7</span><br><span class="line">feat = net.blobs[&apos;fc7&apos;].data[0]</span><br><span class="line">plt.subplot(2, 1, 1)</span><br><span class="line">plt.plot(feat.flat)</span><br><span class="line">plt.subplot(2, 1, 2)</span><br><span class="line">_ = plt.hist(feat.flat[feat.flat &gt; 0], bins=100)</span><br><span class="line"># fc7   (1, 4096)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view20.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after fc8</span><br><span class="line">feat = net.blobs[&apos;fc8&apos;].data[0]</span><br><span class="line">plt.subplot(2, 1, 1)</span><br><span class="line">plt.plot(feat.flat)</span><br><span class="line">plt.subplot(2, 1, 2)</span><br><span class="line">_ = plt.hist(feat.flat[feat.flat &gt; 0], bins=100)</span><br><span class="line"># fc8   (1, 1000)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view21.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show the result after prob layer</span><br><span class="line">feat = net.blobs[&apos;prob&apos;].data[0]</span><br><span class="line">plt.figure(figsize=(15, 3))</span><br><span class="line">plt.plot(feat.flat)</span><br><span class="line"># prob  (1, 1000)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Cristal-yin/MarkdownPhotos/master/images/caffe04/view22.png" alt></p>
<h2 id="Loss-和accuracy可视化"><a href="#Loss-和accuracy可视化" class="headerlink" title="Loss 和accuracy可视化"></a>Loss 和accuracy可视化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">import sys,os,caffe</span><br><span class="line">#设置当前目录</span><br><span class="line">caffe_root = &apos;/home/caffe/&apos; </span><br><span class="line">sys.path.insert(0, caffe_root + &apos;python&apos;)</span><br><span class="line">os.chdir(caffe_root)</span><br><span class="line"></span><br><span class="line"># set the solver prototxt</span><br><span class="line">caffe.set_device(0)</span><br><span class="line">caffe.set_mode_gpu()</span><br><span class="line">solver = caffe.SGDSolver(&apos;examples/cifar10/cifar10_quick_solver.prototxt&apos;)</span><br></pre></td></tr></table></figure>
<p>​    如果不需要绘制曲线，只需要训练出一个caffemodel, 直接调用solver.solve()就可以了。如果要绘制曲线，就需要把迭代过程中的值</p>
<p>保存下来，因此不能直接调用solver.solve(), 需要迭代。在迭代过程中，每迭代200次测试一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%%time</span><br><span class="line">niter =4000</span><br><span class="line">test_interval = 200</span><br><span class="line">train_loss = np.zeros(niter)</span><br><span class="line">test_acc = np.zeros(int(np.ceil(niter / test_interval)))</span><br><span class="line"></span><br><span class="line"># the main solver loop</span><br><span class="line">for it in range(niter):</span><br><span class="line">    solver.step(1)  # SGD by Caffe</span><br><span class="line">    </span><br><span class="line">    # store the train loss</span><br><span class="line">    train_loss[it] = solver.net.blobs[&apos;loss&apos;].data</span><br><span class="line">    solver.test_nets[0].forward(start=&apos;conv1&apos;)</span><br><span class="line">    </span><br><span class="line">    if it % test_interval == 0:</span><br><span class="line">        acc=solver.test_nets[0].blobs[&apos;accuracy&apos;].data</span><br><span class="line">        print &apos;Iteration&apos;, it, &apos;testing...&apos;,&apos;accuracy:&apos;,acc</span><br><span class="line">        test_acc[it // test_interval] = acc</span><br></pre></td></tr></table></figure>
<p>Iteration 0 testing… accuracy: 0.10000000149</p>
<p>Iteration 200 testing… accuracy: 0.419999986887</p>
<p>Iteration 400 testing… accuracy: 0.479999989271</p>
<p>Iteration 600 testing… accuracy: 0.540000021458</p>
<p>Iteration 800 testing… accuracy: 0.620000004768</p>
<p>Iteration 1000 testing… accuracy: 0.629999995232</p>
<p>Iteration 1200 testing… accuracy: 0.649999976158</p>
<p>Iteration 1400 testing… accuracy: 0.660000026226</p>
<p>Iteration 1600 testing… accuracy: 0.660000026226</p>
<p>Iteration 1800 testing… accuracy: 0.670000016689</p>
<p>Iteration 2000 testing… accuracy: 0.709999978542</p>
<p>Iteration 2200 testing… accuracy: 0.699999988079</p>
<p>Iteration 2400 testing… accuracy: 0.75</p>
<p>Iteration 2600 testing… accuracy: 0.740000009537</p>
<p>Iteration 2800 testing… accuracy: 0.769999980927</p>
<p>Iteration 3000 testing… accuracy: 0.75</p>
<p>Iteration 3200 testing… accuracy: 0.699999988079</p>
<p>Iteration 3400 testing… accuracy: 0.740000009537</p>
<p>Iteration 3600 testing… accuracy: 0.72000002861</p>
<p>Iteration 3800 testing… accuracy: 0.769999980927</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print test_acc</span><br><span class="line">_, ax1 = plt.subplots()</span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line">ax1.plot(np.arange(niter), train_loss)</span><br><span class="line">ax2.plot(test_interval * np.arange(len(test_acc)), test_acc, &apos;r&apos;)</span><br><span class="line">ax1.set_xlabel(&apos;iteration&apos;)</span><br><span class="line">ax1.set_ylabel(&apos;train loss&apos;)</span><br><span class="line">ax2.set_ylabel(&apos;test accuracy&apos;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>caffe</category>
      </categories>
  </entry>
  <entry>
    <title>caffe可视化绘制网络结构图</title>
    <url>/2018/05/22/caffe%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%98%E5%88%B6%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE/</url>
    <content><![CDATA[<p>首先我们要知道caffe自带了根据模型prototxt文件作图的python文件，位于$caffe/python文件夹下的draw_net,py文件。执行网络结构可视化之前调用该文件就可以了。具体命令如下：</p>
<p>$cd caffe/python</p>
<p>$python draw_net.py ../models/bvlc_reference_caffenet/train_val.prototxt caffenet.png      #caffenet结构图</p>
<p>$python draw_net.py ../models/bvlc_alexnet/train_val.prototxt alexnet.png       #alexnet结构图<br><a id="more"></a></p>
<p>以下各种结构图不一一列举，只是提供一种方法。</p>
<p>备注：如果想把结构图保存在特定文件夹下，只需在.png前添加所要保存的文件夹路径。</p>
<pre><code>例如：$sudo python draw_net.py ../models/bvlc_reference_caffenet/train_val.prototxt ../jiegoutu/caffenet.png    就是把文件caffenet.png生成并存放在caffe/jiegoutu文件夹下。
</code></pre><p>3、遇到的问题</p>
<p>（1）ImportError: No module named pydot</p>
<p>解决：未安装pydot；</p>
<p>回到根目录命令：$sudo pip install pydot</p>
<p>（2）Exception: “dot” not found in path</p>
<p>解决：未安装graphviz</p>
<p>回到根目录命令：$sudo apt-get install graphviz         #切记不可使用pip安装</p>
]]></content>
      <categories>
        <category>caffe</category>
      </categories>
  </entry>
  <entry>
    <title>caffe的solver文件配置</title>
    <url>/2018/05/22/caffe%E7%9A%84solver%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>假设我们有50000个训练样本，batch_size为64，即每批次处理64个样本，那么需要迭代50000/64=782次才处理完一次全部的样本。我们把处理完一次所有的样本，称之为一代，即epoch。所以，这里的test_interval设置为782，即处理完一次所有的训练数据后，才去进行测试。如果我们想训练100代，则需要设置max_iter为78200.<br><a id="more"></a><br>同理，如果有10000个测试样本，batch_size设为32，那么需要迭代10000/32=313次才完整地测试完一次，所以设置test_iter为313.</p>
<p> 学习率变化规律我们设置为随着迭代次数的增加，慢慢变低。总共迭代78200次，我们将变化lr_rate三次，所以stepsize设置为78200/3=26067，即每迭代26067次，我们就降低一次学习率。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base_lr: 0.001</span><br><span class="line">display: 782</span><br><span class="line">gamma: 0.1</span><br><span class="line">lr_policy: “step”</span><br><span class="line">max_iter: 78200</span><br><span class="line">momentum: 0.9</span><br><span class="line">snapshot: 7820</span><br><span class="line">snapshot_prefix: “snapshot”</span><br><span class="line">solver_mode: GPU</span><br><span class="line">solver_type: SGD</span><br><span class="line">stepsize: 26067</span><br><span class="line">#测试间隔，训练每迭代782次后执行一次测试（测试是为了获得当前模型的训练精度）</span><br><span class="line">test_interval: 782</span><br><span class="line"> #test_iter是定义的测试图例分为多少批次</span><br><span class="line">test_iter: 313</span><br><span class="line">test_net: “/home/xxx/data/val.prototxt”</span><br><span class="line">train_net: “/home/xxx/data/proto/train.prototxt”</span><br><span class="line">weight_decay: 0.0005</span><br></pre></td></tr></table></figure></p>
<p>下面是生成solver文件的python代码，比较简单：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Sun Jul 17 18:20:57 2016</span><br><span class="line"></span><br><span class="line">@author: root</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">path=&apos;/home/xxx/data/&apos;</span><br><span class="line">solver_file=path+&apos;solver.prototxt&apos;     #solver文件保存位置</span><br><span class="line"></span><br><span class="line">sp=&#123;&#125;</span><br><span class="line">sp[&apos;train_net&apos;]=‘“’+path+&apos;train.prototxt”&apos;  # 训练配置文件</span><br><span class="line">sp[&apos;test_net&apos;]=‘“’+path+&apos;val.prototxt”&apos;     # 测试配置文件</span><br><span class="line">sp[&apos;test_iter&apos;]=&apos;313&apos;                  # 测试迭代次数</span><br><span class="line">sp[&apos;test_interval&apos;]=&apos;782&apos;              # 测试间隔</span><br><span class="line">sp[&apos;base_lr&apos;]=&apos;0.001&apos;                  # 基础学习率</span><br><span class="line">sp[&apos;display&apos;]=&apos;782&apos;                    # 屏幕日志显示间隔</span><br><span class="line">sp[&apos;max_iter&apos;]=&apos;78200&apos;                 # 最大迭代次数</span><br><span class="line">sp[&apos;lr_policy&apos;]=&apos;“step”&apos;                 # 学习率变化规律</span><br><span class="line">sp[&apos;gamma&apos;]=&apos;0.1&apos;                      # 学习率变化指数</span><br><span class="line">sp[&apos;momentum&apos;]=&apos;0.9&apos;                   # 动量</span><br><span class="line">sp[&apos;weight_decay&apos;]=&apos;0.0005&apos;            # 权值衰减</span><br><span class="line">sp[&apos;stepsize&apos;]=&apos;26067&apos;                 # 学习率变化频率</span><br><span class="line">sp[&apos;snapshot&apos;]=&apos;7820&apos;                   # 保存model间隔</span><br><span class="line">sp[&apos;snapshot_prefix&apos;]=‘&quot;snapshot&quot;’       # 保存的model前缀</span><br><span class="line">sp[&apos;solver_mode&apos;]=&apos;GPU&apos;                # 是否使用gpu</span><br><span class="line">sp[&apos;solver_type&apos;]=&apos;SGD&apos;                # 优化算法</span><br><span class="line"></span><br><span class="line">def write_solver():</span><br><span class="line">    #写入文件</span><br><span class="line">    with open(solver_file, &apos;w&apos;) as f:</span><br><span class="line">        for key, value in sorted(sp.items()):</span><br><span class="line">            if not(type(value) is str):</span><br><span class="line">                raise TypeError(&apos;All solver parameters must be strings&apos;)</span><br><span class="line">            f.write(&apos;%s: %s\n&apos; % (key, value))</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    write_solver()</span><br></pre></td></tr></table></figure></p>
<p>或写成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from caffe.proto import caffe_pb2</span><br><span class="line">s = caffe_pb2.SolverParameter()</span><br><span class="line"></span><br><span class="line">path=&apos;/home/xxx/data/&apos;</span><br><span class="line">solver_file=path+&apos;solver1.prototxt&apos;</span><br><span class="line"></span><br><span class="line">s.train_net = path+&apos;train.prototxt&apos;</span><br><span class="line">s.test_net.append(path+&apos;val.prototxt&apos;)</span><br><span class="line">s.test_interval = 782  </span><br><span class="line">s.test_iter.append(313) </span><br><span class="line">s.max_iter = 78200 </span><br><span class="line"></span><br><span class="line">s.base_lr = 0.001 </span><br><span class="line">s.momentum = 0.9</span><br><span class="line">s.weight_decay = 5e-4</span><br><span class="line">s.lr_policy = &apos;step&apos;</span><br><span class="line">s.stepsize=26067</span><br><span class="line">s.gamma = 0.1</span><br><span class="line">s.display = 782</span><br><span class="line">s.snapshot = 7820</span><br><span class="line">s.snapshot_prefix = &apos;shapshot&apos;</span><br><span class="line">s.type = “SGD”</span><br><span class="line">s.solver_mode = caffe_pb2.SolverParameter.GPU</span><br><span class="line"></span><br><span class="line">with open(solver_file, &apos;w&apos;) as f:</span><br><span class="line">    f.write(str(s))</span><br></pre></td></tr></table></figure></p>
<p>参考自 <a href="http://www.cnblogs.com/denny402/p/5679154.html" target="_blank" rel="noopener">http://www.cnblogs.com/denny402/p/5679154.html</a></p>
]]></content>
      <categories>
        <category>caffe</category>
      </categories>
  </entry>
  <entry>
    <title>ccf 201609-4交通规划</title>
    <url>/2018/12/01/ccf-201609-4%E4%BA%A4%E9%80%9A%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>问题描述<br>　　G国国王来中国参观后，被中国的高速铁路深深的震撼，决定为自己的国家也建设一个高速铁路系统。<br>　　建设高速铁路投入非常大，为了节约建设成本，G国国王决定不新建铁路，而是将已有的铁路改造成高速铁路。现在，请你为G国国王提供一个方案，将现有的一部分铁路改造成高速铁路，使得任何两个城市间都可以通过高速铁路到达，而且从所有城市乘坐高速铁路到首都的最短路程和原来一样长。请你告诉G国国王在这些条件下最少要改造多长的铁路。<br><a id="more"></a><br>输入格式<br>　　输入的第一行包含两个整数n, m，分别表示G国城市的数量和城市间铁路的数量。所有的城市由1到n编号，首都为1号。<br>　　接下来m行，每行三个整数a, b, c，表示城市a和城市b之间有一条长度为c的双向铁路。这条铁路不会经过a和b以外的城市。<br>输出格式<br>　　输出一行，表示在满足条件的情况下最少要改造的铁路长度。<br>样例输入<br>4 5<br>1 2 4<br>1 3 5<br>2 3 2<br>2 4 3<br>3 4 2<br>样例输出<br>11<br>评测用例规模与约定<br>　　对于20%的评测用例，1 ≤ n ≤ 10，1 ≤ m ≤ 50；<br>　　对于50%的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 5000；<br>　　对于80%的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 50000；<br>　　对于100%的评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000。输入保证每个城市都可以通过铁路达到首都。</p>
<p>题目抽象</p>
<p>要求所有结点与源结点连通，使得所有边权之和最小。即求最小的最短路径树</p>
<p>邻接表存储图，即g[]，是一种动态的存储</p>
<p>数组dist[]中存储单源（首都，结点1）到各个结点（城市）的最短距离。优先队列q按照边的权值从小到大排队，便于计算最短路径。</p>
<p>对于n个结点的城市，要连通起来，最少有n-1条道路就够了。</p>
<p>数组cost[i]用于存储要到达结点i，并且满足单源最短路径的条件，需要改造的铁路的长度。这是使用Dijkstra算法解决本问题需要增加的。程序中的72行就是增加的逻辑。</p>
<p>另外一个问题，从单源出发到达某个结点，最短路径有两条以上，并且路径长度相等时，需要选一个代价小的。例如，测试实例中，结点1到4有两条路径，1-2-4和1-3-4，其距离都是7，边1-2和1-3是必选的，边2-4和3-4是可选的，由于边2-4的权为3，而边3-4的权为2，所以为了到达结点4选择小的权2。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define MAX 10000</span><br><span class="line">#define INF 1e6</span><br><span class="line">using namespace std;</span><br><span class="line">bool vis[MAX+1];</span><br><span class="line">int cost[MAX+1];</span><br><span class="line">int dis[MAX+1];</span><br><span class="line">struct node&#123;</span><br><span class="line">	int num;</span><br><span class="line">	int cost;</span><br><span class="line">	node(int nn,int cc):num(nn),cost(cc)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &lt; (const node&amp;p)const&#123;</span><br><span class="line">	return cost&gt;p.cost;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line">struct edge&#123;</span><br><span class="line">	int v;</span><br><span class="line">	int cost;</span><br><span class="line">	edge(int vv,int cc):v(vv),cost(cc)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; g[MAX+1];</span><br><span class="line">int n;</span><br><span class="line">priority_queue&lt;node&gt; pq;</span><br><span class="line">void dij()&#123;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dis[i]=INF;</span><br><span class="line">		cost[i]=INF;</span><br><span class="line">		vis[i]=false;</span><br><span class="line">	&#125;</span><br><span class="line">//	for(int i=0;i&lt;g[1].size();i++)&#123;</span><br><span class="line">//	edge e=g[1][i];</span><br><span class="line">//	dis[e.v]=e.cost;</span><br><span class="line">//	cout&lt;&lt;e.cost&lt;&lt;endl; </span><br><span class="line">//	</span><br><span class="line">//&#125;</span><br><span class="line">	dis[1]=0;</span><br><span class="line">	cost[1]=0;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	pq.push(node(1,0));</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line">		node t=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		if(vis[t.num]) continue;</span><br><span class="line">		vis[t.num]=true;</span><br><span class="line">		for(int i=0;i&lt;g[t.num].size();i++)&#123;</span><br><span class="line">			edge e=g[t.num][i];</span><br><span class="line">			</span><br><span class="line">			if(vis[e.v]) continue;</span><br><span class="line">			int tmpcost=e.cost;</span><br><span class="line">			if(tmpcost+dis[t.num]&lt;dis[e.v])&#123;</span><br><span class="line">				dis[e.v]=tmpcost+dis[t.num];</span><br><span class="line">				cost[e.v]=tmpcost;</span><br><span class="line">				pq.push(node(e.v,dis[e.v]));</span><br><span class="line">			&#125;</span><br><span class="line">			else if(tmpcost+dis[t.num]==dis[e.v])&#123;</span><br><span class="line">				cost[e.v]=min(cost[e.v],tmpcost);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">		int cases,src,u,v,w;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;cases;</span><br><span class="line">	for(int i=cases;i&gt;0;i--)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		g[u].push_back(edge(v,w));</span><br><span class="line">		g[v].push_back(edge(u,w));	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	dij();</span><br><span class="line">	int ans=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		ans+=cost[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>ccf认证  字符串匹配</title>
    <url>/2018/11/04/ccf-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>用了kmp算法 写的算法虽然AC了 但感觉有点浪费数组空间</p>
<p>问题描述<br>　　给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。</p>
<a id="more"></a>
<p>输入格式</p>
<p>输入的第一行包含一个字符串S，由大小写英文字母组成。</p>
<p>第二行包含一个数字，表示大小写敏感的选项，当数字为0时表示大小写不敏感，当数字为1时表示大小写敏感。</p>
<p>第三行包含一个整数n，表示给出的文字的行数。</p>
<p>接下来n行，每行包含一个字符串，字符串由大小写英文字母组成，不含空格和其他字符。</p>
<p>输出格式<br>　　输出多行，每行包含一个字符串，按出现的顺序依次给出那些包含了字符串S的行。</p>
<p>样例输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">HelloWorld</span><br><span class="line">HiHiHelloHiHi</span><br><span class="line">GrepIsAGreatTool</span><br><span class="line">HELLO</span><br><span class="line">HELLOisNOTHello</span><br><span class="line">样例输出</span><br><span class="line">HelloWorld</span><br><span class="line">HiHiHelloHiHi</span><br><span class="line">HELLOisNOTHello</span><br><span class="line"></span><br><span class="line">样例说明</span><br><span class="line"></span><br><span class="line">在上面的样例中，第四个字符串虽然也是Hello，但是大小写不正确。如果将输入的第二行改为0，则第四个字符串应该输出。</span><br><span class="line">评测用例规模与约定</span><br><span class="line">　　1&lt;=n&lt;=100，每个字符串的长度不超过100。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int n,m;</span><br><span class="line">int prefix[100];</span><br><span class="line">using namespace std;</span><br><span class="line">void prefix_table(char patt[],int n)&#123;</span><br><span class="line">	prefix[0]=0;</span><br><span class="line">	int i=1;</span><br><span class="line">	int len=0;</span><br><span class="line">	while(i&lt;n)&#123;</span><br><span class="line">		</span><br><span class="line">		if(patt[i]==patt[len])</span><br><span class="line">		&#123;</span><br><span class="line">			len++;</span><br><span class="line">			prefix[i]=len;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if(len&gt;0)</span><br><span class="line">			len=prefix[len-1];</span><br><span class="line">			else&#123;</span><br><span class="line">				prefix[i]=len;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void to_lower(char s[])</span><br><span class="line">&#123;</span><br><span class="line">	int n=strlen(s);</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	if(s[i]&gt;=&apos;A&apos;&amp;&amp;s[i]&lt;=&apos;Z&apos;) s[i]+=32;</span><br><span class="line">&#125;</span><br><span class="line">void move_prefix(int prefix[],int n)&#123;</span><br><span class="line">	for(int i=n-1;i&gt;0;i--) prefix[i]=prefix[i-1];</span><br><span class="line">	prefix[0]=-1;</span><br><span class="line">&#125;</span><br><span class="line">bool kmp(char txt[],char patt[])&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	prefix_table(patt,n);</span><br><span class="line">	move_prefix(prefix,n);</span><br><span class="line">	int i=0,j=0;</span><br><span class="line">	m=strlen(txt);</span><br><span class="line">	while(i&lt;m)&#123;</span><br><span class="line">		if(j==n-1&amp;&amp;txt[i]==patt[j])//!!</span><br><span class="line">		&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if(txt[i]==patt[j])&#123;</span><br><span class="line">			i++;j++;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			j=prefix[j];</span><br><span class="line">			if(j==-1)&#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	char patt[100];</span><br><span class="line">//	freopen(&quot;s.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;patt;</span><br><span class="line">	int flag,k;</span><br><span class="line">	cin&gt;&gt;flag;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">	n=strlen(patt);</span><br><span class="line">	if(flag==0) </span><br><span class="line">		to_lower(patt);</span><br><span class="line">	char txt[100][100];</span><br><span class="line">	char txt1[100][100];</span><br><span class="line">	for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;txt[i]; </span><br><span class="line">	strcpy(txt1[i],txt[i]);</span><br><span class="line">&#125;</span><br><span class="line">	for(int i=0;i&lt;k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(flag==0) </span><br><span class="line">		&#123;</span><br><span class="line">			to_lower(txt[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	if(kmp(txt[i],patt)) cout&lt;&lt;txt1[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf</category>
      </categories>
  </entry>
  <entry>
    <title>201609-2 火车购票</title>
    <url>/2018/11/30/ccf/</url>
    <content><![CDATA[<p>问题描述<br>　　请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。<br>&lt;!–more-&gt;<br>假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。</p>
<p>购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。</p>
<p>假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。</p>
<p>输入格式</p>
<p>输入的第一行包含一个整数n，表示购票指令的数量。</p>
<p>第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。</p>
<p>输出格式</p>
<p>输出n行，每行对应一条指令的处理结果。</p>
<p>对于购票指令p，输出p张车票的编号，按从小到大排序。</p>
<p>样例输入</p>
<p>4</p>
<p>2 5 4 2</p>
<p>样例输出</p>
<p>1 2</p>
<p>6 7 8 9 10</p>
<p>11 12 13 14</p>
<p>3 4</p>
<p>样例说明<br>　　1) 购2张票，得到座位1、2。<br>　　2) 购5张票，得到座位6至10。<br>　　3) 购4张票，得到座位11至14。<br>　　4) 购2张票，得到座位3、4。<br>评测用例规模与约定<br>　　对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int	a[20][5];</span><br><span class="line">int	vis[20][5];</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt;ans;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	int nn=1;</span><br><span class="line">	for(int i=0;i&lt;20;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;5;j++)&#123;</span><br><span class="line">			a[i][j]=nn++;</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int num;</span><br><span class="line">	memset( vis, 0, sizeof(vis) );</span><br><span class="line">	while ( n-- )</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		int flag = 0;</span><br><span class="line">		for ( int j = 0; j &lt; 20; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			int start=0;</span><br><span class="line">			int cnt = 0, maxi = 0;</span><br><span class="line">			for ( int k = 0; k &lt; 5; k++ )</span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				if ( vis[j][k] == 0 )</span><br><span class="line">					cnt++;</span><br><span class="line">				</span><br><span class="line">			    if(vis[j][k]==1)&#123;</span><br><span class="line">					start++;</span><br><span class="line">				</span><br><span class="line">					if ( cnt &gt; maxi )</span><br><span class="line">					&#123;</span><br><span class="line">						start = k - cnt;</span><br><span class="line">					&#125;</span><br><span class="line">					/*	maxi=max(cnt,maxi); */</span><br><span class="line">					cnt = 0;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			if ( cnt &gt;= num )</span><br><span class="line">			&#123;</span><br><span class="line">			</span><br><span class="line">				flag = 1;</span><br><span class="line">				vector&lt;int&gt; v;</span><br><span class="line">				for ( int p = start; p &lt; start + num; p++ )</span><br><span class="line">				&#123;</span><br><span class="line">					vis[j][p] = 1;</span><br><span class="line">					v.push_back( a[j][p] );</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				ans.push_back( v );</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if ( flag == 0 )</span><br><span class="line">		&#123;</span><br><span class="line">			while ( num )</span><br><span class="line">			&#123;</span><br><span class="line">				vector&lt;int&gt; vec;</span><br><span class="line">				for ( int i = 0; i &lt; 20; i++ )</span><br><span class="line">				&#123;</span><br><span class="line">					for ( int t = 0; t &lt; 5; t++ )</span><br><span class="line">					&#123;</span><br><span class="line">						if ( vis[i][t]==0 )</span><br><span class="line">						&#123;</span><br><span class="line"></span><br><span class="line">							vec.push_back( a[i][t] );</span><br><span class="line">							num--;</span><br><span class="line">								vis[i][t]=1;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				</span><br><span class="line">				&#125;</span><br><span class="line">				ans.push_back(vec);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;ans.size();i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;ans[i].size();j++)&#123;</span><br><span class="line">			cout&lt;&lt;ans[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(21)</title>
    <url>/2018/12/21/ccf%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>csp成绩出来了 虽然也在预料之中 果然很低 不贴分数了</p>
<p>那一刻反省了下自己 真的尽力了？与考雅思不同的是你知道这件事很难 但你一直拖着 不去做<br><a id="more"></a><br>后来发现积累下去 要打的代码 要看的算法越来越多</p>
<p>发现也是最近才明白 败者注重过程 胜者只在乎结果这个道理</p>
<p>你考的过程的艰辛 你的抱怨都没有一点用处 除了给自己负能量以外</p>
<p>回归初心 为什么要去考这个证 想能在大四下考完研后找到一份实习 希望给自己的大学生活做一个转折点 至少我希望今天的自己能比昨天的自己优秀一点</p>
<p>竞争还是残酷的 梦想是需要坚持的 必须相信 It is possible 希望你能专心下来</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>喜欢的女明星离婚了 心中有种说不出来的难过 但因为都不是当事人 所以不了解事情真相<br>更不好评价 不管怎么说 物是人非是很难改变的 其实发现自己和过去的自己已经变化很多了 记得她说过 人不能活在过去，根本改变不了什么<br>过去的你会听那些大道理么 即使现在的你知道它是真理… 能做的只是活在当下 知道当下的自己想要的是什么 然后一点点去进步 即便最后达不到 但至少我想了很多种办法去尽力达到 那样的我才是真正的我 而不是从一开始就望而却步 做自己 加油~~</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>每天带着看一章节算法笔记</li>
<li>带着刷蓝桥杯题</li>
<li>网站规划</li>
<li>高数带着做一章</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Sublime Text 使用小结</title>
    <url>/2018/04/26/chajian/</url>
    <content><![CDATA[<p>参考博客链接：<br><a href="https://www.jianshu.com/p/dca423358574?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/dca423358574?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a><br><a href="https://www.jianshu.com/p/aa30cc25c91b" target="_blank" rel="noopener">https://www.jianshu.com/p/aa30cc25c91b</a><br><a id="more"></a></p>
<h1 id="代码校验"><a href="#代码校验" class="headerlink" title="代码校验"></a>代码校验</h1><p>SublimeLinter 是 Sublime 的插件，它的作用是检查代码语法是否有错误，并提示。习惯了 IDE 下写代码的人一定需要一款在 Sublime 上类似的语法检查工具。下面我们开始。</p>
<p>安装 SublimeLinter<br>如同其他插件一样使用 Package Control 来安装。</p>
<p>按下 Ctrl+Shift+p 进入 Command Palette<br>输入install进入 Package Control: Install Package<br>输入SublimeLinter。进行安装.<br>SublimeLinter</p>
<p>安装完成后可以看到这样一段话：</p>
<p>Welcome to SublimeLinter, a linter framework for Sublime Text 3.</p>
<pre><code>          * * * IMPORTANT! * * *

 SublimeLinter 3 is NOT a drop-in replacement for
earlier versions.

 Linters *NOT* included with SublimeLinter 3,
 they must be installed separately.

 The settings are different.

         * * * READ THE DOCS! * * *
</code></pre><p> Otherwise you will never know how to install linters, nor will<br> you know about all of the great new features in SublimeLinter 3.</p>
<p> For complete documentation on how to install and use SublimeLinter,<br> please see:</p>
<p> <a href="http://www.sublimelinter.com" target="_blank" rel="noopener">http://www.sublimelinter.com</a><br>可以看到具体的 Linters 组件不被包含在 SublimeLinter 3 中，所以我们要额外独立安装组件。<br>可以针对不同的语言安装不同的组件。</p>
<p>JavaScript 语法检查<br>SublimeLinter-jshint 是基于 nodeJS 下的 jshint 的插件，实际上 SublimeLinter-jshint 调用了 nodeJS 中 jshint 的接口来进行语法检查的。</p>
<p>安装 SublimeLinter-jshint<br>为了让 JavaScript 代码有语法检查，我们安装 SublimeLinter-jshint<br>同样的方法，我们安装 SublimeLinter-jshint</p>
<p>按下 Ctrl+Shift+p 进入 Command Palette<br>输入install进入 Package Control: Install Package<br>输入SublimeLinter-jshint。进行安装.<br>如下图</p>
<p>SublimeLinter-jshint</p>
<p>安装完成后我们可以看到下面的一段话</p>
<h2 id="SublimeLinter-jshint"><a href="#SublimeLinter-jshint" class="headerlink" title="SublimeLinter-jshint"></a>SublimeLinter-jshint</h2><p>  This linter plugin for SublimeLinter provides an interface to jshint.</p>
<p>  <strong> IMPORTANT! </strong></p>
<p>  Before this plugin will activate, you <em>must</em><br>  follow the installation instructions here:</p>
<p>  <a href="https://github.com/SublimeLinter/SublimeLinter-jshint" target="_blank" rel="noopener">https://github.com/SublimeLinter/SublimeLinter-jshint</a><br>安装 nodeJS 和 jshint<br>在插件开始工作之前，我们必须再看一下上述插件的安装说明<br>通过 SublimeLinter-jshint 的说明 我们可以看到，这个组件依赖于 nodeJS 下的 jshint，所以我们安装 nodeJS 环境和 nodeJS 下的 jshint。</p>
<p>安装 Node.js<br>通过 npm 安装jshint<br>在命令行下输入如下代码，完成安装</p>
<p>npm install -g jshint<br>安装完成后命令行中出现如下的信息</p>
<p>C:\Users\Administrator\AppData\Roaming\npm\jshint -&gt; C:\Users\Administrator\AppData\Roaming\npm\node_modules\jshint\bin\jshint<br><a href="mailto:jshint@2.6.3" target="_blank" rel="noopener">jshint@2.6.3</a> C:\Users\Administrator\AppData\Roaming\npm\node_modules\jshint<br>├── <a href="mailto:strip-json-comments@1.0.2" target="_blank" rel="noopener">strip-json-comments@1.0.2</a><br>├── <a href="mailto:underscore@1.6.0" target="_blank" rel="noopener">underscore@1.6.0</a><br>├── <a href="mailto:exit@0.1.2" target="_blank" rel="noopener">exit@0.1.2</a><br>├── <a href="mailto:shelljs@0.3.0" target="_blank" rel="noopener">shelljs@0.3.0</a><br>├── <a href="mailto:console-browserify@1.1.0" target="_blank" rel="noopener">console-browserify@1.1.0</a> (<a href="mailto:date-now@0.1.4" target="_blank" rel="noopener">date-now@0.1.4</a>)<br>├── <a href="mailto:htmlparser2@3.8.2" target="_blank" rel="noopener">htmlparser2@3.8.2</a> (<a href="mailto:domelementtype@1.3.0" target="_blank" rel="noopener">domelementtype@1.3.0</a>, <a href="mailto:entities@1.0.0" target="_blank" rel="noopener">entities@1.0.0</a>, <a href="mailto:domhandler@2.3.0" target="_blank" rel="noopener">domhandler@2.3.0</a>, <a href="mailto:readable-stream@1.1.13" target="_blank" rel="noopener">readable-stream@1.1.13</a>, <a href="mailto:domutils@1.5.1" target="_blank" rel="noopener">domutils@1.5.1</a>)<br>├── <a href="mailto:minimatch@1.0.0" target="_blank" rel="noopener">minimatch@1.0.0</a> (<a href="mailto:sigmund@1.0.0" target="_blank" rel="noopener">sigmund@1.0.0</a>, <a href="mailto:lru-cache@2.5.0" target="_blank" rel="noopener">lru-cache@2.5.0</a>)<br>└── <a href="mailto:cli@0.6.6" target="_blank" rel="noopener">cli@0.6.6</a> (<a href="mailto:glob@3.2.11" target="_blank" rel="noopener">glob@3.2.11</a>)<br>可以查看 jshint 版本，已确认安装完成。</p>
<p>C:\Users\Administrator&gt;jshint -v<br>jshint v2.6.3<br>现在，恭喜你，我们使用 Sublime 编辑 JavaScript 文件，就会有语法检查了！</p>
<p>在编辑过程中，会有如下提示</p>
<p>SublimeLinter-jshint-test</p>
<p>点击提示点后，Sublime 状态栏也会有相应的说明</p>
<p>SublimeLinter-jshint-test2</p>
<p>css 语法检查<br>与 jshint 同理，SublimeLinter-csslint 也是基于 nodeJS 下的 csslint 的插件，实际上 SublimeLinter-csslint 调用了 nodeJS 中 csslint 的接口来进行语法检查的。</p>
<p>安装 SublimeLinter-csslint<br>同样的方法。</p>
<p>按下 Ctrl+Shift+p 进入 Command Palette<br>输入install进入 Package Control: Install Package<br>输入SublimeLinter-csslint。进行安装.<br>如下图</p>
<p>SublimeLinter-csslint</p>
<p>安装完成后我们可以看到下面的一段话</p>
<h2 id="SublimeLinter-csslint"><a href="#SublimeLinter-csslint" class="headerlink" title="SublimeLinter-csslint"></a>SublimeLinter-csslint</h2><p>This linter plugin for SublimeLinter provides an interface to csslint.</p>
<p><strong> IMPORTANT! </strong></p>
<p>Before this plugin will activate, you <em>must</em><br>follow the installation instructions here:</p>
<p><a href="https://github.com/SublimeLinter/SublimeLinter-csslint" target="_blank" rel="noopener">https://github.com/SublimeLinter/SublimeLinter-csslint</a><br>在使用插件之前，必须遵循上述网址中的安装说明</p>
<p>在 nodeJS 下安装 csslint<br>进入上述的 GitHub 地址，csslint 的说明页。我们知道了和 jshint 一样，csslint 也是基于 nodeJS 下的 csslint 来使用的。</p>
<p>这里安装 nodeJS 过程省略。<br>只需用 npm 安装 csslint 即可。</p>
<p>在命令行中输入</p>
<p>npm install -g csslint<br>安装完成后命令行中出现如下的信息</p>
<p>C:\Users\Administrator\AppData\Roaming\npm\csslint -&gt; C:\Users\Administrator\AppData\Roaming\npm\node_modules\csslint\cli.js<br><a href="mailto:csslint@0.10.0" target="_blank" rel="noopener">csslint@0.10.0</a> C:\Users\Administrator\AppData\Roaming\npm\node_modules\csslint<br>└── <a href="mailto:parserlib@0.2.5" target="_blank" rel="noopener">parserlib@0.2.5</a><br>可以查看 csslint 版本，已确认安装完成。</p>
<p>C:\Users\Administrator&gt;csslint –version<br>v0.10.0<br>现在，恭喜你，我们使用 Sublime 编辑 css 文件，就会有语法检查了！</p>
<p>在编辑过程中，会有如下提示</p>
<p>SublimeLinter-csslint-test</p>
<p>点击提示点后，Sublime 状态栏也会有相应的说明</p>
<p>SublimeLinter-csslint-test2</p>
]]></content>
      <categories>
        <category>软件和工具</category>
      </categories>
  </entry>
  <entry>
    <title>chmod和chown命令</title>
    <url>/2018/05/22/chmod%E5%92%8Cchown%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>指令名称 : chmod</p>
<p>使用权限 : 所有使用者</p>
<p>使用方式 : chmod [-cfvR] [–help] [–version] mode file…</p>
<p>说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以控制档案如何被他人所调用。<br><a id="more"></a><br>参数 :<br>mode : 权限设定字串，格式如下 : [ugoa…][[+-=][rwxX]…][,…]，其中</p>
<p>u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p>
<ul>
<li>表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
</ul>
<p>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</p>
<p>-c : 若该档案权限确实已经更改，才显示其更改动作</p>
<p>-f : 若该档案权限无法被更改也不要显示错误讯息</p>
<p>-v : 显示权限变更的详细资料</p>
<p>-R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</p>
<p>–help : 显示辅助说明</p>
<p>–version : 显示版本</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>将档案 file1.txt 设为所有人皆可读取 :</p>
<p>chmod ugo+r file1.txt</p>
<p>将档案 file1.txt 设为所有人皆可读取 :</p>
<p>chmod a+r file1.txt</p>
<p>将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>
<p>chmod ug+w,o-w file1.txt file2.txt</p>
<p>将 ex1.py 设定为只有该档案拥有者可以执行 :</p>
<p>chmod u+x ex1.py</p>
<p>将目前目录下的所有档案与子目录皆设为任何人可读取 :</p>
<p>chmod -R a+r *</p>
<p>此外chmod也可以用数字来表示权限如 chmod 777 file<br>语法为：chmod abc file</p>
<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<p>r=4，w=2，x=1</p>
<p>若要rwx属性则4+2+1=7；</p>
<p>若要rw-属性则4+2=6；</p>
<p>若要r-x属性则4+1=5。</p>
<p>范例：<br>chmod a=rwx file</p>
<p>和<br>chmod 777 file</p>
<p>效果相同</p>
<p>chmod ug=rwx,o=x file<br>和<br>chmod 771 file</p>
<p>效果相同</p>
<p>若用chmod 4755 filename可使此程序具有root的权限</p>
<h2 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h2><p>用途：更改文件的所有者或组。命令由单词change owner组合而成。</p>
<p>使用示例：</p>
<p>1，更改文件的所有者：</p>
<p>chown jim program.c</p>
<p>文件 program.c 的所有者更改为 jim。作为所有者，jim 可以使用 chmod 命令允许或拒绝其他用户访问 program.c。</p>
<p>2，更改目录的所有者：</p>
<p>chown -R john:build /tmp/src</p>
<p>将目录 /tmp/src 中所有文件的所有者和组更改为用户 john 和组 build</p>
<p> -R 递归式地改变指定目录及其下的所有子目录和文件的拥有者。</p>
<p> -v 显示chown命令所做的工作。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p> 1,chown 修改文件和文件夹的用户和用户组属性</p>
<p>eg ,将目录 /tmp/sc 这个目录的所有者和组改为tina和组net–&gt;chown -R tina:net /tmp/sc</p>
<p>2,chmod 修改文件和文件夹读写执行属性</p>
<p>eg,要修改/tmp/sc下所有的文件和文件夹及其子文件夹属性为可写可读可执行–&gt;chmod -R 777 /tmp/sc</p>
<p>常用参数说明</p>
<p>-R ，可递归遍历子目录，把修改应到目录下所有文件和子目录<br>-v，无论修改是否成功，输出每个文件的信息<br> 參考自<br><a href="https://blog.csdn.net/lujun5188/article/details/3743490" target="_blank" rel="noopener">https://blog.csdn.net/lujun5188/article/details/3743490</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title> Cannot find the class file for java.lang.Object</title>
    <url>/2019/01/01/clipse/</url>
    <content><![CDATA[<p>IOUtils.copyBytes(in, System.out, 1024,true); 提示The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files错误。<br><a id="more"></a><br>一:<br>It is indirectly referenced from required .class file</p>
<p>原因：你正要使用的类调用了另一个类，而这个类又调用了其他类，这种关系可能会有好多层。而在这个调用的过程中，某个类所在的包的缺失就会造成以上那个错误。</p>
<p>解决方法：导入缺失的包</p>
<p>二:<br>The project was not built since its build path is incomplete. Cannot find the class file for java.lang.Object. Fix the build path then try building this project<br>The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files</p>
<p>出现以上信息的原因是因为你装了多个版本的jre或jdk的关系。Eclipse在建立时，会自动参照你的jre路径，但多个版本就沒办法了。<br>你只能手动建立…</p>
<ol>
<li>Eclipse进入window\preferences\java\Installed JREs<br>1)按Add<br>2)输入入JRE Name, 例JDK1.5.0.03<br>3)JRE home directory, 选择安装的路径<br>4)按OK</li>
<li>静茹Project\properties\Java Bulid Path<br>1)Add library<br>2)选JRE System Library后按Next<br>3)选workplace default JRE后按finish… </li>
</ol>
<p>或者卸载新版本的JDK，1.8版本的JDK会出现这样的报错。</p>
<p>参考博客<br><a href="https://blog.csdn.net/levy_cui/article/details/51140999" target="_blank" rel="noopener">https://blog.csdn.net/levy_cui/article/details/51140999</a></p>
]]></content>
      <categories>
        <category>环境安装配置</category>
      </categories>
  </entry>
  <entry>
    <title>css梅兰商城项目实战 传智博客</title>
    <url>/2018/12/31/css-background-color/</url>
    <content><![CDATA[<p>前端项目步骤：</p>
<p>1.拿到美工设计图后，开始浏览页面布局，将页面简单划分出来<br><a id="more"></a><br>开发整站的两种方式：</p>
<p>①从上到下依次把每个盒子写完</p>
<p>②先把整站的布局给搞定，然后再把每个布局的盒子中的子元素补齐（模块化）  个人比较倾向</p>
<p>2.整站项目的目录结构搭建好：css   js image index.html</p>
<p>3.css初始化：这里用的是YAHO的css初始化样式。地址为<a href="mailto:git@code.csdn.net" target="_blank" rel="noopener">git@code.csdn.net</a>:snippets/1678156.git</p>
<p>4.测量页面版心宽度及页面top部分（利用PS软件   标尺测量）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       要想文字垂直方向上居中，就要将文字所在标签的line-height与容器的height相同。</span><br><span class="line"></span><br><span class="line">       版心：宽度为970px</span><br></pre></td></tr></table></figure></p>
<p>5.精灵图：<br><code></code><br>      其他名称：雪碧图，雪碧技术，css sprite</p>
<pre><code>  作用：用于将网站上的一些小的图片管理到一个大的图片中。

  历史：最早的网速很慢，512kb/s。所以这个时候程序员为了提高用户的体验，将图片做得越小越好，但是这个存在一些缺点，就是每请求一张图片就要发送一条请求去服务器，消耗服务器的性能，后来网速得到提升以后为了减轻服务器的压力，所以将多张小图片合成一张大图来请求。

 精灵图的制作：

        1.0一定要是一些小图片（最好是不太会发生变化）

        2.0精灵图在制作的时候宽度一定要大于最大的那张图片的宽度

        3.0图片与图片之间必须要空隙

        4.0在精灵图制作完成之后一定要将精灵图的下方留出足够的位置，用来方便将来进行扩展。

使用：在css文件中的相应标签中写    background:url(../image/sprite.png)  位移量（左移为负）;

            也可以通过background-position:0 0;来定位
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6.logo：用h1标签，将图片写在css中，另外在h1标签中写上网站名，并写上</span><br><span class="line"></span><br><span class="line">text-indent:-1000em;(使文字消失，规定文本块中首行文本的缩进，如果使用负值，就会缩进到左边)</span><br><span class="line"></span><br><span class="line">这个文字的比例权重在这个网页中会较高，会放在搜索引擎的第一页，将来这个网站被人搜到的概率会较高，这是搜索引擎的优化。</span><br></pre></td></tr></table></figure>
<p>参考博客<br><a href="https://blog.csdn.net/x_chengqq/article/details/51366428" target="_blank" rel="noopener">https://blog.csdn.net/x_chengqq/article/details/51366428</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>css background-color</title>
    <url>/2018/12/31/css-background-color-1/</url>
    <content><![CDATA[<p>background可以设置图片，背景图拉伸、背景图大小、背景图相对位置、背景颜色等;而background-color只能设置背景色;<br>用这两个属性background-color与 background设置背景颜色有什么不同吗？<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot;&gt;黄丽珍找男朋友，黄丽珍找男朋友!!!&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">a&#123; background:url(&quot;./1.jpg&quot;);&#125;</span><br><span class="line">a:hover&#123; background: #fdff1f;&#125; //使用background</span><br><span class="line">a:hover&#123; background-color: #fdff1f;&#125; //使用background-color</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2922514-68ddaeb749d7a47a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2922514-03970be246cf0023.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"><br>background-color:改变的只是背景色，而不是背景图，效果是有的，只是图片把背景色遮住了看不到．<br>参考博客<br><a href="https://www.jianshu.com/p/6c23f47a0f62" target="_blank" rel="noopener">https://www.jianshu.com/p/6c23f47a0f62</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS padding margin border属性详解</title>
    <url>/2018/12/31/css/</url>
    <content><![CDATA[<p>W3C组织建议把所有网页上的对像都放在一个盒(box)中，设计师可以通过创建定义来控制这个盒的属性，这些对像包括段落、列表、标题、图片以及层。盒模型主要定义四个区域：内容(content)、内边距(padding)、边框(border)和外边距(margin)。对于初学者，经常会搞不清楚margin，background-color，background-image，padding，content，border之间的层次、关系和相互影响。这里提供一张盒模型的3D示意图，希望便于你的理解和记忆。<br><img src="https://images0.cnblogs.com/blog/270324/201402/191935386296017.jpg" alt="image"><br>margin：层的边框以外留的空白<br><a id="more"></a></p>
<p>background-color：背景颜色</p>
<p>background-image：背景图片</p>
<p>padding：层的边框到层的内容之间的空白 </p>
<p>border：边框 </p>
<p>content：内容</p>
<p><img src="https://images0.cnblogs.com/blog/270324/201402/191935495578126.jpg" alt="image"><br>参考博客<br><a href="https://www.cnblogs.com/linjiqin/p/3556497.html" target="_blank" rel="noopener">https://www.cnblogs.com/linjiqin/p/3556497.html</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 451. Sort Characters By Frequency</title>
    <url>/2018/11/28/d/</url>
    <content><![CDATA[<h2 id="array-排序"><a href="#array-排序" class="headerlink" title="array 排序"></a>array 排序</h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array&lt;int,128&gt; v;</span><br><span class="line">bool cmp(char a,char b)&#123;</span><br><span class="line">        if(v[a]!=v[b])</span><br><span class="line">        return v[a]&gt;v[b];</span><br><span class="line">        else return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string frequencySort(string s) &#123;</span><br><span class="line">        v=&#123;0&#125;;//!!</span><br><span class="line">        for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">            v[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">       sort(s.begin(),s.end(),cmp);</span><br><span class="line">       return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="map-排序"><a href="#map-排序" class="headerlink" title="map 排序"></a>map 排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map&lt;char,int&gt; v;</span><br><span class="line">bool cmp(char a,char b)&#123;</span><br><span class="line">        if(v[a]!=v[b])</span><br><span class="line">        return v[a]&gt;v[b];</span><br><span class="line">        else return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string frequencySort(string s) &#123;</span><br><span class="line">        v.clear();</span><br><span class="line">        for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">          //  if(!v.count(s[i]))</span><br><span class="line">           // v[s[i]]=1;</span><br><span class="line">            //  else v[s[i]]++; 可省略 初始化 所有键的值为0</span><br><span class="line">            v[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">       sort(s.begin(),s.end(),cmp);</span><br><span class="line">       return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="couting-计数思想"><a href="#couting-计数思想" class="headerlink" title="couting 计数思想"></a>couting 计数思想</h2><p>用vector&lt;pair&lt;int，char&gt;&gt; 存次数和其对应的字符<br>按次数降序 构成一个新的string<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string frequencySort(string s) &#123;</span><br><span class="line">        vector&lt;int&gt; f(128,0);</span><br><span class="line">         for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">             f[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;int,char&gt;&gt; v;</span><br><span class="line">       for(int i=0;i&lt;128;i++)&#123;</span><br><span class="line">           if(f[i]&gt;0)</span><br><span class="line">           v.push_back(pair&lt;int,int&gt;(f[i],i));</span><br><span class="line">       &#125;</span><br><span class="line">       sort(v.rbegin(),v.rend());</span><br><span class="line">       string ans;</span><br><span class="line">            for(auto t:v)&#123;</span><br><span class="line">                ans.append(t.first,t.second);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">       </span><br><span class="line">       return ans;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>关于empalce_back 和 push_back<br><a href="https://blog.csdn.net/xiaolewennofollow/article/details/52559364" target="_blank" rel="noopener">https://blog.csdn.net/xiaolewennofollow/article/details/52559364</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcod 639. Decode Ways II</title>
    <url>/2018/11/25/decodingways/</url>
    <content><![CDATA[<p>A message containing letters from A-Z is being encoded to numbers using the following mapping way:</p>
<p>‘A’ -&gt; 1</p>
<p>‘B’ -&gt; 2<br><a id="more"></a><br>…</p>
<p>‘Z’ -&gt; 26</p>
<p>Beyond that, now the encoded string can also contain the character ‘*’, which can be treated as one of the numbers from 1 to 9.</p>
<p>Given the encoded message containing digits and the character ‘*’, return the total number of ways to decode it.</p>
<p>Also, since the answer may be very large, you should return the output mod 109 + 7.</p>
<p>Example 1:</p>
<p>Input: “*”</p>
<p>Output: 9</p>
<p>Explanation: The encoded message can be decoded to the string: “A”, “B”, “C”, “D”, “E”, “F”, “G”, “H”, “I”.</p>
<p>Example 2:</p>
<p>Input: “1*”<br>Output: 9 + 9 = 18</p>
<p><strong>动态规划</strong></p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>递推<br>表达式<br><!--more--><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxkdzp1lswj31kw16otqf.jpg" alt="image"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>public:<br>    const static int kMod=1000000007;<br>    int numDecodings(string s) {<br>        long  dp[2]={1,ways(s[0])};<br>        for(int i=1;i&lt;s.length();i++){<br>           long  dp_i=dp[1]<em>ways(s[i])+dp[0]</em>ways(s[i-1],s[i]);<br>            dp_i%=kMod;<br>            dp[0]=dp[1];<br>            dp[1]=dp_i;<br>        }<br>        return dp[1];<br>    }</p>
<pre><code>int ways(char s){
    if(s==&apos;0&apos;) return 0;
    if(s==&apos;*&apos;) return 9;
    if(s&gt;=&apos;1&apos;&amp;&amp;s&lt;=&apos;9&apos;) return 1;
    else return 0;
}
int ways(char a,char b){
    if(a==&apos;*&apos;&amp;&amp;b==&apos;*&apos;) return 15;
    else if(a==&apos;*&apos;){
        if(&apos;b&apos;&gt;=&apos;0&apos;&amp;&amp;b&lt;=&apos;6&apos;) return 2;
        else return 1;
    }
    else if(b==&apos;*&apos;){
        if(a==&apos;1&apos;) return 9;
        else if(a==&apos;2&apos;) return 6;
        else return 0;

  }
    else{
        int prefix=(a-&apos;0&apos;)*10+b-&apos;0&apos;;
        return prefix&gt;=10&amp;&amp;prefix&lt;=26;
    }


}
</code></pre><p>};<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 法二</span><br><span class="line">数据规模很大</span><br><span class="line"> 递归 导致栈溢出 这种方法不可取</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>public:<br>    const static int kMod=1000000007;<br>    int numDecodings(string s) {<br>        int i=s.length()-1;<br>        if(s.length()==2) return ways(s[0],s[1])+ways(s[0])<em>ways(s[1]);<br>        else return decoding(s,i);<br>    }<br>   long decoding(string s,int i){<br>         long ways_i=1;<br>        if(i==-1) return 1;<br>         if(i==0) return ways(s[0])%kMod;<br>         ways_i=(ways(s[i])</em>decoding(s,i-1)+ways(s[i-1],s[i])*decoding(s,i-2))%kMod;<br>        return ways_i;</p>
<pre><code>}
int ways(char s){
    if(s==&apos;0&apos;) return 0;
    if(s==&apos;*&apos;) return 9;
    if(s&gt;=&apos;1&apos;&amp;&amp;s&lt;=&apos;9&apos;) return 1;
    else return 0;
}
int ways(char a,char b){
    if(a==&apos;*&apos;&amp;&amp;b==&apos;*&apos;) return 15;
    else if(a==&apos;*&apos;){
        if(&apos;b&apos;&gt;=&apos;0&apos;&amp;&amp;b&lt;=&apos;6&apos;) return 2;
        else return 1;
    }
    else if(b==&apos;*&apos;){
        if(a==&apos;1&apos;) return 9;
        else if(a==&apos;2&apos;) return 6;
        else return 0;

  }
    else{
        int prefix=(a-&apos;0&apos;)*10+b-&apos;0&apos;;
        return prefix&gt;=10&amp;&amp;prefix&lt;=26;
    }


}
</code></pre><p>};<br><code>`</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxkduahnmyj30ya0af0w6.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>poj3278 Catch That Cow</title>
    <url>/2018/11/16/e/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上<br>，农夫起始位于点N(0&lt;=N&lt;=100000)，牛位于点K(0&lt;=K&lt;=100000)<br>。农夫有两种移动方式：<br>1、从X移动到X-1或X+1，每次移动花费一分钟<br>2、从X移动到2*X，每次移动花费一分钟<br>假设牛没有意识到农夫的行动，站在原地不动。农夫最少要<br>花多少时间才能抓住牛？<br><a id="more"></a><br>Sample Input</p>
<p>5 17</p>
<p>Sample Output</p>
<p>4</p>
<p>Hint</p>
<p>The fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>bfs搜索 记录访问过的节点 若已走过就不再访问 再访问下一层</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">const int	MAXN = 100000;</span><br><span class="line">int		vis[MAXN + 10];</span><br><span class="line">using namespace std;</span><br><span class="line">struct point &#123;</span><br><span class="line">	int x, l;</span><br><span class="line">	point( int xx, int ll ) : x( xx ), l( ll )</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool bfs( int m, int n )</span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;point&gt; q;</span><br><span class="line">	q.push( point( m, 0 ) );</span><br><span class="line">	vis[m] = 1;</span><br><span class="line">	while ( !q.empty() )</span><br><span class="line">	&#123;</span><br><span class="line">		point p = q.front();</span><br><span class="line">		if ( p.x == n )</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; p.l &lt;&lt; endl;</span><br><span class="line">			return(true);</span><br><span class="line">		&#125;</span><br><span class="line">		q.pop();</span><br><span class="line">		if ( p.x - 1 &gt;= 0 &amp;&amp; !vis[p.x - 1] )</span><br><span class="line">		&#123;</span><br><span class="line">			q.push( point( p.x - 1, p.l + 1 ) );</span><br><span class="line">			vis[p.x - 1] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		if ( p.x + 1 &lt;= MAXN &amp;&amp; !vis[p.x + 1] )</span><br><span class="line">		&#123;</span><br><span class="line">			q.push( point( p.x + 1, p.l + 1 ) ); vis[p.x + 1] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		if ( p.x * 2 &lt;= MAXN &amp;&amp; p.x * 2 &gt;= 0 &amp;&amp; !vis[p.x * 2] )</span><br><span class="line">		&#123;</span><br><span class="line">			q.push( point( p.x * 2, p.l + 1 ) ); vis[p.x * 2] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	memset( vis, 0, sizeof(vis) );</span><br><span class="line">	bfs( n, k );</span><br><span class="line">	return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>eclipse 快捷键总结</title>
    <url>/2018/09/09/eclipse-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li><p>Ctrl+左键 和F3<br>这个是大多数人经常用到的，用来查看变量、方法、类的定义<br>跳到光标所在标识符的定义代码。当按执行流程阅读时，F3实现了大部分导航动作。</p>
<a id="more"></a>
<p>2 Ctrl+Shift+G<br>在工作空间中查找引用了光标所在标识符的位置。可以说是与F3相反的快捷键。当按类定义进行阅读时，可以迅速找出当前类方法在被哪些类调用了。</p>
</li>
<li><p>Ctrl+O</p>
</li>
</ol>
<p>查看一个类的纲要，列出其方法和成员变量。提示：再多按一次Ctrl+O，可以列出该类继承的方法和变量。</p>
<p>助记：”O”—&gt;”Outline”—&gt;”纲要”</p>
<p>4 F4<br>打开继承树。显示当前类所在的继承树。不但包括父类，还包括当前类的子类。</p>
<ol start="5">
<li>Ctrl+T</li>
</ol>
<p>查看一个类的继承关系树，是自顶向下的，再多按一次Ctrl+T, 会换成自底向上的显示结构。与”F4”快捷键不同的是显示方式。</p>
<p>提示：选中一个方法名，按Ctrl+T，可以查看到有这个同名方法的父类、子类、接口。</p>
<p>助记：”T”——-&gt;”Tree”—–&gt;”层次树”</p>
<p>6.Alt+左右方向键</p>
<p>我们经常会遇到看代码时Ctrl+左键，层层跟踪，然后迷失在代码中的情况，这时只需要按“Alt+左方向键”就可以退回到上次阅读的位置，同理，按“Alt+右方向键”会前进到刚</p>
<p>才退回的阅读位置，就像浏览器的前进和后退按钮一样。</p>
<p>Alt+–&gt;返回上一个阅读位置。使用查找功能或导航功能跳转后，可以用ALT-左箭头返回上一个阅读位置，而且还是多层历史记录。类似IE的后退。若要这个后退功能 达到最好效</p>
<p>率，就要养成使用它的习惯，例如遇到了一个方法调用，用F3打开了它所在的类文件，看完后应用alt-左箭头来后退，而不是直接关掉新打开的标 签页。否则这个新开的标签页将</p>
<p>会被记录到历史中，下次后退到这里时又会被重新打开。</p>
<p>7.Ctrl+Alt+H</p>
<p>如果你想知道一个类的方法到底被那些其他的类调用，那么请选中这个方法名，然后按“Ctrl+Alt+H”，Eclipse就会显示出这个方法被哪些方法调用，最终产生一个调用关系树。</p>
<p>助记：”H”—&gt;”Hierarchy”—&gt;”调用层次”</p>
<p>8 Alt+M,U<br>Open Super Implementation</p>
<p>打开光标所在类方法所覆盖的超类方法，相当于在覆盖方法中用鼠标点左边的覆盖方法三角标志。此功能没有默认快捷键，须在主菜单 Windows-&gt;Preferences-&gt;General-</p>
<blockquote>
<p>Keys-&gt;Modify-&gt;Command-&gt;Navigate, Open Super Implementation中设置，我个人习惯设为Alt+M,U。<br>9Alt+M,S<br>Show Selected Element Only<br>仅显示光标所在元素（类方法等）。隐藏当前代码中的其他部分，把光标所在的类方法置顶显示。我个人比较喜欢这种方式，一来屏幕比较清洁，二来此时使用导航 功能导航到类<br>方法必然是置顶显示，三来可以迫使自己习惯使用导航功能（F3，ALT+左右箭头）等进行导航而不是习惯性地拖滚动条。再按一次则取消此方式。<br>此功能没有默认快捷键，须在主菜单 Windows-&gt;Preferences-&gt;General-&gt;Keys-&gt;Modify-&gt;Command-&gt;Navigate, Open Super Implementation中设置，我个人习惯设为Alt+M,S。</p>
</blockquote>
<p>10 Ctrl+E<br>弹出一个简易对话框用来精确切换代码编辑栏。(注意不要不小心按了Ctrl+W把当前栏目关了，可以考虑取消Ctrl+W关闭当前栏目的设定，因为Ctrl+W实在太容易误按。我个人比较习惯用Ctrl+F4来关闭栏目）<br>11ctrl+M<br>最大化当前窗口。配合F12（编辑窗口获得焦点），可以立刻最大化代码编辑栏。(F12、Ctrl+M)</p>
<p>12Ctrl+小键盘的+ - * /<br>控制代码结构的折叠与展开。由于我个人喜欢用Show Selected Elemnt Only多于折叠代码，而且要看类成员结构可以用Outline栏目（Shift+Alt+Q,O）或Ctrl+O。因此比较少用这个功能。主要用来集中 查看类方法的Inline JavaDoc注释。<br>13 Open Implemention<br>就是可以跳转到某个调用的方法的具体实现的地方去。为什么说这个是超级好用呢？用过Spring的人都知道，现在都提倡面向接口编程，所以，如果使用Open Declaration来追踪<br>一个方法的调用的话，只会看到该方法在接口中的声明，而看不该方法在具体类中的实现，当然，可以使用Call Hierarchy先得到该方法的整个的调用层次，然后再导航到具体的实现处，但操作有些麻烦了。有了Open Implemention，就可以直接看到实现的代码了，在方法名上点击右键，选择Open Implemention就可以了！只是要享受这个功能，可安装一个Eclipse插件，到这里可以下载 <a href="http://eclipse-tools.sourceforge.net/implementors/" target="_blank" rel="noopener">http://eclipse-tools.sourceforge.net/implementors/</a></p>
<p>Ctrl+Shift+T<br>在工作空间内查找类型（包括所有项目中的类，引用JAR包中的类）。这是按名称打开一个类最快捷的方法。</p>
<p>Ctrl-PageUp/Ctrl-PageDown<br>切换到上一个/下一个标签页</p>
<p>ctrl+F4或ctrl+w<br>关闭当前标签页</p>
<p>Shift+Alt+Q<br>打开一个特定栏目，Shift+Alt+Q后可跟一个键表示要打开的栏目。按下Shift+Alt+Q后过一会可看到提示窗。</p>
<p>Ctrl+J<br>递增式查找。在当前编辑窗口中进行递增式查找。查找过程中按下箭头可跳到下一个匹配点，按上箭头跳到上一个匹配点，按ESC退出递增式查找。</p>
<p>Ctrl+H<br>打开查找窗口。打开一个可以进行详细设置的查找对话框。由于Eclipse各种导航功能很完善，我比较少用这个查找功能。主要用来进行一些用正则表达式做条件的查找。在查找中，用Ctrl+K查找下一个匹配。</p>
<p>Ctrl+Shift+E<br>弹出一个对话框来切换或关闭多个代码编辑栏。</p>
<p>当然还有最基本的，Ctrl+Shift+L，显示快捷键列表。</p>
<p> 转载自<br> <a href="https://www.cnblogs.com/yanyansha/archive/2011/08/30/2159265.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanyansha/archive/2011/08/30/2159265.html</a></p>
]]></content>
      <categories>
        <category>软件和工具</category>
      </categories>
  </entry>
  <entry>
    <title>eclipse配置折叠/展开代码快捷键</title>
    <url>/2018/07/02/eclipse%E9%85%8D%E7%BD%AE%E6%8A%98%E5%8F%A0-%E5%B1%95%E5%BC%80%E4%BB%A3%E7%A0%81%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>1、 取用折叠代码功能</p>
<p>1.1 windows-&gt;perferences-&gt;General-&gt;Editors-&gt;Structured Text Editors<br>可以看到Enable folding选项，打上勾就可以使用代码折叠功能，但还要在具体的语言中设置。<br><a id="more"></a><br>1.2 windows-&gt;perferences-&gt;Java-&gt;Editors-&gt;Folding<br>可以看到Enable folding选项，打上勾就可以使用代码折叠功能。</p>
<p><img src="https://img-blog.csdn.net/20160720170903817?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<p>2、配置折叠快捷键 </p>
<p>windows-&gt;perferences-&gt;General-&gt;搜索collapse</p>
<p><img src="https://img-blog.csdn.net/20160720171100022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<p>3、配置展开快捷键</p>
<p>windows-&gt;perferences-&gt;General-&gt;搜索expand</p>
<p><img src="https://img-blog.csdn.net/20160720171139435?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
]]></content>
  </entry>
  <entry>
    <title>eclipse自动提示和代码补全</title>
    <url>/2018/05/10/eclipse%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8/</url>
    <content><![CDATA[<p>对于编程人员来说，要记住大量的类名或类方法的名字，着实不是一件容易的事情。如果要IDE能够自动补全代码，那将为我们编程人员带来很大帮助。</p>
<p>eclipse代码里面的代码提示功能默认是关闭的，只有输入“.”的时候才会提示功能，用vs的用户可能不太习惯这种，vs是输入任何字母都会提示，下面说一下如何修改eclipse配置，开启代码自动提示功能打开 Eclipse  -&gt; Window -&gt; Perferences -&gt; Java -&gt; Editor -&gt; Content Assist，在右边最下面一栏找到 auto-Activation ，下面有三个选项，找到第二个“Auto activation triggers for Java：”选项在其后的文本框中会看到一个“.”存在。<br><a id="more"></a></p>
<p>这表示：只有输入“.”之后才会有代码提示和自动补全，我们要修改的地方就是这。把该文本框中的“.”换掉，换成“abcdefghijklmnopqrstuvwxyz.”，这样，你在Eclipse里面写Java代码就可以做到按“abcdefghijklmnopqrstuvwxyz.”中的任意一个里字符都会有代码提示。</p>
<p>在编写代码时敲出几个字符的情况下就迅速地完成代码，那是一件很爽的事。可是默认情况下，eclipse只有在你打出’.’（点字符）的时候，才会弹出自动补全窗口给你选择。这在大部分时候是完全不够用的。</p>
<p>由于eclipse 本身有很多选项是默认关闭的，这样开发者只能自己去手动配置一下. </p>
<p>那么如何配置eclipse的代码自动提示功能呢？</p>
<p>1、Window ——&gt; Preferences ——&gt; Java ——&gt; Editor ——&gt; Content Assist</p>
<p>1)将图中复选框勾上</p>
<p>2)将自动补全延迟的时间[auto activation delay(ms)]默认是200ms, 可以将时间缩短一些,比如我设置2ms.</p>
<p>3)[auto activation triggers for java]自动补全触发器,默认是”.”, 这个位置可以设置成26个字母外加’.’：.abcdefghijklmnopqrstuvwxyz(不区分大小写)</p>
<p>4)[auto activation triggers for javadoc]javadoc的触发器,默认是”@#”.</p>
<p>2、eclipse的代码自动提示功能设置成功后：</p>
<p>可是eclipse不允许输入这么的字符，文本框中最多允许输入4个字符，因此要通过修改配置文件的方法实现，具体操作步骤如下</p>
<ol>
<li><p>打开Eclipse，然后“window”→“Preferences”</p>
</li>
<li><p>选择“java”，展开，“Editor”，选择“Content Assist”。</p>
</li>
</ol>
<p>3.选择“Content Assist”，然后看到右边，右边的“Auto Activation”下面的“Auto Activation triggers for java”这个选项。其实就是指触发代码提示的就是“.”这个符号。 </p>
<p>4.“Auto Activation triggers for java”这个选项，在“.”后加abc字母，方便后面的查找修改。然后“apply”，点击“OK”。</p>
<ol start="5">
<li><p>然后，“File”→“Export”，在弹出的窗口中选择“General”→“Perferences”，点击“下一步”。</p>
</li>
<li><p>选择导出文件路径，本人导出到桌面，输入“abc”作为文件名，点击“保存”。</p>
</li>
<li><p>在桌面找到刚在保存的文件“abc.epf”,右键选择“用记事本打开”。 </p>
</li>
<li><p>按“ctrl + F”快捷键，输入“.abc”，点击“查找下一个”。</p>
</li>
<li><p>查找到“.abc”的配置信息如下：如下：</p>
</li>
<li><p>把“.abc”改成“.abcdefghijklmnopqrstuvwxyz(,”，保存，关闭“test.epf”。</p>
</li>
<li><p>回到MyEclipse界面，“File”→“Import”，在弹出的窗口中选择“Perferences”，点击“下一步”，选</p>
</li>
</ol>
<p>择刚在已经修改的“abc.epf”文件，点击“打开”，点击“Finish”。该步骤和上面 的导出步骤类似。</p>
<p>12.修改完毕，测试一下就行了。 </p>
<p>=========================================================================</p>
<p>好啦，接下来就是重点啦！！！按照下面的方法，就可以彻底解决eclipse帮你自动补全变量名了 ！！<br>1,先找到相关的插件： window -&gt; show view -&gt;other&gt; plug-ins<br>找到插件org.eclipse.jface.text,右键点击,选择import as Source Project,导入完成后,在你的workspace就可以看到这个project了<br>2.修改代码<br>在src/org.eclipse.jface.text.contentassist/CompletionProposalPopup.java文件中,找到这样一行代码(好像是在1335行)  </p>
<p>char[] triggers= t.getTriggerCharacters();<br>if (contains(triggers, key)) {</p>
<p>在那行if判断里面,eclipse会判断key(就是你按下的键)是否在triggers中,如果是,那就触发下面的第一行提示上屏的代码.所以我们要做的就是把空格和=号排除就可以了:<br>if(key != ‘=’ &amp;&amp; key != 0x20 &amp;&amp;contains(triggers,key)){<br>………<br>}<br>代码修改成这样后，提示的时候按下空格或者等号，提示就会没掉，也不会自动补全了咯！！！<br>3.把修改好的org.eclipse.jface.text导出<br>右键点击你的workspace里的org.eclipse.jface.text,选择export–&gt;Deployable plugins and fragments,destination 选择archive file，然后finish.</p>
<p>你就可以在zip文件里看到生成好的jar ,用它替换掉eclipse/plugins里面的同名jar包,就可以了。</p>
<p>4.重新启动eclipse即可。</p>
<p>转载自<a href="https://www.cnblogs.com/firstcsharp/p/4025689.html" target="_blank" rel="noopener">https://www.cnblogs.com/firstcsharp/p/4025689.html</a><br>参考链接 <a href="https://blog.csdn.net/zy4668/article/details/7660193" target="_blank" rel="noopener">https://blog.csdn.net/zy4668/article/details/7660193</a><br><a href="http://www.cnblogs.com/dongritengfei/archive/2010/09/09/1822258.html" target="_blank" rel="noopener">http://www.cnblogs.com/dongritengfei/archive/2010/09/09/1822258.html</a></p>
]]></content>
      <categories>
        <category>软件和工具</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 690. Employee Importance</title>
    <url>/2018/12/07/emp/</url>
    <content><![CDATA[<p>You are given a data structure of employee information, which includes the employee’s unique id, his importance value and his direct subordinates’ id.</p>
<p>For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct.</p>
<p>Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.<br><a id="more"></a><br>Example 1:</p>
<p>Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</p>
<p>Output: 11</p>
<p>Explanation:</p>
<p>Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.</p>
<p>Note:</p>
<p>One employee has at most one direct leader and may have several subordinates.</p>
<p>The maximum number of employees won’t exceed 2000.</p>
<h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// Employee info</span><br><span class="line">class Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    // It&apos;s the unique ID of each node.</span><br><span class="line">    // unique id of this employee</span><br><span class="line">    int id;</span><br><span class="line">    // the importance value of this employee</span><br><span class="line">    int importance;</span><br><span class="line">    // the id of direct subordinates</span><br><span class="line">    vector&lt;int&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">      bool vis[2000];</span><br><span class="line">    map&lt;int,Employee*&gt; emap;</span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        for(int i=0;i&lt;employees.size();i++)</span><br><span class="line">            for(Employee* e:employees)&#123;</span><br><span class="line">            emap[e-&gt;id]=e;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">       int cost=0;</span><br><span class="line">        dfs(id,cost);</span><br><span class="line">        return cost;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(int id,int &amp;cost)&#123;</span><br><span class="line">        cost+=emap[id]-&gt;importance;</span><br><span class="line">        vis[id]=true;</span><br><span class="line">        for(auto ch:emap[id]-&gt;subordinates)&#123;</span><br><span class="line">            dfs(ch,cost);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// Employee info</span><br><span class="line">class Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    // It&apos;s the unique ID of each node.</span><br><span class="line">    // unique id of this employee</span><br><span class="line">    int id;</span><br><span class="line">    // the importance value of this employee</span><br><span class="line">    int importance;</span><br><span class="line">    // the id of direct subordinates</span><br><span class="line">    vector&lt;int&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    map&lt;int,Employee*&gt; emap;</span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        for(int i=0;i&lt;employees.size();i++)</span><br><span class="line">            for(Employee* e:employees)&#123;</span><br><span class="line">            emap[e-&gt;id]=e;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Employee*&gt; q;</span><br><span class="line">        q.push(emap[id]);</span><br><span class="line">        int cost=0;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">           Employee* a=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            cost+=a-&gt;importance;</span><br><span class="line">            for(auto ch:a-&gt;subordinates)&#123;</span><br><span class="line">                q.push(emap[ch]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return cost;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>c++中的erase函数总结 </title>
    <url>/2018/12/09/erase%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="set-erase"><a href="#set-erase" class="headerlink" title="set::erase"></a>set::erase</h2><p>(1)<br>     void erase (iterator position);</p>
<p>(2)<br>size_type erase (const value_type&amp; val);</p>
<p>(3)<br>     void erase (iterator first, iterator last);<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// erasing from set</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::set&lt;int&gt; myset;</span><br><span class="line">  std::set&lt;int&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  // insert some values:</span><br><span class="line">  for (int i=1; i&lt;10; i++) myset.insert(i*10);  // 10 20 30 40 50 60 70 80 90</span><br><span class="line"></span><br><span class="line">  it = myset.begin();</span><br><span class="line">  ++it;                                         // &quot;it&quot; points now to 20</span><br><span class="line"></span><br><span class="line">  myset.erase (it);</span><br><span class="line"></span><br><span class="line">  myset.erase (40);</span><br><span class="line"></span><br><span class="line">  it = myset.find (60);</span><br><span class="line">  myset.erase (it, myset.end());</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; &quot;myset contains:&quot;;</span><br><span class="line">  for (it=myset.begin(); it!=myset.end(); ++it)</span><br><span class="line">    std::cout &lt;&lt; &apos; &apos; &lt;&lt; *it;</span><br><span class="line">  std::cout &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<p>myset contains: 10 30 50</p>
<h2 id="vector-erase"><a href="#vector-erase" class="headerlink" title="vector::erase"></a>vector::erase</h2><p>iterator erase (iterator position);</p>
<p>iterator erase (iterator first, iterator last);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/ erasing from vector</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;int&gt; myvector;</span><br><span class="line"></span><br><span class="line">  // set some values (from 1 to 10)</span><br><span class="line">  for (int i=1; i&lt;=10; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  // erase the 6th element</span><br><span class="line">  myvector.erase (myvector.begin()+5);</span><br><span class="line"></span><br><span class="line">  // erase the first 3 elements:</span><br><span class="line">  myvector.erase (myvector.begin(),myvector.begin()+3);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; &quot;myvector contains:&quot;;</span><br><span class="line">  for (unsigned i=0; i&lt;myvector.size(); ++i)</span><br><span class="line">    std::cout &lt;&lt; &apos; &apos; &lt;&lt; myvector[i];</span><br><span class="line">  std::cout &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>myvector contains: 4 5 7 8 9 10</p>
<h2 id="string-erase"><a href="#string-erase" class="headerlink" title="string::erase"></a>string::erase</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// string::erase</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::string str (&quot;This is an example sentence.&quot;);</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                                           // &quot;This is an example sentence.&quot;</span><br><span class="line">  str.erase (10,8);                        //            ^^^^^^^^</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                                           // &quot;This is an sentence.&quot;</span><br><span class="line">  str.erase (str.begin()+9);               //           ^</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                                           // &quot;This is a sentence.&quot;</span><br><span class="line">  str.erase (str.begin()+5, str.end()-9);  //       ^^^^^</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                                           // &quot;This sentence.&quot;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Output:</span><br><span class="line">This is an example sentence.</span><br><span class="line">This is an sentence.</span><br><span class="line">This is a sentence.</span><br><span class="line">This sentence.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>Sudoku (POJ2676)</title>
    <url>/2018/11/15/etrrt-1/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>将数字1到9,填入9x9矩阵中的小方格，使得矩阵中<br>的每行，每列，每个3x3的小格子内，9个数字都会<br>出现。<br><a id="more"></a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>几乎纯暴力搜索</p>
<p>将空白格子的位置放入一个数组，然后用Dfs尝试每个空白格子所放的数字。<br>会超时</p>
<p>剪枝：</p>
<p>放入一个数字后，就要做个标记，表面在当前行，当前列，以及当前小块已经放过这<br>个数字了，那么以后就不会在同行，同列或同小块放同样数字</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">//每行每列每小块不重复 </span><br><span class="line">//行数 num-&gt;标记数组  </span><br><span class="line">int rowFlag[100][100];</span><br><span class="line">int columnFlag[100][100];</span><br><span class="line">int blockFlag[100][100];</span><br><span class="line">int board[100][100];//!!</span><br><span class="line">struct pos&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	pos(int xx,int yy):x(xx),y(yy)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;pos&gt; blankpos;</span><br><span class="line">int getBlockNum(int r,int c)&#123;</span><br><span class="line">//	return r/3*3+c/3;</span><br><span class="line">int rr = r /3;</span><br><span class="line">int cc = c /3;</span><br><span class="line">return rr * 3 + cc;</span><br><span class="line">&#125;</span><br><span class="line">void setFlags(int r,int c,int num,int f)&#123;</span><br><span class="line">//	int k=getBlockNum(r,c);</span><br><span class="line">//	//rowFlag[r][c]=f; 錯了 应该是r这行放Num数字 判断flag</span><br><span class="line">//	rowFlag[r][num]=f;</span><br><span class="line">//	columnFlag[c][num]=f;</span><br><span class="line">//	blockFlag[k][num]=f; </span><br><span class="line">rowFlag[r][num] = f;</span><br><span class="line">columnFlag[c][num] = f;</span><br><span class="line">blockFlag[getBlockNum(r,c)][num] = f;</span><br><span class="line">&#125;</span><br><span class="line">bool IsOK(int i,int j,int num)</span><br><span class="line">&#123;//  看num在 能否放在 i,j 位置</span><br><span class="line">return !rowFlag[i][num]&amp;&amp;!columnFlag[j][num]&amp;&amp;!blockFlag[getBlockNum(i,j)][num];</span><br><span class="line">&#125;</span><br><span class="line">bool dfs(int n)</span><br><span class="line">&#123;// 处理前n 个空格</span><br><span class="line">if( n &lt; 0)</span><br><span class="line">return true;</span><br><span class="line">int r = blankpos[n].x;</span><br><span class="line">int c = blankpos[n].y;</span><br><span class="line">for( int num = 1; num &lt;= 9; ++ num ) &#123;</span><br><span class="line">if( IsOK(r,c,num)) &#123;</span><br><span class="line">board[r][c] = num;</span><br><span class="line">setFlags(r,c,num,1);</span><br><span class="line">if( dfs(n-1))</span><br><span class="line">return true;</span><br><span class="line">setFlags(r,c,num,0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">		int n;</span><br><span class="line">		//freopen(&quot;11-16.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">		int t;</span><br><span class="line">		cin&gt;&gt;t;</span><br><span class="line">		while(t--)&#123;</span><br><span class="line">		memset(rowFlag,0,sizeof(rowFlag));</span><br><span class="line">		memset(columnFlag,0,sizeof(columnFlag));		</span><br><span class="line">		memset(blockFlag,0,sizeof(blockFlag));	</span><br><span class="line">		blankpos.clear();</span><br><span class="line">		for(int i=0;i&lt;9;i++)&#123;</span><br><span class="line">			for(int j=0;j&lt;9;j++)&#123;</span><br><span class="line">				char c;</span><br><span class="line">				cin&gt;&gt;c;</span><br><span class="line">				board[i][j]=c-&apos;0&apos;;</span><br><span class="line">				if(board[i][j]) setFlags(i,j,board[i][j],1);</span><br><span class="line">				else </span><br><span class="line">					blankpos.push_back(pos(i,j));</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		if(dfs(blankpos.size()-1)) &#123;//!! dfs(blankpos.size())-1 括号问题 </span><br><span class="line">				for(int i=0;i&lt;9;i++)&#123;</span><br><span class="line">			for(int j=0;j&lt;9;j++)</span><br><span class="line">				cout&lt;&lt;char(board[i][j]+&apos;0&apos;);</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>百练4110 圣诞老人的礼物</title>
    <url>/2018/11/17/etrrt/</url>
    <content><![CDATA[<p>描述</p>
<p>圣诞节来临了，在城市A中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。<br><a id="more"></a><br>输入</p>
<p>第一行由两个部分组成，分别为糖果箱数正整数n(1 &lt;= n &lt;= 100)，驯鹿能承受的最大重量正整数w（0 &lt; w &lt; 10000），两个数用空格隔开。其余n行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数v和重量正整数w，中间用空格隔开。</p>
<p>输出</p>
<p>输出圣诞老人能带走的糖果的最大总价值，保留1位小数。输出为一行，以换行符结束。</p>
<p>样例输入</p>
<p>4 15</p>
<p>100 4</p>
<p>412 8</p>
<p>266 7</p>
<p>591 2</p>
<p>样例输出</p>
<p>1193.0</p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxat1iutj5j30dg08sq75.jpg" alt="image"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXN 1000</span><br><span class="line">struct box&#123;</span><br><span class="line">	int v,w;</span><br><span class="line">	double density;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">box boxes[MAXN];</span><br><span class="line">double totalv=0,totalw=0;</span><br><span class="line">bool operator &lt;(const box &amp;a,const box &amp;b)&#123;</span><br><span class="line">	return a.density&lt;b.density;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int W,N;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;W;</span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		cin&gt;&gt;boxes[i].v&gt;&gt;boxes[i].w;</span><br><span class="line">		boxes[i].density=1.0*boxes[i].v/boxes[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(boxes,boxes+N);</span><br><span class="line">	for(int i=N-1;i&gt;=0;i--)&#123;</span><br><span class="line">		if(totalw+boxes[i].w&lt;=W)&#123;</span><br><span class="line">			totalw+=boxes[i].w;</span><br><span class="line">			totalv+=boxes[i].v;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;//已放慢</span><br><span class="line">			totalv+=boxes[i].density*(W-totalw);</span><br><span class="line">			totalw=W;  </span><br><span class="line">			break;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%.1lf\n&quot;,totalv);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>freopen函数的使用</title>
    <url>/2018/10/31/freopen%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>当我们求解acm题目时，通常在设计好算法和程序后，要在调试环境（例如VC等）中运行程序，输入测试数据，当能得到正确运行结果后，才将程序提交到oj中。但由于调试往往不能一次成功，每次运行时，都要重新输入一遍测试数据，对于有大量输入数据的题目，输入数据需要花费大量时间。 </p>
<pre><code>使用freopen函数可以解决测试数据输入问题，避免重复输入，不失为一种简单而有效的解决方法。 
</code></pre><a id="more"></a>
<p>函数名：freopen </p>
<p>声明：FILE <em>freopen( const char </em>path, const char <em>mode, FILE </em>stream ); </p>
<p>所在文件： stdio.h </p>
<p>参数说明： </p>
<p>path: 文件名，用于存储输入输出的自定义文件名。 </p>
<p>mode: 文件打开的模式。和fopen中的模式（如r-只读, w-写）相同。</p>
<p>stream: 一个文件，通常使用标准流文件。 </p>
<p>返回值：成功，则返回一个path所指定文件的指针；失败，返回NULL。（一般可以不使用它的返回值）</p>
<p>功能：实现重定向，把预定义的标准流文件定向到由path指定的文件中。标准流文件具体是指stdin、stdout和stderr。其中stdin是标准输入流，默认为键盘；stdout是标准输出流，默认为屏幕；stderr是标准错误流，一般把屏幕设为默认。 </p>
<pre><code>下面以在VC下调试“计算a+b”的程序举例。
```
</code></pre><p>C语法： </p>
<p>#include &lt;stdio.h&gt;<br>int main()<br>{<br>int a,b;<br>freopen(“debug\in.txt”,”r”,stdin); //输入重定向，输入数据将从in.txt文件中读取<br>freopen(“debug\out.txt”,”w”,stdout); //输出重定向，输出数据将保存在out.txt文件中<br>while(scanf(“%d %d”,&amp;a,&amp;b)!=EOF)<br>printf(“%d\n”,a+b);<br>fclose(stdin);//关闭文件<br>fclose(stdout);//关闭文件<br>return 0;<br>} </p>
<p>C++语法 </p>
<p>#include &lt;stdio.h&gt; </p>
<p>#include &lt;iostream.h&gt;<br>int main()<br>{<br>int a,b;<br>freopen(“debug\in.txt”,”r”,stdin); //输入重定向，输入数据将从in.txt文件中读取<br>freopen(“debug\out.txt”,”w”,stdout); //输出重定向，输出数据将保存在out.txt文件中<br>while(cin&gt;&gt;a&gt;&gt;b)<br>cout&lt;&lt;a+b&lt;&lt;endl; // 注意使用endl<br>fclose(stdin);//关闭文件<br>fclose(stdout);//关闭文件<br>return 0;<br>}<br>        freopen(“debug\in.txt”,”r”,stdin)的作用就是把标准输入流stdin重定向到debug\in.txt文件中，这样在用scanf或是用cin输入时便不会从标准输入流读取数据,而是从in.txt文件中获取输入。只要把输入数据事先粘贴到in.txt，调试时就方便多了。<br>类似的，freopen(“debug\out.txt”,”w”,stdout)的作用就是把stdout重定向到debug\out.txt文件中，这样输出结果需要打开out.txt文件查看。 </p>
<pre><code>需要说明的是： 
1. 在freopen(&quot;debug\\in.txt&quot;,&quot;r&quot;,stdin)中，将输入文件in.txt放在文件夹debug中，文件夹debug是在VC中建立工程文件时自动生成的调试文件夹。如果改成freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin)，则in.txt文件将放在所建立的工程文件夹下。in.txt文件也可以放在其他的文件夹下，所在路径写正确即可。 
2. 可以不使用输出重定向，仍然在控制台查看输出。 
3. 程序调试成功后，提交到oj时不要忘记把与重定向有关的语句删除。
</code></pre>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 289. Game of Life</title>
    <url>/2018/12/05/game/</url>
    <content><![CDATA[<p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”<br><a id="more"></a><br>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<p>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</p>
<p>Any live cell with two or three live neighbors lives on to the next generation.</p>
<p>Any live cell with more than three live neighbors dies, as if by over-population..</p>
<p>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</p>
<p>Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.</p>
<p>Example:</p>
<p>Input:<br>[</p>
<p>[0,1,0],</p>
<p>[0,0,1],</p>
<p>[1,1,1],</p>
<p>[0,0,0]<br>]</p>
<p>Output: </p>
<p>[</p>
<p>[0,0,0],</p>
<p>[1,0,1],</p>
<p>[0,1,1],</p>
<p>[0,1,0]</p>
<p>]<br>Follow up:</p>
<p>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.</p>
<p>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dir[8][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,-1&#125;,&#123;-1,1&#125;,&#123;1,1&#125;,&#123;1,-1&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123;</span><br><span class="line">       </span><br><span class="line">     int m=board.size();</span><br><span class="line">        int n=board[0].size();</span><br><span class="line">         vector&lt;vector&lt;int&gt; &gt;tmp(m,vector&lt;int&gt;(n));</span><br><span class="line">        for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">                int cnt=0;</span><br><span class="line">                if(board[i][j]==1) cnt++;</span><br><span class="line">                for(int k=0;k&lt;8;k++)&#123;</span><br><span class="line">                    int newx=i+dir[k][0];</span><br><span class="line">                    int newy=j+dir[k][1];</span><br><span class="line">                    if(newx&lt;0||newx&gt;=m||newy&lt;0||newy&gt;=n) continue;</span><br><span class="line">                    if(board[newx][newy]==1) cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(cnt==3||cnt-board[i][j]==3) tmp[i][j]=1;</span><br><span class="line">                else tmp[i][j]=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            board[i][j]=tmp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>getline使用</title>
    <url>/2018/11/26/getline/</url>
    <content><![CDATA[<p>getline()函数是一个比较常见的函数。根据名字直接”望文-&gt;生义”，就知道这个函数是来完成读入一行数据。<br><a id="more"></a><br>下面就对C++ – getline()函数的用法说明，以及getline()函数作为while条件的问题，总结一下：</p>
<p>在C++中本质上有两种getline函数，（称为第一种）一种在头文件<istream>中，是istream类的成员函数。</istream></p>
<p>（称为第二种）一种在头文件<string>中，是普通函数。</string></p>
<p>1<br>第一种： 在<istream>中的getline()函数有两种重载形式：</istream></p>
<p>istream&amp; getline (char<em> s, streamsize n );<br>istream&amp; getline (char</em> s, streamsize n, char delim );</p>
<p>作用是： 从istream中读取至多n个字符(包含结束标记符)保存在s对应的数组中。即使还没读够n个字符，</p>
<p>如果遇到delim或 字数达到限制，则读取终止，delim都不会被保存进s对应的数组中。</p>
<p>*例程代码：</p>
<p>#include “stdafx.h”</p>
<p>#include <iostream></iostream></p>
<p>//使用标准输入流和标准输出流。</p>
<p>// std::cin ;  std::cout ;  std::endl</p>
<p>int main()</p>
<p>{</p>
<p>char name[256], wolds[256];</p>
<p>std::cout &lt;&lt; “Please input your name: “;</p>
<p>std::cin.getline(name, 256);</p>
<p>std::cout &lt;&lt; “Please input your wolds: “;</p>
<p>std::cin.getline(wolds, 256);</p>
<p>std::cout &lt;&lt; “The result is:   “ &lt;&lt; name&lt;&lt; “, “ &lt;&lt; wolds&lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p>//**输入：</p>
<p>Mr. Ling</p>
<p>You are wonderful !</p>
<p>//输出：</p>
<p>Mr. Ling, You are wonderful !</p>
<p>*通过字数限制和设置终止符修改的代码：</p>
<p>int main()</p>
<p>{</p>
<p>char name[6];</p>
<p>std::cout &lt;&lt; “Please input your name: “;</p>
<p>std::cin.getline(name, 6, ‘#’);</p>
<p>std::cout &lt;&lt; “The result is:   “ &lt;&lt; name&lt;&lt; std::ends;</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p>//**输入： //streamsize限定，截断输出</p>
<p>wonderful</p>
<p>//输出：</p>
<p>wonde</p>
<p>//**输入： //所设置的结束标识符，截断输出</p>
<p>won#derful</p>
<p>//输出：</p>
<p>won</p>
<p>第二种： 在<string>中的getline函数有四种重载形式：</string></p>
<p>istream&amp; getline (istream&amp;  is, string&amp; str, char delim);<br>istream&amp; getline (istream&amp;&amp; is, string&amp; str, char delim);<br>istream&amp; getline (istream&amp;  is, string&amp; str);</p>
<p>istream&amp; getline (istream&amp;&amp; is, string&amp; str);<br>用法和上第一种类似，但是读取的istream是作为参数is传进函数的。读取的字符串保存在string类型的str中。</p>
<p>函数的变量：</p>
<p>is    ：表示一个输入流，例如cin。</p>
<p>str   ：string类型的引用，用来存储输入流中的流信息。</p>
<p>delim ：char类型的变量，所设置的截断字符；在不自定义设置的情况下，遇到’\n’，则终止输入。</p>
<p>*例程代码：</p>
<p>#include “stdafx.h”</p>
<p>#include <iostream></iostream></p>
<p>#include <string></string></p>
<p>int main()</p>
<p>{</p>
<p>std::string name;</p>
<p>std::cout &lt;&lt; “Please input your name: “;</p>
<p>std::getline(std::cin, name);</p>
<p>std::cout &lt;&lt; “Welcome to here!” &lt;&lt; std::ends&lt;&lt; name &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p>在输入时，直至遇到‘\n’或EOF， 才终止输入操作。</p>
<p>//**输入：</p>
<p>wonderful</p>
<p>//输出：</p>
<p>wonderful</p>
<p>*例程代码：</p>
<p>nt main()</p>
<p>{</p>
<p>std::string name;</p>
<p>std::cout &lt;&lt; “Please input your name: “;</p>
<p>std::getline(std::cin, name, ‘#’);</p>
<p>std::cout &lt;&lt; “Welcome to here!” &lt;&lt; std::ends&lt;&lt; name &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p>//**输入：</p>
<p>wonderful#Mr.Ling</p>
<p>//输出：</p>
<p>wonderful</p>
<p>2///////////////////////////////////////////////////////////////////////////////////////////</p>
<p>(EOF是C语言中为了区分有效数据和输入结束符的。</p>
<p>EOF的输入由系统锁定。windows下是ctrl+z,linux/unix下是ctrl+d。)</p>
<p>getline不是C库函数，而是C++库函数。它遇到以下情况发生会导致生成的本字符串结束：</p>
<p>(1)到文件结束，(2)遇到函数的定界符，(3)输入达到最大限度。</p>
<p>getline()函数在while中作为条件判断。</p>
<p>#include “stdafx.h”</p>
<p>#include <iostream></iostream></p>
<p>#include <string></string></p>
<p>using namespace std;</p>
<p>int main()</p>
<p>{</p>
<p>string line;</p>
<p>while (getline(cin, line))</p>
<p>cout &lt;&lt; line &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>大家会发现运行时一般的输入都不能够跳出循环，可能有时还会出现莫名的错误。但是这到底是什么原因造成的呢！下面就来分析一下：</p>
<p>getline()函数的原型是istream&amp; getline ( istream &amp; is , string &amp; str , char delim );</p>
<p>int main()</p>
<p>{</p>
<p>string line;</p>
<p>cout &lt;&lt; “Please input a line: “ &lt;&lt; endl;</p>
<p>while (getline(cin, line,’#’))</p>
<p>cout &lt;&lt; line &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>然后，那么当我们输入 “You are wonderful!#Mr. Ling”时，但是，有效的输入是 “You are wonderful！”，#后面的内容并没有存入。程序运行的结果如：</p>
<p>//输入：</p>
<p>You are wondreful!#LingKing</p>
<p>//输出：</p>
<p>You are wonderful!</p>
<p>在这里设置‘#’为终止符时，当再输入’\n’时也不会影响。在#之前的内容都会照样输出。例如：</p>
<p>//输入： //含有’\n’的输入</p>
<p>Hello world!</p>
<p>You are wonderful!</p>
<p>Mr. Ling#wonderful!</p>
<p>//输出： //照样输出</p>
<p>Hello world!</p>
<p>You are wonderful!</p>
<p>Mr. Ling</p>
<p>通过getline()函数一个小小的实例，那么把getline()函数作为while的判断语句会怎么样的呢！</p>
<p>就分析一下while(getline(cin,line))</p>
<p>（注意：这里默认回车符停止读入,按Ctrl+Z(Windows)(Ctrl+D(Linux))或键入EOF(参考MSDN)回车即可退出循环。）</p>
<p>这个语句中，while判断语句的真实判断对象是cin的状态，也就是判断当前是否存在有效的输入流。</p>
<p>而输入流是对象，判断的是流返回的状态。所以正常的情况下，你怎么输入都是跳不出它的循环。</p>
<p>在这之中可能会用些同志误以为while判断语句的判断对象是line（也就是line是否为空），想通过回车来跳出循环，却发现不能跳出循环。</p>
<p>而回车和设置的终止符都是终止getline()函数的读取操作的。但是while判断语句判断的是getline()函数的输入流是否有效。所以呢！</p>
<p>参考博客：</p>
<p>原文：<a href="https://blog.csdn.net/MisterLing/article/details/51697098" target="_blank" rel="noopener">https://blog.csdn.net/MisterLing/article/details/51697098</a> </p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>github桌面版使用</title>
    <url>/2018/07/05/github%E6%A1%8C%E9%9D%A2%E7%89%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>步骤</p>
<p>modify -&gt; conmmit -&gt; publish -&gt; view<br><a id="more"></a></p>
<h2 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h2><p>先来创建一个仓库，仓库里的文件变动都会被github记录下来</p>
<p>点击又上角的File，然后有一个New repository</p>
<p>给仓库取个名字，给它在本地找一个地址，</p>
<p>然后把第三行的单选框勾上，相当于一个初始化，会创建一个readme文件，这个文件一半是用来介绍自己项目是做什么的，怎么用。</p>
<h2 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h2><p>现在来进行仓库的修改</p>
<p>进入仓库的目录，新建一个txt文件，此时，github上就有显示了</p>
<p>（或者直接用文本编辑器修改TXT，GitHub也能检测到）</p>
<p>（或者将你原来写好的程序组复制进去，GitHub也能检测到）</p>
<h2 id="提交版本conmmit"><a href="#提交版本conmmit" class="headerlink" title="提交版本conmmit"></a>提交版本conmmit</h2><p>commit的意思是“版本”，你修改了依稀代码，那么此时此刻这个项目就进入了新的“版本”，所以如果你确定刚刚做的修改，就应该点击conmmit，提交当前版本。</p>
<p>对修改进行适当地解释，并点击左下角 commit to master</p>
<h2 id="同步到云端publish"><a href="#同步到云端publish" class="headerlink" title="同步到云端publish"></a>同步到云端publish</h2><p>果是云端仓库已经存在当前项目，点击publish就会同步你本地的修改到云端，并刷新云端数据</p>
<h2 id="删除一个repository仓库"><a href="#删除一个repository仓库" class="headerlink" title="删除一个repository仓库"></a>删除一个repository仓库</h2>]]></content>
      <categories>
        <category>软件和工具</category>
      </categories>
  </entry>
  <entry>
    <title>hexo博客重装系统还原</title>
    <url>/2018/05/12/hexo%E5%8D%9A%E5%AE%A2%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E8%BF%98%E5%8E%9F/</url>
    <content><![CDATA[<p>重装系统前备份是个好习惯⊙﹏⊙</p>
<p>更新前备份<br>备份好 hexo 目录下的_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，node_modules（当然如果你硬盘空间够大，备份整个 hexo 文件夹也可以）。然后把 hexo 目录里面的东西全部删掉。</p>
<p>备份用户目录下的文件：开始，你的 windows 用户名，打开你的用户文件夹后备份.ssh文件夹和.gitconfig、_netrc以及_viminfo这三个文件。<br><a id="more"></a></p>
<h2 id="更新后恢复"><a href="#更新后恢复" class="headerlink" title="更新后恢复"></a>更新后恢复</h2><p>安装 node.js 和 git</p>
<p>安装 Hexo</p>
<p>npm install hexo-cli -g<br>cd D:\hexo<br>hexo init<br>npm install<br>打开原来的 hexo 博客所在文件夹，将之前备份的文件夹粘贴进去，覆盖原文件夹。</p>
<p>和 gitcafe 建立连接<br>在 gitbash 里输入：</p>
<p>git config –global user.email “Your email”<br>git config –global user.name “Your name”<br>然后【C:\Users\wmaqingbo】，打开你的用户文件夹，粘贴并替换事先备份的.ssh文件夹和.gitconfig、_netrc以及_viminfo这三个文件。<br>然后再输入：</p>
<p>ssh -T <a href="mailto:git@gitcafe.com" target="_blank" rel="noopener">git@gitcafe.com</a><br>这时会看到显示连接成功信息。</p>
<h2 id="没有提前备份的情况"><a href="#没有提前备份的情况" class="headerlink" title="没有提前备份的情况"></a>没有提前备份的情况</h2><p>我的情况：电脑重装了系统，hexo 博客文件夹还在 D 盘存着，完好无损，但是C盘的用户文件夹内容丢失。现在只能借助这些文件恢复部署。具体方法如下：</p>
<p>将 hexo 文件夹下的文件全部复制到其他地方进行备份</p>
<p>安装 node.js 和 git</p>
<p>安装 hexo</p>
<p>npm install hexo-cli -g<br>cd D:\hexo<br>hexo init<br>npm install<br>打开备份的 hexo 文件夹，选择_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，node_modules这些项目，粘贴到【D:\hexo】覆盖新安装的文件。</p>
<p>安装部署插件<br>npm install hexo-deployer-git –save    //hexo d 部署到git插件<br>配置 git 个人信息，生成新的 ssh 密钥<br>请参考文章：《使用 Github SSH Key 一键部署 Hexo》</p>
<p>测试是否成功。<br>hexo g<br>hexo d</p>
<p><a href="https://wmaqingbo.github.io/blog/2017/06/23/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%EF%BC%8C%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">参考博客1</a> </p>
<p>[参考博客2](<a href="https://xuanwo.org/2015/03/26/hexo-intor/）" target="_blank" rel="noopener">https://xuanwo.org/2015/03/26/hexo-intor/）</a></p>
<p><a href="https://www.jianshu.com/p/4d2c07a330da" target="_blank" rel="noopener">https://www.jianshu.com/p/4d2c07a330da</a></p>
]]></content>
      <categories>
        <category>环境安装配置</category>
      </categories>
  </entry>
  <entry>
    <title>html+css学习笔记（二）</title>
    <url>/2018/05/17/html-2/</url>
    <content><![CDATA[<h2 id="单选-复选框的使用"><a href="#单选-复选框的使用" class="headerlink" title="单选 复选框的使用"></a>单选 复选框的使用</h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;https://fonts.googleapis.com/css?family=Lobster&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.red-text &#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h2 &#123;</span><br><span class="line">font-family: Lobster, Monospace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">font-size: 16px;</span><br><span class="line">font-family: Monospace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.thick-green-border &#123;</span><br><span class="line">border-color: green;</span><br><span class="line">border-width: 10px;</span><br><span class="line">border-style: solid;</span><br><span class="line">border-radius: 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.smaller-image &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">#cat-photo-form&#123;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">.gray-background &#123;</span><br><span class="line">background-color: gray;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2 class=&quot;red-text&quot;&gt;CatPhotoApp&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Click here for &lt;a href=&quot;#&quot;&gt;cat photos&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;#&quot;&gt;&lt;img class=&quot;smaller-image thick-green-border&quot; alt=&quot;A cute orange cat lying on its back&quot; src=&quot;/statics/codecamp/images/relaxing-cat.jpg&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;gray-background&quot;&gt;</span><br><span class="line">&lt;p&gt;Things cats love:&lt;/p&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;cat nip&lt;/li&gt;</span><br><span class="line">&lt;li&gt;laser pointers&lt;/li&gt;</span><br><span class="line">&lt;li&gt;lasagna&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;p&gt;Top 3 things cats hate:&lt;/p&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li&gt;flea treatment&lt;/li&gt;</span><br><span class="line">&lt;li&gt;thunder&lt;/li&gt;</span><br><span class="line">&lt;li&gt;other cats&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;/submit-cat-photo&quot; id=&quot;cat-photo-form&quot;&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; checked&gt; Indoor&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;indoor-outdoor&quot;&gt; Outdoor&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;personality&quot; checked&gt; Loving&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;personality&quot;&gt; Lazy&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;personality&quot;&gt; Energetic&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; placeholder=&quot;cat photo URL&quot; required&gt;</span><br><span class="line">&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h2 id="padding-margin-border"><a href="#padding-margin-border" class="headerlink" title="padding margin border"></a>padding margin border</h2><p><img src="https://ws1.sinaimg.cn/large/006wtREyly1frekyjkz5ej307l0cpdig.jpg" alt="image"></p>
<p>有三个重要的属性控制每个HTML元素的布局：padding(内边距)、margin(外边距)、border(边框)。</p>
<p>元素的 padding 控制元素与其边框 border 之间的距离。</p>
<p>元素的 margin （外边距）控制元素 border （边框）和周围元素实际所占空间的距离。</p>
<h2 id="css覆盖class类的声明"><a href="#css覆盖class类的声明" class="headerlink" title="css覆盖class类的声明"></a>css覆盖class类的声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">body &#123;</span><br><span class="line">background-color: black;</span><br><span class="line">font-family: Monospace;</span><br><span class="line">color: green;</span><br><span class="line">&#125;</span><br><span class="line">.pink-text &#123;</span><br><span class="line">color: pink;</span><br><span class="line">&#125;</span><br><span class="line">.blue-text &#123;</span><br><span class="line">color: blue;</span><br><span class="line">&#125;</span><br><span class="line">#orange-text&#123;</span><br><span class="line">    color:orange;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;h1 id=&quot;orange-text&quot; class=&quot;pink-text blue-text&quot;&gt;Hello World!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1frelpq7prwj308w08iwf1.jpg" alt="image"></p>
<h2 id="CSS-十六进制RGB混合颜色"><a href="#CSS-十六进制RGB混合颜色" class="headerlink" title="CSS 十六进制RGB混合颜色"></a>CSS 十六进制RGB混合颜色</h2><p>十六进制代码使用6个十六进制数字表示颜色，每 2 个分别表示红（R），绿（G）和蓝（B）成分。</p>
<p>从这三种纯色（红、绿、蓝），我们可以改变每种颜色创造超过1600万种其他颜色！</p>
<p>例如，橙色是纯红，与一些绿色混合，没有蓝色。在十六进制代码中，这转换为 ＃FFA500。</p>
<p>数字 0 是十六进制代码中最低的数字，表示完全没有颜色。</p>
<p>数字 F 是十六进制代码中最高的数字，表示最大可能的亮度。</p>
<p>用正确的十六进制代码替换 <style> 元素中的颜色词。</p>
<p>Color    Hex Code<br>Dodger Blue    #2998E4<br>Green    #00FF00<br>Orange    #FFA500<br>Red    #FF0000</p>
</style></p>]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>html+css学习笔记（三）</title>
    <url>/2018/05/17/html-css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>常用标签及基本样式设置</p>
<p>1）标题</p>
<pre><code>h1 一级标题 主标题，h2 副标题，h3,h4···字体依次往下减小
</code></pre><p>2）段落标签p</p>
<pre><code>段落标签&lt;p&gt;&lt;/p&gt;，用来创建段落
</code></pre><a id="more"></a>
<p>3）注释</p>
<pre><code>html中注释用&lt;!-- 中间为注释内容 --&gt;
</code></pre><p>4）设置样式</p>
<pre><code>第一种：直接在元素中使用style进行修改，如，&lt;h2 style=&quot;color:red&quot;&gt;可爱的猫咪&lt;/h2&gt;

第二种：在元素前统一使用

&lt;style&gt;

选择器{属性名称：属性值;} 属性值后面一定要加上英文分号 

&lt;/style&gt;进行样式设置，这里的选择器可以是元素选择器，类选择器，

元素选择器如&lt;style&gt;  h2{color:blue;} &lt;/style&gt;

类选择器如&lt;style&gt; .red-text{color:blue;}&lt;/style&gt; 必须使用.



第三种：单独建立.CSS文件，在html中直接引用
</code></pre><p>5）font-size与 font-family</p>
<pre><code>font-size设置字号 font-family设置字体 

导入谷歌字体：&lt;link href=&quot;https://fonts.gdgdocs.org/css?family=Lobster&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;

有几种默认的字体是所有浏览器都可用的，包括Monospace、Serif和Sans-Serif。当某种字体不可用时，你可以让浏览器自动降级到另一种字体。

如，p {
           font-family: Helvetica, Sans-Serif;
         }当Helvetica字体不能用时，自动降级到Sans-Serif字体
</code></pre><p>6）img标签</p>
<pre><code>img元素是自关闭元素，不需要结束标记。如，&lt;img src=&quot;https://www.your-image-source.com/your-image.jpg&quot;&gt; 使用src属性指向一个图片的具体地址。

设置图片大小，使用width属性设置图片的宽度

当图片无法加载时，使用alt属性进行文字提示代替图片显示，如，&lt;img src=&quot;www.your-image-source.com/your-image.jpg&quot;  alt=&quot;your alt text&quot;&gt;
</code></pre><p>7）设置元素边框</p>
<pre><code> 可以使用border-color: red;border-width: 5px;border-style: solid;这三种属性分别来设置，还可以合起来设置border:5px solid red;

 对于矩形边框，为了使其美观，可以使用border-radius属性来设置边框外形，

例如border-radius：10px;，得到的效果如图所示，设置出来是边角半径为10px的一个边框；border-radius：50%;使用百分比来设置边框半径的值，效果如图
</code></pre><p>8）a标签</p>
<pre><code>用于链接地址&lt;a href=&quot; 链接地址&quot; &gt;链接显示名称&lt;/a&gt;   a可以放在段落中间，即可以进行嵌套，如，&lt;p&gt;Here&apos;s a &lt;a href=&quot;链接地址&quot;&gt; 链接显示名称 &lt;/a&gt; 段落文本&lt;/p&gt;

如果想为你的网站添加一个a元素，但此时你还不知道要将它们链接到哪儿，此时可以使用固定链接，即将href后的链接改为“#”，将其变为一个固定链接。

可以通过把某元素嵌套进a元素使其变成一个链接，如&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;/images/relaxing-cat.jpg&quot;&gt;&lt;/a&gt;，当点击图片时鼠标将变为手型。
</code></pre><p> 9）无序列表ul</p>
<pre><code>无序列表以&lt;ul&gt;元素开始，并包含一个或多个&lt;li&gt;元素。

如&lt;ul&gt;

     &lt;li&gt;milk&lt;/li&gt;

     &lt;li&gt;fish&lt;/li&gt;

         ``````

  &lt;/ul&gt;
</code></pre><p>10）有序列表ol</p>
<pre><code>和ul类似
</code></pre><p>11）表单form1   </p>
<pre><code>Text input(文本输入框)是用来获得用户输入的绝佳方式。

可以创建为：&lt;input type=&quot;text&quot;&gt; 注意，input元素是自关闭的

占位符(placeholder text)是用户在input(输入)框输入任何东西之前放置在input(输入)框中的预定义文本。如，&lt;input type=&quot;text&quot; placeholder=&quot;this is placeholder text&quot;&gt;

使用HTML来构建可以跟服务器交互的Web表单(form)，通过给form元素添加一个action属性来达到此目的，action属性的值指定了表单提交到服务器的地址，

如&lt;form action=&quot;/url-where-you-want-to-submit-form-data&quot;&gt;&lt;/form&gt;

为form添加一个submit(提交)按钮，点击这个按钮，表单中的数据将会被发送到通过action属性指定的地址上。如，&lt;button type=&quot;submit&quot;&gt;this button submits the form&lt;/button&gt;

整个的一个表单如下，实现效果如图具体代码如下:

&lt;form action=&quot;/submit-cat-photo&quot;&gt;
&lt;input type=&quot;text&quot; placeholder=&quot;cat photo URL&quot;&gt;
&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code></pre><p>12）表单form2     </p>
<pre><code>当设计表单时，可以指定某些选项为必填项(required)，只有当用户填写了该选项后，用户才能够提交表单。

例如，如果你想把一个文本输入字段设置为必填项，在你的input元素中加上required属性就可以了，你可以使用：&lt;input type=&quot;text&quot; required&gt;
</code></pre><p>13）单选按钮radio button</p>
<pre><code>单选按钮只是input输入框的一种类型，每一个单选按钮都应该嵌套在它自己的label(标签)元素中。

注意：所有关联的单选按钮应该使用相同的name属性。

如：&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;indoor-outdoor&quot;&gt;indoor&lt;/label&gt;

     &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;indoor-outdoor&quot;&gt;outdoor&lt;/label&gt; 
</code></pre><p> 14）复选按钮checkboxes</p>
<pre><code>复选按钮是input的输入框的另一种类型，每一个复选按钮都应该嵌套进label元素中。和单选按钮类似，所有关联的复选按钮应该具有相同的name属性。      

如： &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;personality&quot;&gt;Loving&lt;/label&gt;
     &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;personality&quot;&gt;outgoing&lt;/label&gt;
     &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;personality&quot;&gt;shy&lt;/label&gt;

使用checked属性，你可以设置复选按钮和单选按钮默认被选中。如&lt;input type=&quot;radio&quot; name=&quot;test-name&quot; checked&gt;
</code></pre><p>15）div和background</p>
<pre><code>div元素，也被称作division(层)元素，是一个盛装其他元素的通用容器       background-color 属性来设置一个元素的背景颜色，如：.green-background {background-color: green;}
</code></pre><p>16）基本选择器</p>
<pre><code>通配选择器 选择文档中所有HTML元素

元素选择器 选择指定类型的HTML元素

类选择器    选择指定class属性值为“class”的任意类型的任意多个元素   定义类选择器必须添加 . 为前缀

ID选择器   选择指定ID属性值为“id”的任意类型元素   id 属性应该是唯一的 定义ID选择器必须添加 # 为前缀，id 属性具有更高的优先级。

群组选择器 将每一个选择器匹配的元素集合并

类选择器后面设置的样式可以覆盖前面设置的样式，ID选择器样式可以覆盖类选择器设置的样式，行内样式设置可以覆盖类选择器和ID选择器设置的样式

如果需要某个样式不被覆盖，可以使用！important，如，color: pink !important;
</code></pre><p>17）HTML元素布局</p>
<pre><code>padding（内边距）控制元素内容 content和元素边框 border 之间的距离，CSS 允许你使用 padding-top、padding-right、padding-bottom 和 padding-left来控制元素上右下左四个方向的 padding。

padding: 10px 20px 10px 20px;这四个值以顺时针方式排列：顶部、右侧、底部、左侧，简称：上右下左。

如果上下相同，左右相同，则可以写成padding: 10px 20px；如果上下左右均相同，则可以写为padding:20px;

margin（外边距） 控制元素边框 border 和元素实际所占空间的距离，将一个元素的 margin 设置为负值，元素将会变大。简写类似padding

border（边框）简写为border:5px solid red;
</code></pre><p>18）颜色表示</p>
<pre><code>英语

16进制。16进制用6位数表示，前2位代表R红色，0最小，F最大，中间2位代表G绿色，最后2位代表B，蓝色，如#00FF00，代表纯绿色，可以简写为#0F0。

RGB值。 background-color: rgb(0,0,0);  表示纯黑。
</code></pre><p>这几天初步入门了html和css<br>推荐初学者在这个网站直接练习<br><a href="https://www.w3cschool.cn/codecamp/list?pename=html5_and_css_camp" target="_blank" rel="noopener">https://www.w3cschool.cn/codecamp/list?pename=html5_and_css_camp</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>html学习笔记（一）</title>
    <url>/2018/05/13/html/</url>
    <content><![CDATA[<p>html 决定页面放什么东西</p>
<h2 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a>HTML 图像</h2><p>使用 <img> 标签定义 HTML 页面中的图像。<img> 标签有两个必需的属性：src 和 alt。<br><a id="more"></a></p>
<h3 id="src属性"><a href="#src属性" class="headerlink" title="src属性"></a>src属性</h3><p><img> 是空标签，意思是说，它只包含属性，并且没有闭合标签。</p>
<p>要在页面上显示图像，你需要使用源属性（src）。src 指 “source”。源属性的值是图像的 URL 地址。</p>
<p>定义图像的语法是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;url&quot; alt=&quot;some_text&quot;&gt;</span><br><span class="line">URL 指存储图像的位置。如果名为 &quot;boat.gif&quot; 的图像位于 www.w3cschool.cn 的 images 目录中，那么其 URL 为 //www.w3cschool.cn/images/boat.gif。</span><br></pre></td></tr></table></figure></p>
<p>浏览器将图像显示在文档中图像标签出现的地方。如果你将图像标签置于两个段落之间，那么浏览器会首先显示第一个段落，然后显示图片，最后显示第二段。</p>
<h3 id="alt属性"><a href="#alt属性" class="headerlink" title="alt属性"></a>alt属性</h3><p>alt 属性， 是当图片无法显示时的替代文本。alt 属性对于盲人或视觉障碍的用户理解图片中的内容非常重要，搜索引擎也会搜索alt 属性来了解图片的内容。</p>
<p>总而言之，alt 属性是一个必需的属性，为页面上的图片都加上 alt 属性是好习惯。</p>
<h2 id="HTML-链接"><a href="#HTML-链接" class="headerlink" title="HTML 链接"></a>HTML 链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;W3Cschool教程(w3cschool.cn)&lt;/title&gt; </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;链接文字&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;http://www.w3cschool.cn/&quot; target=&quot;&quot;&gt;访问W3Cschool教程!&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;如果你将 target 属性设置为 &quot;_blank&quot;, 链接将在新窗口打开。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="HTML-空链接"><a href="#HTML-空链接" class="headerlink" title="HTML 空链接"></a>HTML 空链接</h3><p>HTML 空链接：指指向链接后，鼠标变成手形，但单击后仍停留在当前页面。</p>
<p>临时加的空链接，主要为了能更好的看到最终的效果。</p>
<p>基本语法：</p>
<p><a href="#">链接文字</a><br>其中“ # ”表示空链接。</p>
<p>实例</p>
<p><a href="#">W3CSchool</a></p>
<h3 id="HTML-链接语法"><a href="#HTML-链接语法" class="headerlink" title="HTML 链接语法"></a>HTML 链接语法</h3><p>链接的 HTML 代码很简单。它类似这样：:     </p>
<p><a href="url">Link text</a><br>href 属性描述了链接的目标。.</p>
<p>Example<br><a href="//www.w3cschool.cn/">Visit W3CSchool</a><br>上面这行代码显示为：: Visit W3CSchool</p>
<p>点击这个超链接会把用户带到 W3CSchool 的首页。</p>
<p>提示: “链接文本” 不必一定是文本。图片或其他 HTML 元素都可以成为链接。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;www.your-image-source.com/your-image.jpg&quot; alt=&quot;your alt text&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>HTML 使用#符合设置固定链接<br>有时你想要在你的网站上添加一个 a 元素，但你还不知道将它链接到哪里，这时你可以使用固定连接。</p>
<p>当你使用 jQuery 更改链接的行为时，这也很方便，我们稍后将会了解。</p>
<p>把 a 元素的 href 属性的值替换为一个 # （# 也称为哈希符号），将其转换为一个固定链接。</p>
<h3 id="HTML-链接-target-属性"><a href="#HTML-链接-target-属性" class="headerlink" title="HTML 链接 - target 属性"></a>HTML 链接 - target 属性</h3><p>默认的被链接文档会在原有的窗口中打开的。如果将 target 属性设置为 “_blank” 则文档就会在新窗口打开。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;//www.w3cschool.cn/&quot; target=&quot;_blank&quot;&gt;访问W3CSchool教程!&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="HTML-链接-id-属性"><a href="#HTML-链接-id-属性" class="headerlink" title="HTML 链接 - id 属性"></a>HTML 链接 - id 属性</h3>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html标签</title>
    <url>/2018/12/29/html%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>HTML5  标签<br>comment 注释标签用于在源文档中插入注释。注释内容不会被浏览器显示。为代码编写注释的好处是，有助于增强代码的可读性。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTML5 &lt;!DOCTYPE&gt; 标签</span><br><span class="line">!DOCTYPE 文档声明必须位于 HTML5 文档中的第一行，也就是位于 html 标签之前。该标签告知浏览器文档所使用的 HTML 规范。</span><br><span class="line">HTML5 &lt;a&gt; 标签</span><br><span class="line">html5 a 标签定义超链接，用于从一个页面链接到另一个页面。a 标签最重要的属性是 href 属性，它指定链接的目标 url 。</span><br><span class="line">HTML5 &lt;abbr&gt; 标签</span><br><span class="line">abbr 标签最初是在 HTML 4.0 中引入的，表示它所包含的文本是一个更长的单词或短语的缩写形式。</span><br><span class="line">HTML5 &lt;address&gt; 标签</span><br><span class="line">address 标签定义文档作者或拥有者的联系信息。通常的做法是将 address 元素添加到网页的头部或底部。</span><br><span class="line">HTML5 &lt;applet&gt; 标签</span><br><span class="line">定义和用法 applet 定义嵌入的 applet。 HTML 5 中不支持 applet 标签 请使用 object 标签代替它。</span><br><span class="line">HTML5 &lt;acronym&gt; 标签</span><br><span class="line">定义和用法 HTML 5 不支持 acronym 标签。 请使用 abbr 标签代替它。 在 HTML 4.01 中，acronym 标签定义首字母缩略词。 如果首字母缩略词是一个单词，则可以被读出来，例如 NATO、NASA、ASAP、GUI。</span><br><span class="line">HTML5 &lt;area&gt; 标签</span><br><span class="line">area 元素始终嵌套在 map 标签内部。area 标签定义图像映射内部的区域（图像映射指的是带有可点击区域的图像）。</span><br><span class="line">HTML5 &lt;article&gt; 标签</span><br><span class="line">article 标签是 HTML 5 的新标签, article 标签的内容独立于文档的其余部分。</span><br><span class="line">HTML5 &lt;aside&gt; 标签</span><br><span class="line">html5 aside 标签定义其所处内容之外的内容。aside 标签的内容应该与附近的内容相关。</span><br><span class="line">HTML5 &lt;audio&gt; 标签</span><br><span class="line">audio 标签是 HTML 5 的新标签, audio 标签想网页中插入声音，比如音乐或其他音频流。</span><br><span class="line">HTML5 &lt;b&gt; 标签</span><br><span class="line">html5 b 标签定义粗体的文本。b 标签用于强调某些文本。如果您希望把文本标记为相比其他文本更为重要，应该使用 strong 标签。</span><br><span class="line">HTML5 &lt;base&gt; 标签</span><br><span class="line">base 标签为页面上的所有链接规定默认地址或默认目标。base 标签必须位于 head 元素内部。</span><br><span class="line">HTML5 &lt;basefont&gt; 标签</span><br><span class="line">HTML5 中不支持 basefont 标签。请用 CSS 代替。</span><br><span class="line">HTML5 &lt;bdi&gt; 标签</span><br><span class="line">bdi 标签是 HTML5 中的新标签。bdi 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。</span><br><span class="line">HTML5 &lt;bdo&gt; 标签</span><br><span class="line">bdo 标签覆盖默认的文本方向。通过设置 dir 属性来设置文本的显示方向。</span><br><span class="line">HTML5 &lt;big&gt; 标签</span><br><span class="line">HTML5 中不支持 big 标签。请用 CSS 代替</span><br><span class="line">HTML5 &lt;blockquote&gt; 标签</span><br><span class="line">blockquote 标签之间的所有文本都会从常规文本中分离出来，经常会在左、右两边进行缩进，而且有时会使用斜体。</span><br><span class="line">HTML5 &lt;body&gt; 标签</span><br><span class="line">body 标签定义文档的主体。 body 标签包含文档的所有内容，比如文本、超链接、图像、表格、列表等。在 HTML 5 中，删除了所有 的特殊属性。</span><br><span class="line">HTML5  标签</span><br><span class="line">br 标签插入简单的换行符。br 标签是一个空标签，意味着它没有结束标签。br 标签常用来输出空行</span><br><span class="line">HTML5 &lt;button&gt; 标签</span><br><span class="line">button 标签定义按钮。您可以在 button 标签内放置内容，比如文本或图像。但是在 form 中通常使用 input 标签创建按钮。</span><br><span class="line">HTML5 &lt;canvas&gt; 标签</span><br><span class="line">html5 canvas 标签定义图形，比如图表和其他图像。canvas 标签只是图形容器，您必须使用脚本来绘制图形。</span><br><span class="line">HTML5 &lt;caption&gt; 标签</span><br><span class="line">caption 标签定义表格的标题。caption 标签必须直接放置到 table 标签之后。通常标题会居中显示在表格上方。</span><br><span class="line">HTML5 &lt;center&gt; 标签</span><br><span class="line">HTML5 中不支持该 center 标签。请使用 CSS 代替。</span><br><span class="line">HTML5 &lt;cite&gt; 标签</span><br><span class="line">cite 标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题，通常斜体显示。</span><br><span class="line">HTML5 &lt;code&gt; 标签</span><br><span class="line">em,strong,dfn,code,samp,kbd,var,cite 标签常用来格式话文本，使用 css 样式表可以显示更丰富的效果。</span><br><span class="line">HTML5 &lt;col&gt; 标签</span><br><span class="line">col 标签为表格中的一个或多个列定义属性值。通过使用 col 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。</span><br><span class="line">HTML5 &lt;colgroup&gt; 标签</span><br><span class="line">通过使用 colgroup 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。只能在 table 元素内使用 colgroup 标签。</span><br><span class="line">HTML5 &lt;command&gt; 标签</span><br><span class="line">command 元素表示用户能够调用的命令。可以用它规定键盘快捷键。只有当 command 元素位于 menu 元素内时，该元素才是可见的。</span><br><span class="line">HTML5 &lt;datalist&gt; 标签</span><br><span class="line">datalist 标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。</span><br><span class="line">HTML5 &lt;dd&gt; 标签</span><br><span class="line">dd 标签定义一个定义列表中对项目的描述。dt 标签定义列表中的项目，而 dd&gt; 标签描述这些项目。</span><br><span class="line">HTML5 &lt;del&gt; 标签</span><br><span class="line">del 标签定义文档中已删除的文本。与 ins 标签一起使用，描述文档中的更新和修正。</span><br><span class="line">HTML5 &lt;details&gt; 标签</span><br><span class="line">details 标签是 HTML 5 中的新标签。details 标签用于描述文档或文档某个部分的细节。目前只有 Chrome 支持 details 标签。</span><br><span class="line">HTML5 &lt;dfn&gt; 标签</span><br><span class="line">HTML5 &lt;dir&gt; 标签</span><br><span class="line">HTML5 中不支持 dir 标签。请用 CSS 代替。</span><br><span class="line">HTML5 &lt;div&gt; 标签</span><br><span class="line">div 标签常用于组合块级元素，以便通过样式表来对这些元素进行格式化。通常使用 div + css 对网页进行布局。</span><br><span class="line">HTML5 &lt;dl&gt; 标签</span><br><span class="line">dl 标签定义一个定义列表。dl 标签内部使用 dd 和 dt 定义列表中的项目。</span><br><span class="line">HTML5 &lt;dt&gt; 标签</span><br><span class="line">dt 标签定义一个定义列表中的一个项目。dd 标签描述这些项目。</span><br><span class="line">HTML5 &lt;em&gt; 标签</span><br><span class="line">HTML5 &lt;embed&gt; 标签</span><br><span class="line">embed 标签是 HTML 5 中的新标签。embed 标签定义嵌入的内容，比如插件。</span><br><span class="line">HTML5 &lt;fieldset&gt; 标签</span><br><span class="line">fieldset 标签会在相关表单元素周围绘制边框。fieldset 标签会在相关表单元素周围绘制边框。</span><br><span class="line">HTML5 &lt;figcaption&gt; 标签</span><br><span class="line">figcaption 标签是 HTML 5 中的新标签。figcaption 标签定义 figure 元素的标题（caption）。</span><br><span class="line">HTML5 &lt;figure&gt; 标签</span><br><span class="line">figure 标签是 HTML 5 中的新标签。figure 标签规定独立的流内容（图像、图表、照片、代码等等）。</span><br><span class="line">HTML5 &lt;font&gt; 标签</span><br><span class="line">定义和用法 在 HTML 5 中，不支持 font 标签。请用 CSS 代替它。 font 标签规定文本的字体、大小和颜色。</span><br><span class="line">HTML5 &lt;footer&gt; 标签</span><br><span class="line">footer 标签是 HTML 5 中的新标签。footer 标签定义 section 或 document 的页脚。</span><br><span class="line">HTML5 &lt;form&gt; 标签</span><br><span class="line">form 标签标签用于创建供用户输入的 HTML 表单。form 标签包含多个表单元素，如：button,input,keygen,object,output,select,textarea</span><br><span class="line">HTML5 &lt;frame&gt; 标签</span><br><span class="line">定义和用法 在 HTML 5 中不支持 frame 标签。 frame 标签定义框架集中的子窗口（框架）。 由于该标签对网页可用性的负面影响，在 HTML 5 中 frame 和 frameset 标签没有得到支持。</span><br><span class="line">HTML5 &lt;frameset&gt; 标签</span><br><span class="line">定义和用法 在 HTML 5 中不支持 frameset 标签。 frameset 标签定义框架集。它用于组织多个窗口（框架）。 由于该标签对网页可用性的负面影响，在 HTML 5 中 frame 和 frameset 标签没有得到支持。</span><br><span class="line">HTML5 &lt;h1 - h6&gt; 标签</span><br><span class="line">h1,h2,h3,h4,h5,h6 标签用来定义文档中的标题。h1 定义最大的标题。h6 定义最小的标题。</span><br><span class="line">HTML5 &lt;head&gt; 标签</span><br><span class="line">head 标签是所有头部元素的容器。位于 head 内部的元素可以包含 title,base,link,meta,script,style等。</span><br><span class="line">HTML5 &lt;header&gt; 标签</span><br><span class="line">header 标签是 HTML 5 中的新标签。header 标签定义文档的页眉（介绍信息）。</span><br><span class="line">HTML5 &lt;hgroup&gt; 标签</span><br><span class="line">hgroup 标签是 HTML 5 中的新标签。hgroup 标签用于对网页或区段（section）的标题进行组合。</span><br><span class="line">HTML5  标签</span><br><span class="line">在 HTML 5 中，hr 标签定义内容中的主题变化，并显示为一条水平线。在 HTML 4.01 中，hr 标签仅仅显示为一条水平线。</span><br><span class="line">HTML5 &lt;html&gt; 标签</span><br><span class="line">html 标签告知浏览器这是一个 HTML 文档。html 元素是 HTML 文档中最外层的根元素。</span><br><span class="line">HTML5 &lt;i&gt; 标签</span><br><span class="line">i 标签定义的文本在 html 文档中呈现为斜体，以便与文档中其余部分区别开来。</span><br><span class="line">HTML5 &lt;iframe&gt; 标签</span><br><span class="line">iframe 标签创建包含另一个文档的行内框架。在 HTML 5 中，仅仅支持 src 属性。</span><br><span class="line">HTML5 &lt;img&gt; 标签</span><br><span class="line">img 标签定义 HTML 页面中的图像。img 标签定义 HTML 页面中的图像。img 标签定义 HTML 页面中的图像。</span><br><span class="line">HTML5 &lt;input&gt; 标签</span><br><span class="line">input 标签规定 form 表单中用户可输入数据的输入字段。根据不同的 type 属性，输入字段可以是文本字段、复选框、密码字段、单选按钮、按钮等。</span><br><span class="line">HTML5 &lt;ins&gt; 标签</span><br><span class="line">ins 标签定义文档的其余部分之外的插入文本。通常能够与 del 标签一起使用，来描述对文档的更新和修正。</span><br><span class="line">HTML5 &lt;keygen&gt; 标签</span><br><span class="line">keygen 是 HTML5 中的新元素。keygen 标签规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。</span><br><span class="line">HTML5 &lt;kbd&gt; 标签</span><br><span class="line">HTML5 &lt;label&gt; 标签</span><br><span class="line">label 标签为 input 元素定义文字标识，label 标签的 for 属性应该等于相关元素的 id 元素，以便将它们捆绑起来。</span><br><span class="line">HTML5 &lt;legend&gt; 标签</span><br><span class="line">legend 元素为以下元素定义标题（caption）：fieldset、figure、details 。 legend 元素为以下元素定义标题（caption）：fieldset、figure&gt;、details。</span><br><span class="line">HTML5 &lt;li&gt; 标签</span><br><span class="line">li 标签定义列表项，有序列表 ol 和无序列表 ul 中都使用 li 标签。 HTML 5 中，li 标签不再支持 type 属性。</span><br><span class="line">HTML5 &lt;link&gt; 标签</span><br><span class="line">link 标签定义文档与外部资源之间的关系。link 标签大多数时候都用来连接 css 样式表。link 标签只能位于head 标签中。</span><br><span class="line">HTML5 &lt;map&gt; 标签</span><br><span class="line">map 标签用于定义图像中可点击的热点区域。map 标签的 name 属性与 img 标签的 usemap 属性相关联，以创建图像与映射之间的关系</span><br><span class="line">HTML5 &lt;mark&gt; 标签</span><br><span class="line">mark 标签是 HTML 5 中的新标签。mark 标签定义带有记号的文本。请在需要突出显示文本时使用 mark 标签。</span><br><span class="line">HTML5 &lt;menu&gt; 标签</span><br><span class="line">menu 标签定义菜单列表。当希望列出表单控件时使用该标签。在 HTML 5 中，重新定义了 menu 元素，且使用用于排列表单控件。</span><br><span class="line">HTML5 &lt;meta&gt; 标签</span><br><span class="line">meta 标签位于文档的头部 head 标签中，meta 标签的属性用来定义有关页面的元信息，比如 字符集，关键词，描述，重定向等。</span><br><span class="line">HTML5 &lt;meter&gt; 标签</span><br><span class="line">meter 标签是 HTML 5 中的新标签。meter 标签定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。</span><br><span class="line">HTML5 &lt;nav&gt; 标签</span><br><span class="line">nav 标签是 HTML 5 中的新标签。nav 标签定义导航链接的部分。</span><br><span class="line">HTML5 &lt;noframes&gt; 标签</span><br><span class="line">定义和用法 在 HTML 5 中不支持 noframes 标签。 noframes 标签向浏览器显示无法处理框架的提示文本。</span><br><span class="line">HTML5 &lt;noscript&gt; 标签</span><br><span class="line">noscript 元素用来定义在脚本未被执行时的替代内容（文本）。此标签用于可识别 script 标签但无法支持其中脚本的浏览器。</span><br><span class="line">HTML5 &lt;object&gt; 标签</span><br><span class="line">object 定义一个嵌入的对象。请使用此元素向您的 HTML5 页面添加多媒体。</span><br><span class="line">HTML5 &lt;ol&gt; 标签</span><br><span class="line">ol 标签定义有序列表。在 HTML 5 中，不再支持 compact 和 type 这两个属性</span><br><span class="line">HTML5 &lt;optgroup&gt; 标签</span><br><span class="line">optgroup 标签定义选项组。此元素允许您组合选项。当您使用一个长的选项列表时，对相关的选项进行组合会使处理更加容易。</span><br><span class="line">HTML5 &lt;option&gt; 标签</span><br><span class="line">option 标签定义下拉列表中的一个选项。在 HTML 5 中，option 标签也用于新元素 datalist 中。</span><br><span class="line">HTML5 &lt;output&gt; 标签</span><br><span class="line">output 标签是 HTML 5 中的新标签。output 标签定义不同类型的输出，比如脚本的输出。</span><br><span class="line">HTML5 &lt;p&gt; 标签</span><br><span class="line">p 标签定义段落。在 HTML 5 中不再支持 p 标签的 align 属性。</span><br><span class="line">HTML5 &lt;param&gt; 标签</span><br><span class="line">param 标签允许您为插入 XHTML 文档的对象规定 run-time 设置，也就是说，此标签可为包含它的 object 标签提供参数。</span><br><span class="line">HTML5 &lt;pre&gt; 标签</span><br><span class="line">pre 标签可定义预格式化的文本。pre 标签的一个常见应用就是用来表示计算机的源代码。</span><br><span class="line">HTML5 &lt;progress&gt; 标签</span><br><span class="line">progress 标签是 HTML 5 中的新标签。progress 标签定义运行中的进度（进程）。</span><br><span class="line">HTML5 &lt;q&gt; 标签</span><br><span class="line">q 标签定义一个短的引用。浏览器经常会在这种引用的周围插入引号。</span><br><span class="line">HTML5 &lt;rp&gt; 标签</span><br><span class="line">rp 标签是 HTML 5 的新标签。rp 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。</span><br><span class="line">HTML5 &lt;ruby&gt; 标签</span><br><span class="line">ruby 标签是 HTML 5 的新标签。ruby 标签定义 ruby 注释（中文注音或字符）。</span><br><span class="line">HTML5 &lt;s&gt; 标签</span><br><span class="line">s 标签定义加删除线的文本。HTML 5 中不再支持 s 标签。</span><br><span class="line">HTML5 &lt;samp&gt; 标签</span><br><span class="line">HTML5 &lt;script&gt; 标签</span><br><span class="line">script 标签用于定义客户端脚本，比如 JavaScript。script 元素既可包含脚本语句，也可以通过 src 属性指向外部脚本文件。</span><br><span class="line">HTML5 &lt;select&gt; 标签</span><br><span class="line">select 标签创建下拉列表。请在 form 元素中使用此标签来接受用户的输入</span><br><span class="line">HTML5 &lt;small&gt; 标签</span><br><span class="line">在 HTML5 中，small 元素定义旁注信息，并显示为更小的文本。对于由 em 元素强调过的或由 strong 元素标记为重要的文本，small 元素不会取消对文本的强调，也不会降低这些文本的重要性。</span><br><span class="line">HTML5 &lt;source&gt; 标签</span><br><span class="line">source 标签是 HTML 5 中的新标签。source 标签为媒介元素（比如 video 和 audio）定义媒介资源。</span><br><span class="line">HTML5 &lt;span&gt; 标签</span><br><span class="line">span 标签用于对文档中的行内元素进行组合,以便通过样式表 css 对它们进行格式化。</span><br><span class="line">HTML5 &lt;strike&gt; 标签</span><br><span class="line">定义和用法 在 HTML 5 中不支持 strike 标签。请使用 CSS 代替。 strike 标签定义加删除线的文本。请使用 del 标签代替。</span><br><span class="line">HTML5 &lt;strong&gt; 标签</span><br><span class="line">HTML5 &lt;style&gt; 标签</span><br><span class="line">style 标签定义 HTML 文档的样式信息。scoped 属性是 HTML 5 中的新属性，它允许我们为文档的指定部分定义样式，而不是整个文档。</span><br><span class="line">HTML5  标签</span><br><span class="line">sub 标签可定义下标文本。sup 可定义上标文本。</span><br><span class="line">HTML5 &lt;summary&gt; 标签</span><br><span class="line">summary 标签是 HTML 5 中的新标签。是 details 元素的第一个子元素，定义 details 元素的标题。</span><br><span class="line">HTML5  标签</span><br><span class="line">HTML5 &lt;table&gt; 标签</span><br><span class="line">table 标签定义 HTML 表格。一个简单的 HTML 表格包括 table 元素，一个或多个 tr、th 以及 td 元素。</span><br><span class="line">HTML5 &lt;tbody&gt; 标签</span><br><span class="line">使用 tbody 标签，可以将表格分为一个单独的部分。tbody 标签可将表格中的一行或几行合成一组。在 HTML 5 中，不支持 tbody 标签的任何属性。</span><br><span class="line">HTML5 &lt;td&gt; 标签</span><br><span class="line">td 标签定义 HTML 表格中的标准单元格。thead 元素中只能使用 th 标签按，不允许使用 td 标签。</span><br><span class="line">HTML5 &lt;textarea&gt; 标签</span><br><span class="line">textarea 定义一个多行的文本输入区域。文本区中的默认字体是等宽字体 (fixed pitch)。</span><br><span class="line">HTML5 &lt;tfoot&gt; 标签</span><br><span class="line">tfoot 定义表格的页脚（脚注），tfoot 内部必须拥有 tr 标签！tfoot 表亲必须位于 table 标签内。</span><br><span class="line">HTML5 &lt;th&gt; 标签</span><br><span class="line">th 标签定义 HTML 表格中的表头单元格。th 元素中的文本呈现为粗体并且居中。th 标签在 tr 标签中定义。</span><br><span class="line">HTML5 &lt;thead&gt; 标签</span><br><span class="line">thead 标签在 table 标签中使用，定义表格的表头。thead 内部必须拥有 tr 标签！</span><br><span class="line">HTML5 &lt;time&gt; 标签</span><br><span class="line">time 标签是 HTML 5 中的新标签。time 标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。</span><br><span class="line">HTML5 &lt;title&gt; 标签</span><br><span class="line">title 位于 head 部分，用来定义文档的标题。title 元素在所有 HTML 文档中是必需且唯一的。</span><br><span class="line">HTML5 &lt;tr&gt; 标签</span><br><span class="line">tr 标签定义表格中的行，一个 tr 元素包含一个或多个 td 或 th 标签。</span><br><span class="line">HTML5 &lt;track&gt; 标签</span><br><span class="line">track 标签是 HTML 5 中的新标签。track 标签为诸如 video 元素之类的媒介规定外部字幕文件或其他包含的文版文件。</span><br><span class="line">HTML5 &lt;tt&gt; 标签</span><br><span class="line">定义和用法 在 HTML 5 中不支持 tt 标签。 tt 标签定义打字机文本。</span><br><span class="line">HTML5 &lt;u&gt; 标签</span><br><span class="line">在 HTML 5 中不支持 u 标签</span><br><span class="line">HTML5 &lt;ul&gt; 标签</span><br><span class="line">ul 标签定义无序列表。请使用 CSS 来定义列表的显示样式。</span><br><span class="line">HTML5 &lt;var&gt; 标签</span><br><span class="line">HTML5 &lt;video&gt; 标签</span><br><span class="line">video 标签是 HTML 5 的新标签。video 标签定义视频，比如电影片段或其他视频流。</span><br><span class="line">HTML5 &lt;wbr&gt; 标签</span><br><span class="line">wbr 标签是 HTML 5 中的新标签。wbr 规定在文本中的何处适合添加换行符。</span><br><span class="line">HTML5 &lt;rt&gt; 标签</span><br><span class="line">定义和用法 rt 标签定义字符（中文注音或字符）的解释或发音。 ruby 注释是中文注音或字符。 在东亚使用，显示的是东亚字符的发音。 与 ruby 以及 rt 标签一同使用： ruby 元素由一个或多个字符（需要一个解释/发音）和一个提供该信息的 rt 元素组成，还包括可选的 rp 元素，定义当浏览器不支持 ruby 元素时显示的内容。 实例 一个 ruby 注释： ruby漢 rt ㄏㄢˋ /rt/ruby HTML 4.01 与 HTML 5 之间的差异 rt 标签是 HTML 5 的新标</span><br><span class="line">HTML5 &lt;section&gt; 标签</span><br><span class="line">section 标签是 HTML 5 中的新标签。section 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>input中的value和placeholder</title>
    <url>/2018/12/31/input%E4%B8%AD%E7%9A%84value%E5%92%8Cplaceholder%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="input中value和placeholder区别"><a href="#input中value和placeholder区别" class="headerlink" title="input中value和placeholder区别"></a>input中value和placeholder区别</h2><p>placeholder 属性提供可描述输入字段预期值的提示信息（hint）。<br>该提示会在输入字段为空时显示，并会在字段获得焦点时消失。<br>注释：placeholder 属性适用于以下的 <input> 类型：text, search, url, telephone, email 以及 password。</p>
<a id="more"></a>
<p>value 属性为 input 元素设定值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于不同的输入类型，value 属性的用法也不同：</span><br><span class="line">type=&quot;button&quot;, &quot;reset&quot;, &quot;submit&quot; - 定义按钮上的显示的文本</span><br><span class="line">type=&quot;text&quot;, &quot;password&quot;, &quot;hidden&quot; - 定义输入字段的初始值</span><br><span class="line">type=&quot;checkbox&quot;, &quot;radio&quot;, &quot;image&quot; - 定义与输入相关联的值</span><br><span class="line"></span><br><span class="line">注释：&lt;input type=&quot;checkbox&quot;&gt; 和 &lt;input type=&quot;radio&quot;&gt; 中必须设置 value 属性。</span><br></pre></td></tr></table></figure></p>
<p>注意<br>placeholder在input中只是充当占位符的角色，在你input框中的value为空的时候它才会显示出来，但是它本身并不是value，也不会被表单提交。</p>
<p>value<br>如果用的是value，我们想鼠标focus后默认文字消失，移开后默认文字又重现，可以这样来写。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;请输入手机号&quot; class=&quot;inp-fon&quot;&gt;</span><br><span class="line">$(&quot;.inp-fon&quot;).focus(function()&#123;</span><br><span class="line">          var oldValue = $(this).val();</span><br><span class="line">          if(oldValue == this.defaultValue)&#123;</span><br><span class="line">              $(this).val(&quot;&quot;).addClass(&apos;focus-fon&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).blur(function()&#123;</span><br><span class="line">          var oldValue = $(this).val();</span><br><span class="line">          if(oldValue == &quot;&quot;)&#123;</span><br><span class="line">               $(this).val(this.defaultValue).removeClass(&apos;focus-fon&apos;);;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></p>
<p>默认状态是灰色的，然后focus后，输入的字体会变成黑色的，上面的JS里就是通过添加和删除样式“focus-fon”来控制的。</p>
<h2 id="修改输入框placeholder默认颜色"><a href="#修改输入框placeholder默认颜色" class="headerlink" title="修改输入框placeholder默认颜色"></a>修改输入框placeholder默认颜色</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input::placeholder&#123;/* 去掉私有前缀，谷歌和火狐有效；IE和edge无效 */</span><br><span class="line">     color: orchid;</span><br><span class="line">     opacity:1;</span><br><span class="line">     font-size: 15px;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>参考博客<br><a href="https://blog.csdn.net/xufeiayang/article/details/52786167" target="_blank" rel="noopener">https://blog.csdn.net/xufeiayang/article/details/52786167</a><br><a href="https://blog.csdn.net/tashanhongye/article/details/76423081" target="_blank" rel="noopener">https://blog.csdn.net/tashanhongye/article/details/76423081</a><br><a href="https://blog.csdn.net/J080624/article/details/79312870" target="_blank" rel="noopener">https://blog.csdn.net/J080624/article/details/79312870</a></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 547. Friend Circles</title>
    <url>/2018/12/03/j/</url>
    <content><![CDATA[<p>There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.<br><a id="more"></a><br>Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p>
<p>Example 1:</p>
<p>Input: </p>
<p>[[1,1,0],</p>
<p>[1,1,0],</p>
<p>[0,0,1]]</p>
<p>Output: 2</p>
<p>Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. </p>
<p>The 2nd student himself is in a friend circle. So return 2.<br>Example 2:</p>
<p>Input: </p>
<p>[[1,1,0],</p>
<p>[1,1,1],</p>
<p>[0,1,1]]</p>
<p>Output: 1</p>
<p>Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, </p>
<p>so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.</p>
<p>Note:</p>
<p>N is in range [1,200].</p>
<p>M[i][i] = 1 for all students.</p>
<p>If M[i][j] = 1, then M[j][i] = 1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class unionset&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">    vector&lt;int&gt; rank;</span><br><span class="line">	</span><br><span class="line">    unionset(int n)&#123;</span><br><span class="line">    parent=vector&lt;int&gt;(n+1,0);</span><br><span class="line">    rank=vector&lt;int&gt;(n+1,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">	parent[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bool Union(int u1,int u2)&#123;</span><br><span class="line">		int p1=find(u1);</span><br><span class="line">		int p2=find(u2);</span><br><span class="line">		if(p1==p2) return false;</span><br><span class="line">		if(rank[p1]&gt;rank[p2])&#123;</span><br><span class="line">			parent[p2]=p1;</span><br><span class="line">		&#125;</span><br><span class="line">        else if(rank[p2]&gt;rank[p1])&#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">            rank[p2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    int find(int num)&#123;</span><br><span class="line">        if(num!=parent[num])&#123;</span><br><span class="line">            parent[num]=find(parent[num]);//find(num)一直自己调用自己 错的 find(parent[num]) 往上回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[num];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123;</span><br><span class="line">        int n=M.size();</span><br><span class="line">        unionset u(n);</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">                if(M[i][j]) u.Union(i,j);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;int&gt; s;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            s.insert(u.find(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>jQuery选择器</title>
    <url>/2018/05/26/jQuery%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<p>type选择器$(“button”)、class选择器$(“.btn”)、id选择器$(“#target1”)。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$(document).ready(function() &#123;</span><br><span class="line">$(&quot;button&quot;).addClass(&quot;animated&quot;);</span><br><span class="line">$(&quot;.btn&quot;).addClass(&quot;shake&quot;);</span><br><span class="line">$(&quot;#target1&quot;).addClass(&quot;btn-primary&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Only change code above this line. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class="line">&lt;h3 class=&quot;text-primary text-center&quot;&gt;jQuery Playground&lt;/h3&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-xs-6&quot;&gt;</span><br><span class="line">&lt;h4&gt;#left-well&lt;/h4&gt;</span><br><span class="line">&lt;div class=&quot;well&quot; id=&quot;left-well&quot;&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target1&quot;&gt;#target1&lt;/button&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target2&quot;&gt;#target2&lt;/button&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target3&quot;&gt;#target3&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;col-xs-6&quot;&gt;</span><br><span class="line">&lt;h4&gt;#right-well&lt;/h4&gt;</span><br><span class="line">&lt;div class=&quot;well&quot; id=&quot;right-well&quot;&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target4&quot;&gt;#target4&lt;/button&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target5&quot;&gt;#target5&lt;/button&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target6&quot;&gt;#target6&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document).ready(function() &#123;</span><br><span class="line">$(&quot;#target1&quot;).css(&quot;color&quot;, &quot;red&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$(document).ready(function() &#123;</span><br><span class="line">$(&quot;#target1&quot;).css(&quot;color&quot;, &quot;red&quot;);</span><br><span class="line">$(&quot;#target1&quot;).prop(&quot;disabled&quot;, true);</span><br><span class="line">$(&quot;#target4&quot;).remove();</span><br><span class="line">$(&quot;#target2&quot;).appendTo(&quot;#right-well&quot;);</span><br><span class="line">$(&quot;#target5&quot;).clone().appendTo(&quot;#left-well&quot;);</span><br><span class="line">$(&quot;#target1&quot;).parent().css(&quot;background-color&quot;, &quot;red&quot;);</span><br><span class="line">$(&quot;#right-well&quot;).children().css(&quot;color&quot;, &quot;orange&quot;);</span><br><span class="line">$(&quot;#left-well&quot;).children().css(&quot;color&quot;, &quot;green&quot;);</span><br><span class="line">$(&quot;.target:nth-child(2)&quot;).addClass(&quot;animated bounce&quot;);</span><br><span class="line">$(&quot;.target:even&quot;).addClass(&quot;animated shake&quot;);</span><br><span class="line">$(&quot;body&quot;).addClass(&quot;animated hinge&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Only change code above this line. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class="line">&lt;h3 class=&quot;text-primary text-center&quot;&gt;jQuery Playground&lt;/h3&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-xs-6&quot;&gt;</span><br><span class="line">&lt;h4&gt;#left-well&lt;/h4&gt;</span><br><span class="line">&lt;div class=&quot;well&quot; id=&quot;left-well&quot;&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target1&quot;&gt;#target1&lt;/button&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target2&quot;&gt;#target2&lt;/button&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target3&quot;&gt;#target3&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;col-xs-6&quot;&gt;</span><br><span class="line">&lt;h4&gt;#right-well&lt;/h4&gt;</span><br><span class="line">&lt;div class=&quot;well&quot; id=&quot;right-well&quot;&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target4&quot;&gt;#target4&lt;/button&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target5&quot;&gt;#target5&lt;/button&gt;</span><br><span class="line">&lt;button class=&quot;btn btn-default target&quot; id=&quot;target6&quot;&gt;#target6&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>java中List集合常用的操作</title>
    <url>/2018/05/11/java%E4%B8%ADList%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="list中添加，获取，删除元素"><a href="#list中添加，获取，删除元素" class="headerlink" title="list中添加，获取，删除元素"></a>list中添加，获取，删除元素</h2><p>添加方法是：.add(e)；</p>
<p>获取方法是：.get(index)；</p>
<p>删除方法是：.remove(index)；按照索引删除；<br>              .remove(Object o)； 按照元素内容删除；<br>  <a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; person=new ArrayList&lt;&gt;();</span><br><span class="line">            person.add(&quot;jackie&quot;);   //索引为0  //.add(e)</span><br><span class="line">            person.add(&quot;peter&quot;);    //索引为1</span><br><span class="line">            person.add(&quot;annie&quot;);    //索引为2</span><br><span class="line">            person.add(&quot;martin&quot;);   //索引为3</span><br><span class="line">            person.add(&quot;marry&quot;);    //索引为4</span><br><span class="line">             </span><br><span class="line">            person.remove(3);   //.remove(index)</span><br><span class="line">            person.remove(&quot;marry&quot;);     //.remove(Object o)</span><br><span class="line">             </span><br><span class="line">            String per=&quot;&quot;;</span><br><span class="line">            per=person.get(1);</span><br><span class="line">            System.out.println(per);    ////.get(index)</span><br><span class="line">             </span><br><span class="line">            for (int i = 0; i &lt; person.size(); i++) &#123;</span><br><span class="line">                System.out.println(person.get(i));  //.get(index)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="list中是否包含某个元素"><a href="#list中是否包含某个元素" class="headerlink" title="list中是否包含某个元素"></a>list中是否包含某个元素</h2><p>方法：.contains（Object o）； 返回true或者false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; fruits=new ArrayList&lt;&gt;();</span><br><span class="line">            fruits.add(&quot;苹果&quot;);</span><br><span class="line">            fruits.add(&quot;香蕉&quot;);</span><br><span class="line">            fruits.add(&quot;桃子&quot;);</span><br><span class="line">            //for循环遍历list</span><br><span class="line">            for (int i = 0; i &lt; fruits.size(); i++) &#123;</span><br><span class="line">                System.out.println(fruits.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            String appleString=&quot;苹果&quot;;</span><br><span class="line">            //true or false</span><br><span class="line">            System.out.println(&quot;fruits中是否包含苹果：&quot;+fruits.contains(appleString));</span><br><span class="line">             </span><br><span class="line">            if (fruits.contains(appleString)) &#123;</span><br><span class="line">                System.out.println(&quot;我喜欢吃苹果&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                System.out.println(&quot;我不开心&quot;);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h2 id="list中根据索引将元素数值改变-替换"><a href="#list中根据索引将元素数值改变-替换" class="headerlink" title="list中根据索引将元素数值改变(替换)"></a>list中根据索引将元素数值改变(替换)</h2><p>　　注意 .set(index, element); 和 .add(index, element); 的不同；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String a=&quot;白龙马&quot;, b=&quot;沙和尚&quot;, c=&quot;八戒&quot;, d=&quot;唐僧&quot;, e=&quot;悟空&quot;;</span><br><span class="line">            List&lt;String&gt; people=new ArrayList&lt;&gt;();</span><br><span class="line">            people.add(a);</span><br><span class="line">            people.add(b);</span><br><span class="line">            people.add(c);</span><br><span class="line">            people.set(0, d);   //.set(index, element);     //将d唐僧放到list中索引为0的位置，替换a白龙马</span><br><span class="line">            people.add(1, e);   //.add(index, element);     //将e悟空放到list中索引为1的位置,原来位置的b沙和尚后移一位</span><br><span class="line">             </span><br><span class="line">            //增强for循环遍历list</span><br><span class="line">            for(String str:people)&#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="list中查看（判断）元素的索引"><a href="#list中查看（判断）元素的索引" class="headerlink" title="list中查看（判断）元素的索引　　"></a>list中查看（判断）元素的索引　　</h2><p>　　注意：.indexOf（）； 和  lastIndexOf（）的不同；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names=new ArrayList&lt;&gt;();</span><br><span class="line">            names.add(&quot;刘备&quot;);    //索引为0</span><br><span class="line">            names.add(&quot;关羽&quot;);    //索引为1</span><br><span class="line">            names.add(&quot;张飞&quot;);    //索引为2</span><br><span class="line">            names.add(&quot;刘备&quot;);    //索引为3</span><br><span class="line">            names.add(&quot;张飞&quot;);    //索引为4</span><br><span class="line">            System.out.println(names.indexOf(&quot;刘备&quot;));</span><br><span class="line">            System.out.println(names.lastIndexOf(&quot;刘备&quot;));</span><br><span class="line">            System.out.println(names.indexOf(&quot;张飞&quot;));</span><br><span class="line">            System.out.println(names.lastIndexOf(&quot;张飞&quot;));</span><br></pre></td></tr></table></figure></p>
<h2 id="根据元素索引位置进行的判断"><a href="#根据元素索引位置进行的判断" class="headerlink" title="根据元素索引位置进行的判断"></a>根据元素索引位置进行的判断</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (names.indexOf(&quot;刘备&quot;)==0) &#123;</span><br><span class="line">    System.out.println(&quot;刘备在这里&quot;);</span><br><span class="line">&#125;else if (names.lastIndexOf(&quot;刘备&quot;)==3) &#123;</span><br><span class="line">    System.out.println(&quot;刘备在那里&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    System.out.println(&quot;刘备到底在哪里？&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用list中索引位置重新生成一个新的list（截取集合）"><a href="#利用list中索引位置重新生成一个新的list（截取集合）" class="headerlink" title="利用list中索引位置重新生成一个新的list（截取集合）"></a>利用list中索引位置重新生成一个新的list（截取集合）</h2><p>　　方法： .subList(fromIndex, toIndex)；　　.size() ； 该方法得到list中的元素数的和<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; phone=new ArrayList&lt;&gt;();</span><br><span class="line">            phone.add(&quot;三星&quot;);    //索引为0</span><br><span class="line">            phone.add(&quot;苹果&quot;);    //索引为1</span><br><span class="line">            phone.add(&quot;锤子&quot;);    //索引为2</span><br><span class="line">            phone.add(&quot;华为&quot;);    //索引为3</span><br><span class="line">            phone.add(&quot;小米&quot;);    //索引为4</span><br><span class="line">            //原list进行遍历</span><br><span class="line">            for(String pho:phone)&#123;</span><br><span class="line">                System.out.println(pho);</span><br><span class="line">            &#125;</span><br><span class="line">            //生成新list</span><br><span class="line">            phone=phone.subList(1, 4);  //.subList(fromIndex, toIndex)     </span><br><span class="line">            //利用索引1-4的对象重新生成一个list，但是不包含索引为4的元素，4-1=3</span><br><span class="line">            for (int i = 0; i &lt; phone.size(); i++) &#123; // phone.size() 该方法得到list中的元素数的和</span><br><span class="line">                System.out.println(&quot;新的list包含的元素是&quot;+phone.get(i));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对比两个list中的所有元"><a href="#对比两个list中的所有元" class="headerlink" title="对比两个list中的所有元"></a>对比两个list中的所有元</h2><p>　　//两个相等对象的equals方法一定为true, 但两个hashcode相等的对象不一定是相等的对象<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.if (person.equals(fruits)) &#123;</span></span><br><span class="line">    System.out.println(<span class="string">"两个list中的所有元素相同"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"两个list中的所有元素不一样"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.       </span></span><br><span class="line"><span class="keyword">if</span> (person.hashCode()==fruits.hashCode()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"我们相同"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"我们不一样"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="判断list是否为空"><a href="#判断list是否为空" class="headerlink" title="判断list是否为空"></a>判断list是否为空</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　//空则返回true，非空则返回false</span><br><span class="line"></span><br><span class="line">if (person.isEmpty()) &#123;</span><br><span class="line">    System.out.println(&quot;空的&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    System.out.println(&quot;不是空的&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回Iterator集合对象"><a href="#返回Iterator集合对象" class="headerlink" title="返回Iterator集合对象"></a>返回Iterator集合对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;返回Iterator集合对象:&quot;+person.iterator());</span><br></pre></td></tr></table></figure>
<h2 id="将集合转换为字符串"><a href="#将集合转换为字符串" class="headerlink" title="将集合转换为字符串"></a>将集合转换为字符串</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String liString=&quot;&quot;;</span><br><span class="line">liString=person.toString();</span><br><span class="line">System.out.println(&quot;将集合转换为字符串:&quot;+liString);</span><br></pre></td></tr></table></figure>
<h2 id="将集合转换为数组"><a href="#将集合转换为数组" class="headerlink" title="将集合转换为数组"></a>将集合转换为数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"将集合转换为数组:"</span>+person.toArray());</span><br></pre></td></tr></table></figure>
<h2 id="集合类型转换"><a href="#集合类型转换" class="headerlink" title="集合类型转换"></a>集合类型转换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.默认类型</span><br><span class="line">List&lt;Object&gt; listsStrings=new ArrayList&lt;&gt;();</span><br><span class="line">　　for (int i = 0; i &lt; person.size(); i++) &#123;</span><br><span class="line">    listsStrings.add(person.get(i));</span><br><span class="line">&#125;</span><br><span class="line">//2.指定类型</span><br><span class="line">List&lt;StringBuffer&gt; lst=new ArrayList&lt;&gt;();</span><br><span class="line">　　for(String string:person)&#123;</span><br><span class="line">　　lst.add(StringBuffer(string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="去重复"><a href="#去重复" class="headerlink" title="去重复"></a>去重复</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; lst1=new ArrayList&lt;&gt;();</span><br><span class="line">            lst1.add(&quot;aa&quot;);</span><br><span class="line">            lst1.add(&quot;dd&quot;);</span><br><span class="line">            lst1.add(&quot;ss&quot;);</span><br><span class="line">            lst1.add(&quot;aa&quot;);</span><br><span class="line">            lst1.add(&quot;ss&quot;);</span><br><span class="line"> </span><br><span class="line">//方法 1.</span><br><span class="line">            for (int i = 0; i &lt;lst1.size()-1; i++) &#123;</span><br><span class="line">                for (int j = lst1.size()-1; j &gt;i; j--) &#123;</span><br><span class="line">                    if (lst1.get(j).equals(lst1.get(i))) &#123;</span><br><span class="line">                        lst1.remove(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(lst1);</span><br><span class="line">             </span><br><span class="line">  //方法 2.</span><br><span class="line">            List&lt;String&gt; lst2=new ArrayList&lt;&gt;();</span><br><span class="line">            for (String s:lst1) &#123;</span><br><span class="line">                if (Collections.frequency(lst2, s)&lt;1) &#123;</span><br><span class="line">                    lst2.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(lst2);</span><br></pre></td></tr></table></figure>
<h2 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class ListTest01 &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">            //list中添加，获取，删除元素</span><br><span class="line">            List&lt;String&gt; person=new ArrayList&lt;&gt;();</span><br><span class="line">            person.add(&quot;jackie&quot;);   //索引为0  //.add(e)</span><br><span class="line">            person.add(&quot;peter&quot;);    //索引为1</span><br><span class="line">            person.add(&quot;annie&quot;);    //索引为2</span><br><span class="line">            person.add(&quot;martin&quot;);   //索引为3</span><br><span class="line">            person.add(&quot;marry&quot;);    //索引为4</span><br><span class="line">             </span><br><span class="line">            person.remove(3);   //.remove(index)</span><br><span class="line">            person.remove(&quot;marry&quot;);     //.remove(Object o)</span><br><span class="line">             </span><br><span class="line">            String per=&quot;&quot;;</span><br><span class="line">            per=person.get(1);</span><br><span class="line">            System.out.println(per);    ////.get(index)</span><br><span class="line">             </span><br><span class="line">            for (int i = 0; i &lt; person.size(); i++) &#123;</span><br><span class="line">                System.out.println(person.get(i));  //.get(index)</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">         </span><br><span class="line">            //list总是否包含某个元素</span><br><span class="line">            List&lt;String&gt; fruits=new ArrayList&lt;&gt;();</span><br><span class="line">            fruits.add(&quot;苹果&quot;);</span><br><span class="line">            fruits.add(&quot;香蕉&quot;);</span><br><span class="line">            fruits.add(&quot;桃子&quot;);</span><br><span class="line">            //for循环遍历list</span><br><span class="line">            for (int i = 0; i &lt; fruits.size(); i++) &#123;</span><br><span class="line">                System.out.println(fruits.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            String appleString=&quot;苹果&quot;;</span><br><span class="line">            //true or false</span><br><span class="line">            System.out.println(&quot;fruits中是否包含苹果：&quot;+fruits.contains(appleString));</span><br><span class="line">             </span><br><span class="line">            if (fruits.contains(appleString)) &#123;</span><br><span class="line">                System.out.println(&quot;我喜欢吃苹果&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                System.out.println(&quot;我不开心&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            //list中根据索引将元素数值改变(替换)</span><br><span class="line">            String a=&quot;白龙马&quot;, b=&quot;沙和尚&quot;, c=&quot;八戒&quot;, d=&quot;唐僧&quot;, e=&quot;悟空&quot;;</span><br><span class="line">            List&lt;String&gt; people=new ArrayList&lt;&gt;();</span><br><span class="line">            people.add(a);</span><br><span class="line">            people.add(b);</span><br><span class="line">            people.add(c);</span><br><span class="line">            people.set(0, d);   //.set(index, element)      //将d唐僧放到list中索引为0的位置，替换a白龙马</span><br><span class="line">            people.add(1, e);   //.add(index, element);     //将e悟空放到list中索引为1的位置,原来位置的b沙和尚后移一位</span><br><span class="line">             </span><br><span class="line">            //增强for循环遍历list</span><br><span class="line">            for(String str:people)&#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            //list中查看（判断）元素的索引</span><br><span class="line">            List&lt;String&gt; names=new ArrayList&lt;&gt;();</span><br><span class="line">            names.add(&quot;刘备&quot;);    //索引为0</span><br><span class="line">            names.add(&quot;关羽&quot;);    //索引为1</span><br><span class="line">            names.add(&quot;张飞&quot;);    //索引为2</span><br><span class="line">            names.add(&quot;刘备&quot;);    //索引为3</span><br><span class="line">            names.add(&quot;张飞&quot;);    //索引为4</span><br><span class="line">            System.out.println(names.indexOf(&quot;刘备&quot;));</span><br><span class="line">            System.out.println(names.lastIndexOf(&quot;刘备&quot;));</span><br><span class="line">            System.out.println(names.indexOf(&quot;张飞&quot;));</span><br><span class="line">            System.out.println(names.lastIndexOf(&quot;张飞&quot;));</span><br><span class="line">             </span><br><span class="line">            //根据元素索引位置进行的判断</span><br><span class="line">            if (names.indexOf(&quot;刘备&quot;)==0) &#123;</span><br><span class="line">                System.out.println(&quot;刘备在这里&quot;);</span><br><span class="line">            &#125;else if (names.lastIndexOf(&quot;刘备&quot;)==3) &#123;</span><br><span class="line">                System.out.println(&quot;刘备在那里&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                System.out.println(&quot;刘备到底在哪里？&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            //利用list中索引位置重新生成一个新的list（截取集合）</span><br><span class="line">            List&lt;String&gt; phone=new ArrayList&lt;&gt;();</span><br><span class="line">            phone.add(&quot;三星&quot;);    //索引为0</span><br><span class="line">            phone.add(&quot;苹果&quot;);    //索引为1</span><br><span class="line">            phone.add(&quot;锤子&quot;);    //索引为2</span><br><span class="line">            phone.add(&quot;华为&quot;);    //索引为3</span><br><span class="line">            phone.add(&quot;小米&quot;);    //索引为4</span><br><span class="line">            //原list进行遍历</span><br><span class="line">            for(String pho:phone)&#123;</span><br><span class="line">                System.out.println(pho);</span><br><span class="line">            &#125;</span><br><span class="line">            //生成新list</span><br><span class="line">            phone=phone.subList(1, 4);  //.subList(fromIndex, toIndex)      //利用索引1-4的对象重新生成一个list，但是不包含索引为4的元素，4-1=3</span><br><span class="line">            for (int i = 0; i &lt; phone.size(); i++) &#123; // phone.size() 该方法得到list中的元素数的和</span><br><span class="line">                System.out.println(&quot;新的list包含的元素是&quot;+phone.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            //对比两个list中的所有元素</span><br><span class="line">            //两个相等对象的equals方法一定为true, 但两个hashcode相等的对象不一定是相等的对象</span><br><span class="line">            if (person.equals(fruits)) &#123;</span><br><span class="line">                System.out.println(&quot;两个list中的所有元素相同&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                System.out.println(&quot;两个list中的所有元素不一样&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            if (person.hashCode()==fruits.hashCode()) &#123;</span><br><span class="line">                System.out.println(&quot;我们相同&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                System.out.println(&quot;我们不一样&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">            //判断list是否为空</span><br><span class="line">            //空则返回true，非空则返回false</span><br><span class="line">            if (person.isEmpty()) &#123;</span><br><span class="line">                System.out.println(&quot;空的&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                System.out.println(&quot;不是空的&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            //返回Iterator集合对象</span><br><span class="line">            System.out.println(&quot;返回Iterator集合对象:&quot;+person.iterator());</span><br><span class="line">             </span><br><span class="line">            //将集合转换为字符串</span><br><span class="line">            String liString=&quot;&quot;;</span><br><span class="line">            liString=person.toString();</span><br><span class="line">            System.out.println(&quot;将集合转换为字符串:&quot;+liString);</span><br><span class="line">             </span><br><span class="line">            //将集合转换为数组，默认类型</span><br><span class="line">            System.out.println(&quot;将集合转换为数组:&quot;+person.toArray());</span><br><span class="line">             </span><br><span class="line">            ////将集合转换为指定类型（友好的处理）</span><br><span class="line">            //1.默认类型</span><br><span class="line">            List&lt;Object&gt; listsStrings=new ArrayList&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt; person.size(); i++) &#123;</span><br><span class="line">                listsStrings.add(person.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            //2.指定类型</span><br><span class="line">            List&lt;StringBuffer&gt; lst=new ArrayList&lt;&gt;();</span><br><span class="line">            for(String string:person)&#123;</span><br><span class="line">                lst.add(StringBuffer(string));</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static StringBuffer StringBuffer(String string) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/epeter/p/5648026.html" target="_blank" rel="noopener">参考博客</a></p>
<p><a href="https://blog.csdn.net/u013956878/article/details/56670753" target="_blank" rel="noopener">java List<string>的初始化</string></a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>不能实例化类型list&lt;interval&gt;</title>
    <url>/2018/05/09/java%E6%8E%A5%E5%8F%A3%E4%B8%8D%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96-1/</url>
    <content><![CDATA[<h2 id="java接口可以实例化吗？"><a href="#java接口可以实例化吗？" class="headerlink" title="java接口可以实例化吗？"></a>java接口可以实例化吗？</h2><p>接口不可以实例化。但是接口对象可以指向它的实现类对象。<br>接口可以看做特殊的抽象类，只是所有的方法都是抽象方法（没有实现的方法），接口的方法都是默认public abstract的，<br>所以不能被实例化。<br>比如：<br>List Set Map都是接口<br>使用时先实现<br><a id="more"></a></p>
<p>List<string> list = new ArrayList&lt;&gt;();</string></p>
<p>有点类似于指针的感觉了。Factory接口可以用来代表实现它的类。比如：<br>public interface thing;<br>public class fruit implements thing;<br>thing something = new fruit();<br>这个something指的就是水果。</p>
<p>接口编程是为了实现多继承。</p>
<p>、、、、、、、、、、、、、、、、</p>
<p>以下转自：<a href="http://www.runoob.com/java/java-polymorphism.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-polymorphism.html</a></p>
<p>声明一个接口的变量（接口的引用）可以指向一个实现类（实现该接口的类）的实例，</p>
<p>但是该接口的变量不能使用实现类中有、接口中没有的方法（实现类中没有重写的方法、自添加的方法），比如：</p>
<p>public class InterfaceCat {<br>    public static void main(String[] args) {<br>      show(new Cat());  // 以 Cat 对象调用 show 方法<br>      show(new Dog());  // 以 Dog 对象调用 show 方法</p>
<pre><code>Animal a = new Cat();  // 向上转型  
</code></pre><p>//      a.eat();               // 调用的是 Cat 的 eat<br>//      Cat c = (Cat)a;        // 向下转型<br>//      c.work();        // 调用的是 Cat 的 catchMouse<br>      a.work();   //该处编译报错<br>  }  </p>
<pre><code>public static void show(Animal a)  {
  a.eat();  
    // 类型判断
    if (a instanceof Cat)  {  // 猫做的事情 
        Cat c = (Cat)a;  
        c.work();  
    } else if (a instanceof Dog) { // 狗做的事情 
        Dog c = (Dog)a;  
        c.work();  
    }  
}  
</code></pre><p>}</p>
<p>abstract class Animal {<br>    abstract void eat();<br>//    abstract void work();  // 抽象类（接口）中没有work方法</p>
<p>}  </p>
<p>class Cat extends Animal {<br>    public void eat() {<br>        System.out.println(“吃鱼”);<br>    }<br>    public void work() {<br>        System.out.println(“抓老鼠”);<br>    }<br>}  </p>
<p>class Dog extends Animal {<br>    public void eat() {<br>        System.out.println(“吃骨头”);<br>    }<br>    public void work() {<br>        System.out.println(“看家”);<br>    }<br>}</p>
<p>输出结果为：</p>
<p>吃鱼<br>抓老鼠<br>吃骨头<br>看家<br>吃鱼<br>抓老鼠</p>
<p>对于多态，可以总结以下几点：</p>
<p>一、使用父类类型的引用指向子类的对象；</p>
<p>二、该引用只能调用父类中定义的方法和变量；</p>
<p>三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）;</p>
<p>四、变量不能被重写（覆盖），”重写”的概念只针对方法，如果在子类中”重写”了父类中的变量，那么在编译时会报错。</p>
<h2 id="Java中的泛型"><a href="#Java中的泛型" class="headerlink" title="Java中的泛型"></a>Java中的泛型</h2><p>泛型就是参数化类型，就是所操作的数据类型被指定为一个参数，这种类型可以在类接口和方法中创建，分别称之为泛型类，泛型接口，泛型方法</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>就是一个或者多个具有类型变量的类；如下：<br> public class Pair<t>{<br>    private T first;<br>    private T second;<br>    public Pair(){<br>      first = null;<br>      second = null;<br>    }<br>    public void setFirst(T first){<br>      this.first =   first;<br>    }<br>    public void setSecond(T second){<br>      this.second = second<br>    }<br>    public T getFirst(){<br>        return this.first;<br>    }<br>    public T getSecond(){<br>        return Second;<br>    }<br>  }<br>Pair类引入了一个类型变量T，将其放在”&lt;&gt;”里面；并且将其放在类名的后面，泛型类也可以有多个类型变量；<br>可以将泛型类看做是普通类的工厂；</t></p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>带有类型参数的简单方法；<br>泛型方法可以定义在普通类里面也可以定义在泛型类里面；<br>所谓的泛型方法要么就是返回值是一个泛型，要么就是参数是泛型；<br>class ArrayAlg{<br>  public static <t> T getMiddle(T[] a){<br>    return a[a.length/2]<br>  }<br>}</t></p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>就是一个或者多个具有类型变量的接口<br>pulbic interface Collection<e> extends Iterable<e> {<br>Iterator<e> iterator();<br>}</e></e></e></p>
<h2 id="约束和局限性："><a href="#约束和局限性：" class="headerlink" title="约束和局限性："></a>约束和局限性：</h2><p>使用java中的泛型时需要考虑一些限制，大多是限制都是由于类型擦除引起的；</p>
<p><1>:不能用基本类型实例化类型参数<br>没有Pair<double>只有Pair<double></double></double></1></p>
<p><2>:运行时类查询只适用于原始类型<br>虚拟机中的对象总有一个特定的非泛型类型。因此所有的类型查询只产生原始类型。例如：<br>if(a instanceof Pair<string>)//ERROR</string></2></p>
<p><3>:不能创建参数化类型的数组：<br>Pair<string>[] table = new Pair<string>[10]//ERROR;<br>但是声明类型Pair<string>[]的变量仍是合法的；</string></string></string></3></p>
<p><4>:Varargs警告：<br>由于java布置池泛型类型的数组；当我们向一个参数个数可变的方法 传递一个泛型类型的实例：<br>eg:</4></p>
<p>public static <t> void addAll(Collection<t> coll,T…ts){<br>  for(T t:ts)coll.add(t);<br>}<br>实际上ts是一个数组，包含提供的所有实参。<br>Collection&lt;Pair<string>&gt; table = …;<br>Pair<string> pair1 = ….;<br>Pair<string> pair2 = ….;<br>Pair<string> pair3 = ….;<br>addAll(table,pair1,pair2);<br>为了调用这个方法，Java虚拟机必须建立一个Pair<string>数组；违反前面的规定；但是这种情况并不会报告错误仅仅会报告一个警告可以通过两种方式去消除它：<br>A:为addAll方法添加标注@SuppressWarning(“unchecked”).<br>B:@SafeVarargs直接标志addAll方法<br>@SafeVarags<br>public static <t> void addAll(Collection<t> coll,T…ts)</t></t></string></string></string></string></string></t></t></p>
<h5 id="不能实例化类型参数"><a href="#不能实例化类型参数" class="headerlink" title=":不能实例化类型参数"></a><5>:不能实例化类型参数</5></h5><p>new T(…)，new T[]或者T.class都是不允许的;<br>但是可以通过反射加上一定的API便可实现泛型的实例化；<br><code>`</code>java<br>  public static <t> Pair<t> makePair(Class<t> cl){<br>      try{<br>          return new Pair&lt;&gt;(cl.newIntance(),cl.newInstance())<br>      }catch(Exception e){<br>        return null;<br>      }<br>  }<br>Pair<string> p = Pair.makePair(String.class)<br>类型擦除会让这个方法永远构造Object[2]数组；<br>如果数组仅仅作为一个类的私有实例域，就可以将这个数组声明为Object[],并在获取元素时进行类型转换。例如ArrayList就是这样实现的；</string></t></t></t></p>
<p>Public class ArrayList<e>{<br>  Private Object[] elements;<br>  @SuppressWarning(‘unchecked’)<br>  public E get(int n){<br>      return (E) elements[n]}<br>   }<br>  Public void set(int n,E e){elements[n] = e};<br>  Public class ArrayList<e>{<br>       Private E[] elements;<br>       Public ArrayList(){<br>       Elements = (E[])new Object[10];//假像：类型擦除会使其无法差距<br>  }<br>}<br>编译时不会报错，但是当我们的程序执行时，当我们把Object[]引用赋值给T[]时就会报错；将会发生ClassCastException异常；<br>这种情况下我们可以利用反射：</e></e></p>
<p>Public static <t extends comparable> T[] minmax(T…a){<br>  T[] mm = (T[])Array.newInstance(a.getClass().getComponentType(),2)<br>}</t></p>
<p><6>泛型类的静态上下文中类型变量无效<br>不能在静态域或方法中引用类型变量（即泛型）；（即被static修饰的域或者方法）</6></p>
<p><7>:不能抛出或者捕获泛型类的实例<br>既不能抛出也不能捕获泛型类的实例对象。实际上，甚至泛型类扩展Throwable都是不合法的；T extends Exception(Throwable)<br>Catch字句中不能使用类型变量；catch（T e）Error;<br>PS：可以消除已检查异常的检查：<br>Java异常处理的一个基本原则：必须为所有的已检查异常提供一个处理器；不过可以利用泛型消除这个限制；<br>当你必须捕获run中所有的已检查异常，将其包装到未检查异常中，因为run方法声明为不抛出任何已检查异常；<br>不过在这里我么你没有选择这种“包装”我们只是抛出异常，并“哄骗浏览器”让它认为这不会一个已检查异常；<br>通过使用泛型类，擦除，和@SuppertWarning标注就可以消除java类型系统的部分限制</7></p>
<p><8>注意擦除后的冲突：<br>当泛型类型被擦除时，无法创建引发冲突的条件，如：<br>在某个泛型类中添加equals()方法，当我们给这个泛型类中间穿具体的类型时：<br>进过类型擦除之后equals(String o)方法变为equals(Object o);<br>所以此时从概念上讲：他有两个equals方法：<br>Boolean equals(String)<br>Boolean equals(Object)和Object.Equals(Object)方法冲突；<br>补救方法就是重命名引发错误的方法<br>另外一个原则：“想要支持擦除的转换，就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类”而这两个接口是同一个接口的不同参数化；<br>例如下面的代码就是非法的</8></p>
<p>Class Calendar implements Comparable<calendar>{…}<br>Class GregorianCalendar extends Calendar implements Comparable&lt; GregorianCalendar&gt;(Error)<br>GregorianCalendar会事先Comparable<calendar>和Comparable<gregoriancalendar><br>这是同一接口的不同参数化；这一限制和类型擦柱的关系不是十分明确；下列的非泛型的版本就是合法的；<br>原因：有可能与合成的桥方法产生冲突。实现了Comparable<x>的类可以获得一个桥方法；</x></gregoriancalendar></calendar></calendar></p>
<p>Public int comparaTo(Object other){<br>  return compareTo(X) other<br>};<br>对于不同类型的;不能有两个这样的方法；</p>
<p><9>泛型类型的继承规则：<br>例如：Employee和Manager。Pair<manager>和Pair<employee>之间没有任何关系；<br>无论S和T有什么关系，通常Pair<s>和Pair<t>之间都不会有什么联系；<br>继承泛型类<br>子类不是泛型类：需要给父类传递类型常量<br>当给父类传递的类型常量为String时，那么在父类中所有T都会被String替换！</t></s></employee></manager></9></p>
<p>子类是泛型类：可以给父类传递类型常量，也可以传递类型变量</p>
<p>参考自：<a href="https://www.jianshu.com/p/fa66f06b701b" target="_blank" rel="noopener">https://www.jianshu.com/p/fa66f06b701b</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的引用</title>
    <url>/2018/06/05/java%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>java中内存的分配方式有两种，一种是在堆中分配，一种是在堆栈中分配，所有new出来的对象都是在堆中分配的，函数中参数的传递是在栈中分配的。通常情况下堆的内存可以很大，比如32位操作系统中的虚拟内存都可以被堆所使用（当内存紧张的时候甚至硬盘都可以是堆的存储空间），而堆栈的内存分配是有限的。<br><a id="more"></a><br>这和c++中内存分配差不多。java中有几种基本类型如int,float,double，char,byte等，他们不是对象，除此之外一切都是对象，所有的对象都是在堆上分配的。但好像在C#中这些都有封装好的一些方法，应该算是对象。</p>
<p>java中对象数组是什么，和c++类似，是句柄数组或者叫指针数组，里面保存的是每个元素的地址。和c++中不同，java没有操作符重载和拷贝构造函数（如果不了解这些也没有关系），因此当创建对象或者对已经创建的对象赋值时（注意是对象，不是基本类型）：Object a=new Object 和Object a=b（b是Object的子类型或者同类型）时，进行的是对象地址的传递并复制。这就是所说的句柄的传递和赋值。</p>
<p>句柄里存储的就是对象的地址，句柄就是指针，只不过是你无法得到的地址,java就是通过这一点巧妙的将指针隐藏起来。当对象作为参数传递到方法中时，传递的就是对象的地址，而行参中保存的是实参地址的副本（这就是最关键的地方,也是值传递,值传递就是将实参的值的副本作为行参）</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line"></span><br><span class="line">int i=0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">public class A&#123;</span><br><span class="line"></span><br><span class="line">public int i=0;</span><br><span class="line"></span><br><span class="line">public Example add0(Example e)&#123;</span><br><span class="line"></span><br><span class="line">e.i++;</span><br><span class="line"></span><br><span class="line">return e;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add1(Example e)&#123;</span><br><span class="line"></span><br><span class="line">e.i++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void modify0(Example e)&#123;</span><br><span class="line"></span><br><span class="line">Example b=e;//将e行参对象的地址赋给句柄b</span><br><span class="line"></span><br><span class="line">b.i++;//也同时修改了e.i和实参的值</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void modify1(Example e)&#123;</span><br><span class="line"></span><br><span class="line">e=new Example();</span><br><span class="line"></span><br><span class="line">e.i++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">Example ex=new Example();</span><br><span class="line"></span><br><span class="line">A a=new A();</span><br><span class="line"></span><br><span class="line">a=a.add0(ex);//等价于a.add0(ex)，无需返回值，因为通过传递的对象地址（句柄），直接修改了ex中i的值</span><br><span class="line"></span><br><span class="line">a.add1(ex);//add0，add1都在其中的方法体中直接修改了ex.i的值,因此add0的返回值有点多余</span><br><span class="line"></span><br><span class="line">a.modify0(ex);//对ex所产生的影响同add1</span><br><span class="line"></span><br><span class="line">a.modify1(ex);//对ex没有产生任何影响（而且这就是等价于什么也没有做）.</span><br><span class="line"></span><br><span class="line">//这可能会让一部分人搞不清了。为什么呢？因为是对象地址的副本&quot;值传递&quot;，在modify1中e=new Example();实际上e仅仅是保存ex对象地址的副本的一个句柄，当对e赋值时仅仅是对堆栈中e的赋值（对ex指针副本的变量e赋值），而并没有改变ex的句柄的指向，当方法调用完毕堆栈弹出，e就将要被垃圾回收，没有任何用处。当然你可以将它作为返回值，这就是另外一回事了。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你能明白这个原理，可以避免一些潜在的逻辑错误，如：对象在方法中被改动了，记住c++在这一点上和java有很大的不同，c++默认的是值传递，行参会按照位复制实参（如果用指针或者引用就和java很类似了），在方法中作为参数传递对象，java更象是c++中传递引用，当然还是有区别的，那就是c++中对象的引用不可再赋值为另一个对象。</p>
<p>参考自<a href="https://www.cnblogs.com/gameoverit/p/5178844.html" target="_blank" rel="noopener">https://www.cnblogs.com/gameoverit/p/5178844.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>201709-3 JSON查询</title>
    <url>/2018/12/11/json%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>问题描述<br>　　JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式，可以用来描述半结构化的数据。JSON 格式中的基本单元是值 (value)，出于简化的目的本题只涉及 2 种类型的值：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 字符串 (string)：字符串是由双引号 &quot; 括起来的一组字符（可以为空）。如果字符串的内容中出现双引号 &quot;，在双引号前面加反斜杠，也就是用 \&quot; 表示；如果出现反斜杠 \，则用两个反斜杠 \\ 表示。反斜杠后面不能出现 &quot; 和 \ 以外的字符。例如：&quot;&quot;、&quot;hello&quot;、&quot;\&quot;\\&quot;。</span><br><span class="line"></span><br><span class="line">* 对象 (object)：对象是一组键值对的无序集合（可以为空）。键值对表示对象的属性，键是属性名，值是属性的内容。对象以左花括号 &#123; 开始，右花括号 &#125; 结束，键值对之间以逗号 , 分隔。一个键值对的键和值之间以冒号 : 分隔。键必须是字符串，同一个对象所有键值对的键必须两两都不相同；值可以是字符串，也可以是另一个对象。例如：&#123;&#125;、&#123;&quot;foo&quot;: &quot;bar&quot;&#125;、&#123;&quot;Mon&quot;: &quot;weekday&quot;, &quot;Tue&quot;: &quot;weekday&quot;, &quot;Sun&quot;: &quot;weekend&quot;&#125;。</span><br></pre></td></tr></table></figure></p>
<p>　　除了字符串内部的位置，其他位置都可以插入一个或多个空格使得 JSON 的呈现更加美观，也可以在一些地方换行，不会影响所表示的数据内容。例如，上面举例的最后一个 JSON 数据也可以写成如下形式。</p>
<p>　　{<br>　<br> “Mon”: “weekday”,</p>
<p>“Tue”: “weekday”,</p>
<p>“Sun”: “weekend”</p>
<p>}</p>
<p>　　给出一个 JSON 格式描述的数据，以及若干查询，编程返回这些查询的结果。</p>
<p>输入格式</p>
<p>第一行是两个正整数 n 和 m，分别表示 JSON 数据的行数和查询的个数。</p>
<p>接下来 n 行，描述一个 JSON 数据，保证输入是一个合法的 JSON 对象。</p>
<p>接下来 m 行，每行描述一个查询。给出要查询的属性名，要求返回对应属性的内容。需要支持多层查询，各层的属性名之间用小数点 . 连接。保证查询的格式都是合法的。</p>
<p>输出格式</p>
<p>对于输入的每一个查询，按顺序输出查询结果，每个结果占一行。</p>
<p>如果查询结果是一个字符串，则输出 STRING <string>，其中 <string> 是字符串的值，中间用一个空格分隔。</string></string></p>
<p>如果查询结果是一个对象，则输出 OBJECT，不需要输出对象的内容。</p>
<p>如果查询结果不存在，则输出 NOTEXIST。</p>
<p>样例输入</p>
<p>10 5</p>
<p>{</p>
<p>“firstName”: “John”,</p>
<p>“lastName”: “Smith”,</p>
<p>“address”: {</p>
<p>“streetAddress”: “2ndStreet”,</p>
<p>“city”: “NewYork”,</p>
<p>“state”: “NY”</p>
<p>},</p>
<p>“esc\aped”: “\”hello\””</p>
<p>}</p>
<p>firstName</p>
<p>address</p>
<p>address.city</p>
<p>address.postal</p>
<p>esc\aped</p>
<p>样例输出</p>
<p>STRING John</p>
<p>OBJECT</p>
<p>STRING NewYork</p>
<p>NOTEXIST</p>
<p>STRING “hello”</p>
<p>评测用例规模与约定</p>
<p>　　n ≤ 100，每行不超过 80 个字符。</p>
<p>　　m ≤ 100，每个查询的长度不超过 80 个字符。</p>
<p>　　字符串中的字符均为 ASCII 码 33-126 的可打印字符，不会出现空格。所有字符串都不是空串。</p>
<p>　　所有作为键的字符串不会包含小数点 .。查询时键的大小写敏感。</p>
<p>　　50%的评测用例输入的对象只有 1 层结构，80%的评测用例输入的对象结构层数不超过 2 层。举例来说，{“a”: “b”} 是一层结构的对象，{“a”: {“b”: “c”}} 是二层结构的对象，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">map&lt;string,string&gt; dict;</span><br><span class="line">string parseS(string s,int &amp;i)&#123;</span><br><span class="line">string res=””;</span><br><span class="line">if(s[i]!=’”‘) assert(0);</span><br><span class="line">else i++;</span><br><span class="line">while(i&lt;s.size())&#123;</span><br><span class="line">if(s[i]==’\‘) &#123;</span><br><span class="line">i++;</span><br><span class="line">res+=s[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[i]==’”‘)&#123;</span><br><span class="line">i++;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">res+=s[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">//!</span><br><span class="line">void parseO(string line,string prefix,int &amp;i)&#123;</span><br><span class="line">bool strType=false;</span><br><span class="line">string key,value;</span><br><span class="line">assert(line[0]==’&#123;‘);</span><br><span class="line">if(line[i]==’&#123;‘) i++;</span><br><span class="line">while(i&lt;line.size())&#123;</span><br><span class="line">if(line[i]==’”‘)&#123;</span><br><span class="line">if(!strType)</span><br><span class="line">key=((prefix==””)?””:prefix+”.”)+parseS(line,i);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">value=parseS(line,i);</span><br><span class="line">dict[key]=value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else if(line[i]==&apos;,&apos;)&#123;</span><br><span class="line">        strType=false;</span><br><span class="line">        i++    ;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(line[i]==&apos;:&apos;)&#123;</span><br><span class="line">        strType=true;</span><br><span class="line">        i++    ;</span><br><span class="line">    &#125;        </span><br><span class="line">    else if(line[i]==&apos;&#123;&apos;)&#123;</span><br><span class="line">        dict[key]=&quot;&quot;;</span><br><span class="line">        parseO(line,key,i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else if(line[i]==&apos;&#125;&apos;)&#123;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">string res,line;</span><br><span class="line">int n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">getchar();</span><br><span class="line">// 或者if(cin.peek()==’\n’) cin.ignore();</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">getline(cin,line);</span><br><span class="line">res+=line;</span><br><span class="line">&#125;</span><br><span class="line">int k=0;</span><br><span class="line">string pre=””;</span><br><span class="line">parseO(res,pre,k);</span><br><span class="line">string qu;</span><br><span class="line">for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">getline(cin, qu);</span><br><span class="line">if(dict.count(qu)) &#123;</span><br><span class="line">if(dict[qu]!=””)</span><br><span class="line">cout&lt;&lt;”STRING “&lt;&lt;dict[qu]&lt;&lt;endl;</span><br><span class="line">else</span><br><span class="line">cout&lt;&lt;”OBJECT”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;”NOTEXIST”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复习代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;string,string&gt; dict;</span><br><span class="line">int n,m;</span><br><span class="line">string  parseS(string s,int &amp;i)&#123;</span><br><span class="line">	string rs=&quot;&quot;;</span><br><span class="line">	assert(s[i]==&apos;\&quot;&apos;);</span><br><span class="line">	i++;</span><br><span class="line">	while(i&lt;s.size())&#123;</span><br><span class="line">		if(s[i]==&apos;\\&apos;)&#123;</span><br><span class="line">			i++;</span><br><span class="line">			rs+=s[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	if(s[i]==&apos;&quot;&apos;) break;</span><br><span class="line">		else &#123;</span><br><span class="line">			rs+=s[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//!!</span><br><span class="line">	if(s[i]==&apos;\&quot;&apos;) i++;</span><br><span class="line">	return rs;</span><br><span class="line">&#125;</span><br><span class="line">void parseO(string s,string pre,int &amp;i)&#123;</span><br><span class="line">	bool type=false;</span><br><span class="line">	string key,value;</span><br><span class="line">	if(s[i]==&apos;&#123;&apos;) i++;</span><br><span class="line">	while(i&lt;s.size())&#123;</span><br><span class="line">	//	cout&lt;&lt;s[i]&lt;&lt;endl;</span><br><span class="line">		if(s[i]==&apos;&quot;&apos;)&#123;</span><br><span class="line">			//cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">			</span><br><span class="line">			if(!type)&#123;</span><br><span class="line">				</span><br><span class="line">				string t=parseS(s,i);</span><br><span class="line">				if(pre!=&quot;&quot;)</span><br><span class="line">				key=pre+&quot;.&quot;+t;</span><br><span class="line">				else</span><br><span class="line">				key=t;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">			</span><br><span class="line">				string value=parseS(s,i);</span><br><span class="line">				</span><br><span class="line">				dict[key]=value;</span><br><span class="line">				</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s[i]==&apos;:&apos;)&#123;</span><br><span class="line">			type=true;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;	</span><br><span class="line">		else if(s[i]==&apos;,&apos;)&#123;</span><br><span class="line">			type=false;</span><br><span class="line">			i++;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if(s[i]==&apos;&#123;&apos;)&#123;</span><br><span class="line">			dict[key]=&quot;&quot;;</span><br><span class="line">		</span><br><span class="line">			parseO(s,key,i);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s[i]==&apos;&#125;&apos;)&#123;</span><br><span class="line">			i++;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		else i++;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	string ss;</span><br><span class="line">	string rs=&quot;&quot;;</span><br><span class="line">	//把换行号读进来 </span><br><span class="line">//getchar();</span><br><span class="line">if(cin.peek()==&apos;\n&apos;) cin.ignore();</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		getline(cin,ss);</span><br><span class="line">		rs+=ss;</span><br><span class="line">&#125;</span><br><span class="line">	int i=0;</span><br><span class="line">	parseO(rs,&quot;&quot;,i);</span><br><span class="line">	string qu;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;qu; </span><br><span class="line">	//	getline(cin,qu);</span><br><span class="line">		if(dict.count(qu)) &#123;</span><br><span class="line">			if(dict[qu]==&quot;&quot;) cout&lt;&lt;&quot;OBJECT&quot;&lt;&lt;endl;</span><br><span class="line">			else cout&lt;&lt;&quot;STRING&quot;&lt;&lt;&quot; &quot;&lt;&lt;dict[qu]&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else cout&lt;&lt;&quot;NOTEXIST&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.5日又写了一遍<br>json是一个递归数据结构，因此可以使用函数的递归调用来进行解析。</p>
<p>每一类数据对应一个解析函数，代码中parseString实现解析字符串的功能，parseObject实现解析对象的功能。</p>
<p>解析函数的主体功能就是依次遍历每一个字符，根据字符判断是否是字符串的开始、对象的开始……并进行相应的处理。</p>
<p>json是一个键值对的结构，因此可以用map存储。map的键可以用查询的格式，用小数点.来分隔多层的键。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;string,string&gt; dict;</span><br><span class="line">string parseS(string s,int &amp;i)&#123;</span><br><span class="line">	string ans=&quot;&quot;;</span><br><span class="line">	if(s[i]==&apos;\&quot;&apos;) i++;</span><br><span class="line">	else return &quot;&quot;;</span><br><span class="line">	while(i&lt;s.size())&#123;</span><br><span class="line">		if(s[i]==&apos;\\&apos;)&#123;</span><br><span class="line">			i++;</span><br><span class="line">			ans+=s[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125; </span><br><span class="line">		else if(s[i]==&apos;\&quot;&apos;) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			ans+=s[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	//	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">void parseO(string res,string pre,int &amp;i)&#123;</span><br><span class="line">	bool stype=false;</span><br><span class="line">	if(res[i]==&apos;&#123;&apos;) i++;</span><br><span class="line">		string key;</span><br><span class="line">	while(i&lt;res.length())&#123;</span><br><span class="line">		if(res[i]==&apos;\&quot;&apos;) &#123;</span><br><span class="line">			if(!stype)&#123;</span><br><span class="line">				string tar=parseS(res,i);</span><br><span class="line">				 key=(pre==&quot;&quot;)?tar:pre+&quot;.&quot;+tar;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				dict[key]=parseS(res,i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(res[i]==&apos;:&apos;)&#123;</span><br><span class="line">			i++;</span><br><span class="line">			stype=true;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(res[i]==&apos;,&apos;)&#123;</span><br><span class="line">			i++;</span><br><span class="line">			stype=false;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(res[i]==&apos;&#123;&apos;)&#123;</span><br><span class="line">			dict[key]=&quot;&quot;;</span><br><span class="line">			parseO(res,key,i);</span><br><span class="line">				stype=false;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(res[i]==&apos;&#125;&apos;)&#123;</span><br><span class="line">			i++;</span><br><span class="line">			break;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		else i++; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	getchar();</span><br><span class="line">	string res=&quot;&quot;;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		string s;</span><br><span class="line">		getline(cin,s);</span><br><span class="line">		res+=s;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	string pre=&quot;&quot;;</span><br><span class="line">	int i=0;</span><br><span class="line">	parseO(res,&quot;&quot;,i);</span><br><span class="line">	while(m--)&#123;</span><br><span class="line">		string qu;</span><br><span class="line">		cin&gt;&gt;qu;</span><br><span class="line">		if(dict.count(qu)) &#123;</span><br><span class="line">			if(dict[qu]!=&quot;&quot;) cout&lt;&lt;&quot;STRING &quot;&lt;&lt;dict[qu]&lt;&lt;endl;</span><br><span class="line">			else cout&lt;&lt;&quot;OBJECT&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	else cout&lt;&lt;&quot;NOTEXIST&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">//测试parseS </span><br><span class="line">//	string s;</span><br><span class="line">//	getline(cin,s);</span><br><span class="line">//	int i=0;</span><br><span class="line">//	cout&lt;&lt;parseS(s,i);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>B1024/A1073 科学计数法</title>
    <url>/2019/03/17/kexue/</url>
    <content><![CDATA[<p>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9].[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。<br><a id="more"></a><br>现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。</p>
<p>输入格式：<br>每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。</p>
<p>输出格式：<br>对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入样例 1：</span><br><span class="line">+1.23400E-03</span><br><span class="line">输出样例 1：</span><br><span class="line">0.00123400</span><br><span class="line">输入样例 2：</span><br><span class="line">-1.2E+10</span><br><span class="line">输出样例 2：</span><br><span class="line">-12000000000</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt; </span><br><span class="line">#define MAXN 1000</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	string s;</span><br><span class="line">	getline(cin,s);</span><br><span class="line">	if(s[0]==&apos;-&apos;) cout&lt;&lt;&quot;-&quot;;</span><br><span class="line">	int pos=1;</span><br><span class="line">	while(s[pos]!=&apos;E&apos;) pos++;</span><br><span class="line">	int exp=0;</span><br><span class="line">	for(int j=pos+2;j&lt;s.length();j++)&#123;</span><br><span class="line">		exp=exp*10+(s[j]-&apos;0&apos;);</span><br><span class="line">	&#125; </span><br><span class="line">	if(exp==0)&#123;</span><br><span class="line">		for(int i=1;i&lt;pos;i++)</span><br><span class="line">		cout&lt;&lt;s[i];</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(s[pos+1]==&apos;+&apos;)&#123;</span><br><span class="line">		for(int i=1;i&lt;pos;i++)&#123;</span><br><span class="line">			if(s[i]==&apos;.&apos;) continue;</span><br><span class="line">			cout&lt;&lt;s[i];</span><br><span class="line">			if(i==2+exp&amp;&amp;pos-3!=exp)</span><br><span class="line">			cout&lt;&lt;&quot;.&quot;;</span><br><span class="line">		&#125;	</span><br><span class="line">		while(exp&gt;pos-3)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;0&quot;;</span><br><span class="line">			exp--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else if(s[pos+1]==&apos;-&apos;)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;0.&quot;;</span><br><span class="line">		for(int i=0;i&lt;exp-1;i++)</span><br><span class="line">		cout&lt;&lt;&quot;0&quot;;</span><br><span class="line">		for(int i=1;i&lt;pos;i++)</span><br><span class="line">		&#123;</span><br><span class="line">				if(s[i]==&apos;.&apos;) continue;</span><br><span class="line">					cout&lt;&lt;s[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp算法</title>
    <url>/2018/11/04/kmp%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>kmp 模式匹配<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int n,m;</span><br><span class="line">int prefix[100];</span><br><span class="line">using namespace std;</span><br><span class="line">void prefix_table(char patt[],int n)&#123;</span><br><span class="line">	prefix[0]=0;</span><br><span class="line">	int i=1;</span><br><span class="line">	int len=0;</span><br><span class="line">	while(i&lt;n)&#123;</span><br><span class="line">		</span><br><span class="line">		if(patt[i]==patt[len])</span><br><span class="line">		&#123;</span><br><span class="line">			len++;</span><br><span class="line">			prefix[i]=len;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if(len&gt;0)</span><br><span class="line">			len=prefix[len-1];</span><br><span class="line">			else&#123;</span><br><span class="line">				prefix[i]=len;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void move_prefix(int prefix[],int n)&#123;</span><br><span class="line">	for(int i=n-1;i&gt;0;i--) prefix[i]=prefix[i-1];</span><br><span class="line">	prefix[0]=-1;</span><br><span class="line">&#125;</span><br><span class="line">void kmp(char txt[],char patt[])&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	prefix_table(patt,n);</span><br><span class="line">	move_prefix(prefix,n);</span><br><span class="line">	int i=0,j=0;</span><br><span class="line">	m=strlen(txt);</span><br><span class="line"></span><br><span class="line">	while(i&lt;m)&#123;</span><br><span class="line">		if(j==n-1&amp;&amp;txt[i]==patt[j])//!!</span><br><span class="line">		&#123;</span><br><span class="line">		//	cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">		//	cout&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;&quot;Found at:&quot;&lt;&lt;i-j&lt;&lt;endl;</span><br><span class="line">			j=prefix[j];</span><br><span class="line">	//	cout&lt;&lt;&quot;j:&quot;&lt;&lt;j;</span><br><span class="line">		&#125;</span><br><span class="line">		if(txt[i]==patt[j])&#123;</span><br><span class="line">			i++;j++;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			j=prefix[j];</span><br><span class="line">			if(j==-1)&#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	char patt[100];</span><br><span class="line">	strcpy(patt,&quot;BABA&quot;);</span><br><span class="line">	n=strlen(patt); </span><br><span class="line">	char txt[100];</span><br><span class="line">	strcpy(txt,&quot;ABABABA&quot;);</span><br><span class="line">	kmp(txt,patt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fwwa4hda54j30ci05rq3l.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>历届试题 k好数</title>
    <url>/2019/03/13/k%E5%A5%BD%E6%95%B0/</url>
    <content><![CDATA[<p>问题描述<br>如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。<br><a id="more"></a><br>输入格式<br>输入包含两个正整数，K和L。</p>
<p>输出格式<br>输出一个整数，表示答案对1000000007取模后的值。<br>样例输入<br>4 2<br>样例输出<br>7<br>数据规模与约定<br>对于30%的数据，KL &lt;= 106；</p>
<p>对于50%的数据，K &lt;= 16， L &lt;= 10；</p>
<p>对于100%的数据，1 &lt;= K,L &lt;= 100。</p>
<p>就是要你求满足以下条件的序列的个数<br>1.有L个数<br>2.每个数在0到k的范围内<br>3.相邻的数差不等于一<br>4.第一个数不是0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 105</span><br><span class="line">int k,L;</span><br><span class="line">int mod=1000000007;</span><br><span class="line">int dp[MAX][MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;k&gt;&gt;L;</span><br><span class="line">	for(int j=0;j&lt;k;j++)</span><br><span class="line">	dp[1][j]=1;</span><br><span class="line">	 for(int l=2;l&lt;=L;l++)&#123;</span><br><span class="line">	 	for(int j=0;j&lt;k;j++)&#123;</span><br><span class="line">	 		for(int m=0;m&lt;k;m++)&#123;</span><br><span class="line">	 			if(m!=j-1&amp;&amp;m!=j+1)</span><br><span class="line">	 			dp[l][j]+=dp[l-1][m];</span><br><span class="line">	 			dp[l][j]%=mod;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 long sum=0;</span><br><span class="line">	for(int t=1;t&lt;k;t++)&#123;</span><br><span class="line">		sum+=dp[L][t];</span><br><span class="line">		sum%=mod;//!!!</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title> 蓝桥杯 k倍区间</title>
    <url>/2019/03/22/k%E5%80%8D%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>给定一个长度为N的数列，A1, A2, … AN，如果其中一段连续的子序列Ai, Ai+1, … Aj(i &lt;= j)之和是K的倍数，我们就称这个区间[i, j]是K倍区间。</p>
<p>你能求出数列中总共有多少个K倍区间吗？</p>
<p>输入<br>第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)<br>以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100000)</p>
<p>输出<br>输出一个整数，代表K倍区间的数目。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如， </span><br><span class="line">输入： </span><br><span class="line">5 2 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">程序应该输出： </span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗 &lt; 2000ms</p>
<p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p>
<p>注意：<br>main函数需要返回0;<br>只使用ANSI C/ANSI C++ 标准;<br>不要调用依赖于编译环境或操作系统的特殊函数。<br>所有依赖的函数必须明确地在源文件中 #include<br>不能通过工程设置而省略常用头文件。</p>
<p>提交程序时，注意选择所期望的语言类型和编译器类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 100000</span><br><span class="line">int n,k; </span><br><span class="line">int sum[MAX],num[MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;num[i];</span><br><span class="line">	</span><br><span class="line">	sum[0]=0 ;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		sum[i]=sum[i-1]+num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=i;j&lt;=n;j++)&#123;</span><br><span class="line">	//从I到j的连续子序列和 </span><br><span class="line">		if((sum[j]-sum[i-1])%k==0) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sum[1] = a1;<br>sum[2] = a1+a2;<br>sum[i] = a1+a2+…+ai;<br>对于任意一段区间[l,r]的和就是sum[r]-sum[l-1]. </p>
<p>一看是连续子序列求【i，j】区的问题就应该想到是前缀和的问题，sum[i] 表示是A1+A2+…..+Ai 的和，那么对于区间[i，j]之间的和就是sum[j]-sum[i-1]。要求是k的倍数，则（sum[j]-sum[i-1]）%k==0 转化为 sum[j]%k==sum[i-1]%k 所以在求前缀和的时候就可以进行求模运算，然后比如样例中得到的前缀和求完模后的结果为<br>1 1 0 0 1 那么下面就统计其中相同的数据，用数学角度分析的话 3个1 有3种组合<br>，2个0有一种组合，这是考虑的是相减的情况，然而本身其求模后为0也有两种情况，那么就是3+1+2=6 。数学角度转化就是转化成代码借用bk[]数组进行统计而已<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=10010;</span><br><span class="line">ll bk[maxn]=&#123;0&#125;;</span><br><span class="line">ll arr[maxn];</span><br><span class="line"></span><br><span class="line">ll n,k;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">       scanf(&quot;%lld&quot;,&amp;arr[i]);</span><br><span class="line">    arr[0]%=k;</span><br><span class="line">    ll sum=0;</span><br><span class="line">    for(int i=1;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       arr[i]=(arr[i]+arr[i-1])%k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=(bk[arr[i]]++);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;bk[0]&lt;&lt;&quot; &quot;&lt;&lt;bk[1]&lt;&lt;endl; </span><br><span class="line">    printf(&quot;%lld\n&quot;,sum+bk [0]);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="https://blog.csdn.net/w_x_s_h_h/article/details/79375081" target="_blank" rel="noopener">https://blog.csdn.net/w_x_s_h_h/article/details/79375081</a><br><a href="https://blog.csdn.net/za30312/article/details/69681146" target="_blank" rel="noopener">https://blog.csdn.net/za30312/article/details/69681146</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 210. Course Schedule II</title>
    <url>/2018/12/04/l/</url>
    <content><![CDATA[<p>There are a total of n courses you have to take, labeled from 0 to n-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.<br><a id="more"></a><br>Example 1:</p>
<p>Input: 2, [[1,0]] </p>
<p>Output: [0,1]</p>
<p>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   </p>
<p>course 0. So the correct course order is [0,1] .</p>
<p>Example 2:</p>
<p>Input: 4, [[1,0],[2,0],[3,1],[3,2]]</p>
<p>Output: [0,1,2,3] or [0,2,1,3]</p>
<p>Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both<br>             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.<br>             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .<br>Note:</p>
<p>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>
<p>拓扑排序 </p>
<p>递归退栈的时候 最先加入ans的是依赖条件最小的项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;g;</span><br><span class="line">    vector&lt;int&gt; vis;</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        g=vector&lt;vector&lt;int&gt; &gt;(numCourses);</span><br><span class="line">        vis=vector&lt;int&gt;(numCourses,0);</span><br><span class="line">        for(auto t:prerequisites)&#123;</span><br><span class="line">            g[t.second].push_back(t.first);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;numCourses;i++)&#123;</span><br><span class="line">            if(dfs(i)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(int cur)&#123;</span><br><span class="line">        if(vis[cur]==1) return true;</span><br><span class="line">        if(vis[cur]==2) return false;</span><br><span class="line">        vis[cur]=1;</span><br><span class="line">        for(int i=0;i&lt;g[cur].size();i++)&#123;</span><br><span class="line">            if(dfs(g[cur][i])) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[cur]=2;</span><br><span class="line">               return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode952. Largest Component Size by Common Factor</title>
    <url>/2018/12/06/large/</url>
    <content><![CDATA[<p>Given a non-empty array of unique positive integers A, consider the following graph:</p>
<p>There are A.length nodes, labelled A[0] to A[A.length - 1];<br>There is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.<br>Return the size of the largest connected component in the graph.<br><a id="more"></a></p>
<p>Example 1:</p>
<p>Input: [4,6,15,35]</p>
<p>Output: 4</p>
<p>Example 2:</p>
<p>Input: [20,50,9,63]</p>
<p>Output: 2</p>
<p>Example 3:</p>
<p>Input: [2,3,6,7,4,12,21,39]</p>
<p>Output: 8</p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 20000</p>
<p>1 &lt;= A[i] &lt;= 100000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class unionset&#123;</span><br><span class="line">    public:</span><br><span class="line">    vector&lt;int&gt; parents;</span><br><span class="line">    unionset(int n)&#123;</span><br><span class="line">        parents=vector&lt;int&gt;(n+1);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            parents[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    int find(int x)&#123;</span><br><span class="line">        if(x!=parents[x]) parents[x]=find(parents[x]);</span><br><span class="line">        return parents[x];</span><br><span class="line">    &#125;</span><br><span class="line">    bool Union(int a,int b)&#123;</span><br><span class="line">        int p1=find(a);</span><br><span class="line">        int p2=find(b);</span><br><span class="line">        if(p1==p2) return false;</span><br><span class="line">        parents[p1]=p2;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int largestComponentSize(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int n=*max_element(begin(A),end(A));</span><br><span class="line">       // cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">        unionset u(n);</span><br><span class="line">        for(int p:A)&#123;</span><br><span class="line">            int k=sqrt(p);</span><br><span class="line">            for(int j=2;j&lt;=k;j++)&#123;</span><br><span class="line">                if(p%j==0) &#123;</span><br><span class="line">                    u.Union(p,j);</span><br><span class="line">                    u.Union(p,p/j);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;int,int&gt; c;</span><br><span class="line">        int ans=1;</span><br><span class="line">        for(int k:A)&#123;</span><br><span class="line">           cout&lt;&lt;u.find(k)&lt;&lt;endl;</span><br><span class="line">          if(!c.count(u.find(k))) c[u.find(k)]=1;//!!</span><br><span class="line">            else ++c[u.find(k)];</span><br><span class="line">           ans=max(ans,c[u.find(k)]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 636. Exclusive Time of Functions</title>
    <url>/2018/12/01/le/</url>
    <content><![CDATA[<p>题目大意：给你一些函数的起始/终止时间的日志，让你输出每个函数的总运行时间。假设单核单线程，支持递归函数。<br><a id="more"></a><br>Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.</p>
<p>Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.</p>
<p>A log is a string has this format : function_id:start_or_end:timestamp. For example, “0:start:0” means function 0 starts from the very beginning of time 0. “0:end:0” means function 0 ends to the very end of time 0.</p>
<p>Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function’s exclusive time. You should return the exclusive time of each function sorted by their function id.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">n = 2</span><br><span class="line">logs = </span><br><span class="line">[&quot;0:start:0&quot;,</span><br><span class="line"> &quot;1:start:2&quot;,</span><br><span class="line"> &quot;1:end:5&quot;,</span><br><span class="line"> &quot;0:end:6&quot;]</span><br><span class="line">Output:[3, 4]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. </span><br><span class="line"></span><br><span class="line">Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.</span><br><span class="line">Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. </span><br><span class="line"></span><br><span class="line">So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>Input logs will be sorted by timestamp, NOT log id.</p>
<p>Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.</p>
<p>Two functions won’t start or end at the same time.<br>Functions could be called recursively, and will always end.</p>
<p>1 &lt;= n &lt;= 100</p>
<p>Simulate using stack<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">	int num;</span><br><span class="line">	char op;</span><br><span class="line">	int time;</span><br><span class="line">	node(int nn,char bb,int ee):num(nn),op(bb),time(ee)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">        vector&lt;int&gt; exclusiveTime(int n, vector&lt;string&gt;&amp; logs) &#123;</span><br><span class="line">        stack&lt;node&gt; s;</span><br><span class="line">        vector&lt;int&gt; ans(n,0);//!!</span><br><span class="line">        int id,cur,pre=0;//pre:间隔为1秒的时间刻 起点</span><br><span class="line">        char opp[6];</span><br><span class="line">        for(string str:logs)&#123;</span><br><span class="line">        	sscanf(str.c_str(),&quot;%d:%[a-z]:%d&quot;,&amp;id,&amp;opp,&amp;cur);</span><br><span class="line">        if(opp[0]==&apos;s&apos;)&#123;</span><br><span class="line">        	 </span><br><span class="line">        	//!!</span><br><span class="line">			if(!s.empty()) ans[s.top().num]+=cur-pre;</span><br><span class="line">        	s.push(node(id,opp[0],cur));  </span><br><span class="line">            pre=cur;//!!</span><br><span class="line">		&#125;   	</span><br><span class="line">	    else&#123;</span><br><span class="line">	    </span><br><span class="line">	    		ans[s.top().num]+=cur-pre+1;</span><br><span class="line">	    		s.pop();</span><br><span class="line">                pre=cur+1;//!!</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">            return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode-200.最长回文子串</title>
    <url>/2020/04/19/leetcode-200-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由回文串正序和反序的性质相同，可以得出一个性质，如果一个字符串，其中心不是回文串，那么它一定不是个回文串。如果去掉头和尾，它依然还是一个回文串。在头和尾加上同一个字符也是一个回文串。<br><a id="more"></a><br>由此可以得出判断一个区间是否是回文串，可以由更小的区间得到，并且不受包含这个区间的大区间影响，所以满足无后效性且是最有子结构，可以用动态规划求解。</p>
<p>算法：动态规划<br>设dp(l, r)，代表区间[l, r]是否是回文串。</p>
<p>如果s[l] == s[r]，并且s[l + 1 ~ r - 1]是回文串的话，s[l ~ r]就是回文串。</p>
<p>复杂度分析<br>设字符串长度为n。</p>
<p>时间复杂度O(n^2)<br>枚举端点，O(1)时间转移，时间复杂度为O(n^2)。<br>空间复杂度O(n^2)<br>需要额外O(n^2)空间记录dp值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    @param s: input string</span><br><span class="line">    @return: the longest palindromic substring</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def longestPalindrome(self, s):</span><br><span class="line">        max_len=1</span><br><span class="line">        # write your code here</span><br><span class="line">        length=len(s)</span><br><span class="line">        dp=[[0 for x in range(length)] for x in range(length)]</span><br><span class="line">        for i in range(length):</span><br><span class="line">            dp[i][i]=1</span><br><span class="line">        for i in range(length-1):</span><br><span class="line">            if s[i]==s[i+1]:</span><br><span class="line">                dp[i][i+1]=1</span><br><span class="line">                max_len=2</span><br><span class="line">                start=2</span><br><span class="line"></span><br><span class="line">        for new_len in range(3,length+1):</span><br><span class="line">            for left in range(length-new_len+1):</span><br><span class="line">                right=left+new_len-1</span><br><span class="line">                if dp[left+1][right-1]==1 and s[left]==s[right]:</span><br><span class="line">                    dp[left][right]=1</span><br><span class="line">                    if new_len&gt;max_len:</span><br><span class="line">                        max_len=new_len</span><br><span class="line">                        start=left</span><br><span class="line">        return s[start:start+max_len]</span><br><span class="line">s=Solution()</span><br><span class="line">print(s.longestPalindrome(&quot;abcdzdcab&quot;))</span><br></pre></td></tr></table></figure>
<p>参考链接<br><a href="https://www.jiuzhang.com/solutions/longest-palindromic-substring/#tag-highlight-lang-python" target="_blank" rel="noopener">https://www.jiuzhang.com/solutions/longest-palindromic-substring/#tag-highlight-lang-python</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 329. Longest Increasing Path in a Matrix</title>
    <url>/2018/12/08/leetcode-329/</url>
    <content><![CDATA[<p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).<br><a id="more"></a><br>Example 1:</p>
<p>Input: nums = </p>
<p>[</p>
<p>[9,9,4],</p>
<p>[6,6,8],</p>
<p>[2,1,1]</p>
<p>] </p>
<p>Output: 4 </p>
<p>Explanation: The longest increasing path is [1, 2, 6,<br>9].</p>
<p>Example 2:</p>
<p>Input: nums = </p>
<p>[<br>  [3,4,5],</p>
<p>  [3,2,6],</p>
<p>  [2,2,1]</p>
<p>]<br>Output: 4 </p>
<p>Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>
<p>记忆化递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int m,n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; p;</span><br><span class="line">    vector&lt;vector&lt;int &gt;&gt;dp;</span><br><span class="line">    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        m=matrix.size();</span><br><span class="line">        if(m==0) return 0;</span><br><span class="line">        n=matrix[0].size();</span><br><span class="line">        dp=vector&lt;vector&lt;int &gt;&gt;(m,vector&lt;int&gt;(n,0));</span><br><span class="line">        p.swap(matrix);</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++ )</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                 ans=max(ans,dfs(i,j));</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">    int dfs(int x,int y)&#123;</span><br><span class="line">        if(dp[x][y]!=0) return dp[x][y];</span><br><span class="line">        dp[x][y]=1;</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            int newx=x+dir[i][0];</span><br><span class="line">            int newy=y+dir[i][1];</span><br><span class="line">            if(newx&lt;0||newx&gt;=m||newy&lt;0||newy&gt;=n) continue;</span><br><span class="line">            if(p[newx][newy]&lt;=p[x][y]) continue;</span><br><span class="line">            dp[x][y]=max(dp[x][y],dfs(newx,newy)+1);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return dp[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>dfs</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 461 Hamming Distance</title>
    <url>/2018/11/30/leetcode-461/</url>
    <content><![CDATA[<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given two integers x and y, calculate the Hamming distance.<br><a id="more"></a><br>Note:<br>0 ≤ x, y &lt; 231.</p>
<p>Example:</p>
<p>Input: x = 1, y = 4</p>
<p>Output: 2</p>
<p>Explanation:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑</p>
<p>The above arrows point to positions where the corresponding bits are different.</p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingDistance(int x, int y) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=0;i&lt;31;i++)&#123;</span><br><span class="line">            int bx=x%2;</span><br><span class="line">            int by=y%2;</span><br><span class="line">            if(bx!=by) ans++;</span><br><span class="line">            x/=2;</span><br><span class="line">            y/=2;</span><br><span class="line">        &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>用异或 返回两个数 位不同的状态</p>
<p>统计异或结果转成二进制后中 1的个数</p>
<p>1：00000000 00000000  00000000 00000001(32进制)</p>
<p>即 与1 每次右移1位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingDistance(int x, int y) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">       int t=x^y;</span><br><span class="line">       while(t&gt;0)&#123;</span><br><span class="line">            ans+=t&amp;1;</span><br><span class="line">            t&gt;&gt;=1;</span><br><span class="line">        &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 682. Baseball Game</title>
    <url>/2018/12/05/leetcode-682-Baseball-Game/</url>
    <content><![CDATA[<p>You’re now a baseball game point recorder.</p>
<p>Given a list of strings, each string can be one of the 4 following types:<br><a id="more"></a><br>Integer (one round’s score): Directly represents the number of points you get in this round.<br>“+” (one round’s score): Represents that the points you get in this round are the sum of the last two valid round’s points.<br>“D” (one round’s score): Represents that the points you get in this round are the doubled data of the last valid round’s points.<br>“C” (an operation, which isn’t a round’s score): Represents the last valid round’s points you get were invalid and should be removed.<br>Each round’s operation is permanent and could have an impact on the round before and the round after.</p>
<p>You need to return the sum of the points you could get in all the rounds.</p>
<p>Example 1:</p>
<p>Input: [“5”,”2”,”C”,”D”,”+”]</p>
<p>Output: 30</p>
<p>Explanation: </p>
<p>Round 1: You could get 5 points. The sum is: 5.</p>
<p>Round 2: You could get 2 points. The sum is: 7.<br>Operation 1: The round 2’s data was invalid. The sum is: 5.  </p>
<p>Round 3: You could get 10 points (the round 2’s data has been removed). The sum is: 15.</p>
<p>Round 4: You could get 5 + 10 = 15 points. The sum is: 30.</p>
<p>Example 2:</p>
<p>Input: [“5”,”-2”,”4”,”C”,”D”,”9”,”+”,”+”]</p>
<p>Output: 27</p>
<p>Explanation: </p>
<p>Round 1: You could get 5 points. The sum is: 5.</p>
<p>Round 2: You could get -2 points. The sum is: 3.</p>
<p>Round 3: You could get 4 points. The sum is: 7.</p>
<p>Operation 1: The round 3’s data is invalid. The sum is: 3.  </p>
<p>Round 4: You could get -4 points (the round 3’s data has been removed). The sum is: -1.</p>
<p>Round 5: You could get 9 points. The sum is: 8.</p>
<p>Round 6: You could get -4 + 9 = 5 points. The sum is 13.</p>
<p>Round 7: You could get 9 + 5 = 14 points. The sum is 27.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calPoints(vector&lt;string&gt;&amp; ops) &#123;</span><br><span class="line">       vector&lt;int&gt; s;</span><br><span class="line">        for(string t:ops)&#123;</span><br><span class="line">            if(t==&quot;+&quot;)&#123;</span><br><span class="line">                s.push_back(s.end()[-1]+s.end()[-2]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t==&quot;C&quot;)  s.pop_back();</span><br><span class="line">            else if(t==&quot;D&quot;) s.push_back(s.end()[-1]*2);</span><br><span class="line">            else s.push_back(stoi(t));</span><br><span class="line">                            </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">         int ans=0;</span><br><span class="line">       for(int i=0;i&lt;s.size();i++)</span><br><span class="line">       &#123;</span><br><span class="line">         //cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">           ans+=s[i];</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 683  K Empty Slots</title>
    <url>/2018/12/01/leetcode-683/</url>
    <content><![CDATA[<p>题目大意：有n个花盆，第i天，第flowers[i]个花盆的花会开。问是否存在一天，两朵花之间有k个空花盆。<br><a id="more"></a></p>
<p>There is a garden with N slots. In each slot, there is a flower. The N flowers will bloom one by one in N days. In each day, there will be exactly one flower blooming and it will be in the status of blooming since then.</p>
<p>Given an array flowers consists of number from 1 to N. Each number in the array represents the place where the flower will open in that day.</p>
<p>For example, flowers[i] = x means that the unique flower that blooms at day i will be at position x, where i and x will be in the range from 1 to N.</p>
<p>Also given an integer k, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.</p>
<p>If there isn’t such day, output -1.</p>
<p>Example 1:</p>
<p>Input: </p>
<p>flowers: [1,3,2]</p>
<p>k: 1</p>
<p>Output: 2</p>
<p>Explanation: In the second day, the first and the third flower have become blooming.</p>
<p>Example 2:</p>
<p>Input:<br>flowers: [1,2,3]</p>
<p>k: 1</p>
<p>Output: -1</p>
<p>Note:</p>
<p>The given array will be in the range [1, 20000].<br>Idea:</p>
<p>BST/Buckets</p>
<p>可以直接暴力写 时间复杂度O(2nk)<br>对于第i天的花 遍历左边k个元素都是slots 第k+1个是花 则返回<br>或者 遍历右边k个元素都是slots 第k+1个是花 则也返回<br><!--more--></p>
<h2 id="法一-o-nlogn"><a href="#法一-o-nlogn" class="headerlink" title="法一 (o (nlogn))"></a>法一 (o (nlogn))</h2><p>set有序插入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//有序插入的思想 </span><br><span class="line">//集合set中元素都是有序的</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int kEmptySlots(vector&lt;int&gt;&amp; flowers, int k) &#123;</span><br><span class="line">	int n=flowers.size();</span><br><span class="line">		</span><br><span class="line">	set&lt;int&gt; s;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		int num=flowers[i];</span><br><span class="line">		auto r=s.insert(flowers[i]).first;</span><br><span class="line">		auto l=r;</span><br><span class="line">		//如果set后面有元素 </span><br><span class="line">		if(++r!=s.end()&amp;&amp;*r==num+k+1) return i+1;</span><br><span class="line">		if((l--)!=s.begin()&amp;&amp;*l==num-k-1) return i+1;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	vector&lt;int&gt; flowers;</span><br><span class="line">	flowers.push_back(1); </span><br><span class="line">	flowers.push_back(3);</span><br><span class="line">	flowers.push_back(2);  </span><br><span class="line">	int k=1;</span><br><span class="line">	int t=kEmptySlots(flowers,k);</span><br><span class="line">	cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="bucket思想"><a href="#bucket思想" class="headerlink" title="bucket思想"></a>bucket思想</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,k;</span><br><span class="line">int kEmptySlots(vector&lt;int&gt;&amp; flowers, int k) &#123;</span><br><span class="line">	int n=flowers.size();</span><br><span class="line">	//int	bs=ceil(n/k+1);</span><br><span class="line">	int bs=(n+k)/(k+1);</span><br><span class="line">		vector&lt;int&gt; lower(bs,INT_MAX);</span><br><span class="line">		vector&lt;int&gt; higher(bs,INT_MIN);		</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			int dui=flowers[i]/(k+1);</span><br><span class="line">			if(flowers[i]&lt;lower[dui]) &#123;</span><br><span class="line">				lower[dui]=flowers[i];</span><br><span class="line">				if(dui&gt;0&amp;&amp;higher[dui-1]==flowers[i]-k-1) </span><br><span class="line">		       	return i+1;	</span><br><span class="line">			&#125;</span><br><span class="line">			if(flowers[i]&gt;higher[dui])&#123;</span><br><span class="line">				higher[dui]=flowers[i];</span><br><span class="line">				if(dui&lt;bs-1&amp;&amp;lower[dui+1]==flowers[i]+k+1) return i+1;	</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	return -1;</span><br><span class="line">	</span><br><span class="line">	&#125; </span><br><span class="line">		</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	vector&lt;int&gt; flowers;</span><br><span class="line">	flowers.push_back(1); </span><br><span class="line">	flowers.push_back(3);</span><br><span class="line">	flowers.push_back(2);  </span><br><span class="line">	int k=1;</span><br><span class="line">	int t=kEmptySlots(flowers,k);</span><br><span class="line">	cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 735. Asteroid Collision</title>
    <url>/2018/11/30/leetcode-735/</url>
    <content><![CDATA[<p>We are given an array asteroids of integers representing asteroids in a row.</p>
<p>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.</p>
<p>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</p>
<p>Example 1:</p>
<p>Input:<br>asteroids = [5, 10, -5]</p>
<p>Output: [5, 10]<br><a id="more"></a><br>Explanation: </p>
<p>The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.</p>
<p>Example 2:</p>
<p>Input: </p>
<p>asteroids = [8, -8]</p>
<p>Output: []</p>
<p>Explanation: </p>
<p>The 8 and -8 collide exploding each other.</p>
<p>Example 3:</p>
<p>Input: </p>
<p>asteroids = [10, 2, -5]</p>
<p>Output: [10]</p>
<p>Explanation: </p>
<p>The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.</p>
<p>Example 4:</p>
<p>Input: </p>
<p>asteroids = [-2, -1, 1, 2]</p>
<p>Output: [-2, -1, 1, 2]</p>
<p>Explanation: </p>
<p>The -2 and -1 are moving left, while the 1 and 2 are moving right.</p>
<p>Asteroids moving the same direction never meet, so no asteroids will meet each other.<br>Note:</p>
<p>The length of asteroids will be at most 10000.<br>Each asteroid will be a non-zero integer in the range [-1000, 1000]..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; asteroidCollision(vector&lt;int&gt;&amp; asteroids) &#123;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        for(int i=0;i&lt;asteroids.size();i++)&#123;</span><br><span class="line">            if(asteroids[i]&gt;0) v.push_back(asteroids[i]);</span><br><span class="line">            else if(v.empty()||v.back()&lt;0) v.push_back(asteroids[i]);</span><br><span class="line">            else&#123;</span><br><span class="line">                if(abs(v.back())&lt;=abs(asteroids[i]))&#123;</span><br><span class="line">                    if(abs(v.back())&lt;abs(asteroids[i])) i--; //还用这颗陨石比较</span><br><span class="line">                    v.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode736. Parse Lisp Expression</title>
    <url>/2018/11/24/leetcode-736/</url>
    <content><![CDATA[<p>You are given a string expression representing a Lisp-like expression to return the integer value of.<br><a id="more"></a><br>The syntax for these expressions is given as follows.</p>
<p>An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable. Expressions always evaluate to a single integer.<br>(An integer could be positive or negative.)</p>
<p>A let-expression takes the form (let v1 e1 v2 e2 … vn en expr), where let is always the string “let”, then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.<br>&lt;！–more–&gt;<br>An add-expression takes the form (add e1 e2) where add is always the string “add”, there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.</p>
<p>A mult-expression takes the form (mult e1 e2) where mult is always the string “mult”, there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.</p>
<p>For the purposes of this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally for your convenience, the names “add”, “let”, or “mult” are protected and will never be used as variable names.</p>
<p>Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on scope.</p>
<p>Evaluation Examples:</p>
<p>Input: (add 1 2)</p>
<p>Output: 3</p>
<p>Input: (mult 3 (add 2 3))</p>
<p>Output: 15</p>
<p>Input: (let x 2 (mult x 5))</p>
<p>Output: 10</p>
<p>Input: (let x 2 (mult x (let x 3 y 4 (add x y))))</p>
<p>Output: 14</p>
<p>Explanation: In the expression (add x y), when checking for the value of the variable x,</p>
<p>we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.</p>
<p>Since x = 3 is found first, the value of x is 3.</p>
<p>Input: (let x 3 x 2 x)</p>
<p>Output: 2</p>
<p>Explanation: Assignment in let statements is processed sequentially.</p>
<p>Input: (let x 1 y 2 x (add x y) (add x y))</p>
<p>Output: 5</p>
<p>Explanation: The first (add x y) evaluates as 3, and is assigned to x.</p>
<p>The second (add x y) evaluates as 3+2 = 5.</p>
<p>Input: (let x 2 (add (let x 3 (let x 4 x)) x))</p>
<p>Output: 6</p>
<p>Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context<br>of the final x in the add-expression.  That final x will equal 2.</p>
<p>Input: (let a1 3 b2 (add a1 1) b2) </p>
<p>Output 4</p>
<p>Explanation: Variable names can contain digits after the first character.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evaluate(string expression) &#123;</span><br><span class="line">     scopes.clear();</span><br><span class="line">     </span><br><span class="line">        int pos=0;</span><br><span class="line">   return  eval(expression,pos);  //不能直接写成eval(expression,0) const int</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    int  eval(string &amp;expr,int&amp; pos)&#123;//!!!</span><br><span class="line">        scopes.push_front(unordered_map&lt;string,int&gt;());</span><br><span class="line">        if(expr[pos]==&apos;(&apos;) pos++;</span><br><span class="line">        int value=0;</span><br><span class="line">        const string token=getToken(expr,pos);</span><br><span class="line">        if(token==&quot;add&quot;)&#123;</span><br><span class="line">            int a=eval(expr,++pos);//不能写成pos++</span><br><span class="line">            int b=eval(expr,++pos);</span><br><span class="line">            value=a+b;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(token==&quot;mult&quot;)&#123;</span><br><span class="line">            int a=eval(expr,++pos);</span><br><span class="line">            int b=eval(expr,++pos);</span><br><span class="line">            value=a*b;</span><br><span class="line">        &#125;</span><br><span class="line">        //!!</span><br><span class="line">        else if(token==&quot;let&quot;)&#123;</span><br><span class="line">            //var1 expr1 var2 expr2 .... last_expr</span><br><span class="line"></span><br><span class="line">            while(expr[pos]!=&apos;)&apos;)&#123;</span><br><span class="line">                pos++;//读入一个空格</span><br><span class="line">                if(expr[pos]==&apos;(&apos;) &#123;</span><br><span class="line">                    //只有最后一个表达式可能有左括号</span><br><span class="line">                    value=eval(expr,++pos);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;    </span><br><span class="line">                string t=getToken(expr,pos);</span><br><span class="line">                if(expr[pos]==&apos;)&apos;) &#123;</span><br><span class="line">                    if(isalpha(t[0])) value=getValue(t);</span><br><span class="line">                    else value=std::stoi(t);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">               // scopes.front[t]=eval(expr,++pos); 注意()</span><br><span class="line"></span><br><span class="line">                scopes.front()[t]=eval(expr,++pos);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        else if(isalpha(token[0])) value=getValue(token);</span><br><span class="line">        else value=std::stoi(token);//字符串转成整型</span><br><span class="line">        if(expr[pos]==&apos;)&apos;) ++pos;</span><br><span class="line">        scopes.pop_front();</span><br><span class="line">        return value;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int getValue(const string &amp;t)&#123;//const</span><br><span class="line">        for(const auto&amp;scope:scopes)&#123;</span><br><span class="line">            if(scope.count(t)) return scope.at(t);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    string getToken(string &amp;expr,int &amp;pos)&#123;//!</span><br><span class="line">        int value=0;</span><br><span class="line">        string t;</span><br><span class="line">        //int k=0;</span><br><span class="line">        while(pos&lt;expr.length())&#123;</span><br><span class="line">            if(expr[pos]==&apos; &apos;||expr[pos]==&apos;)&apos;) break;</span><br><span class="line">            //t[k++]=expr[pos++];</span><br><span class="line">            t+=expr[pos++];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deque&lt;unordered_map&lt;string,int&gt;&gt; scopes;//!!双向队列 存储临时变量的Map</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode749. Contain Virus</title>
    <url>/2018/11/30/leetcode-749/</url>
    <content><![CDATA[<p>A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.</p>
<p>The world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.<br><a id="more"></a><br>Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region – the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.</p>
<p>Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.</p>
<p>Example 1:<br>Input: grid = </p>
<p>[[0,1,0,0,0,0,0,1],</p>
<p>[0,1,0,0,0,0,0,1],</p>
<p>[0,0,0,0,0,0,0,1],</p>
<p>[0,0,0,0,0,0,0,0]]<br>Output: 10<br>Explanation:<br>There are 2 contaminated regions.<br>On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:</p>
<p>[[0,1,0,0,0,0,1,1],</p>
<p>[0,1,0,0,0,0,1,1],</p>
<p>[0,0,0,0,0,0,1,1],</p>
<p>[0,0,0,0,0,0,0,1]]</p>
<p>On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.</p>
<p>Example 2:</p>
<p>Input: grid = </p>
<p>[[1,1,1],</p>
<p>[1,0,1],</p>
<p>[1,1,1]]</p>
<p>Output: 4</p>
<p>Explanation: Even though there is only one cell saved, there are 4 walls built.<br>Notice that walls are only built on the shared boundary of two different cells.</p>
<p>Example 3:</p>
<p>Input: grid = </p>
<p>[[1,1,1,0,0,0,0,0,0],</p>
<p>[1,0,1,0,1,1,1,1,1],</p>
<p>[1,1,1,0,0,0,0,0,0]]</p>
<p>Output: 13</p>
<p>Explanation: The region on the left only builds two new walls.<br>Note:</p>
<p>The number of rows and columns of grid will each be in the range [1, 50].</p>
<p>Each grid[i][j] will be either 0 or 1.<br>Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dirs[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int m,n;</span><br><span class="line">    int containVirus(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        m=grid.size();</span><br><span class="line">        int total_walls=0;</span><br><span class="line">        n=grid[0].size();        </span><br><span class="line">        //对于每一天要重新搜索</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //</span><br><span class="line">            vector&lt;unorderedint&gt;</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">            vector&lt;int&gt; vis;</span><br><span class="line">             vector&lt;int&gt; nexts;</span><br><span class="line">            </span><br><span class="line">           vector&lt;int&gt; virus_area;//!!</span><br><span class="line">            int best=0;</span><br><span class="line">            int block_index=-1;</span><br><span class="line">            int block_walls=-1;</span><br><span class="line">            </span><br><span class="line">            for(int x=0;x&lt;m;x++)&#123;</span><br><span class="line">                for(int y=0;y&lt;n;y++)&#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                         int walls=0;</span><br><span class="line">                         vector&lt;int&gt; curr;//!!</span><br><span class="line">                        unordered_set&lt;int&gt; next;//!!</span><br><span class="line">                         if(grid[x][y]==0||grid[x][y]==2) continue;</span><br><span class="line">                         getArea(x,y,curr,vis,next,walls);</span><br><span class="line">                         if(next.empty()) continue;</span><br><span class="line">                         if(nexts.empty()||next.size()&gt;best)&#123;</span><br><span class="line">                             best=next.size();</span><br><span class="line">                             virus_area.swap(curr)</span><br><span class="line">                             block_index=nexts.size();</span><br><span class="line">                             block_walls=walls;</span><br><span class="line">                         &#125;</span><br><span class="line">                        nexts.push_back(std::move(next));//!!</span><br><span class="line">                             </span><br><span class="line">                    &#125;       </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nexts.size()==0) break;</span><br><span class="line">            totalwalls+=block_walls;</span><br><span class="line">            for(int i=0;i&lt;nexts.size();i++)&#123;</span><br><span class="line">                </span><br><span class="line">                if(i==block_index)&#123;</span><br><span class="line">                    for(int key:virus_area)&#123;</span><br><span class="line">                        grid[key/n][key%n]=2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    for(int k:nexts[i])&#123;</span><br><span class="line">                        grid[k/n][k%n]=1;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    void getArea(int x,int y,vetor&lt;int&gt; &amp;curr,vector&lt;int&gt; &amp;vis,unordered_set&lt;int&gt;&amp; next,int &amp;walls)&#123;</span><br><span class="line">        if(x&lt;0||x&lt;m||y=0||y&gt;n||grid[x][y]==2) return;</span><br><span class="line">        int key=x*n+y;</span><br><span class="line">        if(grid[x][y]==0)&#123;</span><br><span class="line">            walls++;</span><br><span class="line">            next.insert(key);//表示能扩展的格子数量</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(vis[key]) return;</span><br><span class="line">        else vis[key]=1;</span><br><span class="line">        curr.push_back(key);</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            x+=dirs[i][0];</span><br><span class="line">            y+=dirs[i][1];</span><br><span class="line">            getArea(x,y,curr,vis,next,walls);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 817. Linked List Components</title>
    <url>/2018/12/04/leetcode-817/</url>
    <content><![CDATA[<p>We are given head, the head node of a linked list containing unique integer values.</p>
<p>We are also given the list G, a subset of the values in the linked list.</p>
<p>Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list.<br><a id="more"></a><br>Example 1:</p>
<p>Input:<br>head: 0-&gt;1-&gt;2-&gt;3</p>
<p>G = [0, 1, 3]</p>
<p>Output: 2</p>
<p>Explanation: </p>
<p>0 and 1 are connected, so [0, 1] and [3] are the two connected components.</p>
<p>Example 2:</p>
<p>Input: </p>
<p>head: 0-&gt;1-&gt;2-&gt;3-&gt;4</p>
<p>G = [0, 3, 1, 4]</p>
<p>Output: 2</p>
<p>Explanation: </p>
<p>0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.<br>Note:</p>
<p>If N is the length of the linked list given by head, 1 &lt;= N &lt;= 10000.<br>The value of each node in the linked list will be in the range [0, N - 1].</p>
<p>1 &lt;= G.length &lt;= 10000.</p>
<p>G is a subset of all values in the linked list.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"> bool vis[10000];</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    map&lt;int,vector&lt;int&gt; &gt;g;</span><br><span class="line">    int numComponents(ListNode* head, vector&lt;int&gt;&amp; G) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; s(G.begin(),G.end());</span><br><span class="line">        </span><br><span class="line">        while(head-&gt;next)&#123;</span><br><span class="line">            int u=head-&gt;val;</span><br><span class="line">            int v=head-&gt;next-&gt;val;</span><br><span class="line">            if(s.count(u)&amp;&amp;s.count(v)) &#123;</span><br><span class="line">                g[u].push_back(v);</span><br><span class="line">                g[v].push_back(u);//!!  0-&gt;1-&gt;2 [1,0] G集合不一定有序 所以是无向图</span><br><span class="line">                cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            head=head-&gt;next;            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        int ans=0;</span><br><span class="line">           memset(vis,0,sizeof(vis));</span><br><span class="line">        for(auto g:G)&#123;</span><br><span class="line">        if(vis[g]) continue;</span><br><span class="line">          else&#123;</span><br><span class="line">               dfs(g,vis);</span><br><span class="line">                ans++;</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;</span><br><span class="line">       return ans;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(int cur,bool vis[])&#123;</span><br><span class="line">        if(vis[cur]) return;</span><br><span class="line">       vis[cur]=true;</span><br><span class="line">        for(int i=0;i&lt;g[cur].size();i++)&#123;</span><br><span class="line">            if(!vis[g[cur][i]]) dfs(g[cur][i],vis);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 863. All Nodes Distance K in Binary Tree</title>
    <url>/2018/12/03/leetcode-863/</url>
    <content><![CDATA[<p>We are given a binary tree (with root node root), a target node, and an integer value K.</p>
<p>Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.</p>
<p>Example 1:</p>
<p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2</p>
<p>Output: [7,4,1]<br><a id="more"></a><br>Explanation:<br>The nodes that are a distance 2 from the target node (with value 5)<br>have values 7, 4, and 1.</p>
<p>Note that the inputs “root” and “target” are actually TreeNodes.<br>The descriptions of the inputs above are just serializations of these objects.</p>
<p> <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="image"></p>
<p>Note:</p>
<p>The given tree is non-empty.<br>Each node in the tree has unique values 0 &lt;= node.val &lt;= 500.<br>The target node is a node in the tree.<br>0 &lt;= K &lt;= 1000.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int vis[1000];</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    //!!</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; g=vector&lt;vector&lt;int&gt;&gt;(500);//沒有初始化vector的大小 不能直接赋值</span><br><span class="line">   </span><br><span class="line">    vector&lt;int&gt; distanceK(TreeNode* root, TreeNode* target, int K) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        buildpath(nullptr,root);</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        q.push(target-&gt;val);</span><br><span class="line">        int k=0;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int size=q.size();</span><br><span class="line">            while(size--)&#123;</span><br><span class="line">            int t=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            vis[t]=1;</span><br><span class="line">            if(k==K) ans.push_back(t);</span><br><span class="line">            for(int i=0;i&lt;g[t].size();i++)&#123;</span><br><span class="line">                if(vis[g[t][i]]) continue;</span><br><span class="line">                q.push(g[t][i]);</span><br><span class="line">            &#125;   </span><br><span class="line">            &#125; </span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    void buildpath(TreeNode *parent,TreeNode *child)&#123;</span><br><span class="line">        if(parent)&#123;</span><br><span class="line">            g[parent-&gt;val].push_back(child-&gt;val);</span><br><span class="line">            g[child-&gt;val].push_back(parent-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        if(child-&gt;left) buildpath(child,child-&gt;left);</span><br><span class="line">         if(child-&gt;right) buildpath(child,child-&gt;right);       </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>leetcode684. Redundant Connection</title>
    <url>/2018/12/03/leetcode684/</url>
    <content><![CDATA[<p>In this problem, a tree is an undirected graph that is connected and has no cycles.</p>
<p>The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, …, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.<br><a id="more"></a><br>The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an undirected edge connecting nodes u and v.</p>
<p>Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v.</p>
<p>Example 1:</p>
<p>Input: [[1,2], [1,3], [2,3]]</p>
<p>Output: [2,3]</p>
<p>Explanation: The given undirected graph will be like this:<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1</span><br><span class="line"></span><br><span class="line">/ \</span><br><span class="line"></span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:</p>
<p>Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]</p>
<p>Output: [1,4]</p>
<p>Explanation: The given undirected graph will be like this:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 - 1 - 2</span><br><span class="line"></span><br><span class="line">|   |</span><br><span class="line"></span><br><span class="line">4 - 3</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>The size of the input 2D-array will be between 3 and 1000.</p>
<p>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</p>
<p>Update (2017-09-26):<br>We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>并查集的思想</p>
<p>union: 把分别含有u,v的集合Merge到一起，如果u,v已经在一个集合 返回false<br>如果不在一个集合 就把一个集合merge到另一个集合中 （把rank小的merge到rank大的集合）</p>
<p>find:返回它的祖先节点(cluster id）  每个节点都有它的parent 在找祖先节点的过程额外地Path compression 回溯的过程中把其Parent也指向祖先节点（如果开始指向的不是祖先节点的话）</p>
<p>这样会降低后几次查找的时间复杂度</p>
<p>可能第一次找是o(n)(链表长度) 第二次找o（1）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class unionset&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">    vector&lt;int&gt; rank;</span><br><span class="line">	</span><br><span class="line">    unionset(int n)&#123;</span><br><span class="line">    parent=vector&lt;int&gt;(n+1,0);</span><br><span class="line">    rank=vector&lt;int&gt;(n+1,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">	parent[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bool Union(int u1,int u2)&#123;</span><br><span class="line">		int p1=find(u1);</span><br><span class="line">		int p2=find(u2);</span><br><span class="line">		if(p1==p2) return false;</span><br><span class="line">		if(rank[p1]&gt;rank[p2])&#123;</span><br><span class="line">			parent[p2]=p1;</span><br><span class="line">		&#125;</span><br><span class="line">        else if(rank[p2]&gt;rank[p1])&#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">            rank[p2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    int find(int num)&#123;</span><br><span class="line">        if(num!=parent[num])&#123;</span><br><span class="line">            parent[num]=find(parent[num]);//find(num)一直自己调用自己 错的 find(parent[num]) 往上回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[num];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        int n=edges.size();</span><br><span class="line">        unionset u(n);</span><br><span class="line">         vector&lt;int&gt; v;</span><br><span class="line">        for(vector&lt;vector&lt;int&gt;&gt;::iterator it=edges.begin();it!=edges.end();it++)&#123;</span><br><span class="line">            cout&lt;&lt;(*it)[0]&lt;&lt;&quot; &quot;&lt;&lt;(*it)[1]&lt;&lt;endl;</span><br><span class="line">           if(!u.Union((*it)[0],(*it)[1]))&#123;</span><br><span class="line">               cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">               v.push_back((*it)[0]);</span><br><span class="line">               v.push_back((*it)[1]);</span><br><span class="line">                   break;</span><br><span class="line">           &#125; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>leetcode725. Split Linked List in Parts</title>
    <url>/2018/11/30/leetcode725-Split-Linked-List-in-Parts/</url>
    <content><![CDATA[<p>Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list “parts”.</p>
<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>
<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>
<p>Return a List of ListNode’s representing the linked list parts that are formed.<br><a id="more"></a><br>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p>
<p>Example 1:</p>
<p>Input: </p>
<p>root = [1, 2, 3], k = 5</p>
<p>Output: [[1],[2],[3],[],[]]</p>
<p>Explanation:</p>
<p>The input and each element of the output are ListNodes, not arrays.</p>
<p>For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.<br>The first element output[0] has output[0].val = 1, output[0].next = null.<br>The last element output[4] is null, but it’s string representation as a ListNode is [].</p>
<p>Example 2:</p>
<p>Input: </p>
<p>root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3</p>
<p>Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</p>
<p>Explanation:</p>
<p>The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.</p>
<p>Note:</p>
<p>The length of root will be in the range [0, 1000].</p>
<p>Each value of a node in the input will be an integer in the range [0, 999].</p>
<p>k will be an integer in the range [1, 50].</p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;ListNode*&gt; splitListToParts(ListNode* root, int k) &#123;</span><br><span class="line">        int len=0;</span><br><span class="line">      //  vector&lt;ListNode*&gt; ans(k,nullptr);</span><br><span class="line">         vector&lt;ListNode*&gt; ans;</span><br><span class="line">        for(ListNode* p=root;p!=NULL;p=p-&gt;next)&#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        int l,r,num;</span><br><span class="line">        l=len/k;</span><br><span class="line">        r=len%k;</span><br><span class="line">        ListNode *pre=nullptr,*head=root;</span><br><span class="line">        //换一种循环方式 按组数循环</span><br><span class="line">        for(int i=0;i&lt;k;i++,--r)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(head);</span><br><span class="line">             for(int j=0;j&lt;l+(r&gt;0);j++)&#123;</span><br><span class="line">                 pre=head;</span><br><span class="line">                 head=head-&gt;next;</span><br><span class="line">             &#125;</span><br><span class="line">            if(pre) pre-&gt;next=nullptr;          </span><br><span class="line">        &#125; </span><br><span class="line">        return ans;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;ListNode*&gt; splitListToParts(ListNode* root, int k) &#123;</span><br><span class="line">        int len=0;</span><br><span class="line">        vector&lt;ListNode*&gt; ans;</span><br><span class="line">        for(ListNode* p=root;p!=NULL;p=p-&gt;next)&#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        int l,r,num;</span><br><span class="line">        l=len/k;</span><br><span class="line">        r=len%k;</span><br><span class="line">        ListNode *pre=root;</span><br><span class="line">        int flag=1;</span><br><span class="line">        num=l+(r&gt;0?1:0);</span><br><span class="line">        ans.push_back(root);</span><br><span class="line">        k--;//k代表组数</span><br><span class="line">        for(ListNode *head=root;head!=NULL;head=head-&gt;next)&#123;        </span><br><span class="line">            if(num==0)&#123;</span><br><span class="line">                if(pre-&gt;next) &#123;</span><br><span class="line">                    ans.push_back(pre-&gt;next);</span><br><span class="line">                    pre-&gt;next=NULL;</span><br><span class="line">                &#125;</span><br><span class="line">                r--;</span><br><span class="line">                num=l+(r&gt;0?1:0);</span><br><span class="line">                k--;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            pre=head;</span><br><span class="line">        &#125;</span><br><span class="line">        while(k&gt;0)&#123;//if和while</span><br><span class="line">            ans.push_back(NULL);</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>201703-3 Markdown</title>
    <url>/2018/12/10/markdown/</url>
    <content><![CDATA[<p>Markdown 是一种很流行的轻量级标记语言（lightweight markup language），广泛用于撰写带格式的文档。例如以下这段文本就是用 Markdown 的语法写成的：</p>
<p><img src="http://118.190.20.162/RequireFile.do?fid=Yy7nr9Yt" alt="image"></p>
<p>　　这些用 Markdown 写成的文本，尽管本身是纯文本格式，然而读者可以很容易地看出它的文档结构。同时，还有很多工具可以自动把 Markdown 文本转换成 HTML 甚至 Word、PDF 等格式，取得更好的排版效果。例如上面这段文本通过转化得到的 HTML 代码如下所示：</p>
<a id="more"></a>
<p><img src="http://118.190.20.162/RequireFile.do?fid=247472gj" alt="image"></p>
<p>　　本题要求由你来编写一个 Markdown 的转换工具，完成 Markdown 文本到 HTML 代码的转换工作。简化起见，本题定义的 Markdown 语法规则和转换规则描述如下：<br>　　●区块：区块是文档的顶级结构。本题的 Markdown 语法有 3 种区块格式。在输入中，相邻两个区块之间用一个或多个空行分隔。输出时删除所有分隔区块的空行。<br>　　○段落：一般情况下，连续多行输入构成一个段落。段落的转换规则是在段落的第一行行首插入 <code>&lt;p&gt;</code>，在最后一行行末插入 <code>&lt;/p&gt;</code>。<br>　　○标题：每个标题区块只有一行，由若干个 <code>#</code> 开头，接着一个或多个空格，然后是标题内容，直到行末。<code>#</code> 的个数决定了标题的等级。转换时，<code># Heading</code> 转换为 <code>&lt;h1&gt;Heading&lt;/h1&gt;</code>，<code>## Heading</code> 转换为 <code>&lt;h2&gt;Heading&lt;/h2&gt;</code>，以此类推。标题等级最深为 6。<br>　　○无序列表：无序列表由若干行组成，每行由 <code>*</code> 开头，接着一个或多个空格，然后是列表项目的文字，直到行末。转换时，在最开始插入一行 <code>&lt;ul&gt;</code>，最后插入一行 <code>&lt;/ul&gt;</code>；对于每行，<code>* Item</code> 转换为 <code>&lt;li&gt;Item&lt;/li&gt;</code>。本题中的无序列表只有一层，不会出现缩进的情况。<br>　　●行内：对于区块中的内容，有以下两种行内结构。<br>　　○强调：<code>_Text_</code> 转换为 <code>&lt;em&gt;Text&lt;/em&gt;</code>。强调不会出现嵌套，每行中 <code>_</code> 的个数一定是偶数，且不会连续相邻。注意 <code>_Text_</code> 的前后不一定是空格字符。<br>　　○超级链接：<code>[Text](Link)</code> 转换为 <code>&lt;a href=&quot;Link&quot;&gt;Text&lt;/a&gt;</code>。超级链接和强调可以相互嵌套，但每种格式不会超过一层。<br>输入格式<br>　　输入由若干行组成，表示一个用本题规定的 Markdown 语法撰写的文档。<br>输出格式<br>　　输出由若干行组成，表示输入的 Markdown 文档转换成产生的 HTML 代码。<br>样例输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Hello</span><br><span class="line"></span><br><span class="line">Hello, world!</span><br><span class="line">样例输出</span><br><span class="line">&lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;Hello, world!&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p>评测用例规模与约定<br>　　本题的测试点满足以下条件：<br>　　●本题每个测试点的输入数据所包含的行数都不超过100，每行字符的个数（包括行末换行符）都不超过100。<br>　　●除了换行符之外，所有字符都是 ASCII 码 32 至 126 的可打印字符。<br>　　●每行行首和行末都不会出现空格字符。<br>　　●输入数据除了 Markdown 语法所需，内容中不会出现 <code>#</code>、<code>*</code>、<code>_</code>、<code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code> 这些字符。<br>　　●所有测试点均符合题目所规定的 Markdown 语法，你的程序不需要考虑语法错误的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string parseLink(string a,string b)&#123;</span><br><span class="line">	string res=&quot;&quot;;</span><br><span class="line">	res+=&quot;&lt;a href=\&quot;&quot;+b+&quot;\&quot;&gt;&quot;+a+&quot;&lt;/a&gt;&quot;;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">string parseFocus(string t)&#123;</span><br><span class="line">	string res=&quot;&lt;em&gt;&quot;;</span><br><span class="line">	res+=t;</span><br><span class="line">	res+=&quot;&lt;/em&gt;&quot;;</span><br><span class="line">	return res;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">string parseL(string line)&#123;</span><br><span class="line">	string res=&quot;&quot;;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(i&lt;line.size())&#123;</span><br><span class="line">	if(line[i]==&apos;[&apos;)&#123;</span><br><span class="line">		int j=i+1;</span><br><span class="line">		while(line[j]!=&apos;]&apos;) j++;</span><br><span class="line">		string txt=line.substr(i+1,j-i-1);</span><br><span class="line">		assert(line[j+1]==&apos;(&apos;);</span><br><span class="line">		i=j+1;</span><br><span class="line">		//!!</span><br><span class="line">		while(line[j]!=&apos;)&apos;) j++;</span><br><span class="line">		</span><br><span class="line">		string link=line.substr(i+1,j-i-1);</span><br><span class="line">		string t1=parseL(txt);</span><br><span class="line">		string l1=parseL(link);</span><br><span class="line">		res+=parseLink(t1,l1);</span><br><span class="line">		i=j+1;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(line[i]==&apos;_&apos;)&#123;</span><br><span class="line">			int j=i+1;</span><br><span class="line">		while(line[j]!=&apos;_&apos;) j++;</span><br><span class="line">		string txt=line.substr(i+1,j-i-1);</span><br><span class="line">		string ntxt=parseL(txt);</span><br><span class="line">		res+=parseFocus(ntxt);</span><br><span class="line">		i=j+1;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		//!</span><br><span class="line">		res+=line[i];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	return res;	</span><br><span class="line">&#125;</span><br><span class="line">string parsePa(vector&lt;string&gt; v)&#123;</span><br><span class="line">	string res=&quot;&lt;p&gt;&quot;;</span><br><span class="line">	for(int i=0;i&lt;v.size();i++)&#123;</span><br><span class="line">			res+=parseL(v[i]);</span><br><span class="line">			if(v.size()!=0&amp;&amp;i!=v.size()-1) res+=&quot;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	res+=&quot;&lt;/p&gt;\n&quot;;</span><br><span class="line">	return res;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">string parseHeads(vector&lt;string&gt; v)&#123;</span><br><span class="line">	assert(v.size()==1);</span><br><span class="line">	string t=v[0];</span><br><span class="line">	int lev=1;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(t[i]==&apos;#&apos;) i++;</span><br><span class="line">	lev=i;</span><br><span class="line">	while(t[i]==&apos; &apos;)i++;</span><br><span class="line">	//substr的位置是i 不是i+1  </span><br><span class="line">	string con=t.substr(i,-1);</span><br><span class="line">	con=parseL(con);</span><br><span class="line">	string res=&quot;&quot;;</span><br><span class="line">	char ss[10];</span><br><span class="line">	itoa(lev,ss,10);</span><br><span class="line">		</span><br><span class="line">	res=&quot;&lt;h&quot;+(string)ss+&quot;&gt;&quot;+con+&quot;&lt;/h&quot;+(string)ss+&quot;&gt;\n&quot;;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string parseU(vector&lt;string&gt; v)&#123;</span><br><span class="line">	string res=&quot;&quot;;</span><br><span class="line">	res+=&quot;&lt;ul&gt;\n&quot;;</span><br><span class="line">	for(int i=0;i&lt;v.size();i++)&#123;</span><br><span class="line">		res+=&quot;&lt;li&gt;&quot;;</span><br><span class="line">		int j=0;</span><br><span class="line">		//!</span><br><span class="line">	if(v[i][j]==&apos;*&apos;) j++;</span><br><span class="line">	while(v[i][j]==&apos; &apos;)j++;</span><br><span class="line">		res+=parseL(v[i].substr(j,-1));</span><br><span class="line">		res+=&quot;&lt;/li&gt;\n&quot;;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	res+=&quot;&lt;/ul&gt;\n&quot;;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string s;</span><br><span class="line">	int block;</span><br><span class="line">	vector&lt;string&gt; v;</span><br><span class="line">	string res=&quot;&quot;;</span><br><span class="line">	while(getline(cin,s)||v.size()&gt;0) </span><br><span class="line">	&#123;</span><br><span class="line">		if(s.empty())&#123;</span><br><span class="line">			if(block!=0)&#123;</span><br><span class="line">			switch(block)&#123;</span><br><span class="line">				case 1:</span><br><span class="line">					res+=parseHeads(v);</span><br><span class="line">					</span><br><span class="line">					break;</span><br><span class="line">				case 2:</span><br><span class="line">					res+=parseU(v);					</span><br><span class="line">					break;</span><br><span class="line">				case 3:</span><br><span class="line">					res+=parsePa(v);</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;					</span><br><span class="line">			&#125;</span><br><span class="line">			//!!</span><br><span class="line">				  v.resize(0);</span><br><span class="line">					block=0;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s[0]==&apos;#&apos;)&#123;</span><br><span class="line">			v.push_back(s);</span><br><span class="line">			block=1;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s[0]==&apos;*&apos;)&#123;</span><br><span class="line">			v.push_back(s);</span><br><span class="line">			block=2;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			v.push_back(s);</span><br><span class="line">		block=3;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">			&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复习了一遍 代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string parseF(string w)&#123;</span><br><span class="line">	string rs=&quot;&lt;em&gt;&quot;+w+&quot;&lt;/em&gt;&quot;;</span><br><span class="line">	return rs;</span><br><span class="line">&#125;</span><br><span class="line">string parseLink(string txt,string link)&#123;</span><br><span class="line">	return &quot;&lt;a href=\&quot;&quot;+link+&quot;\&quot;&gt;&quot;+txt+&quot;&lt;/a&gt;&quot;;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string parseL(string line)&#123;</span><br><span class="line">	int i=0;</span><br><span class="line">	string rs=&quot;&quot;;</span><br><span class="line">	while(i&lt;line.size())&#123;</span><br><span class="line">	if(line[i]==&apos;_&apos;)&#123;</span><br><span class="line">		int j=line.find(&apos;_&apos;,i+1);</span><br><span class="line">		string w=line.substr(i+1,j-i-1);</span><br><span class="line">		w=parseL(w);</span><br><span class="line">		w=parseF(w);</span><br><span class="line">		rs+=w;</span><br><span class="line">		i=j+1; </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else if(line[i]==&apos;[&apos;)&#123;</span><br><span class="line">			int k=line.find(&quot;](&quot;,i+1);</span><br><span class="line">			int next=line.find(&apos;)&apos;,k+1);</span><br><span class="line">			string txt=line.substr(i+1,k-i-1);</span><br><span class="line">			string link=line.substr(k+2,next-k-2);</span><br><span class="line">			txt=parseL(txt);</span><br><span class="line">			link=parseL(link);</span><br><span class="line">			rs+=parseLink(txt,link);</span><br><span class="line">			i=next+1;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		rs+=line[i]; 	</span><br><span class="line">		i++;</span><br><span class="line">	&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line">	return rs;</span><br><span class="line">&#125;</span><br><span class="line">string parseHead(vector&lt;string&gt; lines)&#123;</span><br><span class="line">	assert(lines.size()==1);</span><br><span class="line">	int i=0;</span><br><span class="line">	string line=lines[0];</span><br><span class="line">	while(line[i]==&apos;#&apos;) i++;</span><br><span class="line">	int level=i;</span><br><span class="line">	while(line[i]==&apos; &apos;) i++;</span><br><span class="line">	string con=line.substr(i,-1);</span><br><span class="line">	con=parseL(con);</span><br><span class="line">	char ss[10];</span><br><span class="line">	itoa(level,ss,10);</span><br><span class="line">	string rs=&quot;&lt;h&quot;+(string)ss+&quot;&gt;&quot;+con+&quot;&lt;/h&quot;+(string)ss+&quot;&gt;\n&quot;;</span><br><span class="line">	return rs; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">string parseU(vector&lt;string&gt; lines)&#123;</span><br><span class="line">	string rs=&quot;&lt;ul&gt;\n&quot;;</span><br><span class="line">	for(int i=0;i&lt;lines.size();i++)&#123;</span><br><span class="line">		rs+=&quot;&lt;li&gt;&quot;;</span><br><span class="line">		string ss=lines[i];</span><br><span class="line">		int j=0;</span><br><span class="line">		while(ss[j]==&apos;*&apos;) j++;</span><br><span class="line">		while(ss[j]==&apos; &apos;) j++;</span><br><span class="line">		string w=ss.substr(j,-1);</span><br><span class="line">		rs+=parseL(w);</span><br><span class="line">		rs+=&quot;&lt;/li&gt;\n&quot;;</span><br><span class="line">		</span><br><span class="line">	&#125;	</span><br><span class="line">	rs+=&quot;&lt;/ul&gt;\n&quot;;</span><br><span class="line">	return rs;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">string  parseP(vector&lt;string&gt; lines)&#123;</span><br><span class="line">		string rs=&quot;&lt;p&gt;&quot;;</span><br><span class="line">	for(int i=0;i&lt;lines.size();i++)&#123;</span><br><span class="line">		rs+=parseL(lines[i]);</span><br><span class="line">		if(i!=lines.size()-1) rs+=&quot;\n&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	rs+=&quot;&lt;/p&gt;\n&quot;;</span><br><span class="line">	return rs;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	vector&lt;string&gt; vec;</span><br><span class="line">	string line;</span><br><span class="line">	int type=0;</span><br><span class="line">	string rs=&quot;&quot;;</span><br><span class="line">	while(getline(cin,line)||vec.size()&gt;0)&#123;</span><br><span class="line">		if(line.empty())&#123;</span><br><span class="line">			if(type!=0)&#123;</span><br><span class="line">		</span><br><span class="line">			if(type==1)&#123;</span><br><span class="line">				rs+=parseHead(vec);</span><br><span class="line">			&#125;</span><br><span class="line">			else if(type==2)&#123;</span><br><span class="line">					rs+=parseU(vec);</span><br><span class="line">			&#125; </span><br><span class="line">			else if(type==3)&#123;</span><br><span class="line">					rs+=parseP(vec);</span><br><span class="line">			&#125;</span><br><span class="line">			vec.resize(0);</span><br><span class="line">			type=0;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(line[0]==&apos;#&apos;)&#123;</span><br><span class="line">			type=1;</span><br><span class="line">		vec.push_back(line);			</span><br><span class="line">		&#125; </span><br><span class="line">		else if(line[0]==&apos;*&apos;)&#123;</span><br><span class="line">			type=2;</span><br><span class="line">			vec.push_back(line);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			type=3;</span><br><span class="line">			vec.push_back(line);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 cout&lt;&lt;rs;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>map操作</title>
    <url>/2018/10/28/map%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>map初始化<br>1、直接赋值</p>
<pre><code>map[key]=value;
</code></pre><p>2、用insert添加pair类型的元素<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace::std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//直接赋值法</span><br><span class="line">	map&lt;string, int&gt; m1;</span><br><span class="line">	m1[string(&quot;abc&quot;)] = 1;</span><br><span class="line">	m1[string(&quot;defg&quot;)] = 2;</span><br><span class="line"> </span><br><span class="line">	//用insert添加</span><br><span class="line">	map&lt;string, int&gt; m2;</span><br><span class="line">	m2.insert(&#123; string(&quot;abc&quot;), 1 &#125;);</span><br><span class="line">	m2.insert(make_pair(string(&quot;defg&quot;), 2));</span><br><span class="line">	m2.insert(pair&lt;string, int&gt;(string(&quot;hijk&quot;), 3));</span><br><span class="line"> </span><br><span class="line">	//打印 m1,m2</span><br><span class="line">	auto it1 = m1.begin();</span><br><span class="line">	cout &lt;&lt; &quot;m1：&quot; &lt;&lt; endl;</span><br><span class="line">	while (it1 != m1.end())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it1-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it1-&gt;second &lt;&lt; endl;</span><br><span class="line">		it1++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;&quot;m2:&quot; &lt;&lt; endl;</span><br><span class="line">	auto it2 = m2.begin();</span><br><span class="line">	while (it2 != m2.end())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it2-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it2-&gt;second &lt;&lt; endl;</span><br><span class="line">		it2++;</span><br><span class="line">	&#125;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>百练2815 城堡问题</title>
    <url>/2018/11/13/max-element-1/</url>
    <content><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx7typpua6j30nu0b4q9b.jpg" alt="image"><br><a id="more"></a><br>样例输入</p>
<p>4</p>
<p>7</p>
<p>11 6 11 6 3 10 6</p>
<p>7 9 6 13 5 15 5</p>
<p>1 10 12 7 13 7 5</p>
<p>13 11 10 8 10 12 13</p>
<p> 样例输出</p>
<p>5</p>
<p>9</p>
<p>1表示西墙，2表示北墙，4表示东墙，8表<br>示南墙。每个方块用代表其周围墙的数字之<br>和表示。</p>
<!--more-->
<h2 id="dfs递归"><a href="#dfs递归" class="headerlink" title="dfs递归"></a>dfs递归</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX 50</span><br><span class="line">int fang[MAX][MAX];</span><br><span class="line">int color[MAX][MAX];</span><br><span class="line">int colornum=0,maxroom=0,roomArea;</span><br><span class="line">using namespace std;</span><br><span class="line">void dfs(int i,int j)&#123;</span><br><span class="line">	if(color[i][j]) return;</span><br><span class="line">	else&#123;</span><br><span class="line">		color[i][j]=colornum;</span><br><span class="line">		roomArea++; </span><br><span class="line">		if((fang[i][j]&amp;1)==0) dfs(i,j-1);</span><br><span class="line">		if((fang[i][j]&amp;2)==0) dfs(i-1,j);</span><br><span class="line">		if((fang[i][j]&amp;4)==0) dfs(i,j+1);		</span><br><span class="line">		if((fang[i][j]&amp;8)==0) dfs(i+1,j);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int m,n;</span><br><span class="line">int main()&#123;</span><br><span class="line">	freopen(&quot;11-14.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">	memset(color,0,sizeof(color));</span><br><span class="line">	memset(fang,0,sizeof(fang));	</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;fang[i][j];</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(!color[i][j])&#123;</span><br><span class="line">		</span><br><span class="line">			colornum++;</span><br><span class="line">			roomArea=0; </span><br><span class="line">			dfs(i,j);</span><br><span class="line">			maxroom=max(maxroom,roomArea);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;colornum&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;maxroom&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#define MAX 50</span><br><span class="line">int fang[MAX][MAX];</span><br><span class="line">int color[MAX][MAX];</span><br><span class="line">int colornum=0,maxroom=0,roomArea;</span><br><span class="line">using namespace std;</span><br><span class="line">struct room&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">	room(int xx,int yy):x(xx),y(yy)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line">void dfs(int i,int j)&#123;//一条路走到黑 </span><br><span class="line">	stack&lt;room&gt; s;</span><br><span class="line">	s.push(room(i,j));</span><br><span class="line">	while(!s.empty())&#123;</span><br><span class="line">		room r=s.top();</span><br><span class="line">			    int rx=r.x;</span><br><span class="line">		int ry=r.y; </span><br><span class="line">		if(color[rx][ry])s.pop();//!!! </span><br><span class="line">			else&#123;</span><br><span class="line"></span><br><span class="line">	color[rx][ry]=colornum;</span><br><span class="line">	roomArea++;</span><br><span class="line">    	if((fang[rx][ry]&amp;1)==0) s.push(room(rx,ry-1));//</span><br><span class="line">    	if((fang[rx][ry]&amp;2)==0) s.push(room(rx-1,ry)); </span><br><span class="line">    	if((fang[rx][ry]&amp;4)==0) s.push(room(rx,ry+1)); </span><br><span class="line">    	if((fang[rx][ry]&amp;8)==0) s.push(room(rx+1,ry)); 								           	</span><br><span class="line">	                                                                  </span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">int m,n;</span><br><span class="line">int main()&#123;</span><br><span class="line">	freopen(&quot;11-14.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">	memset(color,0,sizeof(color));</span><br><span class="line">	memset(fang,0,sizeof(fang));	</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;fang[i][j];</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(!color[i][j])&#123;</span><br><span class="line">		</span><br><span class="line">			colornum++;</span><br><span class="line">			roomArea=0; </span><br><span class="line">			dfs(i,j);</span><br><span class="line">			maxroom=max(maxroom,roomArea);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;colornum&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;maxroom&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>最长上升子序列(百练2757)</title>
    <url>/2018/11/13/max-element-2/</url>
    <content><![CDATA[<p>最长上升子序列(百练2757)<br><a id="more"></a></p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个数的序列ai，当a 1 &lt; a 2 &lt; … &lt; a S 的时候，我们称这个<br>序列是上升的。对于给定的一个序列(a 1 , a 2 , …, a N )，我们可<br>以得到一些上升的子序列(a i1 , a i2 , …, a iK )，这里1 &lt;= i1 &lt;<br>i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，<br>有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序<br>列中最长的长度是4，比如子序列(1, 3, 5, 8).<br>你的任务，就是对于给定的序列，求出最长上升子序列的长度</p>
<p>输入数据</p>
<p>输入的第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出<br>序列中的N个整数，这些整数的取值范围都在0到10000。</p>
<p>输出要求</p>
<p>最长上升子序列的长度。</p>
<p>输入样例</p>
<p>7</p>
<p>1 7 3 5 9 4 8</p>
<p>输出样例</p>
<p>4</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求序列的前n个元素的最长上升子序列的长度”是个<br>子问题，但这样分解子问题，不具有“无后效性”</p>
<p>子问题：求以a k （k=1, 2, 3…N）为终点的最长上升子序列的<br>长度”</p>
<p>一个上升子序列中最右边的那个数，称为该子序列的<br>“终点”。<br>虽然这个子问题和原问题形式上并不完全一样，但<br>是只要这N个子问题都解决了，那么这N个子问题的解中，<br>最大的那个就是整个问题的解。</p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx6gytn70ij30pu0b5q9h.jpg" alt="image"></p>
<h2 id="人人为我型递推"><a href="#人人为我型递推" class="headerlink" title="人人为我型递推"></a>人人为我型递推</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">int a[MAX];</span><br><span class="line">int maxLen[MAX];</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	cin&gt;&gt;a[i];		</span><br><span class="line">	maxLen[i]=1;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">			if(a[i]&gt;a[j])</span><br><span class="line">			maxLen[i]=max(maxLen[j]+1,maxLen[i]);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//	int max=0;</span><br><span class="line">//	for(int i=0;i&lt;n;i++)</span><br><span class="line">//	if(maxLen[i]&gt;max) max=maxLen[i];</span><br><span class="line">//	cout&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;*max_element(maxLen,maxLen+n)&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="我为人人型递推"><a href="#我为人人型递推" class="headerlink" title="我为人人型递推"></a>我为人人型递推</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">int a[MAX];</span><br><span class="line">int maxLen[MAX];</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	cin&gt;&gt;a[i];		</span><br><span class="line">	maxLen[i]=1;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=i+1;j&lt;n;j++)&#123;</span><br><span class="line">			if(a[j]&gt;a[i])</span><br><span class="line">			maxLen[j]=max(maxLen[i]+1,maxLen[j]);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//	int max=0;</span><br><span class="line">//	for(int i=0;i&lt;n;i++)</span><br><span class="line">//	if(maxLen[i]&gt;max) max=maxLen[i];</span><br><span class="line">//	cout&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;*max_element(maxLen,maxLen+n)&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx66sixf2rj30cg06a0tg.jpg" alt="image"></p>
]]></content>
  </entry>
  <entry>
    <title>min_element和max_element用法</title>
    <url>/2018/11/13/max-element-3/</url>
    <content><![CDATA[<p>C++ STL 求向量中的最大值和最小值max_element min_element<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n[]=&#123;1,4,22,3,8,5&#125;;</span><br><span class="line">	int len=sizeof(n)/sizeof(int);</span><br><span class="line">	cout&lt;&lt;*max_element(n,n+len)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;*min_element(n,n+len)&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// min_element/max_element example</span><br><span class="line">#include &lt;iostream&gt;     // std::cout</span><br><span class="line">#include &lt;algorithm&gt;    // std::min_element, std::max_element</span><br><span class="line"></span><br><span class="line">bool myfn(int i, int j) &#123; return i&lt;j; &#125;</span><br><span class="line"></span><br><span class="line">struct myclass &#123;</span><br><span class="line">  bool operator() (int i,int j) &#123; return i&lt;j; &#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">  int myints[] = &#123;3,7,2,5,6,4,9&#125;;</span><br><span class="line"></span><br><span class="line">  // using default comparison:</span><br><span class="line">  std::cout &lt;&lt; &quot;The smallest element is &quot; &lt;&lt; *std::min_element(myints,myints+7) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">  std::cout &lt;&lt; &quot;The largest element is &quot;  &lt;&lt; *std::max_element(myints,myints+7) &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  // using function myfn as comp:</span><br><span class="line">  std::cout &lt;&lt; &quot;The smallest element is &quot; &lt;&lt; *std::min_element(myints,myints+7,myfn) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">  std::cout &lt;&lt; &quot;The largest element is &quot;  &lt;&lt; *std::max_element(myints,myints+7,myfn) &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  // using object myobj as comp:</span><br><span class="line">  std::cout &lt;&lt; &quot;The smallest element is &quot; &lt;&lt; *std::min_element(myints,myints+7,myobj) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">  std::cout &lt;&lt; &quot;The largest element is &quot;  &lt;&lt; *std::max_element(myints,myints+7,myobj) &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/A_Eagle/article/details/7373165" target="_blank" rel="noopener">https://blog.csdn.net/A_Eagle/article/details/7373165</a></p>
]]></content>
  </entry>
  <entry>
    <title>memset 为Int型数组初始化问题</title>
    <url>/2018/11/21/memset%E4%B8%BAInt%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>原型：extern void <em>memset(void </em>buffer, int c, int count);</p>
<p>功能：把buffer所指内存区域的前count个字节设置成字符c。<br><a id="more"></a><br>包含头文件：&lt;string.h&gt;</p>
<p>注意这个函数是字符串函数，所以一定要包含字符串头文件。</p>
<p>使用方法：</p>
<p>int a[50];</p>
<p>memset(a,0,sizeof(a));</p>
<p>这样呢，就将数组a内所有的值都赋成0了，sizeof是一个一元操作符，得到数组a的字节大小。</p>
<p>另外需要注意的是，memset函数是逐字节进行填充，所以a一般为char <em>型。对于其它类型的a，可以填充的值有两个，0和-1。因为计算机中用二进制补码表示数字，0和二进制补码为全0，-1的二进制补码为全1。<br>memset是按字节一个一个的设置，比如把整型数a设置为1，int是32位的共四个字节，每个字节设置为1，则为00000001 00000001 00000001 00000001转为十进制数是1+1</em>2^8+1<em>2^16+1</em>2^24=16843009，而不是1。</p>
<p>-1为 11111111 11111111 11111111 11111111（two’s complement负数补码），转化后为-1</p>
]]></content>
  </entry>
  <entry>
    <title>poj1724 ROADS</title>
    <url>/2018/11/14/max-element/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>N个城市，编号1到N。城市间有R条单向道路。<br>每条道路连接两个城市，有长度和过路费两个属性。<br>Bob只有K块钱，他想从城市1走到城市N。问最短共需要走多长的路。如果到不了N，输<br>出-1</p>
<p>2&lt;=N&lt;=100</p>
<p>0&lt;=K&lt;=10000</p>
<p>1&lt;=R&lt;=10000</p>
<p>每条路的长度 L, 1 &lt;= L &lt;= 100</p>
<p>每条路的过路费T , 0 &lt;= T &lt;= 100<br><a id="more"></a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从城市 1开始深度优先遍历整个图，找到所有能到达 N 的走法，<br>选一个最优的。<br>优化：</p>
<p>1) 如果当前已经找到的最优路径长度为L ,那么在继续搜索的过程中，总长度已经大<br>于L的走法，就可以直接放弃，不用走到底了</p>
<p>2) 用midL[k][m] 表示：走到城市k时总过路费为m的条件下，最优路径的长度。若在<br>后续的搜索中，再次走到k时，如果总路费恰好为m，且此时的路径长度已经超过<br>midL[k][m],则不必再走下去了</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">int k,N,r,totalLen,totalCost; </span><br><span class="line">using namespace std;</span><br><span class="line">int vis[MAX]; </span><br><span class="line">//minL[i][j]表示走到i城市 总过路费为J的条件下 最优路径的长度 </span><br><span class="line">int minL[110][10100];</span><br><span class="line">int minLen=1&lt;&lt;30;//</span><br><span class="line">struct road&#123;</span><br><span class="line">	int d,l,t;</span><br><span class="line">	road(int dd,int ll,int tt):d(dd),l(ll),t(tt)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line">vector&lt;vector&lt;road&gt; &gt; v(110);//!!</span><br><span class="line"></span><br><span class="line">//起点从N开始 </span><br><span class="line">void dfs(int n)&#123;</span><br><span class="line">	//递归出口 走到第n个城市 </span><br><span class="line">	if(n==N)&#123;</span><br><span class="line">		minLen = min(minLen,totalLen);//!!!可能不只一条 </span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;v[n].size();i++)&#123;//起点为N的road数量 </span><br><span class="line">		int d=v[n][i].d;//所到达的城市</span><br><span class="line">		if(!vis[d])&#123;</span><br><span class="line"></span><br><span class="line">				if(totalCost+v[n][i].t&gt;k) continue;</span><br><span class="line">					//终点为n 花费同样多时 最短的路径数量 </span><br><span class="line">					if(totalLen+v[n][i].l&gt;minLen||totalLen+v[n][i].l&gt;minL[d][totalCost+v[n][i].t])//!!</span><br><span class="line">						continue; </span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">			totalCost+=v[n][i].t;</span><br><span class="line">			totalLen+=v[n][i].l;</span><br><span class="line">			minL[d][totalCost]=totalLen;</span><br><span class="line">			</span><br><span class="line">				vis[d]=1;</span><br><span class="line">				dfs(d);</span><br><span class="line">				vis[d]=0;</span><br><span class="line">			totalCost-=v[n][i].t;</span><br><span class="line">			totalLen-=v[n][i].l;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//钱 城市数 路数 </span><br><span class="line">	cin&gt;&gt;k&gt;&gt;N&gt;&gt;r;</span><br><span class="line">	for(int i=0;i&lt;r;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int s,e,l,r;</span><br><span class="line">		cin&gt;&gt;s&gt;&gt;e&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		if(s!=e)</span><br><span class="line">		v[s].push_back(road(e,l,r));//!!终点 长度 费用 </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	for( int i = 0;i &lt; 110; ++i )</span><br><span class="line">	for( int j = 0; j &lt; 10100; ++ j )</span><br><span class="line">	minL[i][j] = 1 &lt;&lt; 30;</span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">	totalLen = 0;</span><br><span class="line">	totalCost = 0;</span><br><span class="line">	vis[1] = 1;</span><br><span class="line">	minLen = 1 &lt;&lt; 30;</span><br><span class="line">	dfs(1);</span><br><span class="line">	if( minLen &lt; (1 &lt;&lt; 30))</span><br><span class="line">	cout &lt;&lt; minLen &lt;&lt; endl;</span><br><span class="line">	else</span><br><span class="line">	cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>memset和fill函数区别及用法</title>
    <url>/2019/03/06/memset%E5%92%8Cfill%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>memset 函数， fill 函数的区别及应用：</p>
<ul>
<li>memset函数：</li>
</ul>
<p>1：按照字节赋值</p>
<p>2：头文件在<cstring>中<br><a id="more"></a><br>注：由于memset函数是按照字节赋值的，所以对int型数组用该函数时，只能是1或-1，否则会出错，这里，不管数组是多少维的，语法均为：</cstring></p>
<pre><code>int dp[84][84][84][2];
memset(dp, 0, sizeof(dp)); //只能赋值0或-1
</code></pre><p>memset函数还有一个玄学的问题就是，容易TLE，又一次多效的一个题，一直T，把memset换成for循环就AC了，注意，for循环跑遍了所有的数组单元！！！</p>
<ul>
<li>fill函数：</li>
</ul>
<p>1：按照变量类型单元赋值，将区间 [first, end) 中的每个单元都赋为同一个值。</p>
<p>2：头文件在<algorithm>中</algorithm></p>
<p>以下是cplusplus官网代码：</p>
<p>// fill algorithm example</p>
<p>#include <iostream>     // std::cout</iostream></p>
<p>#include <algorithm>    // std::fill</algorithm></p>
<p>#include <vector>       // std::vector</vector></p>
<p>int main () {<br>  std::vector<int> myvector (8);                       // myvector: 0 0 0 0 0 0 0 0</int></p>
<p>  std::fill (myvector.begin(),myvector.begin()+4,5);   // myvector: 5 5 5 5 0 0 0 0<br>  std::fill (myvector.begin()+3,myvector.end()-2,8);   // myvector: 5 5 5 8 8 8 0 0</p>
<p>  std::cout &lt;&lt; “myvector contains:”;<br>  for (std::vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)<br>    std::cout &lt;&lt; ‘ ‘ &lt;&lt; *it;<br>  std::cout &lt;&lt; ‘\n’;</int></p>
<p>  return 0;<br>}</p>
<p>我们可以直接给一维数组赋值：</p>
<p> int a[4] = {1, 1, 1, 1};<br>    fill(a, a+2, 284);<br>    // 284 284 1 1</p>
<p>当要给多维数组赋值时，这里的区间[first, end)都是指针地址，参看如下赋值方法：</p>
<pre><code>int dp[84][84][84][2];
fill((int*)dp, (int*)dp + 84 * 84 * 84 * 2, INF);
</code></pre><p>如上所说，[first, end)都是指针地址，并且是一维的，由于多维数组在内存空间中连续性，可将(int <em>**</em>)的变量类型dp转化为(int *)类型，得到了dp的首地址，然后按照其区间给其赋值。</p>
<hr>
<p>作者：Southan97<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/Mrx_Nh/article/details/70858385" target="_blank" rel="noopener">https://blog.csdn.net/Mrx_Nh/article/details/70858385</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>next_permutation的使用</title>
    <url>/2018/11/03/next-permutation%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>全排列算法，然后发现C++的STL有一个函数可以方便地生成全排列，这就是next_permutation<br><a id="more"></a></p>
<p>#include <algorithm><br>bool next_permutation( iterator start, iterator end );</algorithm></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    sort(str.begin(), str.end());</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    while (next_permutation(str.begin(), str.end()))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>numpy.random的函数</title>
    <url>/2018/09/23/numpy-random-randn-%E4%B8%8Erand-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="rand函数"><a href="#rand函数" class="headerlink" title="rand函数"></a>rand函数</h2><p>numpy.random.rand(d0,d1,…,dn)<br><a id="more"></a></p>
<ul>
<li>rand函数根据给定维度生成[0,1)之间的数据，包含0，不包含1</li>
<li>dn表格每个维度</li>
<li>返回值为指定维度的array</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> np.random.rand(4,2)</span><br><span class="line">array([[ 0.02173903,  0.44376568],</span><br><span class="line">       [ 0.25309942,  0.85259262],</span><br><span class="line">       [ 0.56465709,  0.95135013],</span><br><span class="line">       [ 0.14145746,  0.55389458]])</span><br></pre></td></tr></table></figure>
<h2 id="numpy-random-randn函数"><a href="#numpy-random-randn函数" class="headerlink" title="numpy.random.randn函数"></a>numpy.random.randn函数</h2><p>numpy.random.randn(d0, d1, …, dn)是从标准正态分布中返回一个或多个样本值。<br>numpy.random.rand(d0, d1, …, dn)的随机样本位于[0, 1)中。</p>
<ul>
<li>randn函数返回一个或一组样本，具有标准正态分布。</li>
<li>dn表格每个维度</li>
<li>返回值为指定维度的array</li>
</ul>
<p>标准正态分布是以0为均数、以1为标准差的正态分布，记为N（0，1）。对应的正态分布曲线如下所示，即 </p>
<hr>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fvjjjdynohj30dq0b1mxz.jpg" alt></p>
<h2 id="numpy-random-randint函数"><a href="#numpy-random-randint函数" class="headerlink" title="numpy.random.randint函数"></a>numpy.random.randint函数</h2><p>numpy.random.randint(low, high=None, size=None, dtype=’l’)</p>
<p>返回随机整数，范围区间为[low,high），包含low，不包含high<br>参数：low为最小值，high为最大值，size为数组维度大小，dtype为数据类型，默认的数据类型是np.int<br>high没有填写时，默认生成随机数的范围是[0，low)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">np.random.randint(1,size=5) # 返回[0,1)之间的整数，所以只有0</span><br><span class="line">array([0, 0, 0, 0, 0])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">np.random.randint(-5,5,size=(2,2))</span><br><span class="line"></span><br><span class="line">array([[ 2, -1],</span><br><span class="line">       [ 2,  0]])</span><br></pre></td></tr></table></figure>
<h2 id="numpy-random-choice函数"><a href="#numpy-random-choice函数" class="headerlink" title="numpy.random.choice函数"></a>numpy.random.choice函数</h2><hr>
<p>numpy.random.choice(a, size=None, replace=True, p=None)</p>
<ul>
<li>从给定的一维数组中生成随机数</li>
<li>参数： a为一维数组类似数据或整数；size为数组维度；p为数组中的数据出现的概率</li>
<li>a为整数时，对应的一维数组为np.arange(a)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">np.random.choice(5,3)</span><br><span class="line">array([4, 1, 4])</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**当replace为False时，生成的随机数不能有重复的数值**</span><br></pre></td></tr></table></figure>
<p>demo_list = [‘lenovo’, ‘sansumg’,’moto’,’xiaomi’, ‘iphone’]<br>np.random.choice(demo_list,size=(3,3), p=[0.1,0.6,0.1,0.1,0.1])</p>
<p>array([[‘sansumg’, ‘sansumg’, ‘sansumg’],<br>       [‘sansumg’, ‘sansumg’, ‘sansumg’],<br>       [‘sansumg’, ‘xiaomi’, ‘iphone’]],<br>      dtype=’&lt;U7’)<br><code>`</code></p>
<p><strong>参数p的长度与参数a的长度需要一致；<br>参数p为概率，p里的数据之和应为1</strong></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/zenghaitao0128/article/details/78556535" target="_blank" rel="noopener">https://blog.csdn.net/zenghaitao0128/article/details/78556535</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>numpy中的dtype和astype</title>
    <url>/2018/09/22/numpy%E4%B8%AD%E7%9A%84dtype%E5%92%8Castype/</url>
    <content><![CDATA[<p>1、查看数据类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [11]: arr = np.array([1,2,3,4,5])</span><br><span class="line"></span><br><span class="line">In [12]: arr</span><br><span class="line">Out[12]: array([1, 2, 3, 4, 5])</span><br><span class="line"></span><br><span class="line">// 该命令查看数据类型</span><br><span class="line">In [13]: arr.dtype</span><br><span class="line">Out[13]: dtype(&apos;int64&apos;)</span><br><span class="line"></span><br><span class="line">In [14]: float_arr = arr.astype(np.float64)</span><br><span class="line"></span><br><span class="line">// 该命令查看数据类型</span><br><span class="line">In [15]: float_arr.dtype</span><br><span class="line">Out[15]: dtype(&apos;float64&apos;)</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>2、转换数据类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如果将浮点数转换为整数，则小数部分会被截断</span><br><span class="line">In [7]: arr2 = np.array([1.1, 2.2, 3.3, 4.4, 5.3221])</span><br><span class="line"></span><br><span class="line">In [8]: arr2</span><br><span class="line">Out[8]: array([ 1.1   ,  2.2   ,  3.3   ,  4.4   ,  5.3221])</span><br><span class="line"></span><br><span class="line">// 查看当前数据类型</span><br><span class="line">In [9]: arr2.dtype</span><br><span class="line">Out[9]: dtype(&apos;float64&apos;)</span><br><span class="line"></span><br><span class="line">// 转换数据类型  float -&gt; int</span><br><span class="line">In [10]: arr2.astype(np.int32)</span><br><span class="line">Out[10]: array([1, 2, 3, 4, 5], dtype=int32)</span><br></pre></td></tr></table></figure></p>
<p>3、字符串数组转换为数值型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [4]: numeric_strings = np.array([&apos;1.2&apos;,&apos;2.3&apos;,&apos;3.2141&apos;], dtype=np.string_)</span><br><span class="line"></span><br><span class="line">In [5]: numeric_strings</span><br><span class="line">Out[5]: array([&apos;1.2&apos;, &apos;2.3&apos;, &apos;3.2141&apos;], dtype=&apos;|S6&apos;)</span><br><span class="line"></span><br><span class="line">// 此处写的是float 而不是np.float64, Numpy很聪明，会将python类型映射到等价的dtype上</span><br><span class="line">In [6]: numeric_strings.astype(float)</span><br><span class="line">Out[6]: array([ 1.2, 2.3, 3.2141])</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>numpy中的ravel()、flatten()、squeeze()的用法与区别</title>
    <url>/2018/09/23/numpy%E4%B8%AD%E7%9A%84ravel-%E3%80%81flatten-%E3%80%81squeeze-%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>numpy中的ravel()、flatten()、squeeze()都有将多维数组转换为一维数组的功能，区别：<br>ravel()：如果没有必要，不会产生源数据的副本<br>flatten()：返回源数据的副本<br>squeeze()：只能对维数为1的维度降维<br><a id="more"></a><br>另外，reshape(-1)也可以“拉平”多维数组</p>
<p><img src="https://img-blog.csdn.net/20180109095535985?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHltYXRsYWI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/iamzhangzhuping/article/details/52366568" target="_blank" rel="noopener">https://blog.csdn.net/iamzhangzhuping/article/details/52366568</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>numpy中的permutation函数</title>
    <url>/2018/09/23/numpy%E4%B8%AD%E7%9A%84permutation/</url>
    <content><![CDATA[<p>numpy.random.shuffle(x) and numpy.random.permutation(x)</p>
<p>np.random.permutation与np.random.shuffle有两处不同：</p>
<p>如果传给permutation一个矩阵，它会返回一个洗牌后的矩阵副本；而shuffle只是对一个矩阵进行洗牌，无返回值。<br><a id="more"></a><br>如果传入一个整数，它会返回一个洗牌后的arange。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def permutation(self, object x):</span><br><span class="line">    if isinstance(x, (int, np.integer)):</span><br><span class="line">         arr = np.arange(x)</span><br><span class="line">     else:</span><br><span class="line">        arr = np.array(x)</span><br><span class="line">     self.shuffle(arr)</span><br><span class="line">     return arr</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>numpy的argmax函数</title>
    <url>/2018/09/23/numpy%E7%9A%84argmax%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>numpy.argmax(a, axis=None, out=None)<br>返回沿轴axis最大值的索引。</p>
<a id="more"></a>
<p>Parameters:<br>a : array_like<br>数组<br>axis : int, 可选<br>默认情况下，索引的是平铺的数组，否则沿指定的轴。<br>out : array, 可选<br>如果提供，结果以合适的形状和类型被插入到此数组中。<br>Returns:<br>index_array : ndarray of ints<br>索引数组。它具有与a.shape相同的形状，其中axis被移除。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = np.arange(6).reshape(2,3)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([[0, 1, 2],</span><br><span class="line">       [3, 4, 5]])</span><br><span class="line">&gt;&gt;&gt; np.argmax(a)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; np.argmax(a, axis=0)#0代表列</span><br><span class="line">array([1, 1, 1])</span><br><span class="line">&gt;&gt;&gt; np.argmax(a, axis=1)#1代表行</span><br><span class="line">array([2, 2])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; b = np.arange(6)</span><br><span class="line">&gt;&gt;&gt; b[1] = 5</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">array([0, 5, 2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; np.argmax(b) # 只返回第一次出现的最大值的索引</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/lemonbit/p/6864179.html" target="_blank" rel="noopener">https://www.cnblogs.com/lemonbit/p/6864179.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>numpy的concatenate函数</title>
    <url>/2018/09/22/numpy%E7%9A%84concatenate%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>concatenate((a1, a2, …), axis=0)<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">concatenate(...)</span><br><span class="line">    concatenate((a1, a2, ...), axis=0)</span><br><span class="line"></span><br><span class="line">    Join a sequence of arrays along an existing axis.</span><br><span class="line"></span><br><span class="line">    Parameters</span><br><span class="line">    ----------</span><br><span class="line">    a1, a2, ... : sequence of array_like</span><br><span class="line">        The arrays must have the same shape, except in the dimension</span><br><span class="line">        corresponding to `axis` (the first, by default).</span><br><span class="line">    axis : int, optional</span><br><span class="line">        The axis along which the arrays will be joined.  Default is 0.</span><br><span class="line"></span><br><span class="line">    Returns</span><br><span class="line">    -------</span><br><span class="line">    res : ndarray</span><br><span class="line">        The concatenated array.</span><br><span class="line"></span><br><span class="line">    See Also</span><br><span class="line">    --------</span><br></pre></td></tr></table></figure></p>
<h2 id="Parameters参数"><a href="#Parameters参数" class="headerlink" title="Parameters参数"></a>Parameters参数</h2><p>传入的参数必须是一个多个数组的元组或者列表</p>
<p>另外需要指定拼接的方向，默认是 axis = 0，也就是说对0轴的数组对象进行纵向的拼接（纵向的拼接沿着axis= 1方向）；注：一般axis = 0，就是对该轴向的数组进行操作，操作方向是另外一个轴，即axis=1。<br>拼接的数组要满足在拼接方向axis轴上数组间的形状一致即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([[1, 2], [3, 4]])</span><br><span class="line">b = np.array([[5, 6]])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">np.concatenate((a, b), axis=0)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array([[1, 2],</span><br><span class="line">       [3, 4],</span><br><span class="line">       [5, 6]])</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>numpy的isin函数</title>
    <url>/2018/09/23/numpy%E7%9A%84isin%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>numpy.isin(element, test_elements, assume_unique=False, invert=False)<br><a id="more"></a></p>
<p>Parameters:    </p>
<ul>
<li><p>element : array_like Input array.</p>
</li>
<li><p>test_elements : array_like</p>
</li>
</ul>
<p>The values against which to test each value of element. This argument is flattened if it is an array or array_like. See notes for behavior with non-array-like parameters.</p>
<ul>
<li>assume_unique : bool, optional</li>
</ul>
<p>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</p>
<ul>
<li>invert : bool, optional</li>
</ul>
<p>If True, the values in the returned array are inverted, as if calculating element not in test_elements. Default is False. np.isin(a, b, invert=True) is equivalent to (but faster than) np.invert(np.isin(a, b)).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; element = 2*np.arange(4).reshape((2, 2))</span><br><span class="line">&gt;&gt;&gt; element</span><br><span class="line">array([[0, 2],</span><br><span class="line">       [4, 6]])</span><br><span class="line">&gt;&gt;&gt; test_elements = [1, 2, 4, 8]</span><br><span class="line">&gt;&gt;&gt; mask = np.isin(element, test_elements)</span><br><span class="line">&gt;&gt;&gt; mask</span><br><span class="line">array([[ False,  True],</span><br><span class="line">       [ True,  False]], dtype=bool)</span><br><span class="line">&gt;&gt;&gt; element[mask]</span><br><span class="line">array([2, 4])</span><br><span class="line">&gt;&gt;&gt; mask = np.isin(element, test_elements, invert=True)</span><br><span class="line">&gt;&gt;&gt; mask</span><br><span class="line">array([[ True, False],</span><br><span class="line">       [ False, True]], dtype=bool)</span><br><span class="line">&gt;&gt;&gt; element[mask]</span><br><span class="line">array([0, 6])</span><br><span class="line">Because of how array handles sets, the following does not work as expected:</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; test_set = &#123;1, 2, 4, 8&#125;</span><br><span class="line">&gt;&gt;&gt; np.isin(element, test_set)</span><br><span class="line">array([[ False, False],</span><br><span class="line">       [ False, False]], dtype=bool)</span><br><span class="line">Casting the set to a list gives the expected result:</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.isin(element, list(test_set))</span><br><span class="line">array([[ False,  True],</span><br><span class="line">       [ True,  False]], dtype=bool)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>n皇后问题</title>
    <url>/2018/10/29/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>回溯法<br><a id="more"></a><br>a数组 填入一个元素开始向列，正对角线，反对角线试探<br>disp 数组记录一组成功的解</p>
<p> 基本思路如上面分析一致，我们采用逐步试探的方式，先从一个方向往前走，能进则进，不能进则退，尝试另外的路径。首先我们来分析一下国际象棋的规则，这些规则能够限制我们的前进，也就是我们前进途中的障碍物。一个皇后q(x,y)能被满足以下条件的皇后q(row,col)吃掉</p>
<p>1）x=row(在纵向不能有两个皇后)</p>
<p>2)  y=col（横向）</p>
<p>3）col + row = y+x;（斜向正方向）</p>
<p>4)  col - row = y-x;（斜向反方向）</p>
<p>遇到上述问题之一的时候，说明我们已经遇到了障碍，不能继续向前了。我们需要退回来，尝试其他路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//tot解决方案</span><br><span class="line">int n,tot=0; </span><br><span class="line">int a[100];</span><br><span class="line">int disp[16];</span><br><span class="line">void search(int cur)&#123;</span><br><span class="line">	if(cur==n)&#123;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">			cout&lt;&lt;disp[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		tot++;</span><br><span class="line">	&#125; </span><br><span class="line">else for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	bool ok=true;</span><br><span class="line">	a[cur]=i;</span><br><span class="line">	for(int j=0;j&lt;cur;j++)&#123;</span><br><span class="line">	if(a[cur]==a[j]||a[cur]-a[j]==cur-j||a[cur]+cur==a[j]+j)</span><br><span class="line">	&#123;</span><br><span class="line">		ok=false;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	if(ok) &#123;</span><br><span class="line">		disp[cur]=i;</span><br><span class="line">		search(cur+1);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line"> memset(a, 0, sizeof(a));</span><br><span class="line">	search(0);</span><br><span class="line">	cout&lt;&lt;tot&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以不用disp数组<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,tot=0; </span><br><span class="line">int a[100];</span><br><span class="line"></span><br><span class="line">void search(int cur)&#123;</span><br><span class="line">	if(cur==n)&#123;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">			cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		tot++;</span><br><span class="line">	&#125; </span><br><span class="line">else for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	bool ok=true;</span><br><span class="line">	a[cur]=i;</span><br><span class="line">	for(int j=0;j&lt;cur;j++)&#123;</span><br><span class="line">	if(a[cur]==a[j]||a[cur]-a[j]==cur-j||a[cur]+cur==a[j]+j)</span><br><span class="line">	&#123;</span><br><span class="line">		ok=false;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	if(ok) &#123;</span><br><span class="line">		a[cur]=i;</span><br><span class="line">		search(cur+1);/递归深度优先搜索解空间树</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">	a[cur]=0;////这句代码就是实现回溯到上一层</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line"> memset(a, 0, sizeof(a));</span><br><span class="line">	search(0);</span><br><span class="line">	cout&lt;&lt;tot&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似解法<br>直接用vis数组判断三个条件;</p>
<ul>
<li><p>当前要填的是否与之前列冲突</p>
</li>
<li><p>行+列是否为定值</p>
</li>
<li><p>行-列是否为定值</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxN = 50;</span><br><span class="line">int n, tot, pos[MaxN];</span><br><span class="line">bool vis[3][MaxN];</span><br><span class="line"></span><br><span class="line">void dfs(int cur)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    if (cur == n) tot++;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        if (!vis[0][i] &amp;&amp; !vis[1][cur + i] &amp;&amp; !vis[2][cur - i + n])</span><br><span class="line">        &#123;</span><br><span class="line">            pos[cur] = i;</span><br><span class="line">            vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 1;</span><br><span class="line">            dfs(cur + 1);</span><br><span class="line">            vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    #define QUERY(X) &#123; \</span><br><span class="line">                n = X, tot = 0; \</span><br><span class="line">                memset(vis, 0, sizeof(vis)); \</span><br><span class="line">                dfs(0); cout &lt;&lt; tot &lt;&lt; endl; \</span><br><span class="line">                &#125;</span><br><span class="line">    QUERY(8);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考网站<br><a href="http://www.cnblogs.com/jillzhang/archive/2007/10/21/922830.html" target="_blank" rel="noopener">http://www.cnblogs.com/jillzhang/archive/2007/10/21/922830.html</a><br><a href="https://github.com/zhsj/nqueen/blob/master/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.md" target="_blank" rel="noopener">https://github.com/zhsj/nqueen/blob/master/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.md</a><br><a href="http://www.cnblogs.com/grandyang/p/4377782.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4377782.html</a><br><a href="https://blog.csdn.net/qinghezhen/article/details/17849837" target="_blank" rel="noopener">https://blog.csdn.net/qinghezhen/article/details/17849837</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>DFS</category>
      </categories>
  </entry>
  <entry>
    <title>POJ3751 时间日期格式转换</title>
    <url>/2018/12/09/oj/</url>
    <content><![CDATA[<p>Description</p>
<p>世界各地有多种格式来表示日期和时间。对于日期的常用格式，在中国常采用格式的是“年年年年/月月/日日”或写为英语缩略表示的”yyyy/mm/dd”，此次编程大赛的启动日期“2009/11/07”就是符合这种格式的一个日期，而北美所用的日期格式则为“月月/日日/年年年年”或”mm/dd/yyyy”，如将“2009/11/07”改成这种格式，对应的则是”11/07/2009”。对于时间的格式，则常有12小时制和24小时制的表示方法，24小时制用0-24来表示一天中的24小时，而12小时制只采用1-12表示小时，再加上am/pm来表示上午或下午，比如”17:30:00”是采用24小时制来表示时间，而对应的12小时制的表示方法是”05:30:00pm”。注意12:00:00pm表示中午12点，而12:00:00am表示凌晨12点。<br><a id="more"></a><br>对于给定的采用”yyyy/mm/dd”加24小时制（用短横线”-”连接）来表示日期和时间的字符串，请编程实现将其转换成”mm/dd/yyyy”加12小时制格式的字符串。<br>Input</p>
<p>第一行为一个整数T（T&lt;=10），代表总共需要转换的时间日期字符串的数目。<br>接下来的总共T行，每行都是一个需要转换的时间日期字符串。<br>Output</p>
<p>分行输出转换之后的结果<br>Sample Input</p>
<p>2<br>2009/11/07-12:12:12<br>1970/01/01-00:01:01<br>Sample Output</p>
<p>11/07/2009-12:12:12pm<br>01/01/1970-12:01:01am<br>Hint</p>
<p>注意中午和凌晨时间的特殊表示</p>
<p>问题链接：POJ3751 时间日期格式转换。</p>
<p>问题分析：简单的日期时间转换，有计算，有格式转换。</p>
<!--more-->
<p>#include<iostream></iostream></p>
<p>#include<cstdio></cstdio></p>
<p>#include<string></string></p>
<p>#include&lt;stdlib.h&gt;<br>using namespace std;<br>int main(){</p>
<p>int yy,hh,cnt,mm,dd,ff,ss;<br>cin&gt;&gt;cnt;<br>for(int i=0;i&lt;cnt;i++){</p>
<pre><code>scanf(&quot;%d/%d/%d-%d:%d:%d&quot;,&amp;yy,&amp;mm,&amp;dd,&amp;hh,&amp;ff,&amp;ss);
</code></pre><p> int hour=hh;<br>    if(hh&gt;12) hour-=12;<br>    else if(hh==0) hour=12;<br>//24小时的时间<br>    if(hh&lt;12) printf(“%02d/%02d/%04d-%02d:%02d:%02da.m\n”,dd,mm,yy,hour,ff,ss);<br>    else printf(“%02d/%02d/%04d-%02d:%02d:%02dp.m\n”,dd,mm,yy,hour,ff,ss);</p>
<p>}</p>
<pre><code>return 0;
</code></pre><p>} </p>
<h2 id="关于字符串与整形的转化"><a href="#关于字符串与整形的转化" class="headerlink" title="关于字符串与整形的转化"></a>关于字符串与整形的转化</h2><p><a href="https://blog.csdn.net/caroline_wendy/article/details/29390573" target="_blank" rel="noopener">https://blog.csdn.net/caroline_wendy/article/details/29390573</a></p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 784 Letter casePermutation</title>
    <url>/2018/11/10/partition/</url>
    <content><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxfs8p5e8qj31kw16oqi3.jpg" alt="image"><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; letterCasePermutation(string S) &#123;</span><br><span class="line">        vector&lt;string&gt; ss;</span><br><span class="line">        dfs(S,0,ss);</span><br><span class="line">        return ss;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void dfs(string &amp;s,int k,vector&lt;string&gt; &amp;ss)&#123;</span><br><span class="line">    if(k==s.length()) &#123;</span><br><span class="line">        ss.push_back(s);//!!</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s,k+1,ss);//!!</span><br><span class="line">    if(!isalpha(s[k])) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        s[k]^=1&lt;&lt;5;</span><br><span class="line">        dfs(s,k+1,ss);</span><br><span class="line">        s[k]^=1&lt;&lt;5;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>opencv获取图像大小</title>
    <url>/2018/09/24/opencv%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>图像矩阵的shape属性表示图像的大小，shape会返回tuple元组，第一个元素表示矩阵行数，第二个元组表示矩阵列数，第三个元素是通道数</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">fn=&quot;baboon.jpg&quot;</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print &apos;load %s as ...&apos; % fn</span><br><span class="line">    img = cv2.imread(fn)</span><br><span class="line">    sp = img.shape</span><br><span class="line">    print sp</span><br><span class="line">    sz1 = sp[0]#height(rows) of image</span><br><span class="line">    sz2 = sp[1]#width(colums) of image</span><br><span class="line">    sz3 = sp[2]#the pixels value is made up of three primary colors</span><br><span class="line">    print &apos;width: %d \nheight: %d \nnumber: %d&apos; %(sz1,sz2,sz3)</span><br></pre></td></tr></table></figure>
<p>load baboon.jpg as …<br>(512, 512, 3)<br>width: 512<br>height: 512<br>number: 3</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>php学习笔记(一）</title>
    <url>/2018/09/03/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>PHP 是一门弱类型语言<br>不必向 PHP 声明该变量的数据类型</p>
<h2 id="PHP-变量"><a href="#PHP-变量" class="headerlink" title="PHP 变量"></a>PHP 变量</h2><ul>
<li>变量以 $ 符号开始，后面跟着变量的名称</li>
<li>变量名必须以字母或者下划线字符开始</li>
<li>变量名是区分大小写的<a id="more"></a>
作用域</li>
</ul>
<p>local</p>
<p>global</p>
<p>static</p>
<p>parameter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$x = 5;//全局变量</span><br><span class="line">function myTest()&#123;</span><br><span class="line">	$y=10;//局部变量</span><br><span class="line">	echo &quot;$y&quot;;</span><br><span class="line">	echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">	echo &quot;&lt;p&gt;hello&lt;p&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</p>
<p><strong>Static 作用域<br>当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。然后，每次调用该函数时，该变量将会保留着函数前一次被调用时的值。
</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">function myTest() </span><br><span class="line">&#123; </span><br><span class="line">static $x=0; </span><br><span class="line">echo $x; </span><br><span class="line">$x++; </span><br><span class="line">&#125; </span><br><span class="line">myTest(); </span><br><span class="line">myTest(); </span><br><span class="line">myTest(); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<h2 id="PHP-echo-print-print-r语句"><a href="#PHP-echo-print-print-r语句" class="headerlink" title="PHP echo,print,print_r语句"></a>PHP echo,print,print_r语句</h2><p>echo   - 可以输出一个或多个字符串</p>
<p>print   - 只能输出简单类型变量的值,如int,string</p>
<p>print_r - 可以输出复杂类型变量的值,如数组,对象 使用时必须加上括号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$txt1=&quot;w3cschool.cn&quot;;;</span><br><span class="line">$cars=array(&quot;ca&quot;,&quot;bmw&quot;);</span><br><span class="line">echo &quot;he  &quot;;</span><br><span class="line">echo &quot;Study PHP at $txt1&quot;;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo &quot;车品牌是&#123;$cars[0]&#125;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>echo和print功能相同 即把所有的echo换成print<br>print_r 输出复杂类型变量的值,如数组,对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$txt1=&quot;Hello World!&quot;;</span><br><span class="line">$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);</span><br><span class="line"></span><br><span class="line">print_r($txt1);</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">print_r($cars);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="php常量"><a href="#php常量" class="headerlink" title="php常量"></a>php常量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )</span><br></pre></td></tr></table></figure>
<p>name<br>常量名。</p>
<p>value<br>常量的值；在 PHP 5 中，value 必须是标量( integer、 float、string、boolean、NULL）在 PHP 7 中还允许是个 array 的值。</p>
<p>Warning<br>常量还可以定义为 resource 类型，但并不推荐这样做，因为可能会有不可预知的行为发生。</p>
<p>case_insensitive<br>如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。比如， CONSTANT 和 Constant 代表了不同的值。</p>
<h2 id="php字符串变量"><a href="#php字符串变量" class="headerlink" title="php字符串变量"></a>php字符串变量</h2><h3 id="strlen-函数"><a href="#strlen-函数" class="headerlink" title="strlen() 函数"></a>strlen() 函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo strlen(&quot;Hello world!&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<h3 id="strpos-函数"><a href="#strpos-函数" class="headerlink" title="strpos() 函数"></a>strpos() 函数</h3><p><strong><br>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo strpos(&quot;Hello world!&quot;,&quot;world&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<h2 id="php数组"><a href="#php数组" class="headerlink" title="php数组"></a>php数组</h2><p>在 PHP 中，有三种类型的数组：</p>
<h3 id="数值数组"><a href="#数值数组" class="headerlink" title="数值数组"></a>数值数组</h3><p>数值数组 - 带有数字 ID 键的数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); </span><br><span class="line">echo &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;; </span><br><span class="line">echo count($cars); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3><p>关联数组 - 带有指定的键的数组，每个键关联一个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); </span><br><span class="line">echo &quot;Peter is &quot; . $age[&apos;Peter&apos;] . &quot; years old.&quot;; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>foreach (array_expression as $value)<br>    statement<br>foreach (array_expression as $key =&gt; $value)<br>    statement</p>
<p>第一种格式遍历给定的 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p>
<p>第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 $key。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);</span><br><span class="line"></span><br><span class="line">foreach($age as $x=&gt;$x_value)&#123;</span><br><span class="line">	echo $x.&quot; &quot;.$x_value;</span><br><span class="line">	echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach($age as $x_value)&#123;</span><br><span class="line">	echo $x_value.&quot; &quot;;	</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$x=array(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;);</span><br><span class="line">foreach ($x as $value)</span><br><span class="line">&#123;</span><br><span class="line">echo $value . &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组 - 包含一个或多个数组的数组</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><ul>
<li>sort() - 对数组进行升序排列</li>
<li>rsort() - 对数组进行降序排列</li>
<li>asort() - 根据关联数组的值，对数组进行升序排列</li>
<li>ksort() - 根据关联数组的键，对数组进行升序排列</li>
<li>arsort() - 根据关联数组的值，对数组进行降序排列</li>
<li>krsort() - 根据关联数组的键，对数组进行降序排列</li>
</ul>
<h3 id="php超级全局变量"><a href="#php超级全局变量" class="headerlink" title="php超级全局变量"></a>php超级全局变量</h3><p>$GLOBALS</p>
<p>$_SERVER</p>
<p>$_REQUEST</p>
<p>$_POST</p>
<p>$_GET</p>
<p>$_FILES</p>
<p>$_ENV</p>
<p>$_COOKIE</p>
<p>$_SESSION</p>
<h3 id="php魔术常量"><a href="#php魔术常量" class="headerlink" title="php魔术常量"></a>php魔术常量</h3><p>PHP 向它运行的任何脚本提供了大量的预定义常量。</p>
<p>不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。</p>
<p>有八个魔术常量它们的值随着它们在代码中的位置改变而改变。</p>
<p><strong>LINE</strong></p>
<p>文件中的当前行号。</p>
<p><strong>FILE</strong></p>
<p>文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">echo &quot;该文件位于&apos;&quot;.__FILE__.&quot;&apos;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p><strong>DIR</strong><br>文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。</p>
<p>它等价于 dirname(<strong>FILE</strong>)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）</p>
<p><strong>FUNCTION</strong><br>函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。</p>
<p><strong>CLASS</strong><br>类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。</p>
<p>在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 <strong>CLASS</strong> 对 trait 也起作用。当用在 trait 方法中时，<strong>CLASS</strong> 是调用 trait 方法的类的名字。</p>
<p><strong>TRAIT</strong><br>Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。</p>
<p>Trait 名包括其被声明的作用区域（例如 Foo\Bar）。</p>
<p>从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。</p>
<p><strong>METHOD</strong><br>类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。</p>
<p><strong>NAMESPACE</strong><br>当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。</p>
<h2 id="php命名空间"><a href="#php命名空间" class="headerlink" title="php命名空间"></a>php命名空间</h2><p>1.用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</p>
<p>2.为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</p>
<p>默认情况下，所有常量、类和函数名都放在全局空间下，就和PHP支持命名空间之前一样。</p>
<p><strong>在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。</strong></p>
<h2 id="命名空间使用"><a href="#命名空间使用" class="headerlink" title="命名空间使用"></a>命名空间使用</h2><ul>
<li><p>非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。</p>
</li>
<li><p>限定名称,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。</p>
</li>
<li><p>完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。</p>
</li>
</ul>
<p>PHP_EOL 为换行符。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$youj = new Site;</span><br><span class="line">$taobao = new Site;</span><br><span class="line">$google = new Site;</span><br><span class="line">$youj-&gt;setTitle( &quot;W3Cschool教程&quot; );</span><br><span class="line">$youj-&gt;getTitle();</span><br><span class="line">&lt;?php</span><br><span class="line">class Site &#123;</span><br><span class="line">  /* 成员变量 */</span><br><span class="line">  var $url;</span><br><span class="line">  var $title;</span><br><span class="line">  function setTitle($par)&#123;</span><br><span class="line">     $this-&gt;title = $par;</span><br><span class="line">  &#125; </span><br><span class="line">    function getTitle()&#123;</span><br><span class="line">     echo $this-&gt;title . PHP_EOL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class MyDestructableClass &#123;</span><br><span class="line">   function __construct() &#123;</span><br><span class="line">       print &quot;构造函数\n&quot;;</span><br><span class="line">       $this-&gt;name = &quot;MyDestructableClass&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function __destruct() &#123;</span><br><span class="line">       print &quot;销毁 &quot; . $this-&gt;name . &quot;\n&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = new MyDestructableClass();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p><strong>const<strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></p>
<h3 id="public-protected-private"><a href="#public-protected-private" class="headerlink" title="public,protected,private"></a>public,protected,private</h3><p>public（公有）：公有的类成员可以在任何地方被访问。</p>
<p>protected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问。</p>
<p>private（私有）：私有的类成员则只能被其定义所在的类访问。</p>
<h2 id="配置及学习网站"><a href="#配置及学习网站" class="headerlink" title="配置及学习网站"></a>配置及学习网站</h2><p><a href="https://blog.csdn.net/NewDayStudy/article/details/79094493" target="_blank" rel="noopener">https://blog.csdn.net/NewDayStudy/article/details/79094493</a></p>
<p>php null值</p>
]]></content>
  </entry>
  <entry>
    <title>piority_queue 重载运算符</title>
    <url>/2018/11/28/piority-queue-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>定义：</p>
<p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。<br><a id="more"></a><br>头文件:</p>
<p>#include <queue><br>运算符重载：</queue></p>
<p> friend bool operator&lt;(node n1,node n2)<br>                return n1.elem&gt;n2.elem;</p>
<p>这是根据node结构体中的elem升序构建的一个操作符,  如果想要降序就把&gt;换成&lt;<br>关于优先队列的定义：</p>
<p>priority_queue<node>q;//其中node为结构体名称，q为优先队列名称<br>先上几个介绍优先队列的博客：</node></p>
<ol>
<li><p>优先级队列几个应用详解</p>
</li>
<li><p>优先队列详解</p>
</li>
<li><p>优先队列priority_queue 用法详解</p>
</li>
</ol>
<p><a href="http://blog.csdn.net/yuanjilai/article/details/8043157" target="_blank" rel="noopener">http://blog.csdn.net/yuanjilai/article/details/8043157</a></p>
<p>关于运算符的重载：</p>
<p>struct point{<br>    int x;<br>    int y;<br>    int times;<br>    friend bool operator &lt; (point a, point b)<br>    {<br>        return a.times &gt; b.times;    //重载小于号使得小的先出队列<br>    }<br>};<br>（a的权值＜b的权值）</p>
<p>在此处定义一个优先队列priority_queue<point> q;</point></p>
<p>如果要按照以times进行从小到大排列，操作如上。</p>
<p>进行重载&lt;操作符。</p>
<p>意思是如果a.times &gt; b.times成立，那么结构体point a &lt; point b成立。由于优先队列是按照从大到小排列，所以结构体b会排列到a之前，然而b.times是最小的，所以实现了按照times的从小到大排序,其实用一句话说就是要想b更大那么b.times.</p>
<p>***在结构体中比较时需要进行运算符的重载（重载&lt;），在不需要结构体时：</p>
<p>priority_queue&lt;int,vector<int>,less<int>&gt;s;//定义优先级队列s，less表示按照递减(从大到小)的顺序插入元素</int></int></p>
<p>priority_queue&lt;int,vector<int>,greater<int>&gt;s;//定义优先级队列s，greater表示按照递增（从小到大）的顺序插入元素</int></int></p>
<p>优先队列(priority_queue)的基本操作：</p>
<p>empty(); 队列为空返回1</p>
<p>pop();   出队</p>
<p>push();  入队</p>
<p>top();   返回队列中优先级最高的元素</p>
<p>size();  返回队列中元素的个数</p>
<p>参考链接</p>
<p><a href="https://blog.csdn.net/QiaoRuoZhuo/article/details/59478378" target="_blank" rel="noopener">https://blog.csdn.net/QiaoRuoZhuo/article/details/59478378</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>pip安装模块时可能遇到的问题</title>
    <url>/2018/05/22/pip%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97%E6%97%B6%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>（1）使用命令：sudo pip install numpy时，可能遇到：<br>The directory ‘/Users/huangqizhi/Library/Caches/pip’ or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo’s -H flag.<br><a id="more"></a><br>说得很清楚，是pip目录的属主不是sudo的root用户。如果必须用sudo pip，更改pip目录属主即可：<br>sudo chown root /Users/huangqizhi/Library/Caches/pip</p>
<p>（2）pip安装时，可能遇到：<br>/Library/Python/2.7/site-packages/pip/<em>vendor/requests/packages/urllib3/util/ssl</em>.py:90: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. For more information, see <a href="https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning" target="_blank" rel="noopener">https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning</a>.<br>  InsecurePlatformWarning<br>解决方法：安装requests，注意后面带[security]：<br>pip install requests[security]</p>
]]></content>
      <categories>
        <category>环境安装配置</category>
      </categories>
  </entry>
  <entry>
    <title>最长公共子序列LCS</title>
    <url>/2018/12/02/po-1/</url>
    <content><![CDATA[<p>二维数组c[][]记录最长公共子序列的长度，b[][]记录最长子序列的来源<br>c[][]右下角的值即为最长子序列的长度<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">int c[MAX][MAX];</span><br><span class="line">int b[MAX][MAX];</span><br><span class="line"></span><br><span class="line">void lcs(string s1,string s2)&#123;</span><br><span class="line">	int m=s1.length();</span><br><span class="line">	int n=s2.length();</span><br><span class="line">	for(int i=0;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			c[i][0]=b[i][0]=0;</span><br><span class="line">			c[0][i]=b[0][i]=0;</span><br><span class="line">		&#125;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			if(s1[i-1]==s2[j-1])&#123;</span><br><span class="line">				c[i][j]=c[i-1][j-1]+1;</span><br><span class="line">				b[i][j]=1;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				if(c[i-1][j]&gt;c[i][j-1])&#123;</span><br><span class="line">					c[i][j]=c[i-1][j];</span><br><span class="line">					b[i][j]=3;</span><br><span class="line">				&#125;</span><br><span class="line">				else&#123;</span><br><span class="line">					</span><br><span class="line">					c[i][j]=c[i][j-1];</span><br><span class="line">					b[i][j]=2;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void findPath(int x,int y,string s1)&#123;</span><br><span class="line">	if(x==0||y==0) return ;</span><br><span class="line">	if(b[x][y]==1)&#123;</span><br><span class="line">		findPath(x-1,y-1,s1);</span><br><span class="line">		cout&lt;&lt;s1[x-1]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(b[x][y]==2)&#123;</span><br><span class="line">		findPath(x,y-1,s1);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		findPath(x-1,y,s1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string s1,s2;</span><br><span class="line">	freopen(&quot;12-2.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	</span><br><span class="line">	lcs(s1,s2);</span><br><span class="line">		int m=s1.length();</span><br><span class="line">	int n=s2.length();</span><br><span class="line">	cout&lt;&lt;&quot;最长公共子序列的长度:&quot;&lt;&lt;c[m][n]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;最长公共子序列是:&quot;&lt;&lt;endl;</span><br><span class="line">	findPath(m,n,s1);</span><br><span class="line">	return 0;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxsjw6igddj30c5045aat.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxsk0r0cfnj31w02ioe81.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 934. Shortest Bridge</title>
    <url>/2018/12/02/po/</url>
    <content><![CDATA[<p>In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)</p>
<p>Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.</p>
<p>Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)</p>
 <a id="more"></a>
<p>Example 1:</p>
<p>Input: [[0,1],[1,0]]</p>
<p>Output: 1</p>
<p>Example 2:</p>
<p>Input: [[0,1,0],[0,0,0],[0,0,1]]</p>
<p>Output: 2</p>
<p>Example 3:</p>
<p>Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]</p>
<p>Output: 1</p>
<p>Note:</p>
<p>1 &lt;= A.length = A[0].length &lt;= 100</p>
<p>A[i][j] == 0 or A[i][j] == 1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int m,n;</span><br><span class="line">     queue&lt;pair&lt;int,int&gt;&gt; q;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;</span><br><span class="line">       //先找到那个小岛再bfs;</span><br><span class="line">       //(可能不止一个小岛)</span><br><span class="line">       m=A.size();</span><br><span class="line">        n=A[0].size();</span><br><span class="line">        vec.swap(A);</span><br><span class="line">        //  for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        //     for(int j=0;j&lt;n;j++)</span><br><span class="line">        //        if(vec[i][j]) &#123;</span><br><span class="line">        //            dfs(i,j,q);</span><br><span class="line">        //            break;</span><br><span class="line">        //        &#125;</span><br><span class="line">        //      break;//!!只要找到一个连通分量就退出 错误 只遍历0这一行 没有1的话就break了</span><br><span class="line">        // &#125;</span><br><span class="line">        bool flag=false;</span><br><span class="line">                 for(int i=0;i&lt;m&amp;&amp;!flag;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;n&amp;&amp;!flag;j++)</span><br><span class="line">               if(vec[i][j]) &#123;</span><br><span class="line">                   dfs(i,j,q);</span><br><span class="line">                  flag=true;</span><br><span class="line">               &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">      //  cout&lt;&lt;q.size()&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">        int steps=0;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int size=q.size();</span><br><span class="line">            while(size--)&#123;</span><br><span class="line">                </span><br><span class="line">            </span><br><span class="line">            pair&lt;int,int&gt; p=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            int x=p.first;</span><br><span class="line">            int y=p.second; </span><br><span class="line">           for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            int newx=x+dir[i][0];</span><br><span class="line">            int newy=y+dir[i][1];</span><br><span class="line">            if(newx&lt;0||newx&gt;=m||newy&lt;0||newy&gt;=n||vec[newx][newy]==2) continue;</span><br><span class="line">               </span><br><span class="line">            if(vec[newx][newy]==1) &#123;</span><br><span class="line">                return steps;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[newx][newy]=2;</span><br><span class="line">            q.push(pair&lt;int,int&gt;(newx,newy));//!!</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">           steps++;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">   void dfs(int x,int y,queue&lt;pair&lt;int,int&gt;&gt;&amp;q)&#123;</span><br><span class="line">  </span><br><span class="line">         if(x&lt;0||x&gt;=m||y&lt;0||y&gt;=n||vec[x][y]!=1) return;</span><br><span class="line">         q.push(pair&lt;int,int&gt;(x,y));</span><br><span class="line">     //  cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">        vec[x][y]=2;</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            int newx=x+dir[i][0];</span><br><span class="line">            int newy=y+dir[i][1];</span><br><span class="line">            dfs(newx,newy,q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>201503-1 图像旋转</title>
    <url>/2018/11/19/prim-1/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。<br>　　计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。<br><a id="more"></a><br>输入格式</p>
<p>输入的第一行包含两个整数n, m，分别表示图像矩阵的行数和列数。</p>
<p>接下来n行每行包含m个整数，表示输入的图像。</p>
<p>输出格式</p>
<p>输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。</p>
<p>样例输入</p>
<p>2 3</p>
<p>1 5 3</p>
<p>3 2 4</p>
<p>样例输出</p>
<p>3 4</p>
<p>5 2</p>
<p>1 3</p>
<p>评测用例规模与约定<br>　　1 ≤ n, m ≤ 1,000，矩阵中的数都是不超过1000的非负整数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#define MAX 1000+10</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">int a[MAX][MAX];</span><br><span class="line">vector&lt;int&gt; v[MAX];</span><br><span class="line">int c[MAX];</span><br><span class="line">using namespace std; </span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)</span><br><span class="line">		cin&gt;&gt;a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j=n-1;j&gt;=0;j--)&#123;</span><br><span class="line">			v[i].push_back(a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;m;j++)</span><br><span class="line">		a[i][j]=v[j][i];</span><br><span class="line">	&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;m;j++)</span><br><span class="line">		cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>python [::-1]</title>
    <url>/2018/09/23/python-1/</url>
    <content><![CDATA[<p>一、反转</p>
<p>　　for value in rang(10)涉及的数字倒序输出：</p>
<p>　　for value in rang(10)[::-1]涉及的数字倒序输出：<br><a id="more"></a><br>二、详解</p>
<p>这个是python的slice notation的特殊用法。</p>
<p>a = [0,1,2,3,4,5,6,7,8,9]<br>b = a[i:j] 表示复制a[i]到a[j-1]，以生成新的list对象<br>b = a[1:3] 那么，b的内容是 [1,2]</p>
<p>当i缺省时，默认为0，即 a[:3]相当于 a[0:3]</p>
<p>当j缺省时，默认为len(alist), 即a[1:]相当于a[1:10]</p>
<p>当i,j都缺省时，a[:]就相当于完整复制一份a了</p>
<p>b = a[i:j:s]这种格式呢，i,j与上面的一样，但s表示步进，缺省为1.<br>所以a[i:j:1]相当于a[i:j]<br>当s&lt;0时，i缺省时，默认为-1. j缺省时，默认为-len(a)-1<br>所以a[::-1]相当于 a[-1:-len(a)-1:-1]，也就是从最后一个元素到第一个元素复制一遍。所以你看到一个倒序的。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>prim求最小生成树</title>
    <url>/2018/12/02/prim/</url>
    <content><![CDATA[<p>flag[i]=true表明 顶点i 已加入最小生成树<br>close 存放最后的相关的最小权值<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">#define INF 1e6</span><br><span class="line">using namespace std;</span><br><span class="line">bool flag[MAX];</span><br><span class="line">int close[MAX];</span><br><span class="line">int p[MAX];</span><br><span class="line">int c[MAX][MAX];</span><br><span class="line">int n;</span><br><span class="line">void prim(int u)&#123;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(c[u][i]!=INF)&#123;</span><br><span class="line">			close[i]=c[u][i];</span><br><span class="line">		&#125;</span><br><span class="line">		else close[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close[u]=0;</span><br><span class="line">	flag[u]=true;</span><br><span class="line">	for(int k=1;k&lt;=n;k++)</span><br><span class="line">	&#123;	</span><br><span class="line"></span><br><span class="line">	int tmp=INF,t=u;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		if(!flag[i]&amp;&amp;close[i]&lt;tmp)&#123;</span><br><span class="line">			tmp=close[i];</span><br><span class="line">			t=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(t==u) return;</span><br><span class="line">	flag[t]=true;</span><br><span class="line">	for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">		if(!flag[j]&amp;&amp;c[t][j]&lt;close[j])&#123;</span><br><span class="line">			close[j]=c[t][j];</span><br><span class="line">			p[j]=t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void findPath(int u)&#123;</span><br><span class="line">	stack&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			s.push(i);</span><br><span class="line">		int x=p[i];</span><br><span class="line">		</span><br><span class="line">		while(x!=-1)&#123;</span><br><span class="line">			s.push(x);</span><br><span class="line">			x=p[x];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;u&lt;&lt;&quot;到&quot;&lt;&lt;i&lt;&lt;&quot;的路径为:&quot;&lt;&lt;endl; </span><br><span class="line">		while(!s.empty())&#123;</span><br><span class="line">			cout&lt;&lt;s.top()&lt;&lt;&quot; &quot;; </span><br><span class="line">			s.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	int cases,src,u,v,w;</span><br><span class="line">	freopen(&quot;12-2.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;cases;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)</span><br><span class="line">			c[i][j]=INF; </span><br><span class="line">	 </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=cases;i&gt;0;i--)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		c[u][v]=w;</span><br><span class="line">		c[v][u]=w;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;src;</span><br><span class="line">	p[src]=-1; </span><br><span class="line">			for(int i=1;i&lt;=n;i++) </span><br><span class="line">	&#123;</span><br><span class="line">	if(i!=src)	&#123;</span><br><span class="line">	flag[i]=false;</span><br><span class="line">	p[i]=src;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int low=0;</span><br><span class="line">	prim(src);//!!</span><br><span class="line">    cout&lt;&lt;&quot;数组Lowercost内容&quot;&lt;&lt;endl; </span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">		cout&lt;&lt;close[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		if(i!=src) &#123;</span><br><span class="line">			low+=close[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;最小花费为:&quot;&lt;&lt;low&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">		findPath(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxsfwfl8p4j309x08s0u2.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fxsfzlk065j31kw16o79g.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>python matplotlib画图</title>
    <url>/2018/09/22/python-matplotlib%E7%94%BB%E5%9B%BE/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"> </span><br><span class="line">h0 = [0.4,.6,.8] # h0取值</span><br><span class="line">lambda0 = [0.03,0.05,0.07] # λ取值</span><br><span class="line">plt.figure(figsize=(6,4)) # 设置图片大小</span><br><span class="line">x = np.linspace(0, 50, 50) # 在[0，50)中取50个点</span><br><span class="line"> </span><br><span class="line">for i in lambda0:</span><br><span class="line">	for h in h0:</span><br><span class="line">		plt.plot(x, 11+(20*np.exp(-i*x)-h*x)/2,label=&apos;lambda=&apos;+str(i)+&apos; h=&apos;+str(h))</span><br><span class="line"># plt.plot(x,y,图例内容)</span><br><span class="line">plt.legend() # 显示图例</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fvibb4l1apj30fu0c642v.jpg" alt></p>
<p>在使用matplotlib的过程中，发现不能像matlab一样同时开几个窗口进行比较，于是查询得知了交互模式，但是放在脚本里运行的适合却总是一闪而过，图像并不停留.<br>python可视化库matplotlib有两种显示模式：</p>
<p>阻塞（block）模式</p>
<p>交互（interactive）模式</p>
<p>在Python Consol命令行中，默认是交互模式。而在python脚本中，matplotlib默认是阻塞模式。</p>
<p>其中的区别是:<br>在交互模式下：</p>
<p>plt.plot(x)或plt.imshow(x)是直接出图像，不需要plt.show()<br>如果在脚本中使用ion()命令开启了交互模式，没有使用ioff()关闭的话，则图像会一闪而过，并不会常留。要想防止这种情况，需要在plt.show()之前加上ioff()命令。</p>
<p>在阻塞模式下：</p>
<p>打开一个窗口以后必须关掉才能打开下一个新的窗口。这种情况下，默认是不能像Matlab一样同时开很多窗口进行对比的。<br>plt.plot(x)或plt.imshow(x)是直接出图像，需要plt.show()后才能显示图像<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">   plt.ion()    # 打开交互模式</span><br><span class="line">   # 同时打开两个窗口显示图片</span><br><span class="line">   plt.figure()</span><br><span class="line">   plt.imshow(i1)</span><br><span class="line">   plt.figure()</span><br><span class="line">   plt.imshow(i2)</span><br><span class="line">   # 显示前关掉交互模式</span><br><span class="line">   plt.ioff()</span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python numpy的shape和reshape用法</title>
    <url>/2018/09/07/python-numpy-shape-reshape/</url>
    <content><![CDATA[<h2 id="导入numpy模块"><a href="#导入numpy模块" class="headerlink" title="导入numpy模块"></a>导入numpy模块</h2><p>from numpy import *<br>或者<br>import numpy as np<br><a id="more"></a></p>
<h2 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h2><p>shape [2,3] 表示为数组的意思是第一维有两个元素，第二维有三个元素，如: [[1,2,3],[4,5,6]]<br>类似tensorflow中张量的定义</p>
<h2 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h2><p><img src="https://img-blog.csdn.net/20151024112829304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br><!--more--></p>
<p>给予数组一个新的形状，而不改变它的数据</p>
<p><strong>newshape：整数值或整数元组。新的形状应该兼容于原始形状。如果是一个整数值，表示一个一维数组的长度；如果是元组，一个元素值可以为-1，此时该元素值表示为指定，此时会从数组的长度和剩余的维度中推断出</strong></p>
<p>!(<a href="https://img-blog.csdn.net/20151024113444952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" target="_blank" rel="noopener">https://img-blog.csdn.net/20151024113444952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center</a>)<br><img src="https://img-blog.csdn.net/20151024113932378?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<p>参考链接</p>
<p><a href="https://blog.csdn.net/u012005313/article/details/49383551" target="_blank" rel="noopener">https://blog.csdn.net/u012005313/article/details/49383551</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python numpy arrange 函数</title>
    <url>/2018/09/22/python-numpy-arrange-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="python自带的range函数"><a href="#python自带的range函数" class="headerlink" title="python自带的range函数"></a>python自带的range函数</h2><p>函数说明： range(start, stop[, step]) -&gt; range object，根据start与stop指定的范围以及step设定的步长，生成一个序列。</p>
<p>参数含义：start:计数从start开始。默认是从0开始。例如range（5）等价于range（0， 5）;</p>
<pre><code>end:技术到end结束，但不包括end.例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5

scan：每次跳跃的间距，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)
</code></pre><p>函数返回的是一个range object</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; range(0,5) 			 	#生成一个range object,而不是[0,1,2,3,4] </span><br><span class="line">range(0, 5)   </span><br><span class="line">&gt;&gt;&gt; c = [i for i in range(0,5)] 	 #从0 开始到4，不包括5，默认的间隔为1</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; c = [i for i in range(0,5,2)] 	 #间隔设为2</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[0, 2, 4]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="numpy中的arrange-函数"><a href="#numpy中的arrange-函数" class="headerlink" title="numpy中的arrange()函数"></a>numpy中的arrange()函数</h2><p>函数说明：arange([start,] stop[, step,], dtype=None)根据start与stop指定的范围以及step设定的步长，生成一个 ndarray。<br>dtype : dtype</p>
<p>The type of the output array.  If <code>dtype</code> is not given, infer the data type from the other input arguments.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &gt;&gt;&gt; np.arange(3)</span><br><span class="line">  array([0, 1, 2])</span><br><span class="line">   &gt;&gt;&gt; np.arange(3.0)</span><br><span class="line">   array([ 0.,  1.,  2.])</span><br><span class="line">   &gt;&gt;&gt; np.arange(3,7)</span><br><span class="line">   array([3, 4, 5, 6])</span><br><span class="line">   &gt;&gt;&gt; np.arange(3,7,2)</span><br><span class="line">   array([3, 5])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; arange(0,1,0.1)</span><br><span class="line">array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python pip install失败</title>
    <url>/2018/06/08/python-pip-install%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Retrying (Retry(total=0, connect=None, read=None, redirect=None)) after connection broken b  </span><br><span class="line">y &apos;ProxyError(&apos;Cannot connect to proxy.&apos;, NewConnectionError(&apos;&lt;pip._vendor.requests.packages.  </span><br><span class="line">urllib3.connection.VerifiedHTTPSConnection object at 0x0000020BE03DF080&gt;: Failed to establish  </span><br><span class="line"> a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。&apos;,))&apos;: /simple/qrcode/</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>proxy设置错误。<br>给出我的原因和解决方法：</p>
<p>我是用的switchOmega和xx-net 翻墙的，但是这个一旦设置，就是整个电脑通用也就是全局代理，然而pip install</p>
<p>把全局代理关闭，结果就好了。</p>
]]></content>
      <categories>
        <category>环境安装配置</category>
      </categories>
  </entry>
  <entry>
    <title>python range用法</title>
    <url>/2018/06/19/python-range%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<blockquote>
<blockquote>
<p>range(1,5) #代表从1到5(不包含5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>[1, 2, 3, 4]</p>
<blockquote>
<blockquote>
<blockquote>
<p>range(1,5,2) #代表从1到5，间隔2(不包含5)<br>[1, 3]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>range(5) #代表从0到5(不包含5)<br>[0, 1, 2, 3, 4]</p>
</blockquote>
</blockquote>
</blockquote>
<a id="more"></a>
<p>array = [1, 2, 5, 3, 6, 8, 4]</p>
<blockquote>
<blockquote>
<blockquote>
<p>array[0:] #列出0以后的</p>
</blockquote>
</blockquote>
</blockquote>
<p>[1, 2, 5, 3, 6, 8, 4]</p>
<blockquote>
<blockquote>
<blockquote>
<p>array[1:] #列出1以后的</p>
</blockquote>
</blockquote>
</blockquote>
<p>[2, 5, 3, 6, 8, 4]</p>
<blockquote>
<blockquote>
<blockquote>
<p>array[:-1] #列出-1之前的</p>
</blockquote>
</blockquote>
</blockquote>
<p>[1, 2, 5, 3, 6, 8]</p>
<blockquote>
<blockquote>
<blockquote>
<p>array[3:-3] #列出3到-3之间的</p>
</blockquote>
</blockquote>
</blockquote>
<p>[3]</p>
<p>那么两个[::]会是什么那？</p>
<blockquote>
<blockquote>
<blockquote>
<p>array[::2]</p>
</blockquote>
</blockquote>
</blockquote>
<p>[1, 5, 6, 4]</p>
<blockquote>
<blockquote>
<blockquote>
<p>array[2::]</p>
</blockquote>
</blockquote>
</blockquote>
<p>[5, 3, 6, 8, 4]</p>
<blockquote>
<blockquote>
<blockquote>
<p>array[::3]</p>
</blockquote>
</blockquote>
</blockquote>
<p>[1, 3, 4]</p>
<blockquote>
<blockquote>
<blockquote>
<p>array[::4]</p>
</blockquote>
</blockquote>
</blockquote>
<p>[1, 6] </p>
<p>如果想让他们颠倒形成reverse函数的效果</p>
<blockquote>
<blockquote>
<blockquote>
<p>array[::-1]<br>[4, 8, 6, 3, 5, 2, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>array[::-2]<br>[4, 6, 5, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<p>冒泡排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array = [1, 2, 5, 3, 6, 8, 4]</span><br><span class="line">for i in range(len(array) - 1, 0, -1):</span><br><span class="line">    print(&quot;i:&quot;+str(i))</span><br><span class="line">    for j in range(0, i):</span><br><span class="line">        print(j)</span><br><span class="line">        if array[j] &gt; array[j + 1]:</span><br><span class="line">            array[j], array[j + 1] = array[j + 1], array[j]</span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>base64编码过程</title>
    <url>/2020/02/07/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83/</url>
    <content><![CDATA[<p>Base64是一种基于64个可打印字符来表示二进制数据的表示方法</p>
<p>Base64是一种编码方式，提及编码方式，必然有其对应的字符集合。在Base64编码中，相互映射的两个集合是：</p>
<p>二进制数据{0, 1}<br>{A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, /}<br>Base64编码方式可使得信息在这两种字符集表示法之间相互等价转换。<br><a id="more"></a><br>因为Base64的编码方式是公开的，所以base64也可以算是公开算法的加密方法；但是只能简单的“加密”保护某些数据，决不能在需要安全等级较高的场景中使用，因为可以使用公开的编码方法轻易从base64字符表示的数据解码二进制数据。</p>
<ol start="2">
<li>base64编码过程<br>由于base64的字符集大小为64，那么，需要6个比特的二进制数作为一个基本单元表示一个base64字符集中的字符。因为6个比特有2^6=64种排列组合。</li>
</ol>
<p>具体来说，编码过程如下：</p>
<p>将每三个字节作为一组，共24bit，若不足24bit在其后补充0；<br>将这24个bit分为4组，每一组6个bit；<br>在每组前加00扩展为8个bit，形成4个字节，每个字节表示base64字符集索引；<br>扩展后的8bit表示的整数作为索引，对应base64字符集的一个字符，这就是base64编码值；在处理最后的不足3字节时，缺一个字节索引字节取3个，最后填充一个=，；缺两个字节取2个索引字节，最后填充==。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64_list = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;,</span><br><span class="line">               &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;,</span><br><span class="line">               &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;,</span><br><span class="line">               &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;+&apos;, &apos;/&apos;]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def encode_ascii(string: str) -&gt; str:</span><br><span class="line">    temp = &apos;&apos;</span><br><span class="line">    base = &apos;&apos;</span><br><span class="line"> </span><br><span class="line">    # 把原始字符串转换为二进制，用bin转换后去掉开头的0b，首位补0补齐8位</span><br><span class="line">    for i in string:</span><br><span class="line">        temp += &apos;&#123;:08&#125;&apos;.format(int(str(bin(ord(i))).replace(&apos;0b&apos;, &apos;&apos;)))</span><br><span class="line"> </span><br><span class="line">    # 6位一组截取，最后一组不足6位的后面补0，获取base_list中对应的字符</span><br><span class="line">    for j in range(0, len(temp), 6):</span><br><span class="line">        t = &apos;&#123;:&lt;06&#125;&apos;.format(temp[j: j + 6])</span><br><span class="line">        base += base64_list[int(t, 2)]</span><br><span class="line"> </span><br><span class="line">    # 判断base字符长度结尾补‘=’</span><br><span class="line">    if len(string) % 3 == 1:</span><br><span class="line">        base += &apos;==&apos;</span><br><span class="line">    elif len(string) % 3 == 2:</span><br><span class="line">        base += &apos;=&apos;</span><br><span class="line">    return base</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def decode_ascii(base: str) -&gt; str:</span><br><span class="line">    temp = &apos;&apos;</span><br><span class="line">    string = &apos;&apos;</span><br><span class="line"> </span><br><span class="line">    # 去掉尾补的‘=’</span><br><span class="line">    base = base.replace(&apos;=&apos;, &apos;&apos;)</span><br><span class="line">    # 获取base在base_list中的索引，转换为二进制，用bin转换后去掉开头的0b，首位补0补齐6位</span><br><span class="line">    for s in range(len(base)):</span><br><span class="line">        temp += &apos;&#123;:06&#125;&apos;.format(int(str(bin(base64_list.index(base[s]))).replace(&apos;0b&apos;, &apos;&apos;)))</span><br><span class="line"> </span><br><span class="line">    # 8位一组截取（已忽略最后一组），转10进制，获取ASCII字符</span><br><span class="line">    for i in range(len(temp) // 8):</span><br><span class="line">        string += chr(int(temp[8 * i: 8 * i + 8], 2))</span><br><span class="line"> </span><br><span class="line">    return string</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 使用utf8支持中文</span><br><span class="line">def encode(string: str, encoding: str = &apos;utf8&apos;) -&gt; str:</span><br><span class="line">    temp = &apos;&apos;</span><br><span class="line">    base = &apos;&apos;</span><br><span class="line"> </span><br><span class="line">    # 获取字符串编码</span><br><span class="line">    string = string.encode(encoding)</span><br><span class="line"> </span><br><span class="line">    # 把字符串编码为二进制，用bin转换后去掉开头的0b，首位补0补齐8位</span><br><span class="line">    for i in string:</span><br><span class="line">        temp += &apos;&#123;:08&#125;&apos;.format(int(str(bin(i)).replace(&apos;0b&apos;, &apos;&apos;)))</span><br><span class="line"> </span><br><span class="line">    # 6位一组截取，最后一组不足6位的后面补0，获取base_list中对应的字符</span><br><span class="line">    for j in range(0, len(temp), 6):</span><br><span class="line">        t = &apos;&#123;:&lt;06&#125;&apos;.format(temp[j: j + 6])</span><br><span class="line">        base += base64_list[int(t, 2)]</span><br><span class="line"> </span><br><span class="line">    # 判断base字符长度结尾补‘=’</span><br><span class="line">    if len(string) % 3 == 1:</span><br><span class="line">        base += &apos;==&apos;</span><br><span class="line">    elif len(string) % 3 == 2:</span><br><span class="line">        base += &apos;=&apos;</span><br><span class="line">    return base</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def decode(base: str, encoding: str = &apos;utf8&apos;) -&gt; str:</span><br><span class="line">    temp = &apos;&apos;</span><br><span class="line">    string_bytes = []</span><br><span class="line"> </span><br><span class="line">    # 去掉尾补的‘=’</span><br><span class="line">    base = base.replace(&apos;=&apos;, &apos;&apos;)</span><br><span class="line">    # 获取base在base_list中的索引，转换为二进制，用bin转换后去掉开头的0b，首位补0补齐6位</span><br><span class="line">    for s in range(len(base)):</span><br><span class="line">        temp += &apos;&#123;:06&#125;&apos;.format(int(str(bin(base64_list.index(base[s]))).replace(&apos;0b&apos;, &apos;&apos;)))</span><br><span class="line"> </span><br><span class="line">    # 8位一组截取（已忽略最后一组），转10进制</span><br><span class="line">    for i in range(len(temp) // 8):</span><br><span class="line">        string_bytes.append(int(temp[8 * i: 8 * i + 8], 2))</span><br><span class="line"> </span><br><span class="line">    # 根据编码获取源字符串</span><br><span class="line">    return bytes(string_bytes).decode(encoding)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># Demo</span><br><span class="line">v = &apos;人人a&apos;</span><br><span class="line">print(v)</span><br><span class="line"> </span><br><span class="line">v = encode(v)</span><br><span class="line">print(v)</span><br><span class="line"> </span><br><span class="line">v = decode(v)</span><br><span class="line">print(v)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python学习笔记(六)</title>
    <url>/2020/01/28/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94/</url>
    <content><![CDATA[<h2 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h2><a id="more"></a>
<p>r’只读模式，必须打开一个已有的文件，且只能执行读操作。</p>
<p>‘r+’读+追加模式，可读可写，与‘r’相同之处在于也是必须打开一个已有的文件，不同的是它可写可读，而且写与读不分先        后，即随时都可进行读与写。（写为追加在文件末尾）<br><!--more--><br>‘w’只写模式，打开即默认创建一个新的空文件，当然若打开的是已有文件，则清空文件，且只能执行写操作。</p>
<p>‘w+’写读模式，打开创建新文件，因此需要先把内容写进去在读。即保证文件有内容通过移动光标来读自己想要的部分。</p>
<p>‘a’追加模式，若打开的是已有文件则直接对已有文件操作，若打开文件不存在则创建新文件，只能执行写（追加在后面），不能读。即追加写。</p>
<p>‘a+’追加读写模式，打开文件方式同‘a’一样，写方式也和’a’一样，但是可以读。且是任意时刻读写。需要注意的是你若刚用‘a+’打开一个文件，则不能立即读，因为此时光标已经是文件末尾，除非你把光标移动到初始位置或任意非末尾的位置。</p>
<p> 操作文件大概流程过程，文件是否存在，打开文件，读写文件，关闭文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 &gt;&gt;&gt; import os</span><br><span class="line"> 2 &gt;&gt;&gt; os.path.isfile(&apos;wdwj&apos;) #不存在</span><br><span class="line"> 3 False</span><br><span class="line"> 4 &gt;&gt;&gt; f=open(&apos;wdwj&apos;,&apos;w&apos;)#用&apos;w&apos;写的方式打开文件，不存在就自动创建</span><br><span class="line"> 5 &gt;&gt;&gt; f.write(&apos;我的文件内容&apos;)#写文件内容</span><br><span class="line"> 6 6</span><br><span class="line"> 7 &gt;&gt;&gt; f.close()#关闭文件</span><br><span class="line"> 8 &gt;&gt;&gt; os.path.isfile(&apos;wdwj&apos;)#已经成功创建</span><br><span class="line"> 9 True</span><br><span class="line">10 &gt;&gt;&gt; with open(&apos;wdwj&apos;) as f: #使用with 打开文件后，自动关闭文件</span><br><span class="line">11 ...     data=f.read()</span><br><span class="line">12 ... </span><br><span class="line">13 &gt;&gt;&gt; print(data)</span><br><span class="line">14 我的文件内容</span><br></pre></td></tr></table></figure>
<p>python3 就是open 没有file</p>
<p>查看/设置系统文件编码集</p>
<p>import sys</p>
<p>sys.getdefaultencoding()</p>
<p>sys.setdefaultencoding(“utf-8”)</p>
<p>关于文件操作的编码问题。</p>
<p>在windows下：在pycharm当中设置基本编码是utf-8，在pycharm里新建文本文件就是utf-8，</p>
<p>然后运行pycharm程序，读取这个文本文件就会出错，它会使用windows默认GBK编码去读取。</p>
<p>打开文件</p>
<p>f = open(‘musictxt’,encoding=’utf-8’)#encoding=’utf-8’不加这个参数的话，就按当前系统编码集</p>
<p>open方法详细参数</p>
<p>def open(file, mode=’r’, buffering=None, encoding=None, errors=None, newline=None, closefd=True):</p>
<p>打开文件的模式，上文中的表格里有更详细的说明</p>
<p> r，只读模式（默认）。</p>
<p> w，只写模式。</p>
<p> a，追加模式。</p>
<p>通常文件以文本打开，读写文件的字符串都会被特定的编码方式（默认是UTF-8）编码。</p>
<p>模式后面加’b’，读写文件都以字节方式读写。常见的JPG、EXE等数据文件使用。</p>
<p>文本模式下，换行时根据操作系统不同，换行也不同Unix上是 \n , Windows上是 \r\n。注意，文本操作时影响不大。但以字节模式操作时，会影响数据。</p>
<p>二、文件对象方法<br>文件读操作时，如果未设置指针位置。默认读取文件的位置指针会从文件头移到文件尾，所以读取一次后无法重复读取。</p>
<p>读取文件</p>
<p>f.read(size)，size是可选项目，指定字符串长度。size未指定或者为负数，会读取整个文件。当文件大小是当前机器内存两倍时，会出错。如果到了文件末尾，会显示空字符串。</p>
<p>注意：是read(),不是readline()。</p>
<p>1 &gt;&gt;&gt; f.read()<br>2 ‘zhe shi wenjian.\n’<br>3 &gt;&gt;&gt; f.read()<br>4 ‘’ #这两个单引号是空字符串<br>读取行</p>
<p>f.readline()，注意：返回的每行结尾会自动加换行符’\n’，如果到文件末尾就返回空字符串’’。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 &gt;&gt;&gt; f.readline()</span><br><span class="line"> 2 &apos;wo shi wenjian neirong.\n&apos;</span><br><span class="line"> 3 &gt;&gt;&gt; f.readline()</span><br><span class="line"> 4 &apos;zhe shi di er hang\n&apos;</span><br><span class="line"> 5 &gt;&gt;&gt; f.readline()</span><br><span class="line"> 6 &apos;&apos;</span><br><span class="line"> 7 </span><br><span class="line"> 8 #循环遍历文件对象，来读取第一行。</span><br><span class="line"> 9 &gt;&gt;&gt; for line in f:</span><br><span class="line">10 ...     print(line, end=&apos;&apos;)</span><br><span class="line">11 ...</span><br><span class="line">12 wo shi wenjian neirong.</span><br><span class="line">13 zhe shi di er hang</span><br></pre></td></tr></table></figure>
<p>如果你想把文件中的所有行读到一个列表中，你也可以使用 list(f) 或者 f.readlines()</p>
<p>写文件</p>
<p>f.write(string)方法将 string 的内容写入文件，并返回写入字符的长度:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f.write(‘This is a test\n’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>15</p>
<p> 想要写入其他非字符串内容，首先要将它转换为字符串:</p>
<blockquote>
<blockquote>
<blockquote>
<p>value = (‘the answer’, 42)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>s = str(value)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>f.write(s)</p>
</blockquote>
</blockquote>
</blockquote>
<p>18</p>
<p>文件对象的指针操作 </p>
<p>f.tell()方法返回一个整数  显示当前指针位置</p>
<p>f.seek(offset,from_what)方法设置设置指针位置。</p>
<p>form_what是起始位置，值为 0 表示自文件起始处开始，1 表示自当前文件指针位置开始，2 表示自文件末尾开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 &gt;&gt; f = open(&apos;workfile&apos;, &apos;rb+&apos;)</span><br><span class="line"> 2 &gt;&gt;&gt; f.write(b&apos;0123456789abcdef&apos;)</span><br><span class="line"> 3 16</span><br><span class="line"> 4 &gt;&gt;&gt; f.seek(5) </span><br><span class="line"> 5 5</span><br><span class="line"> 6 &gt;&gt;&gt; f.read(1)</span><br><span class="line"> 7 b&apos;5&apos;</span><br><span class="line"> 8 &gt;&gt;&gt; f.seek(-3, 2) </span><br><span class="line"> 9 13</span><br><span class="line">10 &gt;&gt;&gt; f.read(1)</span><br><span class="line">11 b&apos;d&apos;</span><br></pre></td></tr></table></figure>
<p>可以操作本文本件，但注意一个字符串是3个字节。指针是按字节走的，不是3的倍数显示会出错。</p>
<p>注意：文本中同时包含中文和ascii时，无论是字节还是字符串操作指针，产生乱码比较麻烦。</p>
<p>例如：以下就是产生了不是3的倍数的字节，需要修改bytes字节数据来修复。操作bytes类型的字符，用切片方法切掉坏数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b</span><br><span class="line"></span><br><span class="line">b&apos;abcdefg,\x8d\xe9\x9d\xa2\xe4\xba\x86,\x80\xe4\xb8\x8b\xe5\x9c\xa8\xe5\x89\x8d\xe9\x9d\xa2\xe5\x8a\xa0\xe4\xb8\x80\xe4\xb8\x8b,,try,try12345678abcdef-------hehe&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; b[:4]</span><br><span class="line"></span><br><span class="line">b&apos;abcd&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; b=b[:8]+b[10:]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c.decode(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">&apos;下在前面加一下,,try,try12345678abcdef-------hehe&apos;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="https://www.cnblogs.com/ekuj/p/9570594.html" target="_blank" rel="noopener">https://www.cnblogs.com/ekuj/p/9570594.html</a><br><a href="https://blog.csdn.net/weixin_44419382/article/details/89504298" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44419382/article/details/89504298</a></p>
<h2 id="random各种使用方法"><a href="#random各种使用方法" class="headerlink" title="random各种使用方法"></a>random各种使用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"> </span><br><span class="line"># 随机生成[0.1)的浮点数</span><br><span class="line">print(&quot;random():&quot;, random.random())</span><br><span class="line"> </span><br><span class="line"># 随机生成1000-9999之间的整数</span><br><span class="line">print(&quot;randint(1000, 9999):&quot;, random.randint(1000, 9999))</span><br><span class="line"> </span><br><span class="line"># 随机生成0-20之间的偶数</span><br><span class="line">print(&quot;randrange(0, 21, 2):&quot;, random.randrange(0, 21, 2))</span><br><span class="line"> </span><br><span class="line"># 随机生成0-20之间的浮点数</span><br><span class="line">print(&quot;uniform(0, 20):&quot;, random.uniform(0, 20))</span><br><span class="line"> </span><br><span class="line"># 从序列中随机选择一个元素</span><br><span class="line">list_string = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">print(&quot;choice(list):&quot;, random.choice(list_string))</span><br><span class="line">print(&quot;choice(string):&quot;, random.choice(&apos;abcd&apos;))</span><br><span class="line"> </span><br><span class="line"># 对列表元素随机排序</span><br><span class="line">list_number = [1, 2, 3, 4, 5]</span><br><span class="line">random.shuffle(list_number)</span><br><span class="line">print(&quot;shuffle(list):&quot;, list_number)</span><br><span class="line"> </span><br><span class="line"># 从指定序列中随机获取指定长度的片断</span><br><span class="line">print(&quot;sample(sequence):&quot;, random.sample(&apos;abcdefg&apos;, 2))</span><br><span class="line">运行结果如下</span><br><span class="line"></span><br><span class="line">random(): 0.6708362810735843</span><br><span class="line">randint(1000, 9999): 5228</span><br><span class="line">randrange(0, 21, 2): 6</span><br><span class="line">uniform(0, 20): 12.767906137387294</span><br><span class="line">choice(list): a</span><br><span class="line">choice(string): d</span><br><span class="line">shuffle(list): [1, 3, 5, 2, 4]</span><br><span class="line">sample(sequence): [&apos;f&apos;, &apos;g&apos;]</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/jinsefm/article/details/80645041" target="_blank" rel="noopener">https://blog.csdn.net/jinsefm/article/details/80645041</a></p>
]]></content>
  </entry>
  <entry>
    <title>python学习笔记(八）</title>
    <url>/2020/03/28/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83%EF%BC%89-1/</url>
    <content><![CDATA[<p>分析错误内容：不支持字符串的修改</p>
<p>总结：字符串一旦创建之后，里面的元素是不可以修改的。但是重新赋值是可以的，例如：name = ‘xiaobai’.</p>
<h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict()"></a>字典dict()</h2><p>python字典初始化比较常用的两种方式：dict() 和 {}</p>
<p>性能方面，{}性能更好。</p>
<a id="more"></a>
<p>1.创建字典表<br>创建一个学生分数字典<br>s={‘stu1’:80,’stu2’:90,’stu3’:60}<br>2.查询</p>
<p>查询stu1的分数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s[&apos;stu1&apos;]</span><br><span class="line">80</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>3.修改value<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s[&apos;stu1&apos;]=50</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&apos;stu3&apos;: 60, &apos;stu2&apos;: 90, &apos;stu1&apos;: 50&#125;</span><br><span class="line">4.增加key</span><br></pre></td></tr></table></figure></p>
<p>例如增加一个代表学生stu4-stu7的key-value<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s[&apos;stu4-7&apos;]=[40,80,50,60]</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&apos;stu3&apos;: 60, &apos;stu2&apos;: 90, &apos;stu1&apos;: 50, &apos;stu4-7&apos;: [40, 80, 50, 60]&#125;</span><br><span class="line">注意：key不能是变量（python里面的变量不太容易理解，就简单的理解key不能是list就行），但是value可以是变量（python里面的），value可以是常量、字符串、list、tuple等</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s[&apos;stu8-9&apos;]=(80,50)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&apos;stu3&apos;: 60, &apos;stu8-9&apos;: (80, 50), &apos;stu2&apos;: 90, &apos;stu1&apos;: 50, &apos;stu4-7&apos;: [40, 80, 50, 60]&#125;</span><br><span class="line">读取stu8的分数</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s[&apos;stu8-9&apos;][0]</span><br><span class="line">80</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>5.删除key</p>
<p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除</p>
<p>例如：删除key”stu1”<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s.pop(&apos;stu1&apos;)</span><br><span class="line">50</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&apos;stu3&apos;: 60, &apos;stu8-9&apos;: (80, 50), &apos;stu2&apos;: 90, &apos;stu4-7&apos;: [40, 80, 50, 60]&#125;</span><br><span class="line">&gt;&gt;&gt; s[&apos;stu1&apos;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#14&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    s[&apos;stu1&apos;]</span><br><span class="line">KeyError: &apos;stu1&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>6.判断一个key是否存在</p>
<p>方法1：直接打印输出，如果key不存在会返回错误<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s[&apos;stu1&apos;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#14&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    s[&apos;stu1&apos;]</span><br><span class="line">KeyError: &apos;stu1&apos;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line"></span><br><span class="line">方法2：通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：</span><br><span class="line"></span><br><span class="line">s.get(&apos;stu1&apos;)</span><br><span class="line">可以用print打印出None</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print (s.get(&apos;stu1&apos;))</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">可以自己指定key不存在返回的值，例如返回1，但是返回值必须是整形</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s.get(&apos;stu1&apos;,1)</span><br><span class="line">1</span><br><span class="line">方法3：通过in判断key是否存在，不存在返回Flase</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &apos;stu1&apos; in s</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; &apos;stu2&apos; in s</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h2 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h2><p>二、set([])</p>
<p>set和dict类似，也是一组key的集合，但不存储value；set和dict一样key不允许是list且key不能重复。</p>
<p>1.创建set</p>
<p>要创建一个set，需要提供一个list作为输入集合,注意set的固定格式，set([]),在set()中加入list<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; se=set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])</span><br><span class="line">&gt;&gt;&gt; se</span><br><span class="line">&#123;&apos;b&apos;, &apos;c&apos;, &apos;a&apos;&#125;</span><br><span class="line">注意：list中的每一个元素都是一个key,但是元素不能是list可以是常量、字符串、tuple、浮点型</span><br></pre></td></tr></table></figure></p>
<p>2.读取key<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; se</span><br><span class="line">&#123;&apos;b&apos;, &apos;c&apos;, &apos;a&apos;&#125;</span><br><span class="line">set不支持索引，所以没办法像list和tuple那样根据索引获取指定的key，比如se[0]会返回错误</span><br></pre></td></tr></table></figure></p>
<p>4.增加key</p>
<p>通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; se.add(&apos;d&apos;)</span><br><span class="line">&gt;&gt;&gt; se</span><br><span class="line">&#123;&apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;a&apos;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>5.删除key<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过remove(key)方法可以删除元素</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; se.remove(&apos;c&apos;)</span><br><span class="line">&gt;&gt;&gt; se</span><br><span class="line">&#123;&apos;b&apos;, &apos;d&apos;, &apos;a&apos;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>6.设置一个list key<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; se.add([&apos;e&apos;,&apos;f&apos;])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#74&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    se.add([&apos;e&apos;,&apos;f&apos;])</span><br><span class="line">TypeError: unhashable type: &apos;list&apos;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python学习笔记(三)</title>
    <url>/2020/01/16/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    <content><![CDATA[<h2 id="输出由1234组成的不同的三位数"><a href="#输出由1234组成的不同的三位数" class="headerlink" title="输出由1234组成的不同的三位数"></a>输出由1234组成的不同的三位数</h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">digit=(1,2,3,4)</span><br><span class="line">for i in digit:</span><br><span class="line">    for j in digit:</span><br><span class="line">        if i==j:</span><br><span class="line">            continue</span><br><span class="line">        for k in digit:</span><br><span class="line">            if k==i or k==j:</span><br><span class="line">                continue</span><br><span class="line">            print(i*100+j*10+k)</span><br></pre></td></tr></table></figure>
<h2 id="map-函数"><a href="#map-函数" class="headerlink" title="map()函数"></a>map()函数</h2><p>map()函数的格式是：</p>
<p>map(function,iterable,…)<br>第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个集合。</p>
<p>把函数依次作用在list中的每一个元素上，得到一个新的list并返回。注意，map不改变原list，而是返回一个新list。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">del square(x):</span><br><span class="line">    return x ** 2</span><br><span class="line"> </span><br><span class="line">map(square,[1,2,3,4,5])</span><br><span class="line"> </span><br><span class="line"># 结果如下:</span><br><span class="line">[1,4,9,16,25]</span><br></pre></td></tr></table></figure></p>
<p>通过使用lambda匿名函数的方法使用map()函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map(lambda x, y: x+y,[1,3,5,7,9],[2,4,6,8,10])</span><br><span class="line"></span><br><span class="line"># 结果如下：</span><br><span class="line">[3,7,11,15,19]</span><br></pre></td></tr></table></figure></p>
<p>通过lambda函数使返回值是一个元组：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map(lambdax, y : (x**y,x+y),[2,4,6],[3,2,1])</span><br><span class="line"> </span><br><span class="line"># 结果如下</span><br><span class="line">[(8,5),(16,6),(6,7)]</span><br></pre></td></tr></table></figure></p>
<p>当不传入function时，map()就等同于zip()，将多个列表相同位置的元素归并到一个元组：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map(None,[2,4,6],[3,2,1])</span><br><span class="line"> </span><br><span class="line"># 结果如下</span><br><span class="line">[(2,3),(4,2),(6,1)]</span><br><span class="line">通过map还可以实现类型转换</span><br><span class="line"></span><br><span class="line">将元组转换为list：</span><br><span class="line"></span><br><span class="line">map(int,(1,2,3))</span><br><span class="line"> </span><br><span class="line"># 结果如下：</span><br><span class="line">[1,2,3]</span><br><span class="line">将字符串转换为list：</span><br><span class="line"></span><br><span class="line">map(int,&apos;1234&apos;)</span><br><span class="line"> </span><br><span class="line"># 结果如下：</span><br><span class="line">[1,2,3,4]</span><br><span class="line">提取字典中的key，并将结果放在一个list中：</span><br><span class="line"></span><br><span class="line">map(int,&#123;1:2,2:3,3:4&#125;)</span><br><span class="line"> </span><br><span class="line"># 结果如下</span><br><span class="line">[1,2,3]</span><br></pre></td></tr></table></figure></p>
<p><a href="https://blog.csdn.net/quanlingtu1272/article/details/95482253" target="_blank" rel="noopener">https://blog.csdn.net/quanlingtu1272/article/details/95482253</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python学习笔记(四）</title>
    <url>/2020/01/27/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/</url>
    <content><![CDATA[<h2 id="python函数嵌套"><a href="#python函数嵌套" class="headerlink" title="python函数嵌套"></a>python函数嵌套</h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python，函数嵌套，到底是个什么东东？</span><br><span class="line"></span><br><span class="line">很少有人用，但是，有时确实会用：</span><br><span class="line"></span><br><span class="line">def multiplier(factor):</span><br><span class="line">    def multiplyByFactor(number):</span><br><span class="line">          return number*factor</span><br><span class="line">    return multiplyByFactor</span><br><span class="line"></span><br><span class="line">python程序，一个函数在另外一个函数的里面，外层的函数返回的是里层函数。也就是函数本身被返回了，返回的是函数（听起来和C语言的一些东东相似）。</span><br><span class="line">注意，返回的函数还可以访问它的定义所在的作用域，也就是它带着它的环境信息奥。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">看看下面的用法，就会有被水浇的感觉了：</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;double = multiplier(2)</span><br><span class="line">&gt;&gt;&gt;double(5)</span><br><span class="line">10</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;triple=multiplier(3)</span><br><span class="line">&gt;&gt;&gt;triple(3)</span><br><span class="line">9</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;multiplier(5)(4)</span><br><span class="line">&gt;&gt;&gt;20</span><br></pre></td></tr></table></figure>
<p>每次调用外层函数，它内部的函数都会被重新绑定，factor变量每次都有一个新的值。</p>
<h2 id="python-turtle库"><a href="#python-turtle库" class="headerlink" title="python turtle库"></a>python turtle库</h2><p>urtle库是Python语言中一个很流行的绘制图像的函数库</p>
<p>  使用之前需要导入库：import turtle</p>
<p>• turtle.setup(width,height,startx,starty)</p>
<p>　　-setup() 设置窗体的位置和大小</p>
<p>　　相对于桌面的起始点的坐标以及窗口的宽度高度，若不写窗口的起始点，则默认在桌面的正中心</p>
<p>　　窗体的坐标原点默认在窗口的中心</p>
<p>• 绝对坐标<br>　　○ turtle.goto(100,100):指从当前的点指向括号内所给坐标</p>
<p>• 海龟坐标，把当前点当做坐标，有前方向，后方向，左方向，右方向</p>
<p>　　○ turtle.fd(d):指沿着海龟的前方向运行</p>
<p>　　○ turtle.bk(d):指沿着海龟的反方向运行</p>
<p>　　○ turtle.circle(r,angle):指沿着海龟左侧的某一点做圆运动</p>
<p>• 绝对角度</p>
<p>　　○ turtle.seth(angle):只改变海龟的行进方向（角度按逆时针），但不行进，angle为绝对度数</p>
<p>• 海龟角度</p>
<p>　　○ turtle.left(angle)</p>
<p>　　○ turtle.right(angle)<br> angle：当前方向上转过得角度（海龟角度）</p>
<h2 id="python-jieba库"><a href="#python-jieba库" class="headerlink" title="python jieba库"></a>python jieba库</h2><h2 id="python读写csv文件"><a href="#python读写csv文件" class="headerlink" title="python读写csv文件"></a>python读写csv文件</h2><p>CSV(Comma-Separated Values)即逗号分隔值，一种以逗号分隔按行存储的文本文件，所有的值都表现为字符串类型（注意：数字为字符串类型）。</p>
<p>如果CSV中有中文，应以utf-8编码读写，如果要支持Excel查看，应是要用utf-8 with bom格式及utf-8-sig</p>
<p>Python3操作CSV文件使用自带的csv包<br>reader=csv.reader(f, delimiter=’,’)：用来读取数据，reader为生成器，每次读取一行，每行数据为列表格式，可以通过delimiter参数指定分隔符<br>writer=csv.writer(f)：用来写入数据，按行写入，writer支持writerow(列表)单行写入，和writerows(嵌套列表)批量写入多行，无须手动保存。<br>当文件中有标题行时，可以使用header=next(reader)先获取到第一行的数据，再进行遍历所有的数据行。<br>写入时，可以先使用writer.writerow(标题行列表)，写入标题行，再使用writer.writerows(多行数据嵌套列表)，写入多行数据（也可以逐行写入）。</p>
<p>数据文件data.csv:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name,password</span><br><span class="line">abc,123456</span><br><span class="line">张五,123#456</span><br><span class="line">张#abc123,123456</span><br><span class="line">666,123456</span><br><span class="line">a b,123456</span><br><span class="line">读取示例：</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">with open(&apos;data.csv&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header = next(reader)</span><br><span class="line">    print(header)</span><br><span class="line">    for row in reader:</span><br><span class="line">        print(row)</span><br><span class="line">注意：reader必须在文件打开的上下文中使用，否则文件被关闭后reader无法使用</span><br><span class="line">所有的数字被作为字符串，如果要使用数字格式，应使用int()/float()做相应转换</span><br><span class="line"></span><br><span class="line">写入示例：</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">header = [&apos;name&apos;, &apos;password&apos;, &apos;status&apos;]</span><br><span class="line"></span><br><span class="line">data = [</span><br><span class="line">    [&apos;abc&apos;, &apos;123456&apos;, &apos;PASS&apos;],</span><br><span class="line">    [&apos;张五&apos;, &apos;123#456&apos;, &apos;PASS&apos;],</span><br><span class="line">    [&apos;张#abc123&apos;, &apos;123456&apos;, &apos;PASS&apos;],</span><br><span class="line">    [&apos;666&apos;, &apos;123456&apos;, &apos;PASS&apos;],</span><br><span class="line">    [&apos;a b&apos;, &apos;123456&apos;, &apos;PASS&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(&apos;result.csv&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;, newline=&apos;&apos;) as f:</span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    writer.writerow(header)</span><br><span class="line">    writer.writerows(data)</span><br><span class="line">注意，打开文件时应指定格式为w, 文本写入，不支持wb,二进制写入，当然，也可以使用a/w+/r+</span><br><span class="line">打开文件时，指定不自动添加新行newline=&apos;&apos;,否则每写入一行就或多一个空行。</span><br><span class="line">如果想写入的文件Excel打开没有乱码，utf-8可以改为utf-8-sig。</span><br><span class="line"></span><br><span class="line">结果展示，result.csv内容：：</span><br><span class="line"></span><br><span class="line">name,password,status</span><br><span class="line">abc,123456,PASS</span><br><span class="line">张五,123#456,PASS</span><br><span class="line">张#abc123,123456,PASS</span><br><span class="line">666,123456,PASS</span><br><span class="line">a b,123456,PASS</span><br><span class="line">使用字典格式的数据：DictReader, DictWriter</span><br><span class="line">注意数据必须有标题行时才能使用</span><br><span class="line"></span><br><span class="line">reader=csv.DictReader(f)：直接将标题和每一列数据组装成有序字典（OrderedDict）格式，无须再单独读取标题行</span><br><span class="line">writer=csv.DictWriter(f, 标题行列表)：写入时可使用writer.writeheader()写入标题，然后使用writer.writerow(字典格式数据行)或write.writerows(多行数据)</span><br><span class="line">读取示例：</span><br><span class="line"></span><br><span class="line"># 将CSV 数据读进列表中（首先查找是否使用给定字段名，如果没有，就是用第一行作为键）</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">with open(&apos;data.csv&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">    reader = csv.DictReader(f)</span><br><span class="line">    for row in reader:</span><br><span class="line">        print(row[&apos;name&apos;], row[&apos;password&apos;])</span><br><span class="line">写入示例：</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">header = [&apos;name&apos;, &apos;password&apos;, &apos;status&apos;]</span><br><span class="line"></span><br><span class="line">data = [</span><br><span class="line">    &#123;&apos;name&apos;:&apos;abc&apos;, &apos;password&apos;:&apos;123456&apos;, &apos;status&apos;:&apos;PASS&apos;&#125;,</span><br><span class="line">    &#123;&apos;name&apos;:&apos;张五&apos;, &apos;password&apos;:&apos;123#456&apos;, &apos;status&apos;:&apos;PASS&apos;&#125;,</span><br><span class="line">    &#123;&apos;name&apos;:&apos;张#abc123&apos;, &apos;password&apos;:&apos;123456&apos;, &apos;status&apos;:&apos;PASS&apos;&#125;,</span><br><span class="line">    &#123;&apos;name&apos;:&apos;666&apos;, &apos;password&apos;:&apos;123456&apos;, &apos;status&apos;:&apos;PASS&apos;&#125;,</span><br><span class="line">    &#123;&apos;name&apos;:&apos;a b&apos;, &apos;password&apos;:&apos;123456&apos;, &apos;status&apos;:&apos;PASS&apos;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(&apos;result2.csv&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;, newline=&apos;&apos;) as f:</span><br><span class="line">    writer = csv.DictWriter(f, header)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerows(data)</span><br></pre></td></tr></table></figure></p>
<p>写入结果，同result.csv</p>
<h2 id="Python中删除空白字符"><a href="#Python中删除空白字符" class="headerlink" title="Python中删除空白字符"></a>Python中删除空白字符</h2><p>空白字符一般指以下几种字符：space, tab, linefeed, return, formfeed, and vertical tab。中英文对照表如下：</p>
<p><img src="https://ask.qcloudimg.com/http-save/developer-news/gs2twtfmf0.png?imageView2/2/w/1620" alt><br>去除空白字符</p>
<p>去除所有的空白字符</p>
<p>使用 str.split()及 join</p>
<h2 id="python二级题库-1"><a href="#python二级题库-1" class="headerlink" title="python二级题库(1)"></a>python二级题库(1)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下代码为提示框架</span><br><span class="line"># 请在...处使用一行或多行代码替换</span><br><span class="line"># 请在______处使用一行代码替换</span><br><span class="line">#</span><br><span class="line"># 注意：提示框架代码可以任意修改，以完成程序功能为准</span><br><span class="line">from operator import itemgetter</span><br><span class="line">fo = open(&quot;PY301-1.txt&quot;,&quot;w&quot;)</span><br><span class="line">with open(&quot;小女孩.txt&quot;,&quot;r&quot;) as f:</span><br><span class="line">    txt=f.read()</span><br><span class="line">d = &#123;&#125;</span><br><span class="line">exclude = &quot;，。！？、（）【】&lt;&gt;《》=：+-*—“”…&quot;</span><br><span class="line"></span><br><span class="line">for i in txt:</span><br><span class="line">    if i in exclude:</span><br><span class="line">        continue</span><br><span class="line">    d[i]=d.get(i,0)+1</span><br><span class="line">#d=list(d.items())</span><br><span class="line">#d.sort(key=lambda x:x[1],reverse=True)</span><br><span class="line">d1=sorted(d.items(),key=itemgetter(1),reverse=True)</span><br><span class="line">fo.write(&quot;&#123;&#125;:&#123;&#125;&quot;.format(d1[0][0],d1[0][1]))</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下代码为提示框架</span><br><span class="line"># 请在...处使用一行或多行代码替换</span><br><span class="line">#</span><br><span class="line"># 注意：提示框架代码可以任意修改，以完成程序功能为准</span><br><span class="line"></span><br><span class="line">fi=open(&quot;小女孩.txt&quot;,&quot;r&quot;)</span><br><span class="line">fo = open(&quot;PY301-2.txt&quot;,&quot;w&quot;)</span><br><span class="line">txt=fi.read()</span><br><span class="line">d = &#123;&#125;</span><br><span class="line">for word in txt:</span><br><span class="line">    d[word]=d.get(word,0)+1</span><br><span class="line">ls = list(d.items())</span><br><span class="line">ls.sort(key=lambda x:x[1], reverse=True) # 此行可以按照词频由高到低排序</span><br><span class="line">for i in range(10):</span><br><span class="line">    fo.write(ls[i][0])</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/wjplearning/article/details/81711032" target="_blank" rel="noopener">https://blog.csdn.net/wjplearning/article/details/81711032</a><br><a href="https://www.cnblogs.com/qican/p/11122206.html" target="_blank" rel="noopener">https://www.cnblogs.com/qican/p/11122206.html</a><br><a href="http://www.manongjc.com/detail/11-giunqdzgzmfykic.html" target="_blank" rel="noopener">http://www.manongjc.com/detail/11-giunqdzgzmfykic.html</a><br><a href="https://www.cnblogs.com/wkfvawl/p/9487165.html" target="_blank" rel="noopener">https://www.cnblogs.com/wkfvawl/p/9487165.html</a><br><a href="https://cloud.tencent.com/developer/news/448964" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/448964</a><br><a href="https://www.cnblogs.com/yudanqu/p/8683794.html" target="_blank" rel="noopener">https://www.cnblogs.com/yudanqu/p/8683794.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>python学习笔记 (一）</title>
    <url>/2020/01/09/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    <content><![CDATA[<h2 id="Python-是强类型的动态脚本语言"><a href="#Python-是强类型的动态脚本语言" class="headerlink" title="Python 是强类型的动态脚本语言"></a>Python 是强类型的动态脚本语言</h2><p>好多人对python到底是强语言类型还是弱语言类型存在误解，其实，是否是强类型语言只需要一句话就可以判别，<br><a id="more"></a><br>强类型：不允许不同类型相加。例如：整形+字符串会报类型错误。</p>
<p>动态：不使用显示数据类型声明，且确定一个变量的类型是在第一次给它赋值的时候。</p>
<p>脚本语言：一般是解释性语言，运行代码只需要一个解释器，不需要编辑。</p>
<p>强弱是对类型而言的。<br>强类型，你有一个值之后这个值是什么类型是确定，比如n=’1’，n的类型是确定的（字符串），因此你不能在Python做n=’3’ m=n+1运算。而弱类型就不是这样的，值的类型可以在需要的时候再去确定，比如PHP里面你可以$n=’3’; $m=$n+1，运算的时候’3’就可以当作整型来进行计算。</p>
<p>弱类型使用会灵活些，但有时候也会因为这种灵活而带来一些歧义，相比而已，强类型就更严谨了。</p>
<p>理解变量在计算机内存中的表示也非常重要。当我们写：</p>
<p>a = ‘ABC’<br>时，Python解释器干了两件事情：</p>
<p>在内存中创建了一个’ABC’的字符串；</p>
<p>在内存中创建了一个名为a的变量，并把它指向’ABC’。</p>
<p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据</p>
<h2 id="python-基本数据类型"><a href="#python-基本数据类型" class="headerlink" title="python 基本数据类型"></a>python 基本数据类型</h2><p>数字 字符串 列表 元组 字典 集合</p>
<p>数字 布尔型 :True false</p>
<h2 id="Python的浮点型不区分单精度和双精度"><a href="#Python的浮点型不区分单精度和双精度" class="headerlink" title="Python的浮点型不区分单精度和双精度"></a>Python的浮点型不区分单精度和双精度</h2><p>python的浮点型数据在内存中占24个字节</p>
<p>Python原生浮点数类型只有一种，叫float，大小为24个字节（我这里Python3.6是这样，别的版本不清楚），本身就是双精度（你打个特别长的小数，最后它会给你截止到15-16位有效数字，这是双精度浮点数的典型特征），不论你是多短的浮点数都是如此</p>
<p>Python和别的语言不一样，每个变量都是对象，而对象里有各种杂七杂八的属性方法，所以内存占用比其他语言大得多</p>
<h2 id="python序列"><a href="#python序列" class="headerlink" title="python序列"></a>python序列</h2><p>• 序列是一块用来存放多个值的连续内存空间。常见的序列有列表、元组、字典和集合。</p>
<p>• 可变与不可变特性</p>
<p>• 可变：列表、字典和集合</p>
<p>• 不可变：元组</p>
<p>• 有序与无序特性</p>
<p>• 有序：列表、元组和字典</p>
<p>• 无序：集合</p>
<p>• 上述序列结构中并不一定要求所有元素都是相同类型的</p>
<p>• 可以利用集合来完成去重处理</p>
<p>• 可以利用字典的哈希特性来完成大数据量的查找和统计的速度<br>• 列表推导式的功能要重点贯彻</p>
<p>如果希望内存占用更小，而有用单精度的需求，建议使用numpy等第三方库，可以提供对变量类型大小的控制。</p>
<h2 id="数据类型的可变与不可变特性"><a href="#数据类型的可变与不可变特性" class="headerlink" title="数据类型的可变与不可变特性"></a>数据类型的可变与不可变特性</h2><p>不可变数据类型： 当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种<br>数据类型，就称不可变数据类型。</p>
<p>• 可变数据类型 ：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数<br>据类型，就称可变数据类型。</p>
<p>• 不可变数据类型： 值相等内存空间地址同</p>
<p>• 数字<br>• 字符串<br>• 元组</p>
<p>• 可变数据类型 值相等内存空间地址不同</p>
<p>• 列表<br>• 字典<br>• 集合<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">x=[123,12]</span><br><span class="line">y=[123,12]</span><br><span class="line">print(id(x))</span><br><span class="line">print(id(y))</span><br></pre></td></tr></table></figure></p>
<p>值相等地址空间不同</p>
<h3 id="python循环"><a href="#python循环" class="headerlink" title="python循环"></a>python循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">money=int(input(&quot;输入&quot;))</span><br><span class="line">coins=(25,10,5,1)</span><br><span class="line">counts=[]</span><br><span class="line">for coin in coins:</span><br><span class="line">    counts.append(money//coin)</span><br><span class="line">    money%=coin</span><br><span class="line">for i in range(len(counts)):</span><br><span class="line">    print(&quot;找零&#123;0&#125;美分硬币&#123;1&#125;个&quot;.format(coins[i],counts[i]))</span><br></pre></td></tr></table></figure>
<h2 id="python格式化输出"><a href="#python格式化输出" class="headerlink" title="python格式化输出"></a>python格式化输出</h2><p><a href="https://www.cnblogs.com/lovejh/p/9201219.html" target="_blank" rel="noopener">https://www.cnblogs.com/lovejh/p/9201219.html</a><br> 相对基本格式化输出采用‘%’的方法，format()功能更强大，该函数把字符串当成一个模板，通过传入的参数进行格式化，并且使用大括号‘{}’作为特殊字符代替‘%’</p>
<p>使用方法由两种：b.format(a)和format(a,b)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &gt;&gt;&gt; print(&apos;&#123;&#125; &#123;&#125;&apos;.format(&apos;hello&apos;,&apos;world&apos;))  # 不带字段</span><br><span class="line">2 hello world</span><br></pre></td></tr></table></figure></p>
<h2 id="python格式化字符"><a href="#python格式化字符" class="headerlink" title="python格式化字符"></a>python格式化字符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式 描述</span><br><span class="line">%% 百分号标记 #就是输出一个%</span><br><span class="line">%c 字符及其ASCII码</span><br><span class="line">%s 字符串</span><br><span class="line">%d 有符号整数(十进制)</span><br><span class="line">%u 无符号整数(十进制)</span><br><span class="line">%o 无符号整数(八进制)</span><br><span class="line">%x 无符号整数(十六进制)</span><br><span class="line">%X 无符号整数(十六进制大写字符)</span><br><span class="line">%e 浮点数字(科学计数法)</span><br><span class="line">%E 浮点数字(科学计数法，用E代替e)</span><br><span class="line">%f 浮点数字(用小数点符号)</span><br><span class="line">%g 浮点数字(根据值的大小采用%e或%f)</span><br><span class="line">%G 浮点数字(类似于%g)</span><br><span class="line">%p 指针(用十六进制打印值的内存地址)</span><br><span class="line">%n 存储输出字符的数量放进参数列表的下一个变量中</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">%格式化符也可用于字典，可用%(name)引用字典中的元素进行格式化输出。</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">负号指时数字应该是左对齐的，“0”告诉Python用前导0填充数字，正号指时数字总是显示它的正负(+，-)符号，即使数字是正数也不例外。</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">可指定最小的字段宽度，如：&quot;%5d&quot; % 2。也可用句点符指定附加的精度，如：&quot;%.3d&quot; % 3。</span><br><span class="line"></span><br><span class="line">e.g.</span><br><span class="line"># 例：数字格式化</span><br><span class="line">nYear = 2018</span><br><span class="line">nMonth = 8</span><br><span class="line">nDay = 18</span><br><span class="line"># 格式化日期 %02d数字转成两位整型缺位填0</span><br><span class="line">print &apos;%04d-%02d-%02d&apos;%(nYear,nMonth,nDay)</span><br><span class="line">&gt;&gt; 2018-08-18 # 输出结果</span><br><span class="line"></span><br><span class="line">fValue = 8.123</span><br><span class="line">print &apos;%06.2f&apos;%fValue # 保留宽度为6的2位小数浮点型</span><br><span class="line">&gt;&gt; 008.12 # 输出</span><br><span class="line"></span><br><span class="line">print &apos;%d&apos;%10 # 输出十进制</span><br><span class="line">&gt;&gt; 10</span><br><span class="line">print &apos;%o&apos;%10 # 输出八进制</span><br><span class="line">&gt;&gt; 12</span><br><span class="line">print &apos;%02x&apos;%10 # 输出两位十六进制，字母小写空缺补零</span><br><span class="line">&gt;&gt; 0a</span><br><span class="line">print &apos;%04X&apos;%10 # 输出四位十六进制，字母大写空缺补零</span><br><span class="line">&gt;&gt; 000A</span><br><span class="line">print &apos;%.2e&apos;%1.2888 # 以科学计数法输出浮点型保留2位小数</span><br><span class="line">&gt;&gt; 1.29e+00</span><br><span class="line"></span><br><span class="line"> 格式化操作符辅助指令</span><br><span class="line">符号 作用</span><br><span class="line">* 定义宽度或者小数点精度</span><br><span class="line">- 用做左对齐</span><br><span class="line">+ 在正数前面显示加号( + )</span><br><span class="line">&lt;sp&gt; 在正数前面显示空格</span><br><span class="line"># 在八进制数前面显示零(&apos;0&apos;),在十六进制前面显示&apos;0x&apos;或者&apos;0X&apos;(取决于</span><br><span class="line">          用的是&apos;x&apos;还是&apos;X&apos;)</span><br><span class="line">0 显示的数字前面填充‘0’而不是默认的空格</span><br><span class="line">% &apos;%%&apos;输出一个单一的&apos;%&apos;</span><br><span class="line">(var) 映射变量(字典参数)</span><br><span class="line">m.n m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</span><br><span class="line"> ``` </span><br><span class="line">小数点前面的数字表示最小宽度</span><br><span class="line"></span><br><span class="line">数字位数大于它时，按实际位数输出，小数点前空缺也是</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">小数点后面的数字表示输出的小数点位数，如果位数不足就会四舍五入，如果位数不够显示就会在后面补0.</span><br><span class="line"></span><br><span class="line">比如x=12.31913</span><br><span class="line">则printf(&quot;%5.3f&quot;,x)就是“12.319”，注意小数点也算一位数长！</span><br><span class="line"></span><br><span class="line">又如x=2.31913</span><br><span class="line">则printf(&quot;%6.3f&quot;,x)就是“ 2.319”，注意小数点也算一位数长，2前面还有一个空格！</span><br><span class="line"></span><br><span class="line">5.3是指结果总长是最小宽度为五位数（注意小数点也算一位数长），就是小数点前两个数字，不足就用空格表示，小数点后保留两位，不足四舍五入！</span><br><span class="line"></span><br><span class="line">关于format方法</span><br><span class="line">![](http://ww1.sinaimg.cn/large/006LSO4Ggy1gdz6p90a10j30me0bot9y.jpg)</span><br></pre></td></tr></table></figure>
<p>print(“float占8位留2位小数：{:8.2f}——默认右对齐”.format(1192.68123))<br>print(“float占18位留2位小数：{:18.2f}——默认右对齐”.format(1192.68123))<br>print(“float占18位留2位小数：{:&gt;18.2f}——右对齐”.format(1192.68123))<br>print(“float占18位留2位小数：{:&lt;18.2f}——左对齐”.format(1192.68123))<br>print(“float占18位留2位小数：{:^18.2f}——居中对齐”.format(1192.68123))<br>print(“float留2位小数：{:.2f}——默认右对齐”.format(1192.68123))<br>print(“float留2位小数：{:&gt;.2f}——右对齐”.format(1192.68123))<br>print(“float留2位小数：{:&lt;.2f}——左对齐”.format(1192.68123))<br>print(“float留2位小数：{:&lt;+.2f}——左对齐带符号”.format(1192.68123))<br>print(“float留2位小数：{:&lt;.2%}——左对齐百分比形式”.format(0.6812345))<br>print(“int占8位：{:&lt;8d}——左对齐”.format(1192))<br>print(“int占8位：{:0&lt;8d}——左对齐补0”.format(1192))<br>print(“int占8位：{:x&lt;8d}——左对齐补x”.format(1192))<br>print(“int占8位：{:中&lt;8d}——左对齐补中”.format(1192))<br>print(“int占8位：{:8d}——默认右对齐”.format(1192))<br>print(“int占8位：{:8d}——默认右对齐”.format(1192))<br>print(“int占22位：{:22e}——默认右对齐科学计数法”.format(1230000))</p>
<p><code>`</code><br><img src="https://img-blog.csdnimg.cn/20190506161044545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1Z3VzaGFuZ2xpYW5n,size_16,color_FFFFFF,t_70" alt></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python的extend和append区别</title>
    <url>/2018/09/24/python%E7%9A%84extend%E5%92%8Cappend%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; li = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]  </span><br><span class="line">&gt;&gt;&gt; li.extend([&apos;d&apos;, &apos;e&apos;, &apos;f&apos;])   </span><br><span class="line">&gt;&gt;&gt; li  </span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]  </span><br><span class="line">&gt;&gt;&gt; len(li)                      </span><br><span class="line">6  </span><br><span class="line">&gt;&gt;&gt; li[-1]  </span><br><span class="line">&apos;f&apos;  </span><br><span class="line">&gt;&gt;&gt; li = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]  </span><br><span class="line">&gt;&gt;&gt; li.append([&apos;d&apos;, &apos;e&apos;, &apos;f&apos;])   </span><br><span class="line">&gt;&gt;&gt; li  </span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;]]  </span><br><span class="line">&gt;&gt;&gt; len(li)                      </span><br><span class="line">4  </span><br><span class="line">&gt;&gt;&gt; li[-1]  </span><br><span class="line">[&apos;d&apos;, &apos;e&apos;, &apos;f&apos;]</span><br></pre></td></tr></table></figure>
 <a id="more"></a>
<p> Lists 的两个方法 extend 和 append 看起来类似，但实际上完全不同。extend 接受一个参数，这个参数总是一个 list，并且把这个 list 中的每个元素添加到原 list 中。<br>在这里 list 中有 3 个元素 (‘a’、’b’ 和 ‘c’)，并且使用另一个有 3 个元素 (‘d’、’e’ 和 ‘f’) 的 list 扩展之，因此新的 list 中有 6 个元素。<br>另一方面，append 接受一个参数，这个参数可以是任何数据类型，并且简单地追加到 list 的尾部。在这里使用一个含有 3 个元素的 list 参数调用 append 方法。<br>原来包含 3 个元素的 list 现在包含 4 个元素。为什么是 4 个元素呢？因为刚刚追加的最后一个元素本身是个 list。List 可以包含任何类型的数据，也包括其他的 list。这或许是您所要的结果，或许不是。如果您的意图是 extend，请不要使用 append。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>Python 语法小记 input及对文件的操作</title>
    <url>/2018/04/28/python%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="input函数用法"><a href="#input函数用法" class="headerlink" title="input函数用法"></a>input函数用法</h2><p>python input() 相等于 eval(raw_input(prompt)) ，用来获取控制台的输入。<br>raw_input() 将所有输入作为字符串看待，返回字符串类型。而 input() 在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（ int, float ）。<br>注意：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）。而对于 input() ，它希望能够读取一个合法的python表达式，即你输入字符串的时候必须使用引号将它括起来，否则它会引发一个 SyntaxError 。<br><a id="more"></a><br>除非对 input() 有特别需要，否则一般情况下我们都是推荐使用 raw_input() 来与用户交互。<br>注意：==python3 里 input() 默认接收到的是 str 类型。==<br>函数语法<br>input([prompt])<br>参数说明：<br>无<br>实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input() 需要输入 python 表达式</span><br><span class="line">&gt;&gt;&gt;a = input(&quot;input:&quot;)</span><br><span class="line">input:123                  # 输入整数</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;type &apos;int&apos;&gt;               # 整型</span><br><span class="line">&gt;&gt;&gt; a = input(&quot;input:&quot;)    </span><br><span class="line">input:&quot;runoob&quot;           # 正确，字符串表达式</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;type &apos;str&apos;&gt;             # 字符串</span><br><span class="line">&gt;&gt;&gt; a = input(&quot;input:&quot;)</span><br><span class="line">input:runoob               # 报错，不是表达式</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &apos;runoob&apos; is not defined</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">raw_input() 将所有输入作为字符串看待</span><br><span class="line">&gt;&gt;&gt;a = raw_input(&quot;input:&quot;)</span><br><span class="line">input:123</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;type &apos;str&apos;&gt;              # 字符串</span><br><span class="line">&gt;&gt;&gt; a = raw_input(&quot;input:&quot;)</span><br><span class="line">input:runoob</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;type &apos;str&apos;&gt;              # 字符串</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="文件的打开与关闭-open-文件名，访问模式"><a href="#文件的打开与关闭-open-文件名，访问模式" class="headerlink" title="文件的打开与关闭 open(文件名，访问模式)"></a>文件的打开与关闭 open(文件名，访问模式)</h2><p>f = open(‘test.txt’, ‘w’)</p>
<blockquote>
<p>访问模式    说明<br>r    以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。<br>w    打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>a    打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</p>
</blockquote>
<p>wb    以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>ab    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>r+    打开一个文件用于读写。文件指针将会放在文件的开头。<br>w+    打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>a+    打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<br>rb+    以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。<br>wb+    以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>ab+    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 新建一个文件，文件名为:test.txt</span><br><span class="line">  f = open(&apos;test.txt&apos;, &apos;w&apos;)</span><br><span class="line"></span><br><span class="line">  # 关闭这个文件</span><br><span class="line">  f.close()</span><br></pre></td></tr></table></figure></p>
<h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><h3 id="写数据-write"><a href="#写数据-write" class="headerlink" title="写数据(write)"></a>写数据(write)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f = open(&apos;test.txt&apos;, &apos;w&apos;)</span><br><span class="line">f.write(&apos;hello world, i am here!&apos;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据</p>
<h3 id="读数据-read"><a href="#读数据-read" class="headerlink" title="读数据(read)"></a>读数据(read)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f = open(&apos;test.txt&apos;)</span><br><span class="line"></span><br><span class="line">content = f.read(5)</span><br><span class="line"></span><br><span class="line">print(content)</span><br><span class="line"></span><br><span class="line">print(&quot;-&quot;*30)</span><br><span class="line"></span><br><span class="line">content = f.read()</span><br><span class="line"></span><br><span class="line">print(content)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<h3 id="读数据（readlines）"><a href="#读数据（readlines）" class="headerlink" title="读数据（readlines）"></a>读数据（readlines）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">f = open(&apos;test.txt&apos;, &apos;r&apos;)</span><br><span class="line">content = f.readlines()</span><br><span class="line"></span><br><span class="line">print(type(content))</span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">for temp in content:</span><br><span class="line">    print(&quot;%d:%s&quot;%(i, temp))</span><br><span class="line">    i+=1</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p><class 'list'><br>1:hello world, i am here!</class></p>
<p>2:hello world, i am here!</p>
<p>3:hello world, i am here!</p>
<p>4:hello world, i am here!</p>
<h3 id="拷贝一个文件"><a href="#拷贝一个文件" class="headerlink" title="拷贝一个文件"></a>拷贝一个文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">oldFileName = input(&quot;请输入要拷贝的文件名字:&quot;)</span><br><span class="line"></span><br><span class="line">oldFile = open(oldFileName,&apos;r&apos;)</span><br><span class="line"># 如果打开文件</span><br><span class="line">if oldFile:</span><br><span class="line"></span><br><span class="line">    # 提取文件的后缀</span><br><span class="line">    fileFlagNum = oldFileName.rfind(&apos;.&apos;)</span><br><span class="line">    if fileFlagNum &gt; 0:</span><br><span class="line">        fileFlag = oldFileName[fileFlagNum:]</span><br><span class="line"></span><br><span class="line">    # 组织新的文件名字</span><br><span class="line">    newFileName = oldFileName[:fileFlagNum] + &apos;[复件]&apos; + fileFlag</span><br><span class="line"></span><br><span class="line">    # 创建新文件</span><br><span class="line">    newFile = open(newFileName, &apos;w&apos;)</span><br><span class="line"></span><br><span class="line">    # 把旧文件中的数据，一行一行的进行复制到新文件中</span><br><span class="line">    for lineContent in oldFile.readlines():</span><br><span class="line">        newFile.write(lineContent)</span><br><span class="line"></span><br><span class="line">    # 关闭文件</span><br><span class="line">    oldFile.close()</span><br><span class="line">    newFile.close()</span><br></pre></td></tr></table></figure>
<h2 id="文件夹的相关操作"><a href="#文件夹的相关操作" class="headerlink" title="文件夹的相关操作"></a>文件夹的相关操作</h2><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><p>import os<br>os.mkdir(“张三”)</p>
<p>###获取当前目录<br> import os<br>os.getcwd()</p>
<p>###改变默认目录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">   os.chdir(&quot;../&quot;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">os.chdir(&quot;../../&quot;)</span><br><span class="line">print(os.getcwd())</span><br></pre></td></tr></table></figure>
<p>C:\Users\lenovo\workspace\te\src\test<br>C:\Users\lenovo\workspace\te</p>
<h3 id="获取目录列表"><a href="#获取目录列表" class="headerlink" title="获取目录列表"></a>获取目录列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">  os.listdir(&quot;./&quot;)</span><br></pre></td></tr></table></figure>
<p>[‘test.py’, ‘test[复件].txt’, ‘ts.py’]</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>import os<br>os.remove(“毕业论文.txt”)</p>
<h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>import os<br>os.rename(“毕业论文.txt”, “毕业论文-最终版.txt”)</p>
<h2 id="python-os-path模块常用方法"><a href="#python-os-path模块常用方法" class="headerlink" title="python os.path模块常用方法"></a>python os.path模块常用方法</h2><h4 id="os-path-abspath-path"><a href="#os-path-abspath-path" class="headerlink" title="os.path.abspath(path)"></a>os.path.abspath(path)</h4><p>返回path规范化的绝对路径。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.abspath(‘test.csv’)<br>‘C:\Python25\test.csv’ </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.abspath(‘c:\test.csv’)<br>‘c:\test.csv’ </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.abspath(‘../csv\test.csv’)<br>‘C:\csv\test.csv’ </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-split-path"><a href="#os-path-split-path" class="headerlink" title="os.path.split(path)"></a>os.path.split(path)</h4><p>将path分割成目录和文件名二元组返回。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.split(‘c:\csv\test.csv’)<br>(‘c:\csv’, ‘test.csv’)<br>os.path.split(‘c:\csv\‘)<br>(‘c:\csv’, ‘’) </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-dirname-path"><a href="#os-path-dirname-path" class="headerlink" title="os.path.dirname(path)"></a>os.path.dirname(path)</h4><p>返回path的目录。其实就是os.path.split(path)的第一个元素。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.dirname(‘c:\csv\test.csv’)<br>‘c:\‘<br>os.path.dirname(‘c:\csv’)<br>‘c:\‘ </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-basename-path"><a href="#os-path-basename-path" class="headerlink" title="os.path.basename(path)"></a>os.path.basename(path)</h4><p>返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.basename(‘c:\test.csv’)<br>‘test.csv’<br>os.path.basename(‘c:\csv’)<br>‘csv’ （这里csv被当作文件名处理了）<br>os.path.basename(‘c:\csv\‘)<br>‘’ </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-commonprefix-list"><a href="#os-path-commonprefix-list" class="headerlink" title="os.path.commonprefix(list)"></a>os.path.commonprefix(list)</h4><p>返回list中，所有path共有的最长的路径。 </p>
<p>如： </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.commonprefix([‘/home/td’,’/home/td/ff’,’/home/td/fff’])<br>‘/home/td’ </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-exists-path"><a href="#os-path-exists-path" class="headerlink" title="os.path.exists(path)"></a>os.path.exists(path)</h4><p>如果path存在，返回True；如果path不存在，返回False。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.exists(‘c:\‘)<br>True<br>os.path.exists(‘c:\csv\test.csv’)<br>False </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-isabs-path"><a href="#os-path-isabs-path" class="headerlink" title="os.path.isabs(path)"></a>os.path.isabs(path)</h4><p>如果path是绝对路径，返回True。 </p>
<h4 id="os-path-isfile-path"><a href="#os-path-isfile-path" class="headerlink" title="os.path.isfile(path)"></a>os.path.isfile(path)</h4><p>如果path是一个存在的文件，返回True。否则返回False。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.isfile(‘c:\boot.ini’)<br>True<br>os.path.isfile(‘c:\csv\test.csv’)<br>False<br>os.path.isfile(‘c:\csv\‘)<br>False </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-isdir-path"><a href="#os-path-isdir-path" class="headerlink" title="os.path.isdir(path)"></a>os.path.isdir(path)</h4><p>如果path是一个存在的目录，则返回True。否则返回False。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.isdir(‘c:\‘)<br>True<br>os.path.isdir(‘c:\csv\‘)<br>False<br>os.path.isdir(‘c:\windows\test.csv’)<br>False </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-join-path1-path2-…"><a href="#os-path-join-path1-path2-…" class="headerlink" title="os.path.join(path1[, path2[, …]])"></a>os.path.join(path1[, path2[, …]])</h4><p>将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.join(‘c:\‘, ‘csv’, ‘test.csv’)<br>‘c:\csv\test.csv’<br>os.path.join(‘windows\temp’, ‘c:\‘, ‘csv’, ‘test.csv’)<br>‘c:\csv\test.csv’<br>os.path.join(‘/home/aa’,’/home/aa/bb’,’/home/aa/bb/c’)<br>‘/home/aa/bb/c’ </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-normcase-path"><a href="#os-path-normcase-path" class="headerlink" title="os.path.normcase(path)"></a>os.path.normcase(path)</h4><p>在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.normcase(‘c:/windows\system32\‘)<br>‘c:\windows\system32\‘ </p>
</blockquote>
</blockquote>
</blockquote>
<p>####os.path.normpath(path)<br>规范化路径。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.normpath(‘c://windows\System32\../Temp/‘)<br>‘c:\windows\Temp’ </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-splitdrive-path"><a href="#os-path-splitdrive-path" class="headerlink" title="os.path.splitdrive(path)"></a>os.path.splitdrive(path)</h4><p>返回（drivername，fpath）元组 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.splitdrive(‘c:\windows’)<br>(‘c:’, ‘\windows’) </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-splitext-path"><a href="#os-path-splitext-path" class="headerlink" title="os.path.splitext(path)"></a>os.path.splitext(path)</h4><p>分离文件名与扩展名；默认返回(fname,fextension)元组，可做分片操作 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.splitext(‘c:\csv\test.csv’)<br>(‘c:\csv\test’, ‘.csv’) </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="os-path-getsize-path"><a href="#os-path-getsize-path" class="headerlink" title="os.path.getsize(path)"></a>os.path.getsize(path)</h4><p>返回path的文件的大小（字节）。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.getsize(‘c:\boot.ini’)<br>299L </p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="dirname-用于去掉文件名，返回目录所在的路径"><a href="#dirname-用于去掉文件名，返回目录所在的路径" class="headerlink" title="dirname()   用于去掉文件名，返回目录所在的路径"></a>dirname()   用于去掉文件名，返回目录所在的路径</h4><p>如：</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.dirname(‘d:\library\book.txt’)<br>‘d:\library’</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="basename-用于去掉目录的路径，只返回文件名"><a href="#basename-用于去掉目录的路径，只返回文件名" class="headerlink" title="basename()   用于去掉目录的路径，只返回文件名"></a>basename()   用于去掉目录的路径，只返回文件名</h4><p>如：</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.basename(‘d:\library\book.txt’)<br>‘book.txt’</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="join-用于将分离的各部分组合成一个路径名"><a href="#join-用于将分离的各部分组合成一个路径名" class="headerlink" title="join()   用于将分离的各部分组合成一个路径名"></a>join()   用于将分离的各部分组合成一个路径名</h4><p>如：</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.join(‘d:\library’,’book.txt’)<br>‘d:\library\book.txt’</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="split-用于返回目录路径和文件名的元组"><a href="#split-用于返回目录路径和文件名的元组" class="headerlink" title="split()  用于返回目录路径和文件名的元组"></a>split()  用于返回目录路径和文件名的元组</h4><p>如：</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.split(‘d:\library\book.txt’)<br>(‘d:\library’, ‘book.txt’)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="splitdrive-用于返回盘符和路径字符元组"><a href="#splitdrive-用于返回盘符和路径字符元组" class="headerlink" title="splitdrive()    用于返回盘符和路径字符元组"></a>splitdrive()    用于返回盘符和路径字符元组</h4><blockquote>
<blockquote>
<blockquote>
<p>import os</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.splitdrive(‘d:\library\book.txt’)<br>(‘d:’, ‘\library\book.txt’)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="splitext-用于返回文件名和扩展名元组"><a href="#splitext-用于返回文件名和扩展名元组" class="headerlink" title="splitext()    用于返回文件名和扩展名元组"></a>splitext()    用于返回文件名和扩展名元组</h4><p>如：</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.splitext(‘d:\library\book.txt’)<br>(‘d:\library\book’, ‘.txt’)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.splitext(‘book.txt’)<br>(‘book’, ‘.txt’)</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>python语法</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 882. Reachable Nodes In Subdivided Graph</title>
    <url>/2018/12/02/re/</url>
    <content><![CDATA[<p>Starting with an undirected graph (the “original graph”) with nodes from 0 to N-1, subdivisions are made to some of the edges.</p>
<p>The graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph,<br><a id="more"></a><br>and n is the total number of new nodes on that edge. </p>
<p>Then, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, …, x_n) are added to the original graph,</p>
<p>and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), …, (x_{n-1}, x_n), (x_n, j) are added to the original graph.</p>
<p>Now, you start at node 0 from the original graph, and in each move, you travel along one edge. </p>
<p>Return how many nodes you can reach in at most M moves.</p>
<p>Example 1:</p>
<p>Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3</p>
<p>Output: 13</p>
<p>Explanation: </p>
<p>The nodes that are reachable in the final graph after M = 6 moves are indicated below.</p>
<p>Example 2:</p>
<p>Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4</p>
<p>Output: 23</p>
<p>Note:</p>
<p>0 &lt;= edges.length &lt;= 10000</p>
<p>0 &lt;= edges[i][0] &lt; edges[i][1] &lt; N</p>
<p>There does not exist any i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1].</p>
<p>The original graph has no parallel edges.</p>
<p>0 &lt;= edges[i][2] &lt;= 10000</p>
<p>0 &lt;= M &lt;= 10^9</p>
<p>1 &lt;= N &lt;= 3000</p>
<p>A reachable node is a node that can be travelled to using at most M moves starting from node 0.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求最短路径(Dij算法)<br>给定源点的血量<br>相当于求从源点到其他顶点剩余的最大值(至少要大于0)<br>有的顶点可能到达不了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int M, int N) &#123;</span><br><span class="line">        //节点，对应的最大血量</span><br><span class="line">        unordered_map&lt;int,int&gt; HP;</span><br><span class="line">        //节点编号-&gt;相邻点(-&gt;边的权值)</span><br><span class="line">        unordered_map&lt;int,unordered_map&lt;int,int&gt;&gt; g_;</span><br><span class="line">        for(auto e:edges)&#123;</span><br><span class="line">            g_[e[0]][e[1]]=e[2];</span><br><span class="line">            g_[e[1]][e[0]]=e[2];</span><br><span class="line">        &#125;</span><br><span class="line">        //hp-&gt;node</span><br><span class="line">        priority_queue&lt;pair&lt;int,int&gt;&gt; pq;</span><br><span class="line">        pq.push(&#123;M,0&#125;);</span><br><span class="line">        while(!pq.empty())&#123;</span><br><span class="line">            pair&lt;int,int&gt; p=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            int hp=p.first;</span><br><span class="line">            int cur=p.second;</span><br><span class="line">            if(HP.count(cur)) continue;</span><br><span class="line">            HP[cur]=hp;</span><br><span class="line">            for(auto tt:g_[cur])&#123;</span><br><span class="line">                int next_hp=hp-tt.second-1;</span><br><span class="line">                int nxt=tt.first;</span><br><span class="line">                //!!</span><br><span class="line">                if(HP.count(nxt)||next_hp&lt;0) continue;</span><br><span class="line">                pq.push(&#123;next_hp,nxt&#125;);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        int ans=HP.size();</span><br><span class="line">        for(auto e:edges)&#123;</span><br><span class="line">           int m=HP.count(e[0])?HP[e[0]]:0;</span><br><span class="line">           int n=HP.count(e[1])?HP[e[1]]:0;</span><br><span class="line">             ans+=min(e[2],m+n);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>ram rom cache 区别</title>
    <url>/2018/06/24/ram-rom-cache-%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><img src="https://pic1.zhimg.com/80/8bf6ef80ddbcd9ed5984fe9a51bb5b78_hd.jpg" alt="image"></p>
<p>内存储器分为随机存储器（ram）和只读存储器（rom）。</p>
<p>RAM通常就是内存，插在主板上；ROM通常是固化在主板上的某些基础功能芯片，还有就是光盘一般也叫ROM；<br><a id="more"></a></p>
<p>ROM表示只读存储器（Read Only Memory），在制造ROM的时候，信息（数据或程序）就被存入并永久保存。这些信息只能读出，一般不能写入，即使机器掉电，这些数据也不会丢失。ROM一般用于存放计算机的基本程序和数据，如BIOS ROM。其物理外形一般是双列直插式（DIP）的集成块。</p>
<p>随机存储器（Random Access Memory）表示既可以从中读取数据，也可以写入数据。当机器电源关闭时，存于其中的数据就会丢失。我们通常购买或升级的内存条就是用作电脑的内存，内存条（SIMM）就是将RAM集成块集中在一起的一小块电路板，它插在计算机中的内存插槽上，以减少RAM集成块占用的空间。目前市场上常见的内存条有4M／条、8M／条、16M／条等。</p>
<p>Cache也是我们经常遇到的概念，它位于CPU与内存之间，是一个读写速度比内存更快的存储器。当CPU向内存中写入或读出数据时，这个数据也被存储进高速缓冲存储器中。当CPU再次需要这些数据时，CPU就从高速缓冲存储器读取数据，而不是访问较慢的内存，当然，如需要的数据在Cache中没有，CPU会再去读取内存中的数据。</p>
<p>参考链接 <a href="https://www.zhihu.com/question/24565362" target="_blank" rel="noopener">https://www.zhihu.com/question/24565362</a></p>
]]></content>
  </entry>
  <entry>
    <title>fopen中的rb和r区别</title>
    <url>/2018/09/07/rb%E5%92%8Cr/</url>
    <content><![CDATA[<p>1) when you use “r” - opening in normal text format<br><a id="more"></a><br>there is a difference in the way C and other (DOS in my example) represents the End-of-LINE (EOL). In C, the EOL is signalled by a single character, the \n the Newlinefeed. but in DOS, the EOL is signalled by 2 characters, combination of \r-Carriage Return and \n-Newlinefeed.</p>
<p>so if you write a C program to count total number of characters in a file and say, for example, result is 100 (for 10 lines in a file), so when you run it in C, the result will be 100 but when you run the program form DOS, the result will be 110 (10 \r for 10 lines) because it will convert all the \n to \r\n.</p>
<p>2) when using “rb” - opening file in Binary format</p>
<p>but this is the not the case with Binary mode. when reading from disk, it will not convert the \r\ns to \ns. here if you run the program through C IDE, the result will be 110 as shown by DOS also and not 100 because of additional \rs.</p>
]]></content>
  </entry>
  <entry>
    <title>round floor ceil函数</title>
    <url>/2018/12/19/round-floor/</url>
    <content><![CDATA[<p>double round (double x);</p>
<p>float round (float x);</p>
<p>long double round (long double x);</p>
<p>double round (T x);</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* round vs floor vs ceil vs trunc */</span><br><span class="line">#include &lt;stdio.h&gt;      /* printf */</span><br><span class="line">#include &lt;math.h&gt;       /* round, floor, ceil, trunc */</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  const char * format = &quot;%.1f \t%.1f \t%.1f \t%.1f \t%.1f\n&quot;;</span><br><span class="line">  printf (&quot;value\tround\tfloor\tceil\ttrunc\n&quot;);</span><br><span class="line">  printf (&quot;-----\t-----\t-----\t----\t-----\n&quot;);</span><br><span class="line">  printf (format, 2.3,round( 2.3),floor( 2.3),ceil( 2.3),trunc( 2.3));</span><br><span class="line">  printf (format, 3.8,round( 3.8),floor( 3.8),ceil( 3.8),trunc( 3.8));</span><br><span class="line">  printf (format, 5.5,round( 5.5),floor( 5.5),ceil( 5.5),trunc( 5.5));</span><br><span class="line">  printf (format,-2.3,round(-2.3),floor(-2.3),ceil(-2.3),trunc(-2.3));</span><br><span class="line">  printf (format,-3.8,round(-3.8),floor(-3.8),ceil(-3.8),trunc(-3.8));</span><br><span class="line">  printf (format,-5.5,round(-5.5),floor(-5.5),ceil(-5.5),trunc(-5.5));</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line"> </span><br><span class="line">value   round   floor   ceil    trunc</span><br><span class="line">-----   -----   -----   ----    -----</span><br><span class="line">2.3     2.0     2.0     3.0     2.0</span><br><span class="line">3.8     4.0     3.0     4.0     3.0</span><br><span class="line">5.5     6.0     5.0     6.0     5.0</span><br><span class="line">-2.3    -2.0    -3.0    -2.0    -2.0</span><br><span class="line">-3.8    -4.0    -4.0    -3.0    -3.0</span><br><span class="line">-5.5    -6.0    -6.0    -5.0    -5.0</span><br></pre></td></tr></table></figure>
<p>pat 1026 程序运行时间 </p>
<p>要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。</p>
<p>这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p>
<p>输入格式：<br>输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,10^7]</p>
<p>输出格式：<br>在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。</p>
<p>输入样例：<br>123 4577973<br>输出样例：<br>12:42:59</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std; </span><br><span class="line">int main()&#123;</span><br><span class="line">	int c1,c2;</span><br><span class="line">	//1s=100clock </span><br><span class="line">	cin&gt;&gt;c1&gt;&gt;c2;</span><br><span class="line">	int ans=c2-c1;</span><br><span class="line">	//ans换算成s ans/100 </span><br><span class="line">	if(ans%100&gt;=50)</span><br><span class="line">	ans=ans/100+1;</span><br><span class="line">	else ans/=100;</span><br><span class="line">	printf(&quot;%02d:%02d:%02d&quot;,ans/3600,ans%3600/60,ans%60);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>`</code></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>sql语句 update深入理解</title>
    <url>/2018/07/03/sql%E8%AF%AD%E5%8F%A5-update%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<h2 id="出现update数据更新成功，反而返回影响行数为0的情况呢"><a href="#出现update数据更新成功，反而返回影响行数为0的情况呢" class="headerlink" title="出现update数据更新成功，反而返回影响行数为0的情况呢"></a>出现update数据更新成功，反而返回影响行数为0的情况呢</h2><p>以为可以判断返回值是否大于0来判断更新是否成功，但是，下面的两种情况均返回0：<br><a id="more"></a><br>1、没有找到需要更新的数据<br>             比如，我们进行update的时候，条件是id=5，但是id=5的数据不存在。这种情况下，更新是失败的，返回0，很正确；</p>
<p>2、要更新的数据和更新的值是完全一样的<br>             比如，我们要对id=5的记录进行更新，把title变成hello。虽然这条记录存在，但是这条记录的title本来就是hello，那么，返回值也是0；</p>
<p>3、本身写的sql语句有问题<br>             比如，update test set cid = ‘5244’ where cid is null or cid=‘’；</p>
<p>第一种情况可以快分析到，但是调查发现不是这种问题，第二种和第三种为啥会出现这样的问题呢? 调查日志发现，同一时间接受到了两条数据导致了二三的出现，所以，大家在碰到这样的问题的时候，看看是不是因为并发请求导致的。控制好自己的并发事物，不然就会怀疑update的这个操作喽~</p>
<p>补充：最近发现update操作使用返回的的影响行数来判断操作成功与否，有时候还与第三方持久化框架有关</p>
<p>使用原生的sql（或者mysql） 重复请求update操作的时候，如 update test set cid = ‘5244’；执行两次的时候发现，update返回影响行数为0</p>
<p>但是使用mybatis的时候，结果却不是这样的，执行两次的时候，发现update返回的影响行数始终是1。后面跟踪发现，原来mybatis这个第三方持久化框架返回来的是被匹配的影响行数，所以返回的始终是1，那如果想要以返回的行数作为判断结果，需要在mybatis连接数据库的时候加上参数，</p>
<p>jdbc:mysql://${jdbc.host}/${jdbc.db}?useAffectedRows=true</p>
<h2 id="update后面使用order-by的情况"><a href="#update后面使用order-by的情况" class="headerlink" title="update后面使用order by的情况"></a>update后面使用order by的情况</h2><p>什么时候有必要增加order by:假如一个表中有自增型或者唯一键id。当想实现对所有id都加一。就会用到类似如下的sql： </p>
<p>update teams set teamno=teamno+1<br>此时就会出现问题，假如有两行数据，一行的teamno=6，另一行的teamno=7。当执行teamno=teamno+1语句，6的值加上1变成7，但是还存在teamno=7的一行，那么就会出现重复而报错。解决办法是，<br>先让teamno=7的行执行更新，然后才让teamno=6的行执行更新。这样就不会出现重复冲突情况。使用 order by可以指定更新的顺序。</p>
<p>sql语句修改为：update teams set teamno=teamno+1 order by teamno desc</p>
<p>成功运行。</p>
<p>总结：因为主键，unique都会要求值是唯一的。更新会出现值重复错误。所以只有针对字段值限制是唯一的时候，使用update才有必要添加order by</p>
<p>参考自 ：<br><a href="https://www.cnblogs.com/wangtao_20/archive/2011/02/23/1962148.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangtao_20/archive/2011/02/23/1962148.html</a><br><a href="https://blog.csdn.net/win7system/article/details/73658270" target="_blank" rel="noopener">https://blog.csdn.net/win7system/article/details/73658270</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>蓝桥杯 分巧克力</title>
    <url>/2019/03/22/s-1/</url>
    <content><![CDATA[<p>题目描述<br>儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。 小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足： 1. 形状是正方形，边长是整数 2. 大小相同 例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？<br><a id="more"></a><br>输入<br>第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000) 以下N行每行包含两个整数Hi和Wi。(1 &lt;= Hi, Wi &lt;= 100000) 输入保证每位小朋友至少能获得一块1x1的巧克力。<br>输出<br>输出切出的正方形巧克力最大可能的边长。<br>样例输入<br>2 10<br>6 5<br>5 6<br>样例输出<br>2<br>题目思路<br>很直接的做法是枚举所有的情况，从最大的可能开始试，不能满足则减一，这样可以得出正确的答案是毋庸置疑的，但是题目的数据较大，加上时间限制，直接枚举会超时。二分法进行优化即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 100005</span><br><span class="line">int n,k; </span><br><span class="line">int a[MAX],b[MAX],ans=0;</span><br><span class="line">long long valid(int v)&#123;//数据较大 考虑用Long</span><br><span class="line">	long long ans=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		ans+=(a[i]/v)*(b[i]/v);</span><br><span class="line">	&#125;</span><br><span class="line">//	cout&lt;&lt;ans;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">void er(int l,int r)&#123;</span><br><span class="line">	int mid;</span><br><span class="line">	while(l&lt;=r)&#123;</span><br><span class="line">		mid=(l+r)/2;</span><br><span class="line">		long long t=valid(mid);</span><br><span class="line">		if(t&gt;=k)&#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			l=mid+1;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">//			er(l,mid-1); 错误</span><br><span class="line">			r=mid-1; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">		cin&gt;&gt;a[i]&gt;&gt;b[i]; </span><br><span class="line">	int l=1,r=MAX;</span><br><span class="line">	er(l,r);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接<br><a href="https://blog.csdn.net/qq_34594236/article/details/72374947" target="_blank" rel="noopener">https://blog.csdn.net/qq_34594236/article/details/72374947</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode 847. Shortest Path Visiting All Nodes</title>
    <url>/2018/12/07/shor/</url>
    <content><![CDATA[<p>An undirected, connected graph of N nodes (labeled 0, 1, 2, …, N-1) is given as graph.</p>
<p>graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected.</p>
<p>Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</p>
 <a id="more"></a>
<p>Example 1:</p>
<p>Input: [[1,2,3],[0],[0],[0]]</p>
<p>Output: 4</p>
<p>Explanation: One possible path is [1,0,2,0,3]</p>
<p>Example 2:</p>
<p>Input: [[1],[0,2,4],[1,3,4],[2],[1,2]]</p>
<p>Output: 4</p>
<p>Explanation: One possible path is [0,1,4,2,3]</p>
<p>Note:</p>
<p>1 &lt;= graph.length &lt;= 12</p>
<p>0 &lt;= graph[i].length &lt; graph.length</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用二进制的数来表示当前访问节点的状态<br>4个节点 如1101表示 0，2，3号节点已访问过</p>
<p>最后的终止状态是1111</p>
<p>或者用Hashtable 也可以</p>
<p>为了遍历所有的节点 一个节点可以被重复访问 所以不能用 vis[cur] 跳过访问过的节点</p>
<p>但是不跳过访问过的状态 可能会陷入 0-&gt;1-&gt;0的死循环</p>
<p>所以建立二维数组vis 记录当前访问过的节点和状态<br>不会重复在这个节点的访问状态<br>即 在1号节点已经访问过0号，1号房间 </p>
<p>pair&lt;int,int&gt; {1,0011}</p>
<p>即在搜索1号节点的邻居时不会再访问0号节点 因为此时状态不会更新<br>还是 0011</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int n,m;</span><br><span class="line">   map&lt;int,vector&lt;int&gt; &gt; g;</span><br><span class="line">    int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        m=graph.size();</span><br><span class="line">     </span><br><span class="line">            for(int i=0;i&lt;graph.size();i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;graph[i].size();j++)&#123;</span><br><span class="line">                g[i].push_back(graph[i][j]);       </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        int ans=1e8;</span><br><span class="line">        queue&lt;pair&lt;int,int&gt; &gt;q;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">            q.push(pair&lt;int,int&gt;&#123;i,1&lt;&lt;i&#125;);</span><br><span class="line">        int steps=0;</span><br><span class="line">        bool vis[12][5000]=&#123;false&#125;;</span><br><span class="line">        int kstate=(1&lt;&lt;m)-1;//!!</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int size=q.size();</span><br><span class="line">            while(size--)&#123;</span><br><span class="line">                pair&lt;int,int&gt; p=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                int cur=p.first;</span><br><span class="line">                int state=p.second;</span><br><span class="line">                </span><br><span class="line">                if(state==kstate) return steps;</span><br><span class="line">                if(vis[cur][state]) continue;</span><br><span class="line">                vis[cur][state]=1;</span><br><span class="line">                for(int i=0;i&lt;g[cur].size();i++)&#123;</span><br><span class="line">                    q.push(pair&lt;int,int&gt;&#123;g[cur][i],state|(1&lt;&lt;g[cur][i])&#125;);//!! 当前状态 1&lt;&lt;g[cur][i]</span><br><span class="line">                //    cout&lt;&lt;cur&lt;&lt;&quot; -&gt; &quot;&lt;&lt;g[cur][i]&lt;&lt;&quot; state:&quot;&lt;&lt;(state|g[cur][i])&lt;&lt;&quot; steps:&quot;&lt;&lt;steps&lt;&lt;endl;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            steps++;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">               return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
        <category>bfs</category>
      </categories>
  </entry>
  <entry>
    <title>HDU2072 单词数【水题】</title>
    <url>/2018/12/09/ss-1/</url>
    <content><![CDATA[<p>Problem Description<br>lily的好朋友xiaoou333最近很空，他想了一件没有什么意义的事情，就是统计一篇文章里不同单词的总数。下面你的任务是帮助xiaoou333解决这个问题。<br> <a id="more"></a></p>
<p>Input<br>有多组数据，每组一行，每组就是一篇小文章。每篇小文章都是由小写字母和空格组成，没有标点符号，遇到#时表示输入结束。</p>
<p>Output<br>每组只输出一个整数，其单独成行，该整数代表一篇文章里不同单词的总数。</p>
<p>Sample Input<br>you are my friend #</p>
<p>Sample Output<br>4<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt; </span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string s;</span><br><span class="line">//!!	set&lt;string&gt; words;</span><br><span class="line">    while(getline(cin, s) &amp;&amp; s != &quot;#&quot;) &#123;</span><br><span class="line">	istringstream sin(s);</span><br><span class="line">	string w;</span><br><span class="line">		set&lt;string&gt; words;</span><br><span class="line">	while(sin&gt;&gt;w)&#123;</span><br><span class="line">		words.insert(w);</span><br><span class="line">	//	cout&lt;&lt;w&lt;&lt;&quot; &quot;;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;words.size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[1024];</span><br><span class="line">    char pound[] = &quot;#&quot;;</span><br><span class="line">    char delim[] = &quot; &quot;;</span><br><span class="line">    char *p;</span><br><span class="line"> </span><br><span class="line">    set&lt;string&gt; words;</span><br><span class="line"> </span><br><span class="line">    while(gets(buf) != NULL) &#123;</span><br><span class="line">        if(strcmp(buf, pound) == 0)</span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        words.clear();</span><br><span class="line"> </span><br><span class="line">        p = strtok(buf, delim);</span><br><span class="line">        while(p) &#123;</span><br><span class="line">             words.insert(p);</span><br><span class="line">             p = strtok(NULL, delim);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; words.size() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于-strtok"><a href="#关于-strtok" class="headerlink" title="关于 strtok"></a>关于 strtok</h2><p>调用方式 ： char <em>strtok(char </em>str1, char *str2);<br>说明    ： strtok()函数的原型在string.h中<br>功能说明：函数strtok()返回字符串str1中指向一个由str2所指定的字符或者字符串的分隔符的指 针，当没有要返回的分隔符时，就返回一个空指针。</p>
<p>函数strtok()实际上修改了有str1指向的字符串。每次找到一个分隔符后，一个空（NULL）就被放到分隔符处，函数用这种方法来连续查找该字符串。</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *p;</span><br><span class="line">    char str[100]=&quot;This is a test ,and you can use it&quot;;</span><br><span class="line">    p = strtok(str,&quot; &quot;); // 注意，此时得到的 p为指向字符串:&quot;This&quot;，即在第一个分隔  符前面的字符串，即每次找到一个分隔符后，一个空（NULL）就被放到分隔符处，所以此时NULL指针指向后面的字符串：&quot;is a test ,and you can use it&quot;。</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%s\n&quot;,p);  // 此时显示：This</span><br><span class="line">    </span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        p = strtok(NULL, &quot;,&quot;);  // NULL 即为上面返回的指针，即字符串:</span><br><span class="line">                                // &quot;is a test ,and you can use it&quot;。</span><br><span class="line">        if(p)</span><br><span class="line">            printf(&quot;|%s&quot;,p);</span><br><span class="line">    &#125;while(p);</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>istringstream,ostringstream用法</title>
    <url>/2018/12/09/ss/</url>
    <content><![CDATA[<p>一、<br>//Example：可以用于分割被空格、制表符等符号分割的字符串<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;sstream&gt;        //istringstream 必须包含这个头文件</span><br><span class="line">#include&lt;string&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int main()&#123;  </span><br><span class="line">    string str=&quot;i am a boy&quot;;  </span><br><span class="line">    istringstream is(str);  </span><br><span class="line">    string s;  </span><br><span class="line">    while(is&gt;&gt;s)  &#123;  </span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<p>i<br>am<br>a<br>boy</p>
<p>二、<br>//Example：stringstream、istringstream、ostringstream的构造函数和用法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // default constructor (input/output stream)</span><br><span class="line">    std::stringstream buf1;</span><br><span class="line">    buf1 &lt;&lt; 7;</span><br><span class="line">    int n = 0;</span><br><span class="line">    buf1 &gt;&gt; n;</span><br><span class="line">    std::cout &lt;&lt; &quot;buf1 = &quot; &lt;&lt; buf1.str() &lt;&lt; &quot; n = &quot; &lt;&lt; n &lt;&lt; &apos;\n&apos;;</span><br><span class="line"> </span><br><span class="line">    // input stream</span><br><span class="line">    std::istringstream inbuf(&quot;-10&quot;);</span><br><span class="line">    inbuf &gt;&gt; n;</span><br><span class="line">    std::cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; &apos;\n&apos;;</span><br><span class="line"> </span><br><span class="line">    // output stream in append mode (C++11)</span><br><span class="line">    std::ostringstream buf2(&quot;test&quot;, std::ios_base::ate);</span><br><span class="line">    buf2 &lt;&lt; &apos;1&apos;;</span><br><span class="line">    std::cout &lt;&lt; buf2.str() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<p>buf1 = 7 n = 7<br>n = -10<br>test1</p>
<p>三、<br>//Example：stringstream的.str()方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line"> </span><br><span class="line">    std::istringstream in;  // could also use in(&quot;1 2&quot;)</span><br><span class="line">    in.str(&quot;1 2&quot;);</span><br><span class="line">    in &gt;&gt; n;</span><br><span class="line">    std::cout &lt;&lt; &quot;after reading the first int from \&quot;1 2\&quot;, the int is &quot;</span><br><span class="line">              &lt;&lt; n &lt;&lt; &quot;, str() = \&quot;&quot; &lt;&lt; in.str() &lt;&lt; &quot;\&quot;\n&quot;;</span><br><span class="line"> </span><br><span class="line">    std::ostringstream out(&quot;1 2&quot;);</span><br><span class="line">    out &lt;&lt; 3;</span><br><span class="line">    std::cout &lt;&lt; &quot;after writing the int &apos;3&apos; to output stream \&quot;1 2\&quot;&quot;</span><br><span class="line">              &lt;&lt; &quot;, str() = \&quot;&quot; &lt;&lt; out.str() &lt;&lt; &quot;\&quot;\n&quot;;</span><br><span class="line"> </span><br><span class="line">    std::ostringstream ate(&quot;1 2&quot;, std::ios_base::ate);</span><br><span class="line">    ate &lt;&lt; 3;</span><br><span class="line">    std::cout &lt;&lt; &quot;after writing the int &apos;3&apos; to append stream \&quot;1 2\&quot;&quot;</span><br><span class="line">              &lt;&lt; &quot;, str() = \&quot;&quot; &lt;&lt; ate.str() &lt;&lt; &quot;\&quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<p>after reading the first int from “1 2”, the int is 1, str() = “1 2”<br>after writing the int ‘3’ to output stream “1 2”, str() = “3 2”<br>after writing the int ‘3’ to append stream “1 2”, str() = “1 23”</p>
<p>注意事项：</p>
<p>由于stringstream构造函数会特别消耗内存，似乎不打算主动释放内存(或许是为了提高效率)，但如果你要在程序中用同一个流，反复读写大量的数据，将会造成大量的内存消耗，因些这时候，需要适时地清除一下缓冲 (用 stream.str(“”) )。<br>参考链接:</p>
<p>istringstream、ostringstream、stringstream 类介绍 .<br><a href="https://www.cnblogs.com/gamesky/archive/2013/01/09/2852356.html" target="_blank" rel="noopener">https://www.cnblogs.com/gamesky/archive/2013/01/09/2852356.html</a></p>
<p>C++中的 istringstream 的用法<br><a href="https://blog.csdn.net/jacky_chenjp/article/details/70233212" target="_blank" rel="noopener">https://blog.csdn.net/jacky_chenjp/article/details/70233212</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title> LeetCode 763. Partition Labels</title>
    <url>/2018/11/22/std/</url>
    <content><![CDATA[<p>题目大意：把字符串分割成尽量多的不重叠子串，输出子串的长度数组。要求相同字符只能出现在一个子串中。<br>Problem:</p>
<p>A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.<br><a id="more"></a><br>Example 1:<br>Input: S = “ababcbacadefegdehijhklij”<br>Output: [9,7,8]<br>Explanation:<br>The partition is “ababcbaca”, “defegde”, “hijhklij”.<br>This is a partition so that each letter appears in at most one part.<br>A partition like “ababcbacadefegde”, “hijhklij” is incorrect, because it splits S into less parts.</p>
<p>贪心 尽可能扩充区间</p>
<p>Solution 1: Greedy</p>
<p>Time complexity: O(n)</p>
<p>Space complexity: O(26/128)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; partitionLabels(string S) &#123;</span><br><span class="line">    //vector&lt;int&gt; arr(128,0);</span><br><span class="line">        int arr[128];</span><br><span class="line">	int start=0,end=0;</span><br><span class="line">	vector&lt;int&gt; ans;</span><br><span class="line">	for(int i=0;i&lt;S.length();i++)</span><br><span class="line">	arr[S[i]]=i;</span><br><span class="line">	for(int i=0;i&lt;S.length();i++)&#123;</span><br><span class="line">		end=max(end,arr[S[i]]);</span><br><span class="line">		if(i==end)&#123;</span><br><span class="line">			ans.push_back(end-start+1);</span><br><span class="line">            start=end+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">       return ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>c++ string rfind find函数</title>
    <url>/2018/12/09/string%E7%B1%BB%E5%9E%8B%E7%9A%84rfind-find/</url>
    <content><![CDATA[<p>1）size_t find (const string&amp; str, size_t pos = 0) const;  //查找对象–string类对象<br>（2）size_t find (const char<em> s, size_t pos = 0) const; //查找对象–字符串<br><a id="more"></a><br>（3）size_t find (const char</em> s, size_t pos, size_t n) const;  //查找对象–字符串的前n个字符<br>（4）size_t find (char c, size_t pos = 0) const;  //查找对象–字符<br>结果：找到 – 返回 第一个字符的索引</p>
<p>string::rfind(string, pos) 是从pos开始由右往左找，返回最后一次出现string的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;       // std::cout</span><br><span class="line">#include &lt;string&gt;         // std::string</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::string str (&quot;There are two needles in this haystack with needles.&quot;);</span><br><span class="line">  std::string str2 (&quot;needle&quot;);</span><br><span class="line"> </span><br><span class="line">  // different member versions of find in the same order as above:</span><br><span class="line">  std::size_t found = str.find(str2);</span><br><span class="line">  if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;first &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line"> </span><br><span class="line">  found=str.find(&quot;needles are small&quot;,found+1,6);</span><br><span class="line">  if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;second &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line"> </span><br><span class="line">  found=str.find(&quot;haystack&quot;);</span><br><span class="line">  if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;&apos;haystack&apos; also found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line"> </span><br><span class="line">  found=str.find(&apos;.&apos;);</span><br><span class="line">  if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;Period found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line"> </span><br><span class="line">  // let&apos;s replace the first needle:</span><br><span class="line">  str.replace(str.find(str2),str2.length(),&quot;preposition&quot;);  //replace 用法</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">first &apos;needle&apos; found at: 14</span><br><span class="line">second &apos;needle&apos; found at: 44</span><br><span class="line">&apos;haystack&apos; also found at: 30</span><br><span class="line">Period found at: 51</span><br><span class="line">There are two prepositions in this haystack with needles</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// string::rfind</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstddef&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::string str (&quot;The sixth sick sheik&apos;s sixth sheep&apos;s sick.&quot;);</span><br><span class="line">  std::string key (&quot;sixth&quot;);</span><br><span class="line">//从起始位置 从右往左找 </span><br><span class="line">  std::size_t found = str.rfind(key,3);</span><br><span class="line">  if (found!=std::string::npos)</span><br><span class="line">    str.replace (found,key.length(),&quot;seventh&quot;);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>sublimetext 控制台乱码</title>
    <url>/2018/05/30/sublimetext-%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工具 -&gt; 编译系统  -&gt; 新编译系统</span><br><span class="line">&#123;  </span><br><span class="line">    &quot;cmd&quot;: [&quot;python&quot;,&quot;-u&quot;,&quot;$file&quot;],  </span><br><span class="line">    &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,  </span><br><span class="line">    &quot;selector&quot;: &quot;source.python&quot;,  </span><br><span class="line">    &quot;encoding&quot;: &quot;cp936&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用上面的代码替换掉&quot;shell_cmd&quot;: &quot;make&quot;, 保存当前配置文件为: &quot;python_支持中文.sublime-build&quot;, 然后在工具-&gt;编译系统-&gt;选择 &quot;python_支持中文&quot;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>tensorflow图像尺寸调整</title>
    <url>/2018/05/07/tensorflow%E5%9B%BE%E5%83%8F%E5%B0%BA%E5%AF%B8%E8%B0%83%E6%95%B4-1/</url>
    <content><![CDATA[<p>图像尺寸调整属于基础的图像几何变换，TensorFlow提供了几种尺寸调整的函数：<br>tf.image.resize_images：将原始图像缩放成指定的图像大小，其中的参数method（默认值为ResizeMethod.BILINEAR）提供了四种插值算法，具体解释可以参考图像几何变换（缩放、旋转）中的常用的插值算法<br><a id="more"></a><br>tf.image.resize_image_with_crop_or_pad：剪裁或填充处理，会根据原图像的尺寸和指定的目标图像的尺寸选择剪裁还是填充，如果原图像尺寸大于目标图像尺寸，则在中心位置剪裁，反之则用黑色像素填充。<br><!--more--><br>tf.image.central_crop：比例调整，central_fraction决定了要指定的比例，取值范围为(0，1]，该函数会以中心点作为基准，选择整幅图中的指定比例的图像作为新的图像<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">image_raw_data = tf.gfile.FastGFile(&quot;C:/Users/admin/Desktop/fish-bike.jpg&quot;,&quot;r&quot;).read();</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">image= tf.image.decode_jpeg(image_raw_data) </span><br><span class="line">print(image.eval(session=tf.Session()))  </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    img_data=tf.image.decode_jpeg(image_raw_data,channels=3)</span><br><span class="line">    print(img_data.eval())</span><br><span class="line">    plt.imshow(img_data.eval())</span><br><span class="line">    plt.show()</span><br><span class="line">    resized = tf.image.resize_images(img_data,[200,200],method=0)</span><br><span class="line">    print(&quot;Digital type: &quot;, resized.dtype)</span><br><span class="line">    resized = np.asarray(resized.eval(), dtype=&apos;uint8&apos;)</span><br><span class="line">     # tf.image.convert_image_dtype(rgb_image, tf.float32)</span><br><span class="line">    plt.imshow(resized)</span><br><span class="line">    plt.show()</span><br><span class="line">    croped = tf.image.resize_image_with_crop_or_pad(img_data, 100, 100)</span><br><span class="line">    padded = tf.image.resize_image_with_crop_or_pad(img_data, 500, 500)</span><br><span class="line">    plt.imshow(croped.eval())</span><br><span class="line">    plt.show()</span><br><span class="line">    plt.imshow(padded.eval())</span><br><span class="line">    plt.show()</span><br><span class="line">    central_cropped = tf.image.central_crop(img_data, 0.5)</span><br><span class="line">    plt.imshow(central_cropped.eval())</span><br><span class="line">t.show()</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fr2skgjeekj30bt0bj0ud.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fr2skzrw9nj307c09w77d.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fr2smc0ca2j30900gy79t.jpg" alt="image"></p>
<p>可参考<br><a href="https://cloud.tencent.com/developer/article/1010250" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1010250</a><br><a href="https://blog.csdn.net/chaipp0607/article/details/73029923" target="_blank" rel="noopener">https://blog.csdn.net/chaipp0607/article/details/73029923</a></p>
]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>图像预处理</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow处理标注框</title>
    <url>/2018/05/07/tensorflow%E5%A4%84%E7%90%86%E6%A0%87%E6%B3%A8%E6%A1%86/</url>
    <content><![CDATA[<h2 id="draw-bounding-boxes"><a href="#draw-bounding-boxes" class="headerlink" title="draw_bounding_boxes"></a>draw_bounding_boxes</h2><p>#给一批图片绘制方框，每张图片的方框数量、大小、位置都一样。</p>
<p>#boxes：shape：<code>[batch, num_bounding_boxes, 4]</code>，方框坐标 <code>[y_min, x_min, y_max, x_max]</code>，取值范围<code>[0.0, 1.0]</code>。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">image_raw_data = tf.gfile.FastGFile(&quot;C:/Users/admin/Desktop/cat.jpg&quot;,&quot;r&quot;).read();</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">     img_data = tf.image.decode_jpeg(image_raw_data)</span><br><span class="line">     print(&quot;Digital type: &quot;, img_data.dtype)</span><br><span class="line">     plt.imshow(img_data.eval())</span><br><span class="line">     plt.show()</span><br><span class="line">     img_data=tf.image.resize_images(img_data,[180,267],method=1)</span><br><span class="line">     print(&quot;Digital type: &quot;, img_data.dtype)</span><br><span class="line">     batched=tf.expand_dims(tf.image.convert_image_dtype(img_data,tf.float32),0)</span><br><span class="line">     boxes=tf.constant([[[0.05,0.05,0.9,0.7],[0.35,0.47,0.5,0.56]]])</span><br><span class="line">     result=tf.image.draw_bounding_boxes(batched,boxes)</span><br><span class="line">     plt.figure(1)  </span><br><span class="line">     plt.imshow(result.eval().reshape([180, 267, 3]))  </span><br><span class="line">     plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fr2w56shnhj308r0cjjx4.jpg" alt="image"><br><a href="https://www.jianshu.com/p/9de529f48d64" target="_blank" rel="noopener">https://www.jianshu.com/p/9de529f48d64</a></p>
<h2 id="sample-distorted-bounding-box"><a href="#sample-distorted-bounding-box" class="headerlink" title="sample_distorted_bounding_box"></a>sample_distorted_bounding_box</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">image_raw_data = tf.gfile.FastGFile(&quot;C:/Users/admin/Desktop/cat.jpg&quot;,&quot;r&quot;).read();</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">     img_data = tf.image.decode_jpeg(image_raw_data)</span><br><span class="line">     print(&quot;Digital type: &quot;, img_data.dtype)</span><br><span class="line">     plt.imshow(img_data.eval())</span><br><span class="line">     plt.show()</span><br><span class="line">     img_data=tf.image.resize_images(img_data,[180,267],method=1)</span><br><span class="line">     print(&quot;Digital type: &quot;, img_data.dtype)</span><br><span class="line">     boxes=tf.constant([[[0.05,0.05,0.9,0.7],[0.35,0.47,0.5,0.56]]])</span><br><span class="line">     begin,size,bbox_for_draw=tf.image.sample_distorted_bounding_box(tf.shape(img_data),bounding_boxes=boxes)</span><br><span class="line">     batched=tf.expand_dims(tf.image.convert_image_dtype(img_data,tf.float32),0)</span><br><span class="line">     image_with_box=tf.image.draw_bounding_boxes(batched,bbox_for_draw)</span><br><span class="line">     distorted_image=tf.slice(img_data,begin,size)</span><br><span class="line">     plt.imshow(distorted_image.eval())  </span><br><span class="line">     plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fr2zvcal7aj308o0cbwjb.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fr2zu7p6gyj30940d10xn.jpg" alt="image"></p>
<h3 id="参数理解"><a href="#参数理解" class="headerlink" title="参数理解"></a>参数理解</h3><p>此函数为图像生成单个随机变形的边界框。函数输出的是可用于裁剪原始图像的单个边框。返回值为3个张量：begin，size和 bboxes。前2个张量用于 tf.slice 剪裁图像。后者可以用于 tf.image.draw_bounding_boxes 函数来画出边界框。</p>
<p>sample_distorted_bounding_box(<br>    image_size,<br>    bounding_boxes,<br>    seed=None,<br>    seed2=None,<br>    min_object_covered=None,<br>    aspect_ratio_range=None,<br>    area_range=None,<br>    max_attempts=None,<br>    use_image_if_no_bounding_boxes=None,<br>    name=None<br>)<br>image_size： 是包含 [height, width, channels] 三个值的一维数组。数值类型必须是 uint8，int8，int16，int32，int64 中的一种。</p>
<p>bounding_boxes： 是一个 shape 为 [batch, N, 4] 的三维数组，数据类型为float32，第一个batch是因为函数是处理一组图片的，N表示描述与图像相关联的N个边界框的形状，而标注框由4个数字 [y_min, x_min, y_max, x_max] 表示出来。例如：tf.constant([[[0.05, 0.05, 0.9, 0.7], [0.35, 0.47, 0.5, 0.56]]]) 的 shape 为 [1,2,4] 表示一张图片中的两个标注框；tf.constant([[[ 0.  0.  1.  1.]]]) 的 shape 为 [1,1,4]表示一张图片中的一个标注框</p>
<p>seed： （可选）数组类型为 int，默认为0。如果任一个seed或被seed2设置为非零，随机数生成器由给定的种子生成。否则，由随机种子生成。<br>seed2： （可选）数组类型为 int，默认为0。第二种子避免种子冲突。</p>
<p>min_object_covered：（可选）数组类型为 float，默认为 0.1。图像的裁剪区域必须包含所提供的任意一个边界框的至少 min_object_covered 的内容。该参数的值应为非负数，当为0时，裁剪区域不必与提供的任何边界框有重叠部分。</p>
<p>aspect_ratio_range： （可选）数组类型为 floats 的列表，默认为 [0.75, 1.33] 。图像的裁剪区域的宽高比（宽高比=宽/高） 必须在这个范围内。</p>
<p>area_range： （可选）数组类型为 floats 的列表，默认为 [0.05, 1] 。图像的裁剪区域必须包含这个范围内的图像的一部分。</p>
<p>max_attempts： （可选）数组类型为 int，默认为100。尝试生成图像指定约束的裁剪区域的次数。经过 max_attempts 次失败后，将返回整个图像。</p>
<p>use_image_if_no_bounding_boxes：（可选）数组类型为 bool，默认为False。如果没有提供边框，则用它来控制行为。如果为True，则假设有一个覆盖整个输入的隐含边界框。如果为False，就报错。</p>
<p>name： 操作的名称（可选）。</p>
<h3 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h3><p>Return：一个Tensor对象的元组（begin，size，bboxes）。</p>
<p>begin： 和 image_size 具有相同的类型。包含 [offset_height, offset_width, 0] 的一维数组。作为 tf.slice 的输入。</p>
<p>size： 和 image_size 具有相同的类型。包含 [target_height, target_width, -1] 的一维数组。作为 tf.slice 的输入。</p>
<p>bboxes：shape为 [1, 1, 4] 的三维矩阵，数据类型为float32，表示随机变形后的边界框。作为 tf.image.draw_bounding_boxes 的输入。</p>
<h3 id="源码解释"><a href="#源码解释" class="headerlink" title="源码解释"></a>源码解释</h3><p>tf.image.sample_distorted_bounding_box(image_size, bounding_boxes, seed=None, seed2=None, min_object_covered=None, aspect_ratio_range=None, area_range=None, max_attempts=None, use_image_if_no_bounding_boxes=None, name=None)</p>
<p>#随机输出截取图片。<br>Generate a single randomly distorted bounding box for an image.</p>
<p>Bounding box annotations are often supplied in addition to ground-truth labels<br>in image recognition or object localization tasks. A common technique for<br>training such a system is to randomly distort an image while preserving<br>its content, i.e. <em>data augmentation</em>. This Op outputs a randomly distorted<br>localization of an object, i.e. bounding box, given an <code>image_size</code>,<br><code>bounding_boxes</code> and a series of constraints.</p>
<p>The output of this Op is a single bounding box that may be used to crop the<br>original image. The output is returned as 3 tensors: <code>begin</code>, <code>size</code> and<br><code>bboxes</code>. The first 2 tensors can be fed directly into <code>tf.slice</code> to crop the<br>image. The latter may be supplied to <code>tf.image.draw_bounding_boxes</code> to visualize<br>what the bounding box looks like.</p>
<p>Bounding boxes are supplied and returned as <code>[y_min, x_min, y_max, x_max]</code>. The<br>bounding box coordinates are floats in <code>[0.0, 1.0]</code> relative to the width and<br>height of the underlying image.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Generate a single distorted bounding box.</span><br><span class="line">begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(</span><br><span class="line">       tf.shape(image),</span><br><span class="line">       bounding_boxes=bounding_boxes)</span><br><span class="line"># Draw the bounding box in an image summary.</span><br><span class="line">  image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),</span><br><span class="line">                                                 bbox_for_draw)</span><br><span class="line">   tf.image_summary(&apos;images_with_box&apos;, image_with_box)</span><br><span class="line">   # Employ the bounding box to distort the image.</span><br><span class="line">   distorted_image = tf.slice(image, begin, size)</span><br></pre></td></tr></table></figure>
<p>Note that if no bounding box information is available, setting<br>use_image_if_no_bounding_boxes = true will assume there is a single implicit<br>bounding box covering the whole image. If use_image_if_no_bounding_boxes is<br>false and no bounding boxes are supplied, an error is raised.</p>
]]></content>
  </entry>
  <entry>
    <title>tensorflow读取图片的方法</title>
    <url>/2018/05/07/tensorflow%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87-1/</url>
    <content><![CDATA[<p>下面讲解tensorflow如何读取jpg格式的图片，png格式的图片是一样的。有两种情况：</p>
<p>第一种就是把图片看做是一个图片直接读进来，获取图片的原始数据，再进行解码，主要用到的函数就是tf.gfile.FastGFile，tf.image.decode_jpeg<br><a id="more"></a></p>
<blockquote>
<p>图像解码与编码：一张RGB三通道的彩色图像可以看成一个三维矩阵，矩阵中的不位置上的数字代表图像的像素值。然后图像在存储时并不是直接记录这些矩阵中的数字，而是经过了压缩编码。所以将一张图像还原成一个三维矩阵的过程就是解码的过程，反之就是编码了。其实如果大家熟悉opencv的话，imread和imwrite就是一个解码和编码的过程。<br><!--more--><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Spyder Editor</span><br><span class="line"></span><br><span class="line">This is a temporary script file.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Spyder Editor</span><br><span class="line"></span><br><span class="line">This is a temporary script file.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import tensorflow as tf</span><br><span class="line">image_raw_data = tf.gfile.FastGFile(&quot;C:/Users/admin/Desktop/fish-bike.jpg&quot;,&quot;r&quot;).read();</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">image= tf.image.decode_jpeg(image_raw_data) </span><br><span class="line">print(image.eval(session=tf.Session()))  </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    img_data=tf.image.decode_jpeg(image_raw_data,channels=3)</span><br><span class="line">    print(img_data.eval())</span><br><span class="line">    plt.imshow(img_data.eval())</span><br><span class="line">    plt.show()</span><br><span class="line">    #img_data = tf.image.convert_image_dtype(img_data,dtype = tf.float32)</span><br><span class="line">    encoded_image=tf.image.encode_jpeg(img_data)</span><br><span class="line">    with tf.gfile.GFile(&quot;C:/Users/admin/Desktop/fish-bike1.jpg&quot;,&quot;wb&quot;) as f:</span><br><span class="line">        f.write(encoded_image.eval())</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fr2rdxlxkuj30c108r412.jpg" alt="image"><br><strong>decode_jpeg函数为jpeg（jpg）图片解码的过程，对应的encode_jpeg函数为编码过程，编码后将图片重命名写入到指定的路径下。</strong><br>第二种方式就是把图片看看成一个文件，用队列的方式读取<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import tensorflow as tf;    </span><br><span class="line">  </span><br><span class="line">path = &apos;C:/Users/admin/Desktop/fish-bike.jpg&apos;  </span><br><span class="line">file_queue = tf.train.string_input_producer([path]) #创建输入队列  </span><br><span class="line">image_reader = tf.WholeFileReader()  </span><br><span class="line">_, image = image_reader.read(file_queue)  </span><br><span class="line">image = tf.image.decode_jpeg(image)  </span><br><span class="line">  </span><br><span class="line">with tf.Session() as sess:  </span><br><span class="line">    coord = tf.train.Coordinator() #协同启动的线程  </span><br><span class="line">    threads = tf.train.start_queue_runners(sess=sess, coord=coord) #启动线程运行队列  </span><br><span class="line">    print sess.run(image)  </span><br><span class="line">    coord.request_stop() #停止所有的线程  </span><br><span class="line">    coord.join(threads)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
        <tag>图像读取</tag>
      </tags>
  </entry>
  <entry>
    <title>the difference between s == null and s.length == 0, where s is a String?</title>
    <url>/2018/05/12/the-difference-between-s-null-and-s-length-0-where-s-is-a-String/</url>
    <content><![CDATA[<blockquote>
<p><strong>NULL means that memory has not been allocated to the pointer (string). So there is no representation of the string in memory.</strong></p>
</blockquote>
<blockquote>
<p><strong>On the other hand, a string can be initialised as “” (empty string). This does mean that memory is allocated, and it is present in memory, it’s just empty. That means its length is 0.</strong></p>
</blockquote>
<a id="more"></a>
<p>In most commonly-used programming languages, strings are represented via reference types.  That means a variable like ‘s’ contains a reference to the data, rather than the data itself, and the reference might be null (not referring to anything).  It also means that you can have multiple variables that are aliased, meaning changes to the data will immediately be visible to all those references.</p>
<p>In Java, for example, fields of reference type are initialized to null.</p>
<p><strong>In some languages, if you try to call a method like length() on a variable that is set to null, you’ll crash the program.  So a common tactic is to rule that out with a short-circuit Boolean operator like ||.</strong></p>
<p>When I give interviews, I want the candidate to at least understand the ramifications of null references getting involved, but I’m not looking for answers to always handle that case.  Many common library methods take the position that you get what you deserve (an exception) if you try to pass them a null parameter.</p>
<p><a href="https://www.quora.com/What-is-the-difference-between-s-null-and-s-length-0-where-s-is-a-String" target="_blank" rel="noopener">参考链接1</a></p>
<p><a href="https://blog.csdn.net/y_dzaichirou/article/details/53716765" target="_blank" rel="noopener">参考链接2</a></p>
<p>多浏览英文网站，多看别人的response,英语很重要，很多答案和解释比较贴切</p>
]]></content>
  </entry>
  <entry>
    <title>201612-2 工资计算</title>
    <url>/2018/11/24/titleds/</url>
    <content><![CDATA[<p>问题描述<br>　　小明的公司每个月给小明发工资，而小明拿到的工资为交完个人所得税之后的工资。假设他一个月的税前工资（扣除五险一金后、未扣税前的工资）为S元，则他应交的个人所得税按如下公式计算：<br><a id="more"></a><br>1） 个人所得税起征点为3500元，若S不超过3500，则不交税，3500元以上的部分才计算个人所得税，令A=S-3500元；</p>
<p>2） A中不超过1500元的部分，税率3%；
　</p>
<p>3） A中超过1500元未超过4500元的部分，税率10%；</p>
<p>4） A中超过4500元未超过9000元的部分，税率20%；</p>
<p>5） A中超过9000元未超过35000元的部分，税率25%；</p>
<p>6） A中超过35000元未超过55000元的部分，税率30%；</p>
<p>7） A中超过55000元未超过80000元的部分，税率35%；</p>
<p>8） A中超过80000元的部分，税率45%；</p>
<p>例如，如果小明的税前工资为10000元，则A=10000-3500=6500元，其中不超过1500元部分应缴税1500×3%=45元，超过1500元不超过4500元部分应缴税(4500-1500)×10%=300元，超过4500元部分应缴税(6500-4500)×20%=400元。总共缴税745元，税后所得为9255元。</p>
<p>已知小明这个月税后所得为T元，请问他的税前工资S是多少元。</p>
<p>输入格式<br>　　输入的第一行包含一个整数T，表示小明的税后所得。所有评测数据保证小明的税前工资为一个整百的数。<br>输出格式<br>　　输出一个整数S，表示小明的税前工资。</p>
<p>样例输入<br>9255</p>
<p>样例输出<br>10000</p>
<p>评测用例规模与约定<br>　　对于所有评测用例，1 ≤ T ≤ 100000。</p>
<p>自己手算范围容易出错</p>
<p>推算公式</p>
<p>该问题原始数据可以建两个表格，一是工资收入段表，二是税率表。根据这两个表可以算出收入范围表，即由实际收入得到最高税率是哪一档的表。进一步的计算就变得简单许多。</p>
<p>程序说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int srange[]=&#123;3500,5000,8000,12500,38500,58500,83500&#125;;</span><br><span class="line">int rate[]=&#123;3,10,20,25,30,35,45&#125;;</span><br><span class="line">int range[10];</span><br><span class="line">int b;</span><br><span class="line">int a;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int minus=0;</span><br><span class="line">	range[0]=3500;</span><br><span class="line">	for(int i=1;i&lt;7;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		minus+=(srange[i]-srange[i-1])*rate[i-1]/100;</span><br><span class="line">		range[i]=srange[i]-minus;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;a;</span><br><span class="line">	if(a&lt;=3500) &#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;7;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		if(range[i-1]&lt;a&amp;&amp;a&lt;=range[i])&#123;</span><br><span class="line">			b=(a+srange[i-1]-range[i-1]-srange[i-1]*rate[i-1]/100)/(100-rate[i-1])*100;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    //!!!</span><br><span class="line">	if(a&gt;range[6]) b=(a+srange[6]-range[6]-srange[6]*rate[6]/100)/(100-rate[6])*100;</span><br><span class="line">	cout&lt;&lt;b&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu下配置shadowsocks</title>
    <url>/2018/05/12/ubuntu%E4%B8%8B%E9%85%8D%E7%BD%AEshadowsocks/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Shadowsocks无GUI客户端教程：<a href="https://blog.huihut.com/2017/08/25/LinuxInstallConfigShadowsocksClient/" target="_blank" rel="noopener">Linux安装配置Shadowsocks客户端及开机自动启动</a><br>Shadowsocks-Qt5客户端教程：<a href="https://blog.huihut.com/2017/03/25/Shadowsocks-Qt5ForCentos7/" target="_blank" rel="noopener">Shadowsocks-Qt5 For Centos 7</a><br>Shadowsocks服务端教程：<a href="https://blog.huihut.com/2016/12/03/BandwagonShadowsocksServer/" target="_blank" rel="noopener">搬瓦工Shadowsocks安装及配置多用户(服务端)</a><br>(<a href="https://blog.huihut.com/2017/08/25/LinuxInstallConfigShadowsocksClient/" target="_blank" rel="noopener">https://blog.huihut.com/2017/08/25/LinuxInstallConfigShadowsocksClient/</a>)<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Debian/Ubuntu:</p>
<p>apt-get install python-pip</p>
<p>pip install shadowsocks</p>
<p>CentOS:</p>
<p>sudo yum install python-setuptools &amp;&amp; easy_install pip</p>
<p>sudo pip install shadowsocks</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>找个地方放shadowsocks的配置文件，一般放到 /etc下面：</p>
<p>sudo vi /etc/shadowsocks.json<br>我放在我的用户目录下，因为有时需要修改，放在这里方便些：</p>
<p>vi /home/xx/Software/ShadowsocksConfig/shadowsocks.json<br>你可以根据自身情况考虑。</p>
<p>然后在shadowsocks.json里面添加配置信息，如：</p>
<p>{<br>  “server”:”my_server_ip”,<br>  “local_address”: “127.0.0.1”,<br>  “local_port”:1080,<br>  “server_port”:my_server_port,<br>  “password”:”my_password”,<br>  “timeout”:300,<br>  “method”:”aes-256-cfb”<br>}<br>把</p>
<p>my_server_ip改为自己的服务器IP</p>
<p>my_server_port改为自己的服务器端口</p>
<p>my_server_password改为自己的密码</p>
<p>method的值改为自己的加密方式，一般是aes-256-cfb或者rc4-md5<br>详细配置说明：</p>
<p>Name    说明</p>
<p>server    服务器地址，填ip或域名</p>
<p>local_address    本地地址</p>
<p>local_port    本地端口，一般1080，可任意</p>
<p>server_port    服务器对外开的端口</p>
<p>password    密码，可以每个服务器端口设置不同密码</p>
<p>port_password    server_port + password ，服务器端口加密码的组合</p>
<p>timeout    超时重连</p>
<p>method    默认: “aes-256-cfb”，见 Encryption</p>
<p>fast_open    开启或关闭 TCP_FASTOPEN, 填true / false，需要服务端支持<br>保存退出就配置好啦！</p>
<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>系统代理<br>可以选择系统代理，就如下图配置就好啦：<br><img src="http://ojlsgreog.bkt.clouddn.com/SystemNetworkProxy.png" alt="image"></p>
<p>但是系统代理是全局走代理的，访问国内网站一般会有限制（速度较慢、浪费流量、版权受限等）。</p>
<p>所以推荐下面的用浏览器按照规则选择性代理。</p>
<p>浏览器代理<br>安装 SwitchyOmega 插件<br>以 Chrome 为例，安装 SwitchyOmega 插件代理。</p>
<p>Github 下载 SwitchyOmega：<a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases/</a></p>
<p>Chrome 打开chrome://extensions/，把插件托进去安装。</p>
<p>配置 Proxy<br>Server填写shadowsocks.json配置中的local_address<br>Port填写shadowsocks.json配置中的local_port<br>左边Apply changes保存。</p>
<p><img src="http://ojlsgreog.bkt.clouddn.com/SwitchyOmegaProxy.png" alt="image"></p>
<p>配置 Auto Switch<br>Rule list rules的Profile填proxy<br>Default的Profile填[Direct]<br>Rule List Format选择AutoProxy<br>Rule List URL填写gfwlist的规则:</p>
<p><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></p>
<p>下载规则文件Download Profile Now</p>
<p>左边Apply changes保存</p>
<p><img src="http://ojlsgreog.bkt.clouddn.com/SwitchyOmegaAutoSwitch.png" alt="image"></p>
<p>启用 SwitchyOmega</p>
<p>启用 SwitchyOmega 插件，选择 Auto Switch 模式就可以了。</p>
<p>测试启动</p>
<p>配置文件的路径改成自己的，如：/etc/shadowsocks.json</p>
<p>前端启动：sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json；</p>
<p>后端启动：sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json -d start；</p>
<p>后端停止：sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json -d stop；</p>
<p>重启(修改配置要重启才生效)：sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json -d restart<br>开机自启</p>
<p>以下使用Systemd来实现shadowsocks开机自启。</p>
<p>sudo vim /etc/systemd/system/shadowsocks.service<br>在里面填写如下内容：</p>
<p>[Unit]</p>
<p>Description=Shadowsocks Client Service<br>After=network.target</p>
<p>[Service]</p>
<p>Type=simple<br>User=root<br>ExecStart=/usr/bin/sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json</p>
<p>[Install]</p>
<p>WantedBy=multi-user.target<br>把/home/xx/Software/ShadowsocksConfig/shadowsocks.json修改为你的shadowsocks.json路径，如：/etc/shadowsocks.json</p>
<p>配置生效：</p>
<p>systemctl enable /etc/systemd/system/shadowsocks.service<br>输入管理员密码就可以了。</p>
<p>现在你可以马上重启试试，或先在后台启动，等下次重启再看看！</p>
]]></content>
      <tags>
        <tag>climb great wall</tag>
      </tags>
  </entry>
  <entry>
    <title>unordered_map</title>
    <url>/2018/12/04/unordered-map/</url>
    <content><![CDATA[<p>c++中map与unordered_map的区别<br>头文件</p>
<p>map: #include &lt; map &gt;<br><a id="more"></a><br>unordered_map: #include &lt; unordered_map &gt;</p>
<p>内部实现机理</p>
<p>map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。</p>
<p>unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</p>
<p>优缺点以及适用处</p>
<p>map </p>
<p>优点：<br>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>红黑树，内部实现一个红黑书使得map的很多操作在lgnlgn的时间复杂度下就可以实现，因此效率非常的高</p>
<p>缺点：<br>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间<br>适用处，对于那些有顺序要求的问题，用map会更高效一些</p>
<p>unordered_map </p>
<p>优点：<br>因为内部实现了哈希表，因此其查找速度非常的快</p>
<p>缺点： </p>
<p>哈希表的建立比较耗费时间<br>适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用</p>
<p>unordered_map</p>
<p>note:</p>
<p>对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的</p>
<p>参考链接</p>
<p><a href="https://blog.csdn.net/batuwuhanpei/article/details/50727227" target="_blank" rel="noopener">https://blog.csdn.net/batuwuhanpei/article/details/50727227</a><br><a href="https://blog.csdn.net/Cypress1010/article/details/53669409" target="_blank" rel="noopener">https://blog.csdn.net/Cypress1010/article/details/53669409</a><br><a href="https://my.oschina.net/ifraincoat/blog/464309" target="_blank" rel="noopener">https://my.oschina.net/ifraincoat/blog/464309</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>uva839 天平问题</title>
    <url>/2018/11/06/uva-%E5%A4%A9%E5%B9%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>题意：天平的两端，每端的重量 wl 和 wr ，每端到中点的距离 dl 和 dr ，要满足wl<em>dl==wr</em>dr才能保持天平平衡。天平的每端可以再系一个天平，该端的重量为该子天平的总重量。问最终天平是否能平衡。</p>
<p>给你一个杠杆两端的物体的质量和力臂，如果质量为零，则下面是一个杠杆，判断是否所有杠杆平衡<br><a id="more"></a><br>Sample  I nput</p>
<p>1</p>
<p>0 2 0 4</p>
<p>0 3 0 1</p>
<p>1 1 1 1</p>
<p>2 4 4 2</p>
<p>1 6 3 2</p>
<p>Sample Output</p>
<p>YES</p>
<p>思路讲解：输入一串数据构成天平，判断该天平是否平衡，利用引用传值，w的值永远为子天平的总重，可以大大简化代码量。<br>题意：输入一个树状天平，根据力矩相等的原则判断是否平衡。就是W1D1= W2D2，其中W1，W2分别为左右两边砝码的重量，D为距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool solve(int &amp;w)&#123;</span><br><span class="line">	int w1,r1,w2,r2;</span><br><span class="line">	cin&gt;&gt;w1&gt;&gt;r1&gt;&gt;w2&gt;&gt;r2;</span><br><span class="line">	bool b1=true,b2=true;//!!!</span><br><span class="line">	if(!w1) b1=solve(w1);</span><br><span class="line">	if(!w2) b2=solve(w2);</span><br><span class="line">	w=w1+w2;</span><br><span class="line">	return b1&amp;&amp;b2&amp;&amp;(w1*r1==w2*r2);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    while (k--)&#123;</span><br><span class="line">        int w;</span><br><span class="line">        if (solve(w))</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        if (k)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">return 0;&#125;</span><br></pre></td></tr></table></figure>
<p>参考博客<br><a href="https://blog.csdn.net/WU5151/article/details/50435529" target="_blank" rel="noopener">https://blog.csdn.net/WU5151/article/details/50435529</a><br><a href="http://www.voidcn.com/article/p-woxgpgdn-zy.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-woxgpgdn-zy.html</a><br><a href="https://blog.csdn.net/xiaojiao_6/article/details/74931249" target="_blank" rel="noopener">https://blog.csdn.net/xiaojiao_6/article/details/74931249</a></p>
]]></content>
      <categories>
        <category>uva</category>
      </categories>
  </entry>
  <entry>
    <title>vector的几种初始化及赋值方式：</title>
    <url>/2018/11/22/vector-1/</url>
    <content><![CDATA[<p>vector的几种初始化及赋值方式：<br>（1）不带参数的构造函数初始化<br><a id="more"></a><br>//初始化一个size为0的vector<br>vector<int> abc;<br>1<br>2<br>（2）带参数的构造函数初始化</int></p>
<p>//初始化size,但每个元素值为默认值<br>vector<int> abc(10);    //初始化了10个默认值为0的元素<br>//初始化size,并且设置初始值<br>vector<int> cde(10，1);    //初始化了10个值为1的元素<br>1<br>2<br>3<br>4<br>（3）通过数组地址初始化</int></int></p>
<p>int a[5] = {1,2,3,4,5};<br>//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）<br>vector<int> b(a, a+5);<br>1<br>2<br>3<br>（4）通过同类型的vector初始化</int></p>
<p>vector<int> a(5,1);<br>//通过a初始化<br>vector<int> b(a);<br>1<br>2<br>3<br>（5）通过insert初始化</int></int></p>
<p>//insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中<br>vector<int> a(6,6);<br>vecot<int> b;<br>//将a[0]~a[2]插入到b中，b.size()由0变为3<br>b.insert(b.begin(), a.begin(), a.begin() + 3);<br>1<br>2<br>3<br>4<br>5<br>insert也可通过数组地址区间实现插入</int></int></p>
<p>int a[6] = {6,6,6,6,6,6};<br>vector<int> b;<br>//将a的所有元素插入到b中<br>b.insert(b.begin(), a, a+7);<br>1<br>2<br>3<br>4<br>此外，insert还可以插入m个值为n的元素</int></p>
<p>//在b开始位置处插入6个6<br>b.insert(b.begin(), 6, 6);<br>1<br>2<br>（6）通过copy函数赋值</p>
<p>vector<int> a(5,1);<br>int a1[5] = {2,2,2,2,2};<br>vector<int> b(10);</int></int></p>
<p>/<em>将a中元素全部拷贝到b开始的位置中,注意拷贝的区间为a.begin() ~ a.end()的左闭右开的区间</em>/<br>copy(a.begin(), a.end(), b.begin());</p>
<p>//拷贝区间也可以是数组地址构成的区间<br>copy(a1, a1+5, b.begin() + 5);</p>
<p>参考博客</p>
<p><a href="https://blog.csdn.net/yjunyu/article/details/77728410" target="_blank" rel="noopener">https://blog.csdn.net/yjunyu/article/details/77728410</a> </p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>virtualenv Django在aphae2的配置</title>
    <url>/2018/05/27/virtualenv-Django%E5%9C%A8aphae2%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>网上教程很多 有的是旧版本 有很多误区<br>导致配了半天 特意记录一下流程</p>
<p>virtualenv下的python3.5 Django在aphache2部署</p>
<p>python3.5 位置 /home/tina/.local/virtualenvs/jobboardscraper<br><a id="more"></a></p>
<p><strong>使用 virtualenv 的方式使用 django，核心的问题是修改 项目下的wsgi.py 文件，指定正确</strong></p>
<h2 id="建立Django与Apache的连接"><a href="#建立Django与Apache的连接" class="headerlink" title="建立Django与Apache的连接"></a>建立Django与Apache的连接</h2><p>sudo apt-get install libapache2-mod-wsgi #Python2<br>sudo apt-get install libapache2-mod-wsgi-py3 #Python3</p>
<h2 id="让Apache找到Django"><a href="#让Apache找到Django" class="headerlink" title="让Apache找到Django"></a>让Apache找到Django</h2><ul>
<li>将Django工程放在/var/www/下；</li>
<li>sudo vi /etc/apache2/sites-available/yoursite.conf 修改配置文件；</li>
<li>sudo a2ensite yoursite.conf 配置文件生效；</li>
<li>sudo service apache2 restart 重启Apache。</li>
</ul>
<p><strong>如你的Apache版本为2.2.x 则将Require all granted改为Order deny,allow Allow from all</strong></p>
<blockquote>
<p>执行sudo a2ensite yoursite.conf来使网站生效<br>也可以执行sudo a2dissite yoursite.conf来使网站失效<br>最后重启Apache即可 sudo service apache2 restart</p>
</blockquote>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h2 id="job-conf"><a href="#job-conf" class="headerlink" title="job.conf"></a>job.conf</h2><p>位置 /etc/apache2/sites-available/job.conf<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">#serverName 设置本机的ip地址,这样可以通过局域网访问.通过localhost和127.0.0.1,我测试发现访问的结果不一样.</span><br><span class="line">ServerName :10.205.49.198</span><br><span class="line">DocumentRoot /var/www/jobboardscraper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WSGIDaemonProcess python-path=/var/www/jobboardscraper python-home=/home/tina/.local/virtualenvs/jobboardscraper/lib/python3.5/site-packages</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&lt;Directory /var/www/jobboardscraper/static/&gt;    </span><br><span class="line"></span><br><span class="line">    Require all granted</span><br><span class="line"></span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory /var/www/jobboardscraper &gt;</span><br><span class="line">    Require all granted </span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">WSGIScriptAlias / /var/www/jobboardscraper/jobboardscraper/wsgi.py</span><br><span class="line">#//前面在建立的文件</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="wsgi-py"><a href="#wsgi-py" class="headerlink" title="wsgi.py"></a>wsgi.py</h3><p>位置 var/www/jobboardscraper/jobboardscraper/wsgi.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import site</span><br><span class="line">from os.path import join, dirname, abspath</span><br><span class="line"></span><br><span class="line">site.addsitedir(&apos;/home/tina/.local/virtualenvs/jobboardscraper/lib/python3.5/site-packages&apos;)</span><br><span class="line"></span><br><span class="line">PROJECT_DIR = dirname(dirname(abspath(__file__)))</span><br><span class="line"></span><br><span class="line">sys.path.append(r&apos;var/www/jobboardscraper&apos;)</span><br><span class="line">sys.path.append(r&apos;var/www/jobboardscraper/jobboardscraper&apos;)</span><br><span class="line">sys.path.insert(0, PROJECT_DIR)</span><br><span class="line"></span><br><span class="line"># Activate your virtual env</span><br><span class="line">activate_env=os.path.expanduser(&quot;/home/tina/.local/virtualenvs/jobboardscraper/bin/activate_this.py&quot;)  #虚拟环境中的路径</span><br><span class="line">with open(activate_env) as file:</span><br><span class="line">    exec(file.read(), dict(__file__=activate_env))</span><br><span class="line">os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;jobboardscraper.settings&quot;)</span><br><span class="line">from django.core.wsgi import get_wsgi_application</span><br><span class="line"></span><br><span class="line">application = get_wsgi_application()</span><br></pre></td></tr></table></figure>
<h2 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h2><p>主要看日志/var/log/apache2/error.log与systemctl -xe</p>
<h2 id="OperationalError-unable-to-open-database-file"><a href="#OperationalError-unable-to-open-database-file" class="headerlink" title="OperationalError: unable to open database file"></a>OperationalError: unable to open database file</h2><p>通过对象调用不到类属性<br>Django 在读写 sqlite 时会在 project 目录下产生临时文件，所以不仅要对 db.sqlite3 执行 chmod 777，还要对整个 project 目录执行 chmod 777 -R。<br>参考　<a href="http://elvestar.com/notes/django/" target="_blank" rel="noopener">http://elvestar.com/notes/django/</a></p>
<h2 id="import-Django-错误"><a href="#import-Django-错误" class="headerlink" title="import Django 错误"></a>import Django 错误</h2><p>在log里查看当前的python环境，一般原因都算没激活virtualenv(activate_this.py)</p>
<h2 id="name-‘execfile’-is-not-defined"><a href="#name-‘execfile’-is-not-defined" class="headerlink" title="name ‘execfile’ is not defined"></a>name ‘execfile’ is not defined</h2><p>参考stackoverflow的解释</p>
<p>这是别人python2下配的wsgi.py<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># Install venv by `virtualenv --distribute venv`</span><br><span class="line"># Then install depedencies: `source venv/bin/active`</span><br><span class="line"># `pip install -r requirements.txt`</span><br><span class="line">activate_this = &apos;/var/www/apache/csshat.com/csshat.com/venv/bin/activate_this.py&apos;</span><br><span class="line">execfile(activate_this, dict(__file__=activate_this))</span><br><span class="line"></span><br><span class="line">path = os.path.join(os.path.dirname(__file__), os.pardir)</span><br><span class="line">if path not in sys.path:</span><br><span class="line">    sys.path.append(path)</span><br><span class="line"></span><br><span class="line"># The application object is used by any WSGI server configured to use this</span><br><span class="line"># file.</span><br><span class="line"></span><br><span class="line"># Ensure there is an app.py script in the current folder</span><br><span class="line">from app import app as application</span><br></pre></td></tr></table></figure></p>
<p>python3 下要修改成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activate_this = &apos;/var/www/apache/csshat.com/csshat.com/venv/bin/activate_this.py&apos;</span><br><span class="line">with open(activate_this) as file:</span><br><span class="line">    exec(file.read(), dict(__file__=activate_this))</span><br></pre></td></tr></table></figure></p>
<h2 id="localhost能访问，局域网访问不了"><a href="#localhost能访问，局域网访问不了" class="headerlink" title="localhost能访问，局域网访问不了"></a>localhost能访问，局域网访问不了</h2><p>修改settings.py 改成’*’<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS = [</span><br><span class="line">    #&apos;127.0.0.1&apos;,</span><br><span class="line">    #&apos;localhost&apos;,</span><br><span class="line">    #&apos;10.205.49.198&apos;</span><br><span class="line">    #&apos;.herokuapp.com&apos;</span><br><span class="line">    &apos;*&apos;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="https://www.thecodeship.com/deployment/deploy-django-apache-virtualenv-and-mod_wsgi/" target="_blank" rel="noopener">https://www.thecodeship.com/deployment/deploy-django-apache-virtualenv-and-mod_wsgi/</a><br><a href="https://blog.csdn.net/caterpillarous/article/details/52917917" target="_blank" rel="noopener">https://blog.csdn.net/caterpillarous/article/details/52917917</a><br><a href="https://www.jianshu.com/p/44ab75fbaef2" target="_blank" rel="noopener">https://www.jianshu.com/p/44ab75fbaef2</a><br><a href="https://www.jianshu.com/p/b40a4a12fff1" target="_blank" rel="noopener">https://www.jianshu.com/p/b40a4a12fff1</a><br><a href="https://blog.csdn.net/qingyuanluofeng/article/details/44184135" target="_blank" rel="noopener">https://blog.csdn.net/qingyuanluofeng/article/details/44184135</a><br><a href="https://www.jianshu.com/p/3a45daa9e558" target="_blank" rel="noopener">https://www.jianshu.com/p/3a45daa9e558</a><br><a href="https://jerrynest.io/mod-wsgi-apache-django/" target="_blank" rel="noopener">https://jerrynest.io/mod-wsgi-apache-django/</a></p>
]]></content>
      <categories>
        <category>环境安装配置</category>
      </categories>
  </entry>
  <entry>
    <title>Windows7下caffe-ssd-microsoft下编译 - 深度学习</title>
    <url>/2018/04/26/windows%E4%B8%8B%E5%AE%89%E8%A3%85caffe-ssd/</url>
    <content><![CDATA[<p>整个编译可谓漫长 编译了两天 网上教程也很多 但是也很杂 遇到各种错误 总归是编完了</p>
<p>1、下载Windows版本的Caffe-SSD源码<br>下载链接：<a href="https://github.com/conner99/caffe，选择ssd-microsoft" target="_blank" rel="noopener">https://github.com/conner99/caffe，选择ssd-microsoft</a> 分支；<br>2、编译caffe<br>1）、打开caffe-ssd-microsoft文件夹,然后看到一个windows文件夹,然后继续打开windows文件夹,看到里面一个CommonSettings.props.example文件,复制出来一份,并改名字为CommonSettings.props；<br><a id="more"></a><br>2）、修改CommonSettings.props文件，选择gpu或是cpu以及cuda版本，这里选择的是GPU编译和Cuda7.5;这里写图片描述<br>3、编译问题解决<br>1）、设置libcaffe为启动项，进行编译，报错：与boost相关的regex正则表达式库出现问题，在项目中我们不需要正则表达式，所以将相关语句注释掉即可；<br>解决方法：<br>进入项libcaffe中，进入detection_output_layer.hpp中，将与regex相关头文件注释掉； </p>
<p>进入detection_output_layer.cpp文件，将所有出现regex和rv的语句注释掉； </p>
<p>进入detection_output_layer.cu文件，将所有出现regex和rv的语句注释掉； </p>
<p>2）、编译工程，报错:expected an identifier in caffe.pb.h；<br>解决方法：修改bbox_util.cu，注释掉所有带thrust的语句； </p>
<p>3）、编译工程，报错：找不到”.\caffe\3rdparty\hungarian.h”文件；<br>编译工程，报错：找不到”.\src\caffe\3rdparty\hungarian.cpp”文件；<br>解决方法：<br>在路径.\caffe-master\include\caffe\3rdparty\下添加hungarian.h文件；<br>在路径.\caffe-master\src\caffe\3rdparty\下添加hungarian.cpp文件；<br>在这里找这个文件,链接：<a href="http://pan.baidu.com/s/1mhYuf7y" target="_blank" rel="noopener">http://pan.baidu.com/s/1mhYuf7y</a> 密码：3jp2； </p>
<p>接下來這個一定要改，不改的話會反覆出現類似於：error MSB3721: 命令“”C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v7.5\bin\nvcc.exe” ….等錯誤。我本人在此被坑幾天，頭髮都掉了一地，哎。這裏的解決辦法是在detection_output_layer.cu，detection_output_layer.cpp兩個文檔中註釋掉所有出現的regex和rv的語句；然後再detection_output_layer.hpp中將語句#include &lt;boost/regex.hpp&gt;註釋掉。</p>
<p>此外，在libcaffe項目下的bbox_util.cu文檔，註釋掉thrust相關的內容，如下所示:  //#include “thrust/functional.h”  //#include “thrust/sort.h”</p>
<p>…..  </p>
<p>//thrust::sort_by_key(&amp;confidence[0],&amp;confidence[0]+num_remain,&amp;idx[0],  </p>
<p>//thrurst::greater<dtype>());*/  </dtype></p>
<p>5 上面的執行完畢之後，恭喜你基本上可以生成libcaffe、caffe.exe文檔，先編譯libcaffe，再caffe（一般都是Release下）。</p>
<p>另外我还遇到了</p>
<p>protobuf版本冲突的问题，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In file included from .build_release/src/caffe/proto/caffe.pb.cc:5:0:  </span><br><span class="line">.build_release/src/caffe/proto/caffe.pb.h:12:2: error: #error This file was generated by a newer version of protoc which is  </span><br><span class="line"> #error This file was generated by a newer version of protoc which is  </span><br><span class="line">  ^  </span><br><span class="line">.build_release/src/caffe/proto/caffe.pb.h:13:2: error: #error incompatible with your Protocol Buffer headers. Please update  </span><br><span class="line"> #error incompatible with your Protocol Buffer headers.  Please update  </span><br><span class="line">  ^  </span><br><span class="line">.build_release/src/caffe/proto/caffe.pb.h:14:2: error: #error your headers.  </span><br><span class="line"> #error your headers.  </span><br><span class="line">  ^  </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>这个问题的出现是因为我们在安装caffe之前，安装Anaconda或tensorflow时都已经安装过libprotobuf，所以解决冲突的方法是使用以下命令</p>
<p>conda uninstall libprotobuf<br>即可解决。<br>该解决方案来源于<a href="https://stackoverflow.com/questions/36678292/caffe-error-with-protobuf-version" target="_blank" rel="noopener">https://stackoverflow.com/questions/36678292/caffe-error-with-protobuf-version</a></p>
<p>全都编译完了 可以看下目录应该有这些 exe<br><img src="https://images2018.cnblogs.com/blog/1212015/201804/1212015-20180409204852136-465048910.png" alt="image"><br>SSD测试：</p>
<p>新建ssd_detect.bat文件，运行；<br>ssd_detect.bat文件内容：<br>（1）ssd_detect.exe路径；<br>（2）model_file路径，即deploy.prototxt;<br>（3）weights_file路径，即XXX.caffemodel;<br>（4）test.txt图片路径，将图片的绝对路径写入test.txt中；<br>（5）–file_type image，此处还可以进行video检测，可自行看源码修改；<br>（6）–confidence_threshold 0.5； </p>
<p>注意release和X64等配置，接下来是pycaffe的编译，步骤也同上，</p>
<p>我遇到了错误 no module named _caffe</p>
<p> 先把 F:\caffe-ssd\Build\x64\Release\pycaffe里的caffe复制到F:\caffe-ssd\python里 替代原有的caffe </p>
<p>再把F:caffe-ssd\Build\x64\Release\pycaffe下的caffe文件夹复制到Anaconda2\Lib\site-packages文件夹下</p>
<p>类似下图</p>
<p>6.在pycharm中测试一下，可能会出现No module named google.protobuf.internal的问题。<br><img src="https://images2018.cnblogs.com/blog/1212015/201804/1212015-20180409220228803-1113714849.png" alt="image"></p>
<p>解决方法：下载protobuf的两个文件（地址：<a href="https://github.com/google/protobuf/releases/tag/v3.0.0），一个是protoc-3.0.0-win32.zip，一个是Source" target="_blank" rel="noopener">https://github.com/google/protobuf/releases/tag/v3.0.0），一个是protoc-3.0.0-win32.zip，一个是Source</a> code (zip)</p>
<p>解压缩，将protoc-3.0.0-win32\bin\protoc.exe 拷贝进入protobuf-3.0.0源代码文件夹下src文件夹里，进入protobuf-3.0.0源代码文件夹下python文件夹，按住shift右击选择“在此处打开命令窗口”，执行 python setup.py build 、执行 python setup.py install</p>
<p>这时caffe已经在pycharm里配置成功了，赶快试一下吧。</p>
<p>参考博客链接：<br><a href="https://blog.csdn.net/Chen_yingpeng/article/details/59056245" target="_blank" rel="noopener">https://blog.csdn.net/Chen_yingpeng/article/details/59056245</a><br><a href="https://www.jianshu.com/p/9a84cc434e05" target="_blank" rel="noopener">https://www.jianshu.com/p/9a84cc434e05</a><br><a href="https://blog.csdn.net/wfei101/article/details/78565042" target="_blank" rel="noopener">https://blog.csdn.net/wfei101/article/details/78565042</a><br><a href="https://blog.csdn.net/tigerda/article/details/75272621" target="_blank" rel="noopener">https://blog.csdn.net/tigerda/article/details/75272621</a><br><a href="https://blog.csdn.net/yakerang/article/details/78408927" target="_blank" rel="noopener">https://blog.csdn.net/yakerang/article/details/78408927</a><br><a href="https://www.jianshu.com/p/109e30491ec4" target="_blank" rel="noopener">https://www.jianshu.com/p/109e30491ec4</a><br><a href="http://lanbing510.info/2017/08/01/Run-SSD.html" target="_blank" rel="noopener">http://lanbing510.info/2017/08/01/Run-SSD.html</a><br><a href="https://blog.csdn.net/sinat_26917383/article/details/67639189" target="_blank" rel="noopener">https://blog.csdn.net/sinat_26917383/article/details/67639189</a></p>
]]></content>
      <categories>
        <category>环境安装配置</category>
      </categories>
  </entry>
  <entry>
    <title>windows下安装Tensorflow</title>
    <url>/2018/05/06/windows%E4%B8%8B%E5%AE%89%E8%A3%85tensorflow/</url>
    <content><![CDATA[<p>看来tensorflow比caffe好装多了，相到当时在windows下配<br>caffe-ssd真是踩了太多坑了，如此轻易也是有点unbelievable<br><a id="more"></a></p>
<h2 id="确定安装哪类TensorFlow"><a href="#确定安装哪类TensorFlow" class="headerlink" title="确定安装哪类TensorFlow"></a>确定安装哪类TensorFlow</h2><p>需要先确定哪种类型的TensorFlow：</p>
<p>仅支持CUP运算版本：如果电脑的系统没有 NVIDIA®的GPU，那么必须安装这个版本。这个版本的TensorFlow安装非常简单（安装仅需一个命令，5到10分钟），所以即使系统中有满足要求的NVIDIA® GPU官方还是建议在学习阶段安装这个版本。<br>支持GPU运算的版本：TensorFlow程序在GPU下运行比在CPU下运行明显快很多。如果系统中包含 NVIDIA®的GPU满足下一个小节所示的条件并且程序对性能要求很高，建议安装此版本。<br>运行TensorFlow所需要的GPU配置<br>如果在系统中安装使用GPU运行的TensorFlow，需要确保下面介绍的NVIDIA软件已经安装到系统中。</p>
<p>CUDA® Toolkit 8.0。请看 NVIDIA安装cuda 的文档，根据文档中的描述确保已经将CUDA相关的路径增加到 %PATH% 环境变量中。<br>NVIDIA的驱动关联 CUDA Toolkit 8.0。<br>cuDNN v5.1。请查看 NVIDIA cudnn 文档。需要注意的是cuDNN通常安装在与其他CUDA动态链接库（dll）不同的位置。确保已经将cuDNN的 动态链接库（dll）的地址添加到系统的  %PATH% 环境变量中。<br>GPU显卡必须拥有3.0以上版本的CUDA计算能力，查看 NVIDIA显卡支持列表 了解支持情况。<br>如果系统中已经安装了以前的相关包，请更新到所指定的版本。</p>
<h2 id="如何安装TensorFlow"><a href="#如何安装TensorFlow" class="headerlink" title="如何安装TensorFlow"></a>如何安装TensorFlow</h2><p>在安装TensorFlow之前必须选定一个安装机制。目前提供2种机制：</p>
<p>“native”app<br>Anaconda<br>Native的安装（以下简称本地安装）方式会将TensorFlow直接安装在当前的系统中，不会在系统和TensorFlow之间搭建任何的虚拟环境，所以本地安装不会额外安装一个独立的容器。需要注意的是本地安装可能会干扰系统中其他基于python安装的程序。如果事先已经安装配置了满足需要的python环境，本地安装通常只需要一个命令就可以完成。使用本地安装，用户可以在系统中任何位置运行TensorFlow。</p>
<p>在Anaconda模式下，需要使用conda创建一个虚拟环境。官方优先推荐使用 pip install 命令来安装TensorFlow，其次再考虑anaconda的 conda install 命令。conda包是第三方社区提供的（非TensorFlow官方），TensorFlow团队从始至终都不会去测试在conda中运行的情况，在使用时需考虑这个风险。</p>
<p>本地安装<br>首先，需要安装以下版本的python：</p>
<p><strong>Python 3.5.x from python.org<br>TensorFlow在windows操作系统中仅仅支持3.5.x版本的python。Python 3.5.x附带pip3软件包管理器，这是用于安装TensorFlow的程序。</strong></p>
<p>安装TensorFlow需要启动一个终端（terminal），然后在该终端中输入对应的pip3 install命令。安装仅支持CPU版本的TensorFlow，输入以下命令：</p>
<p>C:> pip3 install –upgrade tensorflow<br>安装GPU版本的TensorFlow，使用以下命令：</p>
<p>C:> pip3 install –upgrade tensorflow-gpu<br>Anaconda模式安装</p>
<p>再次强调，Anaconda安装是有第三方社区提供的，非官方。</p>
<p>在Anaconda环境中安装TensorFlow分为以下几个步骤：</p>
<p>按照 Anaconda download site 的说明进行下载和安装操作。<br>调用以下命令来创建一个名为tensorflow的conda环境：<br><strong>C:&gt; conda create -n tensorflow </strong></p>
<p> 键入以下命令来启用conda环境：</p>
<p><strong>C:&gt; activate tensorflow<br> (tensorflow)C:&gt;  # Your prompt should change </strong></p>
<p>键入以下命令在conda环境中安装TensorFlow。这里 安装CPU版本的命令：</p>
<p>(tensorflow)C:&gt; pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.1-cp35-cp35m-win_amd64.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.1-cp35-cp35m-win_amd64.whl</a><br>这是GPU版本的命令：</p>
<p><strong>(tensorflow)C:&gt; pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.0.1-cp35-cp35m-win_amd64.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.0.1-cp35-cp35m-win_amd64.whl</a> </strong></p>
<p>验证安装<br>通过以下步骤来验证TensorFlow是否安装成功：<br>启动一个终端（比如CMD）<br>如果通过Anaconda安装，先启动Anaconda环境。<br>在终端运行python<br>C:&gt; python<br>在python的交互环境中输入以下脚本代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> import tensorflow as tf</span><br><span class="line"></span><br><span class="line">hello = tf.constant(&apos;Hello, TensorFlow!&apos;)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure></p>
<p>如果python输出以下内容，则表明TensorFlow已经安装成功然后就可以写TensorFlow的程序了：</p>
<p>Hello, TensorFlow!<br>如果收到了一些异常信息，请继续向下看。<br>常见的安装问题<br>TensorFlow通过Stack Overflow网站来记录错误信息以及处理方法。下面的列表包含一些跳转的到 Stack Overflow的连接。如果在安装过程中遇到的问题没有在下面中，请到Stack Overflow去搜索相关的关键字。若还是搜索不到，请直接提出新问题并标记 tensorflow 的标签。</p>
<p>Stack Overflow Link    Error Message<br>41007279    </p>
<p>[…\stream_executor\dso_loader.cc] Couldn’t open CUDA library nvcuda.dll<br>41007279    </p>
<p>[…\stream_executor\cuda\cuda_dnn.cc] Unable to load cuDNN DSO<br>42006320    </p>
<p>ImportError: Traceback (most recent call last): File “…\tensorflow\core\framework\graph_pb2.py”, line 6, in from google.protobuf import descriptor as _descriptor ImportError: cannot import name ‘descriptor’<br>42011070    </p>
<p>No module named “pywrap_tensorflow”</p>
<p>安装教程参考自<br><a href="https://my.oschina.net/chkui/blog/881871" target="_blank" rel="noopener">https://my.oschina.net/chkui/blog/881871</a><br><a href="https://blog.csdn.net/u012052268/article/details/74202439" target="_blank" rel="noopener">https://blog.csdn.net/u012052268/article/details/74202439</a></p>
]]></content>
      <categories>
        <category>环境安装配置</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习笔记(五)</title>
    <url>/2020/01/27/ython/</url>
    <content><![CDATA[<h2 id="python编码问题"><a href="#python编码问题" class="headerlink" title="python编码问题"></a>python编码问题</h2><p>在使用python时经常会遇到一些编码的错误</p>
<p>例如’gbk’ codec can’t decode byte 0xbe in position 18: illegal multibyte sequenc<br><a id="more"></a></p>
<p>源代码片段为</p>
<p>很明显从错误中我们可以指导，这是因为文本文档采用的是gbk编码，这个时候我们需要转换成python能识别的编码，比如utf-8</p>
<h2 id="join-和os-path-join-两个函数"><a href="#join-和os-path-join-两个函数" class="headerlink" title="join()和os.path.join()两个函数"></a>join()和os.path.join()两个函数</h2><p>函数：string.join() </p>
<p>Python中有join()和os.path.join()两个函数，具体作用如下：<br>str.join()： 连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串<br>os.path.join()： 将多个路径组合后返回，一般cv2.imread(path),这时候需要拼接路径就会用到这个函数。</p>
<p>一、函数说明<br>1、join()函数<br>语法： ‘sep’.join(seq)<br>参数说明<br>sep：分隔符。可以为空<br>seq：要连接的元素序列、字符串、元组、字典<br>上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串<br>返回值：返回一个以分隔符sep连接各个元素后生成的字符串<br>2、os.path.join()函数<br>语法： os.path.join(path1[,path2[,……]])<br>返回值：将多个路径组合后返回</p>
<p>os.path.join()函数用于路径拼接文件路径。os.path.join()函数中可以传入多个路径：</p>
<p>需要导入 import os</p>
<p>os.path.join()函数：</p>
<p>第一个以”/”开头的参数开始拼接，之前的参数全部丢弃。</p>
<p>以  上一种情况为先。在上一种情况确保下，若出现”./”开头的参数，会从”./”开头参数的  上一个参数开始拼接</p>
<p>例如：</p>
<p>import os<br>print(“1:”,os.path.join(‘aaaa’,’/bbbb’,’ccccc.txt’))<br>print(“2:”,os.path.join(‘/aaaa’,’/bbbb’,’/ccccc.txt’))  #不良写法习惯<br>print(“3:”,os.path.join(‘aaaa’,’./bbb’,’ccccc.txt’))<br>print(“22:”,os.path.join(‘/aaaa/‘,’bbbb/‘,’ccccc.txt’))  #通常可以这样写<br>输出为</p>
<p>#以字符串中含有 / 的第一个开始拼接<br>1: /bbbb/ccccc.txt</p>
<p>#当有多个是最后一个才开始，<br>2: /ccccc.txt</p>
<p>#以./ 的上一个开始拼接<br>3: aaaa/bbb/ccccc.txt</p>
<p>22: aaaa/bbb/ccccc.txt</p>
<p>#通常习惯的写法，合并目录</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os<br>os.path.join(‘/hello/‘,’good/boy/‘,’doiido’)<br>输出：’/hello/good/boy/doiido’</p>
</blockquote>
</blockquote>
</blockquote>
<p>总结一下:其实只是2种不同写法而已，度可以达到相同的拼接效果的。看自己的喜好来写吧</p>
<p>print(“1:”,os.path.join(‘aaaa’,’/bbbb’,’ccccc.txt’))<br>os.path.join(‘/hello/‘,’good/boy/‘,’doiido’)<br>整个串里面只有一个以”/”开头的，参数从它开始往后拼接，”/”开头之前的参数全部丢弃。</p>
<p>print(“2:”,os.path.join(‘/aaaa’,’/bbbb’,’/ccccc.txt’))<br>整个串有多个以”/”开头的参数，从最后”/”开头的的开始往后拼接，之前的参数全部丢弃。</p>
<p>print(“3:”,os.path.join(‘aaaa’,’./bbb’,’ccccc.txt’))</p>
<p>若出现”./”开头的参数，会从”./”开头的参数  的上一个参数开始拼接</p>
<p>print（‘4：’，os.path.join(‘aa/bb/cc/‘,’../dd.txt’)）</p>
<p>结果却是：aa/bb/dd.txt.  可以跳过CC路径</p>
<p>参考链接<br><a href="https://blog.csdn.net/fu6543210/article/details/80032895" target="_blank" rel="noopener">https://blog.csdn.net/fu6543210/article/details/80032895</a></p>
<p><a href="https://blog.csdn.net/weixin_41931602/article/details/80557416" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41931602/article/details/80557416</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>算法训练 表达式计算</title>
    <url>/2018/12/17/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>表达式计算</p>
<p>问题描述</p>
<p>　　输入一个只包含加减乖除和括号的合法表达式，求表达式的值。其中除表示整除。</p>
<p>输入格式<br>　　输入一行，包含一个表达式。</p>
<p>输出格式<br>　　输出这个表达式的值。</p>
<p>样例输入</p>
<p>1-2+3*(4-5)</p>
<p>样例输出</p>
<p>-4</p>
<p>数据规模和约定<br>　　表达式长度不超过100，表达式运算合法且运算过程都在int内进行。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从中缀表达式中从左往右依次取出数据</span><br><span class="line">如遇到操作数，直接输出到后缀的队列里。</span><br><span class="line">如果遇到操作符（包括括号），这里再定义一个存放操作符的栈，则:</span><br><span class="line">i.如果操作符是&apos;(&apos;,入栈</span><br><span class="line">ii.如果操作符是&apos;)&apos;,则把栈里的操作符依次出栈并插入到后缀序列后面，直到遇到&apos;)&apos;.</span><br><span class="line">iii.如果操作符不是‘(’和‘)’,则：</span><br><span class="line">     (1). 如果操作符的优先级比top的优先级高，则入栈</span><br><span class="line">     (2).如果操作符优先级等于或小于top优先级，则将top出栈并插入到后缀序列后面，pop后,再比较栈顶元素的优先级，重复iii，直到把此操作符      插入，将此操作符入栈。</span><br><span class="line">如果中序队列里的数据已经读取完毕，记录操作符的栈里，还有操作符的话，依次出栈插入到后缀序列的后面。</span><br><span class="line">此时中缀就已经转换为后缀表达式,如下图</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20170928182209826?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZHJlYW1fMTk5Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<p>参考博客<br><a href="https://blog.csdn.net/dream_1996/article/details/78126839" target="_blank" rel="noopener">https://blog.csdn.net/dream_1996/article/details/78126839</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 200+2</span><br><span class="line">string ch;</span><br><span class="line">stack&lt;char&gt; s1,s2;//s1 运算符栈 </span><br><span class="line">//s2 操作数 栈 </span><br><span class="line">stack&lt;int&gt; s3;</span><br><span class="line">int pri(char a)&#123;</span><br><span class="line">	switch(a)&#123;</span><br><span class="line">	</span><br><span class="line">		case &apos;-&apos;:</span><br><span class="line">		case &apos;+&apos;: return 1;</span><br><span class="line">		case &apos;*&apos;:</span><br><span class="line">		case &apos;/&apos;: return 2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool isop(char t)&#123;</span><br><span class="line">	return t==&apos;+&apos;||t==&apos;-&apos;||t==&apos;*&apos;||t==&apos;/&apos;;</span><br><span class="line">&#125;</span><br><span class="line">string transform(string s,int &amp;k)&#123;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(i&lt;s.length())&#123;</span><br><span class="line">			if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;)&#123;</span><br><span class="line">				if((i+1&lt;s.length()&amp;&amp;(s[i+1]&lt;&apos;0&apos;||s[i+1]&gt;&apos;9&apos;))||i==s.length()-1)&#123;</span><br><span class="line">					</span><br><span class="line">					s2.push(s[i]);	</span><br><span class="line">					s2.push(&apos;#&apos;);						</span><br><span class="line">				&#125;			</span><br><span class="line">				else &#123;</span><br><span class="line">					s2.push(s[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(isop(s[i]))&#123;</span><br><span class="line">				if(s1.empty()||pri(s[i])&gt;pri(s1.top()))</span><br><span class="line">				&#123;</span><br><span class="line">					s1.push(s[i]);</span><br><span class="line">					//!</span><br><span class="line">				</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					while(!s1.empty()&amp;&amp;pri(s[i])&lt;=pri(s1.top())&amp;&amp;s1.top()!=&apos;(&apos;)&#123;</span><br><span class="line">						s2.push(s1.top());</span><br><span class="line">						s1.pop();</span><br><span class="line">					&#125;</span><br><span class="line">					s1.push(s[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(s[i]==&apos;(&apos;)</span><br><span class="line">				s1.push(s[i]);</span><br><span class="line">			else if(s[i]==&apos;)&apos;)&#123;</span><br><span class="line">				while(!s1.empty())&#123;</span><br><span class="line">					char t=s1.top();</span><br><span class="line">					if(t==&apos;(&apos;) break;</span><br><span class="line">					s2.push(t);</span><br><span class="line">					s1.pop();</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				s1.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			i++;</span><br><span class="line">	&#125;</span><br><span class="line">	while(!s1.empty())&#123;</span><br><span class="line">		</span><br><span class="line">		s2.push(s1.top());</span><br><span class="line">		s1.pop();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	char ss[200];</span><br><span class="line">	</span><br><span class="line">	while(!s2.empty())&#123;</span><br><span class="line">	//!!</span><br><span class="line">	ss[k++]=s2.top();</span><br><span class="line">	</span><br><span class="line">	s2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	ss[k]=&apos;\0&apos;;</span><br><span class="line">//!!</span><br><span class="line">	reverse(ss,ss+k);</span><br><span class="line">	</span><br><span class="line">	return ss;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int val(char t,int t1,int t2)&#123;</span><br><span class="line">	if(t==&apos;+&apos;) return t1+t2;</span><br><span class="line">	else if(t==&apos;-&apos;) return t1-t2;</span><br><span class="line">	else if(t==&apos;*&apos;) return t1*t2;</span><br><span class="line">	else if(t==&apos;/&apos;) return t1/t2;</span><br><span class="line">	else return 0; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int cal(string ss,int k)&#123;</span><br><span class="line">	char num[200];</span><br><span class="line">	int len=0;</span><br><span class="line">	for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">	char t=ss[i];</span><br><span class="line">		if(t&gt;=&apos;0&apos;&amp;&amp;t&lt;=&apos;9&apos;)&#123;</span><br><span class="line">		</span><br><span class="line">			if(ss[i+1]==&apos;#&apos;)&#123;</span><br><span class="line">				num[len++]=t;</span><br><span class="line">				int tmp=0;</span><br><span class="line">			for(int j=0;j&lt;len;j++)&#123;</span><br><span class="line">			tmp+=(num[j]-&apos;0&apos;)*pow(10,len-1-j);</span><br><span class="line">			&#125;</span><br><span class="line">		//	cout&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">			s3.push(tmp);	</span><br><span class="line">			//!!</span><br><span class="line">			len=0;</span><br><span class="line">			tmp=0;</span><br><span class="line">		&#125;</span><br><span class="line">		else num[len++]=t;</span><br><span class="line">	&#125;</span><br><span class="line">		else if(t==&apos;#&apos;) continue;</span><br><span class="line">		else if(isop(t))&#123;</span><br><span class="line">			int t1=s3.top();</span><br><span class="line">			s3.pop();</span><br><span class="line">			int t2=s3.top();</span><br><span class="line">			s3.pop();</span><br><span class="line">			//!!</span><br><span class="line">			int ans=val(t,t2,t1);</span><br><span class="line">			s3.push(ans);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return s3.top();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	getline(cin,ch);</span><br><span class="line">int k;</span><br><span class="line">string  ss;</span><br><span class="line">ss=transform(ch,k);</span><br><span class="line">//cout&lt;&lt;ss&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;cal(ss,k)&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//表达式转换</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	char op;</span><br><span class="line">	int num;</span><br><span class="line">	bool f;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; que;//后缀表达式序列</span><br><span class="line">stack&lt;node&gt; s;//操作符栈 </span><br><span class="line">map&lt;char,int&gt;op;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string str;</span><br><span class="line">	freopen(&quot;21.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	op[&apos;+&apos;]=op[&apos;-&apos;]=1;</span><br><span class="line">	op[&apos;*&apos;]=op[&apos;/&apos;]=2;	</span><br><span class="line">	op[&apos;(&apos;]=-1;	</span><br><span class="line">	getline(cin,str);</span><br><span class="line">	node tmp;</span><br><span class="line">	//2+3*7-4</span><br><span class="line">	for(int i=0;i&lt;str.length();)&#123;</span><br><span class="line">		if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123;</span><br><span class="line">			tmp.f=true;</span><br><span class="line">			tmp.num=str[i]-&apos;0&apos;;			</span><br><span class="line">			while(i+1&lt;str.length()&amp;&amp;str[i+1]&gt;=&apos;0&apos;&amp;&amp;str[i+1]&lt;=&apos;9&apos;)&#123;</span><br><span class="line">				tmp.num=tmp.num*10+str[i+1]-&apos;0&apos;;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			que.push(tmp);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">			else  if(str[i]==&apos;)&apos;)&#123;</span><br><span class="line">				while(!s.empty()&amp;&amp;s.top().op!=&apos;(&apos;)&#123;</span><br><span class="line">					que.push(s.top());</span><br><span class="line">					s.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				s.pop();</span><br><span class="line">				i++;</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">			else if(str[i]==&apos;(&apos;)&#123;</span><br><span class="line">				tmp.f=false;</span><br><span class="line">				tmp.op=&apos;(&apos;;</span><br><span class="line">				s.push(tmp);	i++;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				tmp.f=false;</span><br><span class="line">				while(!s.empty()&amp;&amp;op[str[i]]&lt;=op[s.top().op])&#123;</span><br><span class="line">					que.push(s.top());</span><br><span class="line">					s.pop(); </span><br><span class="line">					</span><br><span class="line">				&#125;						</span><br><span class="line">				tmp.op=str[i];</span><br><span class="line">				s.push(tmp);</span><br><span class="line">				i++;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	while(!s.empty())&#123;</span><br><span class="line">		que.push(s.top());</span><br><span class="line">		s.pop();	</span><br><span class="line">	&#125;</span><br><span class="line">	while(!que.empty())&#123;</span><br><span class="line">	node tmp=que.front();</span><br><span class="line">	que.pop(); </span><br><span class="line">	if(tmp.f==false)</span><br><span class="line">	cout&lt;&lt;tmp.op&lt;&lt;&quot; &quot;;</span><br><span class="line">	else&#123;</span><br><span class="line">			cout&lt;&lt;tmp.num&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯算法训练</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>201809-2 买菜</title>
    <url>/2018/12/13/%E4%B9%B0%E8%8F%9C/</url>
    <content><![CDATA[<p>问题描述</p>
<p>小H和小W来到了一条街上，两人分开买菜，他们买菜的过程可以描述为，去店里买一些菜然后去旁边的一个广场把菜装上车，两人都要买n种菜，所以也都要装n次车。具体的，对于小H来说有n个不相交的时间段[a1,b1],[a2,b2]…[an,bn]在装车，对于小W来说有n个不相交的时间段[c1,d1],[c2,d2]…[cn,dn]在装车。其中，一个时间段[s, t]表示的是从时刻s到时刻t这段时间，时长为t-s。<br><a id="more"></a><br>由于他们是好朋友，他们都在广场上装车的时候会聊天，他们想知道他们可以聊多长时间。</p>
<p>输入格式</p>
<p>输入的第一行包含一个正整数n，表示时间段的数量。</p>
<p>接下来n行每行两个数ai，bi，描述小H的各个装车的时间段。</p>
<p>接下来n行每行两个数ci，di，描述小W的各个装车的时间段。</p>
<p>输出格式</p>
<p>输出一行，一个正整数，表示两人可以聊多长时间。</p>
<p>样例输入</p>
<p>4</p>
<p>1 3</p>
<p>5 6</p>
<p>9 13</p>
<p>14 15</p>
<p>2 4</p>
<p>5 7</p>
<p>10 11</p>
<p>13 14</p>
<p>样例输出</p>
<p>3</p>
<p>数据规模和约定
　</p>
<p> 对于所有的评测用例，1 ≤ n ≤ 2000, ai &lt; bi &lt; ai+1，ci &lt; di &lt; ci+1,对于所有的i(1 ≤ i ≤ n)有，1 ≤ ai, bi, ci, di ≤ 1000000。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int st;</span><br><span class="line">	int end;</span><br><span class="line">	node(int ss,int ee)&#123;</span><br><span class="line">		st=ss;</span><br><span class="line">		end=ee;</span><br><span class="line">	&#125;</span><br><span class="line">	node()&#123;&#125;</span><br><span class="line">	bool operator &lt;(const node t)const&#123;</span><br><span class="line">	if(st==t.st) return end&lt;t.end;</span><br><span class="line">	else return st&lt;t.st;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node v1[2002],v2[2002];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,st,end;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;st&gt;&gt;end;</span><br><span class="line">		v1[i]=node(st,end);</span><br><span class="line">	&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;st&gt;&gt;end;</span><br><span class="line">		v2[i]=node(st,end);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(v1,v1+n);</span><br><span class="line">	sort(v2,v2+n);</span><br><span class="line">	int cnt=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		int timer=0;</span><br><span class="line">		for(int k=0;k&lt;n;k++)</span><br><span class="line">		&#123;</span><br><span class="line">		if(v1[i].st&gt;=v2[k].end) continue;</span><br><span class="line">		if(v1[i].end&lt;=v2[k].st) continue;</span><br><span class="line">		else if(v1[i].st&lt;=v2[k].st&amp;&amp;v2[k].end&gt;=v1[i].end) timer+=v1[i].end-v2[k].st;</span><br><span class="line">		else if(v1[i].st&gt;=v2[k].st&amp;&amp;v2[k].end&lt;=v1[i].end) timer+=v2[k].end-v1[i].st;		</span><br><span class="line">		else if(v1[i].st&gt;=v2[k].st&amp;&amp;v2[k].end&gt;=v1[i].end) timer+=v1[i].end-v1[i].st;	</span><br><span class="line">		else if(v1[i].st&lt;=v2[k].st&amp;&amp;v2[k].end&lt;=v1[i].end) timer+=v2[k].end-v2[k].st;		</span><br><span class="line">		&#125;</span><br><span class="line">	//	cout&lt;&lt;v1[i].st&lt;&lt;&quot; &quot;&lt;&lt;v1[i].end&lt;&lt;&quot; &quot;&lt;&lt;v2[i].st&lt;&lt;&quot; &quot;&lt;&lt;v2[i].end&lt;&lt;&quot; &quot;&lt;&lt;timer&lt;&lt;endl; </span><br><span class="line">		cnt+=timer;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>二叉查找树 BST</title>
    <url>/2018/05/19/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h2 id="BST特点"><a href="#BST特点" class="headerlink" title="BST特点"></a>BST特点</h2><p>在二叉查找树中：<br>(1) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>(2) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>(3) 任意节点的左、右子树也分别为二叉查找树。</p>
<p>(4) 没有键值相等的节点（no duplicate nodes）。<br><a id="more"></a></p>
<h2 id="找前驱和后继节点"><a href="#找前驱和后继节点" class="headerlink" title="找前驱和后继节点"></a>找前驱和后继节点</h2><p>BST中某节点前驱节点==小于该节点的所有节点中的最大值</p>
<p>前驱容易情形：5寻前驱 4</p>
<p>前驱复杂情形：11寻前驱 10</p>
<p>BST中某节点后继节点==大于该节点的所有节点中的最小值<br>后继容易情形：5寻后继 6</p>
<p>复杂情形：9寻后继 10</p>
<p><img src="https://img-blog.csdn.net/20140806233845765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hlZXBtdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<h2 id="二叉树的插入"><a href="#二叉树的插入" class="headerlink" title="二叉树的插入"></a>二叉树的插入</h2><p>a.若当前的二叉查找树为空，则插入的元素为根节点 </p>
<p>b.若插入的元素值小于根节点值，则将元素插入到左子树中</p>
<p>c.若插入的元素值不小于根节点值，则将元素插入到右子树中。首先找到插入的位置，要么向左，要么向右，直到找到空结点，即为插入位置，如果找到了相同值的结点，插入失败。</p>
<h2 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h2><p>分三种情况进行处理：</p>
<p>1.p为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点），如图a。</p>
<p>2.p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可；（注意分是根节点和不是根节点）；如图b。</p>
<p>3.有两个孩子的情况，当前结点与左子树中最大的元素交换，然后删除当前结点。左子树最大的元素一定是叶子结点，交换后，当前结点即为叶子结点，删除参考没有孩子的情况。另一种方法是，当前结点与右子树中最小的元素交换，然后删除当前结点。如图c。<br><img src="https://img-blog.csdn.net/20140807005303062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hlZXBtdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">	int value;</span><br><span class="line">	TreeNode parent;</span><br><span class="line">	TreeNode left;</span><br><span class="line">	TreeNode right;</span><br><span class="line"></span><br><span class="line">	public TreeNode(int value, TreeNode parent, TreeNode left, TreeNode right) &#123;</span><br><span class="line">		this.value = value;</span><br><span class="line">		this.parent = parent;</span><br><span class="line">		this.left = left;</span><br><span class="line">		this.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BST &#123;</span><br><span class="line">	public TreeNode getMax(TreeNode root) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			return null;</span><br><span class="line">		while (root.right != null)</span><br><span class="line">			root = root.right;</span><br><span class="line">		return root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public TreeNode getMin(TreeNode root) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			return null;</span><br><span class="line">		while (root.left != null)</span><br><span class="line">			root = root.left;</span><br><span class="line">		return root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public TreeNode search(TreeNode root, int val) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			return root;</span><br><span class="line">		if (root.value &lt; val)</span><br><span class="line">			return search(root.left, val);</span><br><span class="line">		else if (root.value &gt; val)</span><br><span class="line">			return search(root.right, val);</span><br><span class="line">		else</span><br><span class="line">			return root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public TreeNode preNode(TreeNode x) &#123;</span><br><span class="line">		if (x.left != null)</span><br><span class="line">			return getMax(x.left);</span><br><span class="line">		// 如果x没有左孩子。则x有以下两种可能：</span><br><span class="line">		// (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。</span><br><span class="line">		// (02) x是&quot;一个左孩子&quot;，则 前驱节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的右儿子</span><br><span class="line">		else &#123;</span><br><span class="line">			TreeNode p = x.parent;</span><br><span class="line">			while (p != null &amp;&amp; p.left == x) &#123;</span><br><span class="line">				x = p;</span><br><span class="line">				p = p.parent;</span><br><span class="line">			&#125;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public TreeNode postNode(TreeNode x) &#123;</span><br><span class="line">		if (x.right != null)</span><br><span class="line">			return getMin(x.right);</span><br><span class="line">		// 如果x没有左孩子。则x有以下两种可能：</span><br><span class="line">		// (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。</span><br><span class="line">		// (02) x是&quot;一个左孩子&quot;，则 前驱节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的左儿子</span><br><span class="line">		else &#123;</span><br><span class="line">			TreeNode p = x.parent;</span><br><span class="line">			while (p != null &amp;&amp; p.right == x) &#123;</span><br><span class="line">				x = p;</span><br><span class="line">				p = p.parent;</span><br><span class="line">			&#125;</span><br><span class="line">			return p;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public TreeNode insertRec(TreeNode root, TreeNode x) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			root = x;</span><br><span class="line">		else if (x.value &lt; root.value)</span><br><span class="line">			root.left = insertRec(root.left, x);</span><br><span class="line">		else if (x.value &gt; root.value)</span><br><span class="line">			root.right = insertRec(root.right, x);</span><br><span class="line">		return root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void delete(TreeNode root, TreeNode x) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			return;</span><br><span class="line">		TreeNode p = null;</span><br><span class="line">		while (root != null)// 定位到需要删除的节点</span><br><span class="line">		&#123;</span><br><span class="line">			if (x.value &lt; root.value) &#123;</span><br><span class="line">				p = root;// 记录父节点</span><br><span class="line">				root = root.left;</span><br><span class="line">			&#125; else if (x.value &gt; root.value) &#123;</span><br><span class="line">				p = root;// 记录父节点</span><br><span class="line">				root = root.right;</span><br><span class="line">			&#125; else// 找到啦</span><br><span class="line">			&#123;</span><br><span class="line">				if (root.left == null &amp;&amp; root.right == null)// ①待删除的是 叶子节点</span><br><span class="line">				&#123;</span><br><span class="line">					if (p == null)// 待删除的是根节点</span><br><span class="line">						root = null;</span><br><span class="line">					else &#123;</span><br><span class="line">						if (p.left == root)</span><br><span class="line">							p.left = null;</span><br><span class="line">						else if (p.right == root)</span><br><span class="line">							p.right = null;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else if (root.left != null &amp;&amp; root.right == null)// ②</span><br><span class="line">																	// 待删除的节点只有左孩子</span><br><span class="line">				&#123;</span><br><span class="line">					if (p == null)// 待删除的是根节点</span><br><span class="line">						root = root.left;</span><br><span class="line">					else &#123;</span><br><span class="line">						if (p.left == root)// 待删除的本身是一个左孩子</span><br><span class="line">							p.left = root.left;</span><br><span class="line">						else if (p.right == root)</span><br><span class="line">							p.right = root.left;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else if (root.left == null &amp;&amp; root.right != null)// ②</span><br><span class="line">																	// 待删除的节点只有右孩子</span><br><span class="line">				&#123;</span><br><span class="line">					if (p == null)// 待删除的是根节点</span><br><span class="line">						root = root.right;</span><br><span class="line">					else &#123;</span><br><span class="line">						if (p.left == root)// 待删除的本身是一个左孩子</span><br><span class="line">							p.left = root.right;</span><br><span class="line">						else if (p.right == root)</span><br><span class="line">							p.right = root.right;</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else// ③待删除的节点即有左孩子又有右孩子 方法：得到待删除节点右子树的最小值，</span><br><span class="line">				&#123;// 该最小值与待删除节点进行“ 值 ”交换，删除该最小值位置处的节点</span><br><span class="line">					TreeNode rMin = root.right; // 求待删除节点的后继节点,即待删除节点的右孩子的最小值(找到的后继节点肯定没有左孩子！！！)</span><br><span class="line">					TreeNode rMinP = null;// 因为需要删除后继节点位置，所以需要记录父节点</span><br><span class="line">					while (rMin != null) &#123;</span><br><span class="line">						rMinP = rMin;</span><br><span class="line">						rMin = rMin.left;</span><br><span class="line">					&#125;</span><br><span class="line">					int rootVtemp = root.value;// 值交换</span><br><span class="line">					root.value = rMin.value;</span><br><span class="line">					rMin.value = rootVtemp;</span><br><span class="line">					// 删除rMin位置的节点，此时此位置的值已是待删节点的值</span><br><span class="line">					if (rMinP.left == rMin)</span><br><span class="line">						rMinP.left = rMin.right;</span><br><span class="line">					else if (rMinP.right == rMin)</span><br><span class="line">						rMinP.right = rMin.right;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			break;// 找到后删了后就跳出while循环</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>复习</category>
      </categories>
  </entry>
  <entry>
    <title>201612-1 中间数</title>
    <url>/2018/11/07/%E4%B8%AD%E9%97%B4%E6%95%B0/</url>
    <content><![CDATA[<p>问题描述<br>　　在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。<br><a id="more"></a><br>给定一个整数序列，请找出这个整数序列的中间数的值。<br>输入格式<br>　　输入的第一行包含了一个整数n，表示整数序列中数的个数。<br>　　第二行包含n个正整数，依次表示a1, a2, …, an。</p>
<p>输出格式<br>　　如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。</p>
<p>样例输入</p>
<p>6</p>
<p>2 6 5 6 3 5</p>
<p>样例输出<br>5</p>
<p>样例说明<br>　　比5小的数有2个，比5大的数也有2个。</p>
<p>样例输入<br>4</p>
<p>3 4 6 7</p>
<p>样例输出<br>-1</p>
<p>样例说明<br>　　在序列中的4个数都不满足中间数的定义。</p>
<p>样例输入</p>
<p>5</p>
<p>3 4 6 6 7</p>
<p>样例输出</p>
<p>-1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#define MAX 1000</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	int a[MAX];</span><br><span class="line">	set&lt;int&gt; s;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i]; </span><br><span class="line">		s.insert(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	int flag=0;</span><br><span class="line">	for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)&#123;</span><br><span class="line">		int n1=0;</span><br><span class="line">				int n2=0;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(*it&lt;a[i]) n1++;</span><br><span class="line">			if(*it&gt;a[i]) n2++;</span><br><span class="line">		&#125;	</span><br><span class="line">		if(n1==n2) &#123;</span><br><span class="line">			flag=1;</span><br><span class="line">			cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(flag==0) cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>位运算符</title>
    <url>/2018/04/26/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。</p>
<h2 id="按位取反："><a href="#按位取反：" class="headerlink" title="按位取反：~"></a>按位取反：~</h2><ul>
<li>将a每位上的1变为0,0变为1</li>
<li>相当于~a = -a - 1</li>
</ul>
<h2 id="位与：-amp"><a href="#位与：-amp" class="headerlink" title="位与：&amp;"></a>位与：&amp;</h2><ul>
<li>只有a和b对应位同为1的时候才为1 </li>
<li>掩码：将某些位设置为开(1)而某些位设置为关(0)</li>
<li>关闭位：不影响其他位，只关闭特定位<a id="more"></a>
</li>
</ul>
<h2 id="位或："><a href="#位或：" class="headerlink" title="位或：|"></a>位或：|</h2><p><strong>只要对应的两个二进位有一个为1时，结果位就为1。参与运算的两个数均以补码出现出现</strong></p>
<ul>
<li>要有a和b的对应位上有一个1就为1 </li>
<li>打开位：打开某一个特定的位（1），同时其他位保持不变</li>
</ul>
<h2 id="位异或："><a href="#位异或：" class="headerlink" title="位异或：^"></a>位异或：^</h2><p><strong>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。参与运算数仍以补码出现</strong></p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aplusb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">       aplusb(a^b,(a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; aplusb(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两数相减"><a href="#两数相减" class="headerlink" title="两数相减"></a>两数相减</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = a ^ b;</span><br><span class="line">    <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> add(s, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(a, add(~b, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; del(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>位运算符</category>
      </categories>
      <tags>
        <tag>位运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法中的交叉配对</title>
    <url>/2018/09/22/%E4%BA%A4%E5%8F%89%E9%85%8D%E5%AF%B9/</url>
    <content><![CDATA[<p>选择DNA的部分进行交叉配对<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">DNA_SIZE =10</span><br><span class="line"></span><br><span class="line">POP_SIZE=10</span><br><span class="line"></span><br><span class="line">pop = np.random.randint(2, size=[POP_SIZE,DNA_SIZE])</span><br><span class="line"></span><br><span class="line">print(pop)</span><br><span class="line"></span><br><span class="line">for parent in pop:</span><br><span class="line"></span><br><span class="line">        print(&apos;parent:&apos;,parent)  #依次选择pop中的DNA进行交叉</span><br><span class="line"></span><br><span class="line">        i_ = np.random.randint(0, POP_SIZE,size=1) # 选取pop中某一个DNA</span><br><span class="line"></span><br><span class="line">        print(&apos;选择pop中第:&apos;,i_,&apos;个DNA&apos;)</span><br><span class="line"></span><br><span class="line">        print(&apos;任意生成DNA:&apos;,np.random.randint(0,2,size=DNA_SIZE))   # 任意生成DNA</span><br><span class="line"></span><br><span class="line">        # 利用任意生成的DNA产生交叉点，为布尔值组成的列表</span><br><span class="line"></span><br><span class="line">        cross_points = np.random.randint(0, 2, size=DNA_SIZE).astype(np.bool)                  </span><br><span class="line"></span><br><span class="line">        print(&apos;cosspoint:&apos;,cross_points) # 生成交叉点</span><br><span class="line"></span><br><span class="line">        print(&apos;截取第&apos;,i_,&apos;个DNA的片段&apos;,pop[i_, cross_points])</span><br><span class="line"></span><br><span class="line">        parent[cross_points] = pop[i_,cross_points]</span><br><span class="line"></span><br><span class="line">         print(&apos;cross_parent:&apos;,parent)</span><br><span class="line"></span><br><span class="line">         print(&apos;#######&apos;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line"></span><br><span class="line">[[1 0 1 0 1 0 1 1 0 1]</span><br><span class="line"></span><br><span class="line">[0 1 1 0 0 1 0 1 1 1]</span><br><span class="line"></span><br><span class="line">[1 1 0 1 0 0 0 1 1 0]</span><br><span class="line"></span><br><span class="line">[0 0 1 1 0 1 1 1 0 1]</span><br><span class="line"></span><br><span class="line">[1 0 0 0 1 0 1 1 1 1]</span><br><span class="line"></span><br><span class="line">[1 1 1 0 1 0 1 0 0 0]</span><br><span class="line"></span><br><span class="line">[0 0 1 1 0 1 1 0 0 1]</span><br><span class="line"></span><br><span class="line">[0 0 0 0 0 1 1 1 0 0]</span><br><span class="line"></span><br><span class="line">[1 0 0 1 1 1 1 1 0 0]</span><br><span class="line"></span><br><span class="line">[1 1 1 1 0 0 1 0 0 0]]</span><br><span class="line"></span><br><span class="line">parent: [1 0 1 0 1 0 1 1 0 1]</span><br><span class="line"></span><br><span class="line">选择pop中第: [0] 个DNA</span><br><span class="line"></span><br><span class="line">任意生成DNA: [1 1 1 1 0 0 0 1 0 0]</span><br><span class="line"></span><br><span class="line">cosspoint: [ True  True False  True False False  True False False  True]</span><br><span class="line"></span><br><span class="line">截取第 [0] 个DNA的片段 [1 0 0 1 1]</span><br><span class="line"></span><br><span class="line">cross_parent: [1 0 1 0 1 0 1 1 0 1]</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"></span><br><span class="line">parent: [0 1 1 0 0 1 0 1 1 1]</span><br><span class="line"></span><br><span class="line">选择pop中第: [4] 个DNA</span><br><span class="line"></span><br><span class="line">任意生成DNA: [0 1 0 1 0 0 0 0 1 1]</span><br><span class="line"></span><br><span class="line">cosspoint: [ True False  True False False  True False False False  True]</span><br><span class="line"></span><br><span class="line">截取第 [4] 个DNA的片段 [1 0 0 1]</span><br><span class="line"></span><br><span class="line">cross_parent: [1 1 0 0 0 0 0 1 1 1]</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"></span><br><span class="line">parent: [1 1 0 1 0 0 0 1 1 0]</span><br><span class="line"></span><br><span class="line">选择pop中第: [2] 个DNA</span><br><span class="line"></span><br><span class="line">任意生成DNA: [0 1 1 1 1 0 1 1 1 1]</span><br><span class="line"></span><br><span class="line">cosspoint: [ True False  True  True False  True  True  True False False]</span><br><span class="line"></span><br><span class="line">截取第 [2] 个DNA的片段 [1 0 1 0 0 1]</span><br><span class="line"></span><br><span class="line">cross_parent: [1 1 0 1 0 0 0 1 1 0]</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"></span><br><span class="line">parent: [0 0 1 1 0 1 1 1 0 1]</span><br><span class="line"></span><br><span class="line">选择pop中第: [2] 个DNA</span><br><span class="line"></span><br><span class="line">任意生成DNA: [1 1 1 1 0 0 0 1 1 0]</span><br><span class="line"></span><br><span class="line">cosspoint: [ True False  True  True  True False False  True  True False]</span><br><span class="line"></span><br><span class="line">截取第 [2] 个DNA的片段 [1 0 1 0 1 1]</span><br><span class="line"></span><br><span class="line">cross_parent: [1 0 0 1 0 1 1 1 1 1]</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"></span><br><span class="line">parent: [1 0 0 0 1 0 1 1 1 1]</span><br><span class="line"></span><br><span class="line">选择pop中第: [4] 个DNA</span><br><span class="line"></span><br><span class="line">任意生成DNA: [1 1 0 0 1 0 0 1 1 0]</span><br><span class="line"></span><br><span class="line">cosspoint: [False  True False False False  True False False False False]</span><br><span class="line"></span><br><span class="line">截取第 [4] 个DNA的片段 [0 0]</span><br><span class="line"></span><br><span class="line">cross_parent: [1 0 0 0 1 0 1 1 1 1]</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"></span><br><span class="line">parent: [1 1 1 0 1 0 1 0 0 0]</span><br><span class="line"></span><br><span class="line">选择pop中第: [5] 个DNA</span><br><span class="line"></span><br><span class="line">任意生成DNA: [1 1 1 1 0 0 1 0 0 1]</span><br><span class="line"></span><br><span class="line">cosspoint: [ True False  True False False False False  True False  True]</span><br><span class="line"></span><br><span class="line">截取第 [5] 个DNA的片段 [1 1 0 0]</span><br><span class="line"></span><br><span class="line">cross_parent: [1 1 1 0 1 0 1 0 0 0]</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"></span><br><span class="line">parent: [0 0 1 1 0 1 1 0 0 1]</span><br><span class="line"></span><br><span class="line">选择pop中第: [9] 个DNA</span><br><span class="line"></span><br><span class="line">任意生成DNA: [0 1 1 1 0 1 0 0 0 0]</span><br><span class="line"></span><br><span class="line">cosspoint: [ True False  True  True  True  True  True  True  True False]</span><br><span class="line"></span><br><span class="line">截取第 [9] 个DNA的片段 [1 1 1 0 0 1 0 0]</span><br><span class="line"></span><br><span class="line">cross_parent: [1 0 1 1 0 0 1 0 0 1]</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"></span><br><span class="line">parent: [0 0 0 0 0 1 1 1 0 0]</span><br><span class="line"></span><br><span class="line">选择pop中第: [6] 个DNA</span><br><span class="line"></span><br><span class="line">任意生成DNA: [1 1 1 1 1 0 1 1 0 1]</span><br><span class="line"></span><br><span class="line">cosspoint: [ True  True False  True False  True  True  True False False]</span><br><span class="line"></span><br><span class="line">截取第 [6] 个DNA的片段 [1 0 1 0 1 0]</span><br><span class="line"></span><br><span class="line">cross_parent: [1 0 0 1 0 0 1 0 0 0]</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"></span><br><span class="line">parent: [1 0 0 1 1 1 1 1 0 0]</span><br><span class="line"></span><br><span class="line">选择pop中第: [3] 个DNA</span><br><span class="line"></span><br><span class="line">任意生成DNA: [1 1 0 1 0 0 1 1 0 1]</span><br><span class="line"></span><br><span class="line">cosspoint: [ True False False  True False False False  True  True  True]</span><br><span class="line"></span><br><span class="line">截取第 [3] 个DNA的片段 [1 1 1 1 1]</span><br><span class="line"></span><br><span class="line">cross_parent: [1 0 0 1 1 1 1 1 1 1]</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"></span><br><span class="line">parent: [1 1 1 1 0 0 1 0 0 0]</span><br><span class="line"></span><br><span class="line">选择pop中第: [1] 个DNA</span><br><span class="line"></span><br><span class="line">任意生成DNA: [0 1 0 1 1 0 1 1 0 1]</span><br><span class="line"></span><br><span class="line">cosspoint: [ True  True  True False False False  True False False  True]</span><br><span class="line"></span><br><span class="line">截取第 [1] 个DNA的片段 [1 1 0 0 1]</span><br><span class="line"></span><br><span class="line">cross_parent: [1 1 0 1 0 0 0 0 0 1]</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>参考自 <a href="https://www.jianshu.com/p/adc995053ad8" target="_blank" rel="noopener">https://www.jianshu.com/p/adc995053ad8</a></p>
]]></content>
      <categories>
        <category>遗传算法</category>
      </categories>
  </entry>
  <entry>
    <title>例题5-4 反片语</title>
    <url>/2018/10/31/%E4%BE%8B%E9%A2%985-4-%E5%8F%8D%E7%89%87%E8%AF%AD/</url>
    <content><![CDATA[<p>将每个单词标准化加入set,再用Map统计次数<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt; </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string repr(string s)&#123;</span><br><span class="line">	string ans=s;</span><br><span class="line">	for(int i=0;i&lt;ans.length();i++)&#123;</span><br><span class="line">		ans[i]=tolower(ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(ans.begin(),ans.end());</span><br><span class="line">	return ans;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	map&lt;string,int&gt; m;</span><br><span class="line">	string ss;</span><br><span class="line">	vector&lt;string&gt; v;</span><br><span class="line">	while(cin&gt;&gt;ss)&#123;</span><br><span class="line">		if(ss[0]==&apos;#&apos;) break;</span><br><span class="line">			v.push_back(ss);</span><br><span class="line">		ss=repr(ss);</span><br><span class="line">		if(!m.count(ss)) m[ss]=0;</span><br><span class="line">		m[ss]++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">//	for(vector&lt;string&gt;::iterator it=v.begin();it!=v.end();it++)&#123; </span><br><span class="line">//	if(m[repr(*it)]==1) cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">//	&#125;</span><br><span class="line">	for(int i=0;i&lt;v.size();i++)&#123;</span><br><span class="line">		if(m[repr(v[i])]==1) cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法入门经典</category>
      </categories>
  </entry>
  <entry>
    <title>vector的几种初始化及赋值方式：</title>
    <url>/2018/11/05/%E4%BE%8B%E9%A2%987-7-%E5%A4%A9%E5%B9%B3%E9%9A%BE%E9%A2%98/</url>
    <content><![CDATA[<p>vector的几种初始化及赋值方式：<br>（1）不带参数的构造函数初始化</p>
<p>//初始化一个size为0的vector<br>vector<int> abc;</int></p>
<a id="more"></a>
<p>（2）带参数的构造函数初始化</p>
<p>//初始化size,但每个元素值为默认值<br>vector<int> abc(10);    //初始化了10个默认值为0的元素<br>//初始化size,并且设置初始值<br>vector<int> cde(10，1);    //初始化了10个值为1的元素</int></int></p>
<p>（3）通过数组地址初始化</p>
<p>int a[5] = {1,2,3,4,5};<br>//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）<br>vector<int> b(a, a+5);</int></p>
<p>（4）通过同类型的vector初始化</p>
<p>vector<int> a(5,1);<br>//通过a初始化<br>vector<int> b(a);</int></int></p>
<p>（5）通过insert初始化</p>
<p>//insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中<br>vector<int> a(6,6);<br>vecot<int> b;<br>//将a[0]~a[2]插入到b中，b.size()由0变为3<br>b.insert(b.begin(), a.begin(), a.begin() + 3);</int></int></p>
<p>insert也可通过数组地址区间实现插入</p>
<p>int a[6] = {6,6,6,6,6,6};<br>vector<int> b;<br>//将a的所有元素插入到b中<br>b.insert(b.begin(), a, a+7);</int></p>
<p>此外，insert还可以插入m个值为n的元素</p>
<p>//在b开始位置处插入6个6<br>b.insert(b.begin(), 6, 6);</p>
<p>（6）通过copy函数赋值</p>
<p>vector<int> a(5,1);<br>int a1[5] = {2,2,2,2,2};<br>vector<int> b(10);</int></int></p>
<p>/<em>将a中元素全部拷贝到b开始的位置中,注意拷贝的区间为a.begin() ~ a.end()的左闭右开的区间</em>/<br>copy(a.begin(), a.end(), b.begin());</p>
<p>//拷贝区间也可以是数组地址构成的区间<br>copy(a1, a1+5, b.begin() + 5);</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>如何入门深度学习</title>
    <url>/2018/05/11/%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>在网上看到一篇关于深度学习的贴子，写的比较好，特转来与大家分享，感谢原作者</p>
<p>Tel-Aviv大学深度学习实验室的Ofir同学写了一篇如何入门深度学习的文章，顺手翻译一下，造福大家。</p>
<p>人工神经网络最近在很多领域（例如面部识别，物体发现和围棋）都取得了突破，深度学习变得炙手可热。如果你对深度学习感兴趣的话，这篇文章是个不错的起点。<br><a id="more"></a></p>
<p>如果你学过线性代数，微积分，概率论和编程，我建议你从斯坦福大学的CS231n课程开始。这门课内容广泛，写得很高。可每次课的幻灯片都可以下载，虽然官方网站删除了配套的视频，但是你很容易就能在网上搜索到。</p>
<p>如果你没有学过那些数学课，网上也有很多免费的学习材料可以用来学习必要的数学知识。Gilbert Stange的线性代数课程很适合入门。对于其他科目，edX上有MIT的微积分和概率论课程。</p>
<p>如果想学习更多关于机器学习的东西，Andrew Ng在Coursera上的机器学习课程是最佳入门选择。除此之外，Yaser Abu-Mostafa的机器学习课程更关注理论，但也很适合初学者。学习深度学习并不要求掌握机器学习，但如果能有一些了解的话还是很有帮助的。此外，学习经典的机器学习，而不仅仅是深度学习，能让我们有深厚的理论背景————因为，深度学习并不总是最佳方案。</p>
<p>CS231n并不是在线深度学习课程的唯一选择。Geoffrey Hinton的Coursera课程『用于机器学习的神经网络』(Neural Nerworks for Machine Learning)涵盖了诸多内容，Hugo Larochelle的『神经网络课』(Neural Networks Class) 也是如此。这两门课都有视频材料。Nando de Freitas的在线课程也带有视频、幻灯片和家庭作业。</p>
<p>如果你不喜欢看视频，而是更喜欢阅读，《神经网络和深度学习》(Neural Networks and Deep Learning)是一本为深度学习的初学者撰写的在线免费书。《深度学习之书》(The Deep Learning Book)也是一本很赞的免费书，不过内容略高阶一点。</p>
<p>有了基础知识之后，还可以往这些方面发展：<br>几乎上述所有的深度学习材料都或多或少的涉及到计算机视觉(Computer Vision)。<br>递归神经网络(Recurrent Nerual Networks)是用于解决诸如机器翻译和语音识别之类的问题的神经网络模型的基础。Andrej Karpathy关于RNN的博客文章可以帮你学习它。Christopher Olah的博客上有一篇文章用非常形象生动的方式解释了很多深度学习的概念。他关于LSTM网络的文章是一篇很不错的导论，LSTM是一种应用广泛的RNN变体。<br>自然语言处理：CS224d课程介绍了深度学习在自然语言处理中的应用。更高阶的课程来自Kyunghyun Cho(这里有课堂笔记)和Yoav Goldberg。<br>增强学习：如果你想要控制机器人，或者是在围棋比赛上战胜人类，增强学习或许是最佳选择。Andrej Karpathy关于深度增强学习的博客文章可以帮你入门。David Silver最近也发表了一篇介绍深度增强学习的短文章。</p>
<p>深度学习框架：深度学习框架很多，最有名的三个应该是Tensorflow(谷歌)，Torch(Facebook)和Theano(MILA)。三个都很牛逼，如果一定要推荐一个的话，我建议初学者去试试Tensorflow。Tensorflow的教程很不错。</p>
<p>训练神经网络几乎离不开GPU。虽然不是必须的，但GPU可以帮你更快的完成工作。NVIDIA显卡是工业标准，大部分研究实验室都在用一千美元的显卡，很少有便宜货能搞定这个事情。另一个成本更低的办法是从诸如亚马逊之类的云计算服务供应商那租一个带GPU的实例（这里有短教程）。</p>
<p>原文地址：<a href="http://ofir.io/How-to-Start-Learning-Deep-Learning/" target="_blank" rel="noopener">http://ofir.io/How-to-Start-Learning-Deep-Learning/</a></p>
<p>转自：<a href="https://zhuanlan.zhihu.com/p/21475898" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21475898</a></p>
]]></content>
  </entry>
  <entry>
    <title>201604-2 俄罗斯方块</title>
    <url>/2018/12/04/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
    <content><![CDATA[<p>问题描述</p>
<p>俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。</p>
<p>游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。<br><a id="more"></a><br>在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。</p>
<p>具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。</p>
<p>输入格式</p>
<p>输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。</p>
<p>输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。</p>
<p>第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例）</p>
<p>输出格式</p>
<p>输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。</p>
<p>样例输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 1 0 0</span><br><span class="line">0 0 0 0 0 0 1 0 0 0</span><br><span class="line">0 0 0 0 0 0 1 0 0 0</span><br><span class="line">1 1 1 0 0 0 1 1 1 1</span><br><span class="line">0 0 0 0 1 0 0 0 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 0 1</span><br><span class="line">0 0 0 0</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>样例输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 1 0 0</span><br><span class="line">0 0 0 0 0 0 1 0 0 0</span><br><span class="line">0 0 0 0 0 0 1 0 0 0</span><br><span class="line">1 1 1 1 1 1 1 1 1 1</span><br><span class="line">0 0 0 0 1 1 0 0 0 0</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[15][10];</span><br><span class="line">int b[4][4];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int k;</span><br><span class="line">	for(int i=1;i&lt;=15;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=10;j++)</span><br><span class="line">		cin&gt;&gt;a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=4;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=4;j++)</span><br><span class="line">		cin&gt;&gt;b[i][j]; </span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">	int x[10];</span><br><span class="line">	int y[10];</span><br><span class="line">	int t=1;</span><br><span class="line">	for(int i=1;i&lt;=4;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=4;j++)&#123;</span><br><span class="line">			if(b[i][j]==1)&#123;</span><br><span class="line">				x[t]=i;</span><br><span class="line">				y[t]=k+j-1;</span><br><span class="line">				t++;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bool flag1=true;</span><br><span class="line">	int cnt=0;</span><br><span class="line">	int offset=0;</span><br><span class="line">	while(flag1)&#123;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	for(int i=1;i&lt;=4&amp;&amp;flag1;i++)&#123;</span><br><span class="line">		if(x[i]+offset==15) &#123;</span><br><span class="line">			for(int j=1;j&lt;=4;j++)&#123;</span><br><span class="line">					a[offset+x[j]][y[j]]=1; 	</span><br><span class="line">			&#125;</span><br><span class="line">			flag1=false;</span><br><span class="line">		&#125; </span><br><span class="line">		if(flag1==false) break;//!!</span><br><span class="line">			if(a[x[i]+offset][y[i]]==0) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	if(flag1==false) break; </span><br><span class="line">		if(cnt==4)&#123;</span><br><span class="line">			offset++;</span><br><span class="line">			cnt=0;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			for(int k=1;k&lt;=4;k++)&#123;</span><br><span class="line">				a[x[k]+offset-1][y[k]]=1;</span><br><span class="line">				flag1=false;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		for(int i=1;i&lt;=15;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=10;j++)</span><br><span class="line">		cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		 </span><br><span class="line">	&#125;	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>POJ1077 八数码问题(bfs)</title>
    <url>/2018/11/07/%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>八数码问题 ，单向广搜<br>八数码问题：<br>由1,2,3,4,5,6,7,8,x组成一个3*3的矩阵，如<br>1 2 3<br>4 x 5<br>6 7 8<br>其中x可与其上，下，左，右相邻的元素互换，<br>现问从给出状态出发到达以下状态：<br>1 2 3<br>4 5 6<br>7 8 x<br>需要对x进行怎样的位移操作，输出x的最少位移信息，<br>若状态不可达，输出unsolvable</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">int factorial[21];</span><br><span class="line">bitset&lt;362880&gt; flags;</span><br><span class="line">int goal;</span><br><span class="line"></span><br><span class="line">char moves[4]=&#123;&apos;u&apos;,&apos;d&apos;,&apos;l&apos;,&apos;r&apos;&#125;;</span><br><span class="line">struct Node &#123;</span><br><span class="line">int state; //状态 ，即排列的编号</span><br><span class="line">int father; //父节点指针</span><br><span class="line">char move; //父节点到本节点的移动方式 u/d/r/l</span><br><span class="line">Node(int s,int f,char m):state(s), father(f),move(m) &#123; &#125;</span><br><span class="line">Node() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node queue[400000];</span><br><span class="line">int qhead,qtail;</span><br><span class="line">//给排列求其序号 </span><br><span class="line">int  GetPermutationNumByInt(int *a,int len)&#123;</span><br><span class="line">	bool vis[MAX]=&#123;false&#125;;</span><br><span class="line">	int num=0;</span><br><span class="line">	for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">		int n=0;</span><br><span class="line">		for(int j=0;j&lt;a[i];j++)&#123;</span><br><span class="line">			if(!vis[j]) n++;</span><br><span class="line">		&#125;</span><br><span class="line">		num+=n*factorial[len-1-i];</span><br><span class="line">		vis[a[i]]=true;</span><br><span class="line">	&#125; </span><br><span class="line">	return num;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int  GetPermutationNum(T ori,T sta,int len)&#123;</span><br><span class="line">	int tmp[100];</span><br><span class="line">	for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;len;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(sta[i]==ori[j]) tmp[i]=j; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int num= GetPermutationNumByInt(tmp,len);</span><br><span class="line">	return num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">//给定序号求其排列</span><br><span class="line">void GetPermutation(T ori,T sta,int len,int k)&#123;</span><br><span class="line">	int tmp[21];</span><br><span class="line">	bool used[MAX]=&#123;false&#125;;</span><br><span class="line">	for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">		int j;</span><br><span class="line">		for( j=0;j&lt;len;j++)&#123;</span><br><span class="line">			if(used[j]) continue;</span><br><span class="line">			if(factorial[len-1-i]&gt;=k+1) break;</span><br><span class="line">			else k-=factorial[len-1-i];</span><br><span class="line">		&#125;</span><br><span class="line">		tmp[i]=j;</span><br><span class="line">		used[j]=true;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;len;i++)</span><br><span class="line">	*(sta+i)=*(ori+tmp[i]);//!!!</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void IntToStr(int k,char* status)&#123;</span><br><span class="line">	 GetPermutation((char*)&quot;012345678&quot;,status,9,k);</span><br><span class="line">&#125; </span><br><span class="line">int StrToInt(char *str)&#123;</span><br><span class="line">	char s[20]=&quot;012345678&quot;;</span><br><span class="line">	return GetPermutationNum(s,str,9);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int newstate(int state,char move)&#123;</span><br><span class="line">	char tmp[20];</span><br><span class="line">	IntToStr(state,tmp);</span><br><span class="line">	int zeropos=0;</span><br><span class="line">	for(int i=0;i&lt;9;i++)&#123;</span><br><span class="line">		if(tmp[i]==&apos;0&apos;) &#123;//!!!</span><br><span class="line">		zeropos=i;</span><br><span class="line">		break;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	switch(move)&#123;</span><br><span class="line">		case &apos;u&apos;:&#123;</span><br><span class="line">			if(zeropos-3&lt;0) return -1;</span><br><span class="line">			else &#123;</span><br><span class="line">				tmp[zeropos]=tmp[zeropos-3];</span><br><span class="line">				tmp[zeropos-3]=&apos;0&apos;;//!!</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		case &apos;d&apos;:&#123;</span><br><span class="line">			if(zeropos+3&gt;8)  return -1;</span><br><span class="line">			else &#123;</span><br><span class="line">				tmp[zeropos]=tmp[zeropos+3];</span><br><span class="line">				tmp[zeropos+3]=&apos;0&apos;;</span><br><span class="line">				</span><br><span class="line">			&#125;			</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		case &apos;l&apos;:&#123;</span><br><span class="line">			if(zeropos%3==0)  return -1;</span><br><span class="line">			else &#123;</span><br><span class="line">				tmp[zeropos]=tmp[zeropos-1];</span><br><span class="line">				tmp[zeropos-1]=&apos;0&apos;;</span><br><span class="line">			&#125;				</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		case &apos;r&apos;:&#123;</span><br><span class="line">			if(zeropos%3==2)  return -1;</span><br><span class="line">			else &#123;</span><br><span class="line">				tmp[zeropos]=tmp[zeropos+1];</span><br><span class="line">				tmp[zeropos+1]=&apos;0&apos;;</span><br><span class="line">			&#125;				</span><br><span class="line">			break;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return StrToInt(tmp);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">bool bfs(int state,int goal)&#123;</span><br><span class="line"></span><br><span class="line">	flags.reset();</span><br><span class="line">	qhead=0,qtail=1;</span><br><span class="line">	queue[qhead]=Node(state,-1,0);</span><br><span class="line">	flags.set(state,true);</span><br><span class="line">	while(qhead!=qtail)&#123;</span><br><span class="line">			int nstate=queue[qhead].state;</span><br><span class="line">if(nstate==goal) return true;</span><br><span class="line">		for(int j=0;j&lt;4;j++ )&#123;</span><br><span class="line">			char move=moves[j];</span><br><span class="line">		int nnewstate=newstate(nstate,move);</span><br><span class="line"></span><br><span class="line">		if(nnewstate==-1) continue;//如果移动超出界限 不合法 </span><br><span class="line">		if( flags[nnewstate] ) &#123;</span><br><span class="line">		continue;//如果该状态已经被访问过 </span><br><span class="line">		&#125;</span><br><span class="line">	//	queue[qtail++]=Node(nnewstate,nstate,move); </span><br><span class="line">			queue[qtail++]=Node(nnewstate,qhead,move);	</span><br><span class="line">					flags.set(nnewstate,true);		</span><br><span class="line">			</span><br><span class="line">		&#125;	</span><br><span class="line"></span><br><span class="line">		qhead++;</span><br><span class="line">	&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">	</span><br><span class="line">	factorial[0]=factorial[1]=1;</span><br><span class="line">	for(int i=2;i&lt;21;i++)</span><br><span class="line">	factorial[i]=i*factorial[i-1];</span><br><span class="line">	char str[50];</span><br><span class="line">	//freopen(&quot;s.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin.getline(str,50);</span><br><span class="line">	char str2[50]; </span><br><span class="line">	int j=0;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0;str[i]!=0;i++)&#123;</span><br><span class="line">		if(str[i]!=&apos; &apos;)&#123; </span><br><span class="line">		if(str[i]==&apos;x&apos;) str2[j++]=&apos;0&apos;;</span><br><span class="line">		else str2[j++]=str[i];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	str2[i]=&apos;\0&apos;; </span><br><span class="line">	int sumGoal=0;</span><br><span class="line">	int sumOri=0;</span><br><span class="line">for(int i=0;i&lt;8;i++)&#123;</span><br><span class="line">	sumGoal+=i-1;</span><br><span class="line">&#125; </span><br><span class="line">	for(int i=0;i&lt;9;i++)&#123;</span><br><span class="line">		if(str2[i]==0) continue;</span><br><span class="line">		for(int j=0;j&lt;i;j++)</span><br><span class="line">		if(str2[j]&lt;str2[i]&amp;&amp; str2[j] != &apos;0&apos; ) sumOri++;//!!!</span><br><span class="line"> 	&#125; </span><br><span class="line"> 	</span><br><span class="line"> 	if(sumGoal%2!=sumOri%2) &#123;</span><br><span class="line">cout &lt;&lt; &quot;unsolvable&quot; &lt;&lt; endl;</span><br><span class="line"> 		return 0;</span><br><span class="line">	 &#125; </span><br><span class="line">	 char states[50];</span><br><span class="line">	 int k=0;</span><br><span class="line">	 int state=StrToInt(str2);</span><br><span class="line">	 char s1[20]=&quot;123456780&quot;;</span><br><span class="line">	 int goal=StrToInt(s1);</span><br><span class="line">	 if(bfs(state,goal))&#123;</span><br><span class="line">	 //	Node p=queue[qhead];</span><br><span class="line">	 int p=qhead;</span><br><span class="line">	 do&#123; //通过father找到成功的状态序列，输出相应步骤</span><br><span class="line">	 	states[k++]=queue[p].move;</span><br><span class="line">	 	p=queue[p].father;</span><br><span class="line">	 &#125;while(queue[p].father!=-1);</span><br><span class="line">//</span><br><span class="line">//if( bfs(state,goal))&#123;</span><br><span class="line">//int nMoves = 0;</span><br><span class="line">//int nPos = qhead;</span><br><span class="line">//do &#123;</span><br><span class="line">// states[nMoves++] = queue[nPos].move;</span><br><span class="line">//nPos = queue[nPos].father;</span><br><span class="line">//&#125; while( nPos); //nPos = 0 说明已经回退到初始状态了</span><br><span class="line">for( int i = k -1; i &gt;= 0; i -- )</span><br><span class="line">cout &lt;&lt; states[i];&#125;</span><br><span class="line">	  else &#123;</span><br><span class="line"> 		cout&lt;&lt;&quot;unsloved&quot;;</span><br><span class="line"> 		return 0;</span><br><span class="line">	 &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度，就是状态总数</p>
<p>参考《算法基础》课程代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int goalStatus; //目标状态</span><br><span class="line">bitset&lt;362880&gt; Flags; //节点是否扩展的标记</span><br><span class="line">const int MAXS = 400000;</span><br><span class="line">char result[MAXS]; //结果</span><br><span class="line">struct Node &#123;</span><br><span class="line">int status; //状态 ，即排列的编号</span><br><span class="line">int father; //父节点指针</span><br><span class="line">char move; //父节点到本节点的移动方式 u/d/r/l</span><br><span class="line">Node(int s,int f,char m):status(s), father(f),move(m) &#123; &#125;</span><br><span class="line">Node() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node myQueue[MAXS]; //状态队列，状态总数362880</span><br><span class="line">int qHead; int qTail; //队头指针和队尾指针</span><br><span class="line">char sz4Moves[] = &quot;udrl&quot;; //四种动作</span><br><span class="line">unsigned int factorial[21]; //存放0-20的阶乘。21的阶乘unsigned放不下了</span><br><span class="line"></span><br><span class="line">unsigned int GetPermutationNumForInt(int * perInt,int len)</span><br><span class="line">//perInt里放着整数 0 到 len-1 的一个排列，求它是第几个排列</span><br><span class="line">//len不能超过21</span><br><span class="line">&#123;</span><br><span class="line">unsigned int num = 0;</span><br><span class="line">bool used[21];</span><br><span class="line">memset(used,0,sizeof(bool)*len);</span><br><span class="line">for( int i = 0;i &lt; len; ++ i ) &#123;</span><br><span class="line">unsigned int n = 0;</span><br><span class="line">for( int j = 0; j &lt; perInt[i]; ++ j) &#123;</span><br><span class="line">if(! used[j] )</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line">num += n * factorial[len-i-1];</span><br><span class="line">used[perInt[i]] = true;</span><br><span class="line">&#125;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt; class T&gt;</span><br><span class="line">unsigned int GetPermutationNum( T s1, T s2,int len)</span><br><span class="line">//给定排列，求序号 。[s1,s1+len)里面放着第0号排列，[s2,s2+len)是要求序号的排列</span><br><span class="line">//两者必须一样长 ，len不能超过21</span><br><span class="line">//排列的每个元素都不一样。返回排列的编号</span><br><span class="line">&#123;</span><br><span class="line">int perInt[21]; //要转换成 [0,len-1] 的整数的排列</span><br><span class="line">for( int i = 0;i &lt; len; ++i )</span><br><span class="line">for( int j = 0; j &lt; len; ++j ) &#123;</span><br><span class="line">if( * ( s2 + i ) == * (s1+j)) &#123;</span><br><span class="line">perInt[i] = j;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">unsigned int num = GetPermutationNumForInt(perInt,len);</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void GenPermutationByNum(T s1, T s2,int len, unsigned int No)</span><br><span class="line">//根据排列编号，生成排列 len不能超过21</span><br><span class="line">&#123; //[s1,s1+len) 里面放着第0号 permutation,，排列的每个元素都不一样</span><br><span class="line">int perInt[21]; //要转换成 [0,len-1] 的整数的排列</span><br><span class="line">bool used[21];</span><br><span class="line">memset(used,0,sizeof(bool)*len);</span><br><span class="line">for(int i = 0;i &lt; len; ++ i ) &#123;</span><br><span class="line">unsigned int tmp; int n = 0;int j;</span><br><span class="line">for( j = 0; j &lt; len; ++j ) &#123;</span><br><span class="line">if( !used[j] ) &#123;</span><br><span class="line">if( factorial[len - i - 1] &gt;= No+1) break;</span><br><span class="line">else No -= factorial[len - i - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">perInt[i] = j;</span><br><span class="line">used[j] = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for( int i = 0;i &lt; len; ++i )</span><br><span class="line">* ( s2 + i ) = * ( s1 + perInt[i]);</span><br><span class="line">&#125;</span><br><span class="line">int StrStatusToIntStatus( const char * strStatus)</span><br><span class="line">&#123;//字符串形式的状态，转换为整数形式的状态(排列序号） </span><br><span class="line">return GetPermutationNum( &quot;012345678&quot;,strStatus,9);</span><br><span class="line">&#125;</span><br><span class="line">void IntStatusToStrStatus( int n, char * strStatus)</span><br><span class="line">&#123;//整数形式的状态(排列序号），转换为字符串形式的状态</span><br><span class="line">GenPermutationByNum((char*)&quot;012345678&quot;,strStatus,9,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int NewStatus( int nStatus, char cMove) &#123;</span><br><span class="line">//求从nStatus经过 cMove 移动后得到的新状态。若移动不可行则返回-1</span><br><span class="line">char szTmp[20]; int nZeroPos;</span><br><span class="line">IntStatusToStrStatus(nStatus,szTmp);</span><br><span class="line">for( int i = 0;i &lt; 9; ++ i )</span><br><span class="line">if( szTmp[i] == &apos;0&apos; ) &#123;</span><br><span class="line">nZeroPos = i;</span><br><span class="line">break;</span><br><span class="line">&#125; //返回空格的位置</span><br><span class="line">switch( cMove) &#123;</span><br><span class="line">case &apos;u&apos;: if( nZeroPos - 3 &lt; 0 ) return -1; //空格在第一行</span><br><span class="line">else &#123;  szTmp[nZeroPos] = szTmp[nZeroPos - 3];</span><br><span class="line">szTmp[nZeroPos - 3] = &apos;0&apos;; &#125;</span><br><span class="line">break;</span><br><span class="line">case &apos;d&apos;: if( nZeroPos + 3 &gt; 8 ) return -1; //空格在第三行</span><br><span class="line">else &#123; szTmp[nZeroPos] = szTmp[nZeroPos + 3];</span><br><span class="line">szTmp[nZeroPos + 3] = &apos;0&apos;; &#125;</span><br><span class="line">break;</span><br><span class="line">case &apos;l&apos;: if( nZeroPos % 3 == 0) return -1; //空格在第一列</span><br><span class="line">else &#123;  szTmp[nZeroPos] = szTmp[nZeroPos -1];</span><br><span class="line">szTmp[nZeroPos -1 ] = &apos;0&apos;; &#125;</span><br><span class="line">break;</span><br><span class="line">case &apos;r&apos;: if( nZeroPos % 3 == 2) return -1; //空格在第三列</span><br><span class="line">else &#123;  szTmp[nZeroPos] = szTmp[nZeroPos + 1];</span><br><span class="line">szTmp[nZeroPos + 1 ] = &apos;0&apos;;  &#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return StrStatusToIntStatus(szTmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Bfs(int nStatus) &#123; //寻找从初始状态nStatus到目标的路径</span><br><span class="line">int nNewStatus; Flags.reset(); //清除所有扩展标记</span><br><span class="line">qHead = 0;  qTail = 1;</span><br><span class="line">myQueue[qHead] = Node(nStatus,-1,0);</span><br><span class="line">while ( qHead != qTail) &#123; //队列不为空</span><br><span class="line">nStatus = myQueue[qHead].status;</span><br><span class="line">if( nStatus == goalStatus ) //找到目标状态</span><br><span class="line">return true;</span><br><span class="line">for( int i = 0;i &lt; 4;i ++ ) &#123; //尝试4种移动</span><br><span class="line">nNewStatus = NewStatus(nStatus,sz4Moves[i]); </span><br><span class="line">if( nNewStatus == -1 ) continue; //不可移，试下一种</span><br><span class="line">if( Flags[nNewStatus] ) continue; //扩展标记已经存在，则不入队</span><br><span class="line">Flags.set(nNewStatus,true); //设上已扩展标记</span><br><span class="line">myQueue[qTail++] =</span><br><span class="line">Node(nNewStatus,qHead,sz4Moves[i]); //新节点入队列</span><br><span class="line">&#125;</span><br><span class="line">qHead ++;</span><br><span class="line">&#125;</span><br><span class="line">return false; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">factorial[0] = factorial[1] =1; </span><br><span class="line">for(int i = 2;i &lt; 21; ++i )</span><br><span class="line">factorial[i] = i * factorial[i-1];</span><br><span class="line">goalStatus = StrStatusToIntStatus(&quot;123456780&quot;);</span><br><span class="line">char szLine[50]; char szLine2[20];</span><br><span class="line">freopen(&quot;s.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">while( cin.getline(szLine,48)) &#123;</span><br><span class="line">int i,j;</span><br><span class="line">//将输入的原始字符串变为数字字符串</span><br><span class="line">for( i = 0, j = 0; szLine[i]; i ++ ) &#123;</span><br><span class="line">if( szLine[i] != &apos; &apos; ) &#123;</span><br><span class="line">if( szLine[i] == &apos;x&apos; ) szLine2[j++] = &apos;0&apos;;</span><br><span class="line">else szLine2[j++] = szLine[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">szLine2[j] = 0; //字符串形式的初始状态</span><br><span class="line">int sumGoal = 0; //从此往后用奇偶性判断是否有解</span><br><span class="line">for( int i = 0;i &lt; 8; ++i )</span><br><span class="line">sumGoal += i -1;</span><br><span class="line">cout&lt;&lt;sumGoal&lt;&lt;endl;</span><br><span class="line">int sumOri = 0;</span><br><span class="line">for( int i = 0;i &lt; 9 ; ++i ) &#123;</span><br><span class="line">if( szLine2[i] == &apos;0&apos;)</span><br><span class="line">continue;</span><br><span class="line">for( int j = 0; j &lt; i; ++j ) &#123;</span><br><span class="line">if( szLine2[j] &lt; szLine2[i] &amp;&amp; szLine2[j] != &apos;0&apos; )</span><br><span class="line">sumOri ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if( sumOri %2 != sumGoal %2 ) &#123;</span><br><span class="line">cout &lt;&lt; &quot;unsolvable&quot; &lt;&lt; endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">//上面用奇偶性判断是否有解</span><br><span class="line">if( Bfs(StrStatusToIntStatus(szLine2))) &#123;</span><br><span class="line">int nMoves = 0;</span><br><span class="line">int nPos = qHead;</span><br><span class="line">do &#123; //通过father找到成功的状态序列，输出相应步骤</span><br><span class="line">result[nMoves++] = myQueue[nPos].move;</span><br><span class="line">nPos = myQueue[nPos].father;</span><br><span class="line">&#125; while( nPos); //nPos = 0 说明已经回退到初始状态了</span><br><span class="line">for( int i = nMoves -1; i &gt;= 0; i -- )</span><br><span class="line">cout &lt;&lt; result[i];</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;unsolvable&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>201709-2 公共钥匙盒</title>
    <url>/2018/11/28/%E5%85%AC%E5%85%B1/</url>
    <content><![CDATA[<p>有一个学校的老师共用N个教室，按照规定，所有的钥匙都必须放在公共钥匙盒里，老师不能带钥匙回家。每次老师上课前，都从公共钥匙盒里找到自己上课的教室的钥匙去开门，上完课后，再将钥匙放回到钥匙盒中。<br> 　　钥匙盒一共有N个挂钩，从左到右排成一排，用来挂N个教室的钥匙。一串钥匙没有固定的悬挂位置，但钥匙上有标识，所以老师们不会弄混钥匙。<br> 　　每次取钥匙的时候，老师们都会找到自己所需要的钥匙将其取走，而不会移动其他钥匙。每次还钥匙的时候，还钥匙的老师会找到最左边的空的挂钩，将钥匙挂在这个挂钩上。如果有多位老师还钥匙，则他们按钥匙编号从小到大的顺序还。如果同一时刻既有老师还钥匙又有老师取钥匙，则老师们会先将钥匙全还回去再取出。<br> 　　今天开始的时候钥匙是按编号从小到大的顺序放在钥匙盒里的。有K位老师要上课，给出每位老师所需要的钥匙、开始上课的时间和上课的时长，假设下课时间就是还钥匙时间，请问最终钥匙盒里面钥匙的顺序是怎样的？<br><a id="more"></a><br>输入格式</p>
<p>　　输入的第一行包含两个整数N, K。<br> 　　接下来K行，每行三个整数w, s, c，分别表示一位老师要使用的钥匙编号、开始上课的时间和上课的时长。可能有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。<br> 　　保证输入数据满足输入格式，你不用检查数据合法性。</p>
<p>输出格式</p>
<p>　　输出一行，包含N个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。</p>
<p>样例输入</p>
<p>5 2</p>
<p>4 3 3</p>
<p>2 2 7</p>
<p>样例输出</p>
<p>1 4 3 2 5</p>
<p>样例说明</p>
<p>　　第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使用钥匙，使用7单位时间，所以在时刻9还钥匙。</p>
<p>每个关键时刻后的钥匙状态如下（X表示空）：</p>
<p>时刻2后为1X345；</p>
<p>时刻3后为1X3X5；</p>
<p>时刻6后为143X5；</p>
<p>时刻9后为14325。</p>
<p>样例输入</p>
<p>5 7</p>
<p>1 1 14</p>
<p>3 3 12</p>
<p>1 15 12</p>
<p>2 7 20</p>
<p>3 18 12</p>
<p>4 21 19</p>
<p>5 30 9</p>
<p>样例输出</p>
<p>1 2 3 5 4</p>
<p>评测用例规模与约定</p>
<p>对于30%的评测用例，1 ≤ N, K ≤ 10, 1 ≤ w ≤ N, 1 ≤ s, c ≤ 30；</p>
<p>对于60%的评测用例，1 ≤ N, K ≤ 50，1 ≤ w ≤ N，1 ≤ s ≤ 300，1 ≤ c ≤ 50；</p>
<p>对于所有评测用例，1 ≤ N, K ≤ 1000，1 ≤ w ≤ N，1 ≤ s ≤ 10000，1 ≤ c ≤ 100。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">int cls[1000+10];</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int num;</span><br><span class="line">	int time;</span><br><span class="line">	char op;</span><br><span class="line">	node(int nn,int tt,char oo):num(nn),time(tt),op(oo)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	bool operator &lt; (node p)const&#123;</span><br><span class="line">		if(time!=p.time) return time&gt;p.time;</span><br><span class="line">		else if(op!=p.op) return op&lt;p.op;</span><br><span class="line">		else return num&gt;p.num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int N,K,w,s,c;</span><br><span class="line">	priority_queue&lt;node&gt; pq; </span><br><span class="line">	cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">	for(int i=0;i&lt;K;i++)&#123;</span><br><span class="line">		cin&gt;&gt;w&gt;&gt;s&gt;&gt;c;</span><br><span class="line">		pq.push(node(w,s,&apos;G&apos;));</span><br><span class="line">		pq.push(node(w,s+c,&apos;R&apos;));</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=N;i++)</span><br><span class="line">	cls[i]=i;</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line"></span><br><span class="line">		node t=pq.top();</span><br><span class="line">		//	cout&lt;&lt;t.num&lt;&lt;&quot; &quot;&lt;&lt;t.time&lt;&lt;&quot; &quot;&lt;&lt;t.op&lt;&lt;endl;</span><br><span class="line">		pq.pop();</span><br><span class="line">		if(t.op==&apos;G&apos;) &#123;</span><br><span class="line">				for(int k=1;k&lt;=N;k++)&#123;</span><br><span class="line">					if(cls[k]==t.num)cls[k]=0;//!!!</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			for(int j=1;j&lt;=N;j++)&#123;</span><br><span class="line">				if(cls[j]==0)</span><br><span class="line">				&#123;</span><br><span class="line">					cls[j]=t.num;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">		for(int i=1;i&lt;=N;i++)</span><br><span class="line">	cout&lt;&lt;cls[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>关于图像通道的理解</title>
    <url>/2018/09/24/%E5%85%B3%E4%BA%8Eopencv%E7%9A%84%E9%80%9A%E9%81%93/</url>
    <content><![CDATA[<p>tips1:  一个图像的通道数是N，就表明每个像素点处有N个数，一个a×b的N通道图像，其图像矩阵实际上是b行N×a列的数字矩阵。<br><a id="more"></a><br>OpenCV中图像的通道可以是1、2、3和4。其中常见的是1通道和3通道，2通道和4通道不常见。</p>
<pre><code>1通道的是灰度图。

3通道的是彩色图像，比如RGB图像。

4通道的图像是RGBA，是RGB加上一个A通道，也叫alpha通道，表示透明度。PNG图像是一种典型的4通道图像。alpha通道可以赋值0到1，或者0到255，表示透明到不透明。

2通道的图像是RGB555和RGB565。2通道图在程序处理中会用到，如傅里叶变换，可能会用到，一个通道为实数，一个通道为虚数，主要是编程方便。RGB555是16位的，2个字节，5+6+5，第一字节的前5位是R，后三位+第二字节是G，第二字节后5位是B，可见对原图像进行压缩了。
</code></pre><p>tips2: OpenCV中用imshow( )来显示图像，只要Mat的数据矩阵符合图像的要求，就可以用imshow来显示。二通道好像不可以。。。超过了4通道，就不是图像了，imshow( )也显示不了。</p>
<p>tips3: imshow( )显示单通道图像时一定是灰度图，如果我们想显示红色的R分量，还是应该按三通道图像显示，只不过G和B通道要赋值成0或255.</p>
<p>tips4: 通道分解用split( )，通道合成用merge( )，这俩函数都是mixchannel( )的特例。</p>
<p>参考链接<br><a href="http://lib.csdn.net/article/opencv/33264" target="_blank" rel="noopener">http://lib.csdn.net/article/opencv/33264</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>关于递归</title>
    <url>/2018/05/18/%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="递归调用栈溢出"><a href="#递归调用栈溢出" class="headerlink" title="递归调用栈溢出"></a>递归调用栈溢出</h2><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：</p>
<p>fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n<br><a id="more"></a><br>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。</p>
<p>于是，fact(n)用递归的方式写出来就是：</p>
<p>def fact(n):<br>    if n==1:<br>        return 1<br>    return n * fact(n - 1)<br>上面就是一个递归函数。可以试试：</p>
<blockquote>
<blockquote>
<blockquote>
<p>fact(1)<br>1<br>fact(5)<br>120<br>fact(100)<br>93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000<br>如果我们计算fact(5)，可以根据函数定义看到计算过程如下：</p>
</blockquote>
</blockquote>
</blockquote>
<p>===&gt; fact(5)<br>===&gt; 5 <em> fact(4)<br>===&gt; 5 </em> (4 <em> fact(3))<br>===&gt; 5 </em> (4 <em> (3 </em> fact(2)))<br>===&gt; 5 <em> (4 </em> (3 <em> (2 </em> fact(1))))<br>===&gt; 5 <em> (4 </em> (3 <em> (2 </em> 1)))<br>===&gt; 5 <em> (4 </em> (3 <em> 2))<br>===&gt; 5 </em> (4 <em> 6)<br>===&gt; 5 </em> 24<br>===&gt; 120<br>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：</p>
<blockquote>
<blockquote>
<blockquote>
<p>fact(1000)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>  File “<stdin>“, line 4, in fact<br>  …<br>  File “<stdin>“, line 4, in fact<br>RuntimeError: maximum recursion depth exceeded in comparison<br>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</stdin></stdin></module></stdin></p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h2><p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
<p>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<p>def fact(n):<br>    return fact_iter(n, 1)</p>
<p>def fact_iter(num, product):<br>    if num == 1:<br>        return product<br>    return fact_iter(num - 1, num <em> product)<br>可以看到，return fact_iter(num - 1, num </em> product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。</p>
<p>fact(5)对应的fact_iter(5, 1)的调用如下：</p>
<p>===&gt; fact_iter(5, 1)</p>
<p>===&gt; fact_iter(4, 5)</p>
<p>===&gt; fact_iter(3, 20)</p>
<p>===&gt; fact_iter(2, 60)</p>
<p>===&gt; fact_iter(1, 120)</p>
<p>===&gt; 120<br>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p>
<p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p>
<p>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>
<p>参考自廖雪峰的官方教程<br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756044276a15558a759ec43de8e30eb0ed169fb11000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756044276a15558a759ec43de8e30eb0ed169fb11000</a></p>
]]></content>
      <categories>
        <category>python语法</category>
      </categories>
  </entry>
  <entry>
    <title>决策树学习笔记</title>
    <url>/2018/09/07/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>csv文件<br>构建决策树并进行预测</p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fv3i96tj2tj30fb08dwgr.jpg" alt></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from sklearn.feature_extraction import DictVectorizer</span><br><span class="line">import csv</span><br><span class="line">from sklearn import preprocessing</span><br><span class="line">from sklearn import tree</span><br><span class="line"># from sklearn.externals.six import StringIO</span><br><span class="line"> </span><br><span class="line">allElectronicsDate = open(r&apos;E:\Python\practice\Decision_Tree\Class_buys_computer.csv&apos;,&apos;rt&apos;)</span><br><span class="line">reader = csv.reader(allElectronicsDate)#CSV模块自带的reader方法，可按行读取内容</span><br><span class="line"># print(&apos;reader:&apos;+ str(reader))</span><br><span class="line">headers = next(reader)</span><br><span class="line"> </span><br><span class="line">print(headers)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">featureList = []</span><br><span class="line">labelList = []</span><br><span class="line"> </span><br><span class="line">for row in reader:</span><br><span class="line">    print(row)</span><br><span class="line">    labelList.append(row[len(row)-1])</span><br><span class="line">    rowDict = &#123;&#125;</span><br><span class="line">    for i in range(1,len(row)-1):</span><br><span class="line">        rowDict[headers[i]]=row[i]</span><br><span class="line">    featureList.append(rowDict)</span><br><span class="line">print(featureList)</span><br><span class="line">print(labelList)</span><br><span class="line"> </span><br><span class="line">vec = DictVectorizer()#python自带模块</span><br><span class="line">dummyX = vec.fit_transform(featureList).toarray()</span><br><span class="line">#调用方法fit_transform将字典类型的[&#123;&apos;a&apos;:&apos;b&apos;&#125;,&#123;&apos;c&apos;:&apos;d&apos;&#125;]数据中的&apos;b&apos;,&apos;d&apos;数据转换成0,1的矩阵形式</span><br><span class="line"> </span><br><span class="line">print(&quot;dummyX:&quot;+str(dummyX))</span><br><span class="line">print(vec.get_feature_names())#调用此方法得到&apos;b&apos;,&apos;d&apos;对应的特征名</span><br><span class="line"> </span><br><span class="line">print(&quot;labellist:&quot;+str(labelList))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">lb = preprocessing.LabelBinarizer()#python内部模块</span><br><span class="line">dummyY = lb.fit_transform(labelList)</span><br><span class="line">#调用fit_transform方法将标签列表中的数据转成0,1格式</span><br><span class="line">print(&quot;dummyY:&quot;+str(dummyY))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">clf = tree.DecisionTreeClassifier(criterion=&apos;entropy&apos;)</span><br><span class="line">#tree模块，创建clf分类器，entropy表示度量标准信息熵</span><br><span class="line">clf = clf.fit(dummyX,dummyY)</span><br><span class="line"># 用训练数据dummyX，dummyY拟合分类器模型</span><br><span class="line">print(&quot;clf:&quot;+str(clf))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">with open(&quot;allElectronicInformationGainOri.dot&quot;,&apos;w&apos;) as f:</span><br><span class="line">    f = tree.export_graphviz(clf,feature_names=vec.get_feature_names(),out_file = f)</span><br><span class="line">    #通过export_graphviz模块导出dot文件中,后通过cmd命令dot -Tpdf  1.dot -o 1.pdf</span><br><span class="line">    #将dot文件转化成pdf视图</span><br><span class="line"></span><br><span class="line">oneRowX = dummyX[0,:]#取X矩阵数组里面的第一行</span><br><span class="line">print(&quot;oneRowX:&quot; + str(oneRowX))</span><br><span class="line"> </span><br><span class="line">newRowX = oneRowX#赋给新标签</span><br><span class="line"> </span><br><span class="line">newRowX[0] = 1</span><br><span class="line">newRowX[2] = 0</span><br><span class="line">print(&quot;newRowX:&quot; + str(newRowX))</span><br><span class="line">#newRowX:[ 1.  0.  0.  0.  1.  1.  0.  0.  1.  0.]</span><br><span class="line"> </span><br><span class="line">newRowX = newRowX.reshape(1,-1)</span><br><span class="line">#将列表转化为矩阵，共predict调用</span><br><span class="line">print(&quot;newRowX:&quot; + str(newRowX))</span><br><span class="line">#newRowX:[[ 1.  0.  0.  0.  1.  1.  0.  0.  1.  0.]]</span><br><span class="line"> </span><br><span class="line">predictedY = clf.predict(newRowX)</span><br><span class="line">#用之前创建好的分类器clf（classifier），newRowX必须是矩阵类型</span><br></pre></td></tr></table></figure>
<p>输出的dot文件可以使用graphvize软件转为PDF<br><img src="https://upload-images.jianshu.io/upload_images/7174849-f677661e148f2e9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/854/format/webp" alt></p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
  </entry>
  <entry>
    <title>2013-12-1 出现次数最多的数</title>
    <url>/2018/11/10/%E5%88%86%E5%86%B6%E6%B3%95/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>map stl<br>使用参考</p>
<p><a href="http://mropengate.blogspot.com/2015/12/cc-map-stl.html" target="_blank" rel="noopener">http://mropengate.blogspot.com/2015/12/cc-map-stl.html</a></p>
<p><a href="https://blog.csdn.net/shuzfan/article/details/53115922#21-%E4%BD%BF%E7%94%A8-%E8%BF%9B%E8%A1%8C%E5%8D%95%E4%B8%AA%E6%8F%92%E5%85%A5" target="_blank" rel="noopener">https://blog.csdn.net/shuzfan/article/details/53115922#21-%E4%BD%BF%E7%94%A8-%E8%BF%9B%E8%A1%8C%E5%8D%95%E4%B8%AA%E6%8F%92%E5%85%A5</a><br><a id="more"></a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">int a[10000];</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	map&lt;int,int&gt; m;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	if(!m.count(a[i])) m[a[i]]=1;</span><br><span class="line">	else m[a[i]]++;</span><br><span class="line">	&#125; </span><br><span class="line">	int k=0;</span><br><span class="line">	int ans;</span><br><span class="line">	for(map&lt;int,int&gt;::iterator t=m.begin();t!=m.end();t++ )&#123;</span><br><span class="line">		if(t-&gt;second&gt;k)&#123;</span><br><span class="line">			ans=t-&gt;first;</span><br><span class="line">			k=t-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(t-&gt;second==k)&#123;</span><br><span class="line">			if(t-&gt;first&lt;ans) ans=t-&gt;first;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf</category>
      </categories>
  </entry>
  <entry>
    <title>L1-删除排序数组中的重复数字 II</title>
    <url>/2018/05/30/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97-II/</url>
    <content><![CDATA[<p>跟进“删除重复数字”：</p>
<p>如果可以允许出现两次重复将如何处理？<br><a id="more"></a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    @param: nums: An ineger array</span><br><span class="line">    @return: An integer</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    #def removeDuplicates(self, nums):</span><br><span class="line">        # write your code here</span><br><span class="line">    def removeDuplicates(self,A):</span><br><span class="line">    	i = 1</span><br><span class="line">    	j = 0</span><br><span class="line">    	count = 1</span><br><span class="line">    	while(i &lt;len(A)):</span><br><span class="line">    		if A[i] == A[j] and count == 2:</span><br><span class="line">    			A.pop(i)</span><br><span class="line">    		elif A[i] == A[j]:</span><br><span class="line">    			count+=1</span><br><span class="line">    			j+=1</span><br><span class="line">    			i+=1  //注意i+=1不能放在最外面</span><br><span class="line">    		else:</span><br><span class="line">    			count = 1</span><br><span class="line">    			j+=1</span><br><span class="line">    			i+=1</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:  </span><br><span class="line">    &quot;&quot;&quot; </span><br><span class="line">    @param A: a list of integers </span><br><span class="line">    @return an integer </span><br><span class="line">    &quot;&quot;&quot;  </span><br><span class="line">    def removeDuplicates(self, A):  </span><br><span class="line">        if len(A) &lt;= 1:  </span><br><span class="line">            return len(A)  </span><br><span class="line">        temp = A[0]  </span><br><span class="line">        count, index = 1, 1  </span><br><span class="line">        while index != len(A):  </span><br><span class="line">            if A[index] == temp and count == 2:  </span><br><span class="line">                A.pop(index)  </span><br><span class="line">            elif A[index] == temp:  </span><br><span class="line">                count += 1  </span><br><span class="line">                index += 1  </span><br><span class="line">            else:  </span><br><span class="line">                temp = A[index]  </span><br><span class="line">                count = 1  </span><br><span class="line">                index += 1  </span><br><span class="line">        return index + 1  </span><br><span class="line">        # write your code here</span><br></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>同上题，快慢指针的思想，用i来遍历数组，j来检查重复元素<br>如果相同且count已经为2，则移出遍历的该元素<br>如果相同出现一次，count++,快慢指针同时后移<br>如果不同，则count置1，快慢指针同时后移</p>
]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
  </entry>
  <entry>
    <title>蓝桥杯  分糖果</title>
    <url>/2018/12/21/%E5%88%86%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<p>问题描述</p>
<p>有n个小朋友围坐成一圈。老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：<br><a id="more"></a><br>每个小朋友都把自己的糖果分一半给左手边的孩子。<br>　　一轮分糖后，拥有奇数颗糖的孩子由老师补给1个糖果，从而变成偶数。<br>　　反复进行这个游戏，直到所有小朋友的糖果数都相同为止。<br>　　你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果。</p>
<p>输入格式</p>
<p>程序首先读入一个整数N(2&lt;N&lt;100)，表示小朋友的人数。</p>
<p>接着是一行用空格分开的N个偶数（每个偶数不大于1000，不小于2）</p>
<p>输出格式</p>
<p>要求程序输出一个整数，表示老师需要补发的糖果数。</p>
<p>样例输入</p>
<p>3</p>
<p>2 2 4</p>
<p>样例输出<br>4</p>
<p>//是被右边人给的糖果之前 自己拥有的糖果给左边的人 再加上被右边人给的糖果</p>
<p><strong>同时给左边的人糖果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 1000+2 </span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	int a[MAX];</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line">	int cnt=0;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">			int flag=1;</span><br><span class="line">			int tp=a[0];</span><br><span class="line">		for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">			if(a[i]!=tp) &#123;</span><br><span class="line">				flag=0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag==1) &#123;</span><br><span class="line">				cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		int tmp=a[n-1]/2;</span><br><span class="line">		int t;</span><br><span class="line">		for(int i=0;i&lt;=n-1;i++)&#123;</span><br><span class="line">	 t=a[i]/2;</span><br><span class="line">		a[i]=t+tmp;</span><br><span class="line">			tmp=t;</span><br><span class="line">	&#125;</span><br><span class="line">			for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(a[i]%2) &#123;</span><br><span class="line">			a[i]+=1;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 1000+2 </span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	int a[MAX];</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line">	int cnt=0;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">			int flag=1;</span><br><span class="line">		int tmp=a[0];</span><br><span class="line">		for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">			if(a[i]!=tmp) &#123;</span><br><span class="line">				flag=0;</span><br><span class="line">				//break;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag==1) &#123;</span><br><span class="line">				cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int i=0;i&lt;=n-1;i++)&#123;</span><br><span class="line">		a[(i-1+n)%n]+=a[i]/2;</span><br><span class="line">		a[i]-=a[i]/2;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">			for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(a[i]%2) &#123;</span><br><span class="line">			a[i]+=1;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考博客</p>
<p><a href="https://blog.csdn.net/qq_34845121/article/details/67655064" target="_blank" rel="noopener">https://blog.csdn.net/qq_34845121/article/details/67655064</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
  </entry>
  <entry>
    <title>前向星链式存储</title>
    <url>/2019/03/13/%E5%89%8D%E5%90%91%E6%98%9F/</url>
    <content><![CDATA[<p>类似于邻接表<br>有一个数组head,它是用来表示以i为起点的索引的第一条边存储的位置,实际上你会发现这里的第一条边存储的位置其实在以i为起点的所有边的最后输入的那个编号.如果按照索引顺序，next表示下一条边的存储位置，如果按照添加顺序，next即为上一条添加的边的位置。所以我们可以得到，输入顺序和存图顺序或者说是遍历顺序是相反的。还是上面的图，我们定义全局变量int cnt=0;并将head初始化为-1；<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX 1000</span><br><span class="line">using namespace std;</span><br><span class="line">int cnt=0;</span><br><span class="line">int head[MAX];//head[i] 表示以 i为起点的第一条边 </span><br><span class="line">struct edge&#123;</span><br><span class="line">	int to;</span><br><span class="line">	int next;</span><br><span class="line">	edge(int tt,int nn):to(tt),next(nn)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	edge()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line">edge e[MAX];</span><br><span class="line">void addEdge(int u,int v)&#123;</span><br><span class="line">	e[cnt].to=v;</span><br><span class="line">	e[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt++;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	//n条边 </span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	memset(head,-1,sizeof(head));</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		int a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		addEdge(a,b);</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;&quot;遍历图的各个顶点&quot;&lt;&lt;endl; </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=head[i];j!=-1;j=e[j].next)&#123;</span><br><span class="line">			cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;e[j].to&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/006wtREyly1g120zoz61wj30cr08ut98.jpg" alt="img"></p>
<p>参考链接</p>
<p><a href="https://www.jianshu.com/p/107a645797a6" target="_blank" rel="noopener">https://www.jianshu.com/p/107a645797a6</a></p>
<p><a href="https://blog.csdn.net/AC_Gibson/article/details/42612817" target="_blank" rel="noopener">https://blog.csdn.net/AC_Gibson/article/details/42612817</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>历届试题 剪格子</title>
    <url>/2019/03/13/%E5%8E%86%E5%B1%8A%E8%AF%95%E9%A2%98-%E5%89%AA%E6%A0%BC%E5%AD%90/</url>
    <content><![CDATA[<p>问题描述<br>如下图所示，3 x 3 的格子中填写了一些整数。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--*--+--+</span><br><span class="line">|10* 1|52|</span><br><span class="line">+--****--+</span><br><span class="line">|20|30* 1|</span><br><span class="line">*******--+</span><br><span class="line">| 1| 2| 3|</span><br><span class="line">+--+--+--+</span><br></pre></td></tr></table></figure></p>
<p>我们沿着图中的星号线剪开，得到两个部分，每个部分的数字和都是60。</p>
<p>本题的要求就是请你编程判定：对给定的m x n 的格子中的整数，是否可以分割为两个部分，使得这两个区域的数字和相等。</p>
<p>如果存在多种解答，请输出包含左上角格子的那个区域包含的格子的最小数目。</p>
<p>如果无法分割，则输出 0。</p>
<p>输入格式<br>程序先读入两个整数 m n 用空格分割 (m,n&lt;10)。</p>
<p>表示表格的宽度和高度。</p>
<p>接下来是n行，每行m个正整数，用空格分开。每个整数不大于10000。</p>
<p>输出格式<br>输出一个整数，表示在所有解中，包含左上角的分割区可能包含的最小的格子数目。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入1</span><br><span class="line">3 3</span><br><span class="line">10 1 52</span><br><span class="line">20 30 1</span><br><span class="line">1 2 3</span><br><span class="line">样例输出1</span><br><span class="line">3</span><br><span class="line">样例输入2</span><br><span class="line">4 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 30 80 2</span><br><span class="line">1 1 1 100</span><br><span class="line">样例输出2</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define MAX 11</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[MAX][MAX],arr[MAX][MAX];</span><br><span class="line">int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int ans;</span><br><span class="line">int m,n,numm;</span><br><span class="line">int minn=0x3f3f3f3f;</span><br><span class="line">void dfs(int x,int y,int num,int sum)&#123;</span><br><span class="line">	if(sum==ans)&#123;</span><br><span class="line">		if(num&lt;minn)&#123;</span><br><span class="line">			minn=num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int newx=x+dir[i][0];</span><br><span class="line">		int newy=y+dir[i][1];</span><br><span class="line">		if(!vis[newx][newy]&amp;&amp;newx&gt;=0&amp;&amp;newx&lt;n&amp;&amp;newy&gt;=0&amp;&amp;newy&lt;m)&#123;</span><br><span class="line">			vis[newx][newy]=true;</span><br><span class="line">			dfs(newx,newy,num+1,sum+arr[newx][newy]);</span><br><span class="line">			vis[newx][newy]=false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	int t=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">			cin&gt;&gt;arr[i][j];</span><br><span class="line">			t+=arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=t/2;</span><br><span class="line">	int sum=arr[0][0];</span><br><span class="line">	vis[0][0]=true;</span><br><span class="line">	dfs(0,0,1,sum);</span><br><span class="line">	cout&lt;&lt;minn&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>历届试题 翻硬币</title>
    <url>/2019/03/12/%E5%8E%86%E5%B1%8A%E8%AF%95%E9%A2%98-%E7%BF%BB%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<p>问题描述<br>小明正在玩一个“翻硬币”的游戏。<br><a id="more"></a><br>桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。</p>
<p>比如，可能情形是：<strong>oo*</strong>oooo</p>
<p>如果同时翻转左边的两个硬币，则变为：oooo***oooo</p>
<p>现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？</p>
<p>我们约定：把翻动相邻的两个硬币叫做一步操作，那么要求：</p>
<p>输入格式<br>两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度&lt;1000</p>
<p>输出格式<br>一个整数，表示最小操作步数。</p>
<p>简单的贪心 两个字符串比较，如果发现不同，将当前和之后的翻到另一面，再继续寻找<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入1</span><br><span class="line">**********</span><br><span class="line">o****o****</span><br><span class="line">样例输出1</span><br><span class="line">5</span><br><span class="line">样例输入2</span><br><span class="line">*o**o***o***</span><br><span class="line">*o***o**o***</span><br><span class="line">样例输出2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">	string s1,s2;</span><br><span class="line">void fan(int i)&#123;</span><br><span class="line">	if(s2[i]==&apos;o&apos;) s2[i]=&apos;*&apos;;</span><br><span class="line">	else if(s2[i]==&apos;*&apos;) s2[i]=&apos;o&apos; ;</span><br><span class="line">	if(s2[i+1]==&apos;o&apos;) s2[i+1]=&apos;*&apos;;</span><br><span class="line">	else if(s2[i+1]==&apos;*&apos;) s2[i+1]=&apos;o&apos; ;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int sum=0;</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	int n=s1.length();</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">		if(s1[i]!=s2[i])&#123;</span><br><span class="line">			++sum;</span><br><span class="line">			fan(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>历届试题 连号区间数</title>
    <url>/2018/12/22/%E5%8E%86%E5%B1%8A%E8%AF%95%E9%A2%98-%E8%BF%9E%E5%8F%B7%E5%8C%BA%E9%97%B4%E6%95%B0/</url>
    <content><![CDATA[<p>问题描述<br>小明这些天一直在思考这样一个奇怪而有趣的问题：<br><a id="more"></a><br>在1~N的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是：</p>
<p>如果区间(L,R)里的所有元素（即此排列的第L个到第R个元素）递增排序后能得到一个长度为R-L+1的“连续”数列，则称这个区间连号区间。</p>
<p>当N很小的时候，小明可以很快地算出答案，但是当N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。</p>
<p>输入格式<br>第一行是一个正整数N (1 &lt;= N &lt;= 50000), 表示全排列的规模。</p>
<p>第二行是N个不同的数字Pi(1 &lt;= Pi &lt;= N)， 表示这N个数字的某一全排列。</p>
<p>输出格式</p>
<p>输出一个整数，表示不同连号区间的数目。</p>
<p>样例输入1</p>
<p>4</p>
<p>3 2 4 1</p>
<p>样例输出1</p>
<p>7</p>
<p>样例输入2</p>
<p>5</p>
<p>3 4 2 5 1</p>
<p>样例输出2</p>
<p>9</p>
<p>枚举区间起点 终点<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//逻辑 R-L+1=max-min+1 </span><br><span class="line">#define MAX 50000</span><br><span class="line">int n;</span><br><span class="line">int a[MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line">	int num=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			int maxn=a[i];</span><br><span class="line">			int minn=a[i];</span><br><span class="line">		for(int j=i;j&lt;n;j++)&#123;</span><br><span class="line">		</span><br><span class="line">			if(maxn&lt;a[j]) maxn=a[j];</span><br><span class="line">			if(minn&gt;a[j]) minn=a[j];</span><br><span class="line">		//	cout&lt;&lt;maxn&lt;&lt;&quot; &quot;&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">			if(maxn-minn+1==j-i+1) ++num;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考博客<br><a href="https://blog.csdn.net/qsyzb/article/details/19119301" target="_blank" rel="noopener">https://blog.csdn.net/qsyzb/article/details/19119301</a><br><a href="https://blog.csdn.net/jopus/article/details/19206885" target="_blank" rel="noopener">https://blog.csdn.net/jopus/article/details/19206885</a></p>
]]></content>
  </entry>
  <entry>
    <title>周总结(13)</title>
    <url>/2018/10/12/%E5%91%A8%E6%80%BB%E7%BB%93-13/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>前几天信誓旦旦说要把高数复习完</p>
<p>结果国庆一直想着出去玩 </p>
<p>于是高数下还没复习完</p>
<p>是该收收心了<br><a id="more"></a></p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li><p>三点一线的生活有点单调 于是有几天一直想呆在宿舍 不想出门 </p>
</li>
<li><p>数了一下这学期坚持了7天晨跑 突然发现改变一下自己原有的生活状态还是很有必要的 没课的时候真的是很懒散的…  </p>
</li>
<li><p>最近看了看复旦 突然也有点想考复旦 上海是个魔都 但也许这样能收获更好的自己 但也很想去东南大学 说不准呢 也许哪一天会做个冲动的决定</p>
</li>
<li><p>最近突然想打打代码 打算考完高数竞赛 继续做表情识别的项目 刷刷专业课  尤其是数据结构</p>
</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>带着看做网页的书 用spring框架写一个网站</li>
<li>等考完高数竞赛 打算开始刷算法</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(10)</title>
    <url>/2018/09/16/%E5%91%A8%E6%80%BB%E7%BB%93-10/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li><p>高数看完了1,2章</p>
</li>
<li><p>继续看了php书 20 30 页</p>
</li>
</ul>
<a id="more"></a>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>最近一阵子很开心</p>
<p>大概是有帅帅的外教 Professor Daniel </p>
<p>上的是理论课不是关于技术的 大抵是上讲如何设计一个好的应用软件 </p>
<p>time estimation,detailed plan,proto type.the requirements of clients and users…</p>
<p>但是却觉得很有趣 之前一直觉得技术很重要 </p>
<p>现在发现excellent cooperation and communication skill比coding skills重要得多</p>
<p>他总是用实例或者很新奇的idea来阐述一些看起来有点枯燥的东西</p>
<p>觉得这样的上课方式更适合我 尽管自己的英语表达还比较不成熟</p>
<p>但发现沟通比注意语法错误重要得多 毕竟Who cares your grammar error?They just care what you think.</p>
<p>倒也是坚定了我想考上985 以后出去交换的决心</p>
<p>发现自己变化也挺大 </p>
<p>如果是以前 倒也不会主动去加外教微信 又或是下课主动找外教聊天</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li><p>继续看机器学习和深度学习</p>
</li>
<li><p>好好准备10.27号高数竞赛，20天内复习完高数上下册 做1800对应基础</p>
</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(15)</title>
    <url>/2018/10/31/%E5%91%A8%E6%80%BB%E7%BB%93-15/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>考完了数学竞赛 尽力去答题了 尽管没做出来多少</li>
<li>报了ccf认证 有点冲动 不过觉得也是个很好的机会 <a id="more"></a>
目标300吧  做自己想做的事 无所谓结果 毕竟能力比证书重要<br>（总结了一下 想太多 倒容易放弃）希望一年后的自己仍然有勇气 自信去相信i can do hard things 废话说多了 现在还是认真准备比较好 还剩一个多月了</li>
</ul>
<p>时间只是提供给你解决问题的机会，也不代表你能解决多少</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>比前一阵子规律多了，基本早上7点左右去图书馆，晚上9点多回来，大抵还是有点事做比较好</li>
<li>发现与自己握手言和还是挺重要的 学会整理自己的心情 因为有些事 有些人不值得你去付出，也不要一昧地从别人的角度想，活出自己就好。希望未来的自己更强大 更从容一点</li>
<li>少玩社交软件 因为很多东西都是没有意义的 但要注意倾听别人的想法 看清很多事但不全说 做很多的事都要付出相应的代价 只是在你还没完成之前 再多的感慨和抱怨 不过是废话</li>
<li>学会在短时间内提高学习效率和自己的专注力</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>带着刷高数下习题</li>
<li>把基础 dp 贪心 数据结构 字符串的题基础看一遍</li>
<li>每天带着刷ccf的2-3题</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(14)</title>
    <url>/2018/10/16/%E5%91%A8%E6%80%BB%E7%BB%93-14/</url>
    <content><![CDATA[<p>突然想有一种淡然的生活态度<br>觉得每天都是为自己热爱的事而奋斗<br>并不是给自己灌很多鸡汤<br><a id="more"></a></p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>看完了高数上下册</li>
<li>看了php mysql书 20页</li>
<li>在做竞赛试卷<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2>跟室友有点不愉快</li>
</ul>
<p>发现自己默默地为小组做了好多却被说</p>
<p>在生气的时候,忍住了那句能让对方崩溃的话</p>
<p>但对不起 这是我最后的尊重</p>
<p>凌晨三点的难受或许只有自己才清楚吧</p>
<p>其实发现真的不必勉强自己去刻意讨好谁或者迎合谁</p>
<p>何苦这么委屈自己 只想做真实的自己</p>
<p>想保护自己以至于不必伤得太深</p>
<p>不过自己也是有不足 事前适当分工一下<br>什么都自己做 搞得自己累别人也不满意 或许也不会有这样的结果了</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>看竞赛书+做试卷 总结</li>
<li>找时间重写软件工程报告</li>
<li>准备大创中期检查 </li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(17)</title>
    <url>/2018/11/08/%E5%91%A8%E6%80%BB%E7%BB%93-17/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>这周 嗯….有点小开心 高数竞赛拿了国家二等奖，前后也就复习了一个半月左右吧，想想之前写数学的迷茫和有点想放弃，挣扎着看着网课刷题，突然觉得一切努力都是值得的。学姐拿了国一，毕竟是我亲爱的老学姐，哈哈，很为她开心，希望她考研成功。</li>
<li>刷算法题刷得有点难受，一方面觉得自己思维发散不出来，想不到别人的思路，另一方面调个bug还能调个半天，大抵大学这两年专业课学得有点水，大概做很多事都要付出一定的代价吧。但是至少我现在有时间可以弥补。不过时间也是给你提供解决问题的机会，不代表你能解决多少。<a id="more"></a>
</li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li><p>默默有点佩服那些为兴趣而选择专业的人….如果当时没选计算机专业，现在的我又会是什么样子<br>闺蜜说我做什么事都会做得很认真，尽力会做得出色，但其实错了，我只会对自己在意的人或事那么认真，因为我觉得不管结果如何，至少我很享受这个过程，那就值得。</p>
</li>
<li><p>希望能活成自己想要的模样</p>
</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>下周刷完算法基础课程</li>
<li>刷完所有ccf的前两题</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(16)</title>
    <url>/2018/11/05/%E5%91%A8%E6%80%BB%E7%BB%93-16/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>这周学算法花了很长时间，但直到最近才发现真正学号算法还是需要时间的积累以及技巧的理解，画图很重要，可以看别人答案，但看完自己重新打一遍，会发现很多bug.</li>
<li>想想短时间内如何提高工作效率，制定并尽可能完成每天的计划<a id="more"></a>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1></li>
<li>努力成为淡定 从容 自信 优秀的自己</li>
<li>把未来的五年做一个计划 再划分到1年 在想想这一个星期该做什么</li>
<li>专注 少玩手机</li>
<li>没有人逼迫你做什么的事 更应该清楚自己想做什么</li>
<li>多读书多听多思考</li>
<li>似乎从来没后悔过自己做的任何一个冲动的决定，但三分钟热度后总会理性去准备考证书。因为与其放弃而言，我更喜欢这种无所畏惧的勇气和初生牛犊不怕虎的自信。</li>
<li>不过心里清楚ccf认证考300分以上确实有点难 必须有400分的基础（贪心 二分 字符串相关算法 模拟 dfs bfs dp….） 全力以赴吧 就算现实给了你不止一巴掌….</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>刷紫书6 7 8 9章节例题加习题（预计2星期）</li>
<li>刷lintcode题</li>
<li>带着刷ccf真题贪心，枚举</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(11)</title>
    <url>/2018/09/25/%E5%91%A8%E6%80%BB%E7%BB%93-22/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>最近都在中软实训 没有什么更新 教的内容比较基础 发现想做一个真正的网站还要学很多知识</p>
<p>越发是明白人外有人 天外有天这个道理了<br><a id="more"></a></p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>发现在做一件稍微大点的事前一定要和别人商量好 你的好意别人未必接受 </li>
<li>出门安全第一 </li>
<li>对自己有所约束 对未来有所规划 planA planB….</li>
<li>安全感都是自己给的 你必须要有颗清醒地头脑去明白如何地活在当下 慢慢地朝着自己想要的方向前进 </li>
<li>快跨年了 回想起这一年 觉得有失有得 如果要打个分 也勉强及格吧 生而为人 请务必洒脱 所以有些事就forget掉吧 不过最大的收获也许是与自己握手言和吧 以前眼中的自己是很不自信的 现在觉得我有能力去做 也会竭尽全力去把自己想做的事做好 在慢慢地成长吧 正如老郑所言 人都在路上 哪会没遗憾呢 一天天的积累总有一天会看到你的远方的</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>假期四天粗看完疯狂javaee企业应用实战 做出一个小demo</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(23）</title>
    <url>/2019/01/21/%E5%91%A8%E6%80%BB%E7%BB%93-23%EF%BC%89/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>放假回来学习节奏就有点怠慢 规定的计划总是完成一半</li>
<li>高数才看了1/5 代码还没开始刷题 算法笔记看了一小半 就快过年了 再不抓紧时间就来不及了</li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li><p>似乎对自己想要的未来有点不大确定 或者说是没有那么大的自信，自己的能力真的还远远不够</p>
</li>
<li><p>去了趟南京 和高中同学聚了聚 发现过了三年 变化真的好大 高中时期努力的人依旧那么拼命 而自己似乎又有些安于现状  说白了 是对现在的自己不是那么满意 想逼自己一把 青春不是用来浪费 而是用来奋斗的</p>
</li>
<li><p>居安思危 希望自己能每天进步一点点 身体和灵魂总有一个要在路上</p>
</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>算法笔记前7章</li>
<li>算法笔记实训 前7章</li>
<li>高数1800基础前5章</li>
<li>蓝桥杯刷题</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(24)</title>
    <url>/2019/01/29/%E5%91%A8%E6%80%BB%E7%BB%93-24/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>算法笔记+实训两本书 基本看完并理解<a id="more"></a>
</li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>发现最近有点迷茫 </li>
<li>对于计划 总是明日复明日 总是在拖延</li>
<li>对时间安排没有明确的掌握感</li>
<li>至于借掉qq 你必须找到自己真正想做的事</li>
<li>从现在开始多读点书</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>高数18讲</li>
<li>蓝桥杯算法刷一遍</li>
<li>复习全书</li>
<li>数据结构王道</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(5)</title>
    <url>/2018/06/03/%E5%91%A8%E6%80%BB%E7%BB%93-5/</url>
    <content><![CDATA[<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>找老师报销找了n次，多亏了个善良的小姐姐，要不然估计截止也报不成了让我想到好多之前迷路遇见的暖暖的小姐姐</li>
<li>比赛有点揪心，老师的意思是不管怎么都要交，要有始有终，只是谈何容易，放弃也是。只是太多时候一个人扛了太多事，只是心态有点崩。比赛快截止的时候大家一起写，还不一定能写完，过一阵子还有期末考试，我大概是抱着快挂科的心态去搞比赛的吧，抱着一清早去打代码的心态去搞的，忽略我是一个拿过奖学金的人…</li>
<li><p>给学弟学妹讲了python和caffe，但愿能有所帮助吧。只是希望不要像我走了太多弯路。</p>
</li>
<li><p>最近想得有点多，可能是有点想家了</p>
</li>
</ul>
<a id="more"></a>
<p>希望以后的你会感谢现在拼命的自己</p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>忙蝴蝶比赛，练习了python的xml解析和matlab的使用</li>
<li>意料之中，还没有复习操作系统</li>
<li>还在带着刷题</li>
<li>英语…嗯…好像一点没看 姑且等到考完吧</li>
<li>疯狂Ajax,css权威指南带着看了几十页</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>搞比赛</li>
<li>复习操作系统，计算机组成原理</li>
<li>带着刷题</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(7)</title>
    <url>/2018/07/07/%E5%91%A8%E6%80%BB%E7%BB%93-7/</url>
    <content><![CDATA[<p>大概是本学期最后一次总结了</p>
<p>送走了所有的室友</p>
<p>emm…有一种百感交集的感觉<br><a id="more"></a><br>像是早就知道很多人会离开但自己还停在原地</p>
<p>说不想家也是假的 大概是流浪多了 习惯一个人了</p>
<p>大抵是冲动而又畏惧的幻想者了 </p>
<p>话又说回来</p>
<p>对于考雅思没有那么大把握</p>
<p>或许会后悔当时的冲动 </p>
<p>但希望自己能借此改变一下</p>
<p>做一些自己想做的事，追逐下遥远的梦想</p>
<p>全力以赴可以不在乎最终结果 </p>
<p>有所畏惧却敢于去冒险 去尝试</p>
<p>那就足够了</p>
<p>希望未来的自己 与此共勉</p>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(4)</title>
    <url>/2018/05/26/%E5%91%A8%E6%80%BB%E7%BB%93-4/</url>
    <content><![CDATA[<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>这周早起的日子变成习惯了，很可能是快期末的原因吧，再加上so many so many busy things,坚持不易，尤其是我还有一点拖延症，给自己鼓掌<a id="more"></a></li>
<li><p>对联通没有好感了，一天话费居然扣了100多！！流量用超居然一点察觉都没有，一个短信提醒也没有，只好认栽了。不甘心~~</p>
</li>
<li><p>一直没有时间静下心出去走走，想念一个遥远的朋友，这几天回国了，只是已经太久没有联系了。或许如今的我们都已经变了吧（至少我变了），期待下一次见她还是如往昔一样，平稳从容，善良大方。</p>
</li>
<li>以后很多路都是一个人闯荡（always single dog） 不能总是像长不大的孩子 希望大学教给你的不只是知识，而是内在和梦想。期待又害怕着大二最后一个学期的期末。加油吧。</li>
</ul>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>学习Django项目在Apache服务器上配置，很有感慨，看起来教程很简单的，实际动手操作还是有点问题。对Linux的熟悉程度还不够成熟<br>附上搭好的low low的网站<br><img src="https://ws1.sinaimg.cn/large/006wtREyly1frp2n9bnooj30n70p4n9x.jpg" alt="image"></li>
<li><p>初步开始跑了个demo:表情识别，对caffe流程有了一个大概的了解，但打算下一步还是用ck+数据集，考虑的方向:卷积神经网络训练，人脸检测关键点，头部姿态位置检测，如何提高准确率，精通opencv</p>
</li>
<li><p>这星期刷题有点少，快期末还是每天刷1-2题吧</p>
</li>
<li><p>口语发现有进步，只是积累的词伙不够还有连接词要多练多想。</p>
</li>
<li>写作和阅读需要加强</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li><p>复习六级，写一到两篇作文</p>
</li>
<li><p>继续学习python的Django框架</p>
</li>
<li><p>复习操作系统和数据库</p>
</li>
<li><p>看caffe21天实战，Ajax讲义</p>
</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(8)</title>
    <url>/2018/09/02/%E5%91%A8%E6%80%BB%E7%BB%93-8/</url>
    <content><![CDATA[<p>开学第一天 写个总结吧<br><a id="more"></a></p>
<p>雅思成绩出来了 </p>
<p>听力有点惊喜  第一次考6.5分 还好 也不辜负一个月的努力</p>
<p>行动力还是要有的 倒觉得留校的这段时间自己收获了很多</p>
<p>发现有想法就要去做，总归是自己想做的事情，就尽全力去做吧</p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fuvjojqi6oj30jh09bjty.jpg" alt></p>
<h2 id="新学期新目标"><a href="#新学期新目标" class="headerlink" title="新学期新目标"></a>新学期新目标</h2><ul>
<li><p>搭一个web网站</p>
</li>
<li><p>大创 表情识别</p>
</li>
<li><p>每天刷Lintcode+3 </p>
</li>
<li><p>看动态规划课件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(12)</title>
    <url>/2018/09/30/%E5%91%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li><p>理解了遗传算法，读懂了基于遗传算法的自动拼图的源码</p>
</li>
<li><p>看完了高数上册，在刷习题</p>
<a id="more"></a>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2></li>
<li><p>这周结束了外教的课，有点舍不得这么帅的professor.在课上 不仅有很多fun,更重要的是学到了很多，<br>不管是英语的沟通，还是对于软件设计的思考(PS:发现设计一个好的软件不仅需要明白用户和客户的需求还要对时间的合理评估以及学会prototype的重要性)。</p>
</li>
<li><p>仍记得最后的时候我问了Danniel一个问题 关于考研和工作有什么建议 发现了看同一个问题不一样的视角<br>之前我或许想得有点功利，总是希望走更好走的一条路。他说If you are a curious guy或者对学术有追求 希望更进一步地钻研你所热爱的领域 那么就去do a master，找工作取决于个人。每个人在每个阶段都有不同的想法。他认识一个教授，55岁才博士毕业.But Who cares?也许二三十岁你想放弃工作，选择学术领域，这未尝不是个新的起点。There is no right or wrong.</p>
</li>
<li><p>男神发了条动态 谁知道爱是什么 短暂的相遇却念念不忘…大概是心有所属了，可惜那个人不是我。虽然说不相信一见钟情，只是偶尔会想起那一个不可能的人。再来一次还会选择错过么？或许还会吧，毕竟这样对谁都好。真想在对的时间遇到对的人，可惜大学四年应该是不可能了。</p>
</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li><p>国庆假期刷完高数下书</p>
</li>
<li><p>做高数竞赛与提高的书 一天10页</p>
</li>
<li><p>读&lt;&lt;你要相信 没有到不了的明天&gt;&gt;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(19)</title>
    <url>/2018/11/24/%E5%91%A8%E6%80%BB%E7%BB%9319/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>算法题还是没有尽全力去刷 看着发现有刷不完的算法 但是能理解一道 这种类型的都可以差不多理解 所以还是有进步<a id="more"></a>
</li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>起床困难户 有一点懒癌 知道自己是起得来的 只是那一刻有点不想动弹 是得改变一下心态<br>早起能做很多事 每天安排的满满的计划 总不能按希望达成 或许跟这个有点原因</li>
<li>提高午睡质量发现早上八九点还有晚上七八点效率最高 下午学习效率略低</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>刷完leetcode 字符串和模拟专题</li>
<li>刷完ccf-csp所有前四题</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(1)</title>
    <url>/2018/05/06/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<ul>
<li>这周看了一半&lt;&lt;神经网络与深度学习&gt;&gt;，发现这本书写的很好，很适合初学者<br>里面对BP反向传播算法的缺点也分析的很好，对卷积神经网络那块也讲的很清晰。下周任务继续看这本书和并研究一下tensorflow，做一下蝴蝶图片的数据增强。可惜上学期光顾着看cs231n的视频了，发现其实关于深度学习没熟练掌握多少，倒是英语长进很多，哈哈哈，也是六级过的原因之一吧。也算有得有失。这学期突然知道自己要干啥了，更有方向和目的性了。<a id="more"></a></li>
<li><p>时间管理自认为做得不好，每天其实事也不算多，如果合理安排，也是能高效完成的。<br>从下周开始要规划好时间和计划，记录一点一滴的进步。</p>
</li>
<li><p>这周有点分心，i may还没从五一的玩耍中调整过来，也许是有个让我很欣赏的人。不过现在已经放下了，以后毕竟是各奔东西，没有交集的。虽然会有遗憾，但不曾后悔。毕竟有些人，有些事不可强求。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>周总结（20）</title>
    <url>/2018/11/30/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%8820%EF%BC%89/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>发现算法没有想象中那么难 感觉某些时候还是挺有趣的 尤其是当你自己写的代码能AC的时候 注重手写思路<a id="more"></a>
</li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li><p>早睡早起的作息还在养成中 </p>
</li>
<li><p>安利一个ios的app 时间块（青春版） 与之前用的番茄钟不同<br>感觉更像是一种记录时间 你可以更好地知道自己的一天是怎样过去的 它以每半个小时作为一个单位时长 这个时长可以安排一个小任务 你也可以用好几个时间块来完成一个任务 感觉极大地提高了效率 也是突然发现自己每天浪费的时间累加起来也有两三个小时 做每一项任务只是单纯注重时间 不注重效率 生产力提高才是最终目的…</p>
</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li><p>把ccf难题刷完 把ccf中等题再刷一遍</p>
</li>
<li><p>带着看web书</p>
</li>
<li><p>leetcode分类的题都刷完</p>
</li>
<li><p>带着些高数</p>
</li>
<li><p>自己再找题库刷 主要是模拟 字符串 图….<br>(有时间可以看看蓝桥杯题库,下学期可以提前做做准备)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结（21）</title>
    <url>/2018/12/06/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%8821%EF%BC%89/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li><p>突然觉得兴趣是最大的动力，最近看算法看得很头疼，却突然发现意义不在于刷题，而是投入到算法本身的魅力</p>
</li>
<li><p>学得有点焦虑 但是知道自己这样还远远不够 离自己定的标准而言</p>
<a id="more"></a>
</li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li><p>发现自己有时候是间接性努力，没有那种持续性努力的动力，或许对自己的毅力还远远不够，又或许是懒癌又犯了，所以有时候会后悔这半天都没干啥时间就这么过去了，把玩手机的时间加在一起可能每天都有两三个小时，相比高中那种规律的时间作息而言 发现大学的生活节奏是很快的 变化赶不上计划 而且你必须制定长久的计划 然后细分到每一个小计划 你才能跟上别人的步伐</p>
</li>
<li><p>去图书馆的这些天 发现永远有人比你起得早 比你更努力 这世界上聪明的人也很多<br>所以我只能做到的是让今天的自己会比昨天的自己好一点</p>
</li>
<li><p>安利一下 时间块（青春版） ios上的一款APP，记录时间块，会让你意识到每个时间块的重要性，当你回顾这一天做了啥 你会用时间块的角度去看 去分析 统计趋势，而不是具体到每个细节，让你对时间有一种掌控感的同时 不会太有压力。</p>
</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>把CCF难题再刷一遍（整理思路）</li>
<li>刷完CCF字符串的题</li>
<li>刷蓝桥杯/PAT的图论题或者字符串模拟题</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结（25）</title>
    <url>/2019/03/22/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%8825%EF%BC%89/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>用forest计时，每天学8个多小时左右，有时效率也低 ，只有5 6 个小时，但基本也能把握好学习节奏。也算是一种进步。<br><a id="more"></a></p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>不知不觉，开学了快1个月，都没有感觉到时间的流逝，只是习惯了早睡早起的作息。与之前的懒不同，这学期总能听到闹钟就起。然后泡一整天的图书馆。其实是有点烦躁不安的。总结了一下原因 都是归结于对现在的不满意。想搞算法 却知道水很深。和老师谈了谈心，被一句 目标学校定的有点高给影响到。不过有一句话倒是和我想的一致。先按这个复习，最后报名前好好评估自己的实力，但凡有几成把握就报。之前看过别人写的文章 大概是说决策和行动要分开看。与其考你不想做的学校 考上了了还可能后悔，倒不如选自己想考的学校 然后拼尽全力 赌一把。就算赌输了又何妨呢 只能说明你适合其他路，有一扇门关了，必定会有另一扇窗。</li>
<li>最近又会被以前的一些事困扰或者焦虑，发现还是得学会一种平和的心态。这是你人生的一个step 而不是全部。何必care那么多，何必给自己增加负担。活出自己就好。不负青春，不负自己。</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>蓝桥杯历届试题</li>
<li>复习全书 1800</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结（3）</title>
    <url>/2018/05/19/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>这周,很丧的一周,早起了两天:星期一和星期五。上课的第一天和最后一天确实是跨越了一周。<br>感觉不能这样自甘堕落了。</li>
<li>偶然翻到一本书中夹着闺蜜两年前的画，渐渐想到刚入大学的我确实是变了很多。突然有很多感慨，但也不知道说些什么。了解你的人才会知道你做的很多的事，而懂你的人是那句不用多余的解释都会懂你。只是你太过孤冷，只是怕会伤害别人，只是与很多人渐行渐远。</li>
<li>也许某一天，失去的东西都会以另一种方式归来。但在才华撑不起你的梦想的时候，你该知道你要做什么 而不是等待。<a id="more"></a>
</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li><p>看完了html+css的基础知识，过阵子有时间写个网页的小游戏(切水果)巩固一下所学的</p>
<p>【也许我只是随口说说。下个月三门专业课考试,还没开始复习，任务很重呀，很多东西都是理论 看来是不得不背了】</p>
<ul>
<li><p>操作系统还是班导教的，班导问我有信心讲完就考试么，我就笑笑好了（没有底气）。目测重点是P/V操作，生产者消费者模式。</p>
</li>
<li><p>计算机组成原理看起难，但题目类型其实还是固定的，不过仍需过一遍ppt.</p>
</li>
<li><p>数据库免听了，全靠上学期的基础和题目（坚信一定会过的）</p>
</li>
</ul>
</li>
<li>坚持了每天刷了两三道题</li>
<li>口语倒是没练得多好，意外地发现听力提升了不少（推荐可可英语软件）</li>
<li>写作一直放在to-do-list的最后一项，想有时间就写一篇，看来不是一直没找时间写，而是忙着忙着就忘了，要提上计划。</li>
<li><p>疯狂Ajax讲义看了80页左右，caffe21天实战感觉写得有点水（很多都是源码），具体还是得自己实践（琢磨一下）</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>开始写大创 表情识别（初步跑起来模型）</li>
<li>带着学tensorflow，看视频教程</li>
<li>口语和写作</li>
<li>复习操作系统</li>
<li>刷题</li>
<li>带着看 javascipt高级程序设计，疯狂Ajax讲义</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结（2）</title>
    <url>/2018/05/13/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li><p>这周起床起得越来越晚了，尴尬…说好要早起晨跑，事实上也就坚持了三天，看来行动力还是不够</p>
</li>
<li><p>一天到晚也不知道胡思乱想啥，有些事必须心无旁骛地去做。没有时间允许你停下脚步。</p>
<a id="more"></a>
</li>
</ul>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li><p>前半个星期在忙蝴蝶比赛的事，虽然知道很大程度上都是自己一个人在做，当然了，从一开始也不抱着获奖的心态，只是想鼓励自己继续捡起深度学习的知识，但每次想到放弃的时候了，总觉得对自己有点失望，不管是作为一个leader,没有很好的协调好组员，又或是作为参赛者，也没有很好的钻研SSD的原理和调参的技巧。比赛是残酷的，现实也是。</p>
</li>
<li><p>关于雅思，口语和作文始终是块难题，阅读的时间把握不好。暑假留校两三个星期考的想法倒是没有动摇，may be看一大批人离校的时候会有一点点难过，但不后悔。（PS:考完也不打算出国的我也许在玩火吧，但未来某一天我想出去看看这个世界，有可能的话去听一场乡村演唱会，或者在某个地方偶遇我的idol。)</p>
</li>
<li><p>看了 caffe21天实战 看了80,90页吧，但没有动手实践，总体这周没怎么好好看书</p>
</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>专注力稍微比上周好一点，然而还是计划赶不上变化，不过每天的计划也能完成80%。</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>口语和写作</li>
<li>caffe 21天实战每周做一个项目 </li>
<li>html+css</li>
<li>刷题</li>
<li>看Python web视频</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结（6）</title>
    <url>/2018/06/16/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%886%EF%BC%89/</url>
    <content><![CDATA[<p>这两周忙比赛和考试，闲下来补一下周总结吧。</p>
<a id="more"></a>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>出去工作室聚会了两次…会想象自己大四的时候会是什么样的，有些许期待和不舍</li>
<li>早起晚睡的作息</li>
<li>知道生命中很多人不是过客，但依旧选择错过。</li>
<li>一直以为时光能淡化很多事，发现忘记一个人还是有点难。</li>
<li>Love yourself</li>
</ul>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>这两个星期很拼，几乎每天早上6点半自然醒，晚上还在想比赛。有一天晚上是真想哭了，也不是写不下去，只是自己一个人搞确实太累了，何况还是个女生（必须承认确实得付出比别人多几倍的努力才能打代码打得很好），太多的逻辑bug，太多的调参，还有很多弄不懂的原理,大概是处于崩溃的边缘吧。为此，放弃了考前复习重要的三四天，为此报废了一个移动硬盘，写了很多废话(ing)，然而从未后悔，只是愿未来的自己会感谢此刻拼命的自己。</p>
<p>搞完比赛，发现自己对caffe的了解还是太浅，对深度学习的原理欠缺了太多，以致于有些迷茫不知道自己这样是不是徒劳又或是自以为的努力和给的感动。</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>复习java和计组</li>
<li>看caffe的经典模型</li>
<li>带着看javascript书</li>
<li>练习雅思口语</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>命令行连接Mysql</title>
    <url>/2018/07/02/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9E%E6%8E%A5Mysql/</url>
    <content><![CDATA[<p>1、登陆服务器端，进入命令行，windows cmd;</p>
<p>2、设置用户、密码让指定的IP访问：mysql -u root -p 或安装的快捷方式进入:MySQL Command Line Client,使用grant命令：<br><a id="more"></a><br>grant 权限1,权限2,…权限n on 数据库名称.表名称 to 用户名@用户地址 identified by ‘连接口令’;</p>
<p>例子：</p>
<p>mysql&gt;grant select,insert,update,delete,create,drop on mydb.mytable to <a href="mailto:lzpddd@192.168.1.88" target="_blank" rel="noopener">lzpddd@192.168.1.88</a> identified by ‘mypassword’;<br>给来自192.168.1.88的用户lzpddd分配可对数据库 mydb的mytable表进行select,insert,update,delete,create,drop等操作的权限，并设定口令为’mypassword’;</p>
<p>mysql&gt;grant all privileges on <em>.</em> to <a href="mailto:lzpddd@192.168.1.88" target="_blank" rel="noopener">lzpddd@192.168.1.88</a> identified by ‘mypassword’;</p>
<p>给来自192.168.1.88的用户lzpddd分配可对所有数据库的所有表进行所有操作的权限限，并设定口令为’mypassword’;</p>
<p>mysql&gt;grant all privileges on <em>.</em> to lzpddd@’%’ identified by ‘mypassword’;</p>
<p>给来自任何IP地址的用户lzpddd分配可对所有数据库的所有表进行所有操作的权限限，并设定口令为’mypassword’;</p>
<p>3、关闭服务器端防火墙或者开放3306端口（很重要）；</p>
<p>4、客户端连接：</p>
<p>进入命令行，windows cmd，连接：</p>
<p>mysql -u 用户名 -p密码 -h 服务器IP地址 -P 服务器端MySQL端口号 -D 数据库名</p>
<p>注意：</p>
<pre><code>(1)服务器端口标志-P一定要大些以区别于用户-p,如果直接连接数据库标志-D也要大写；

(2)如果要直接输入密码-p后面不能留有空格如-pmypassword;

(3)命令结束段没有&apos;;&apos;分号。
</code></pre><p>例子：</p>
<p>mysql -u lzpddd -pmypassword -h 192.168.1.88 -P 3306 -D mydb</p>
<p> 注意： ubuntu需要修改文件$sudo gedit /etc/mysql/my.cnf </p>
<p>skip-networking =&gt; # skip-networking</p>
<p>或者</p>
<p>bind-address=127.0.0.1 =&gt; bind-address= 你机器的IP</p>
]]></content>
  </entry>
  <entry>
    <title>国王的烦恼</title>
    <url>/2018/12/22/%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC/</url>
    <content><![CDATA[<p>问题描述<br>　　C国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然而，由于海水冲刷，有一些大桥面临着不能使用的危险。<br><a id="more"></a><br>　　如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。</p>
<p>　　现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。<br>输入格式<br>　　输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。<br>　　接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。<br>输出格式<br>　　输出一个整数，表示居民们会抗议的天数。<br>样例输入</p>
<p>4 4</p>
<p>1 2 2</p>
<p>1 3 2</p>
<p>2 3 1</p>
<p>3 4 3</p>
<p>样例输出</p>
<p>2</p>
<p>样例说明<br>　　第一天后2和3之间的桥不能使用，不影响。<br>　　第二天后1和2之间，以及1和3之间的桥不能使用，居民们会抗议。<br>　　第三天后3和4之间的桥不能使用，居民们会抗议。<br>数据规模和约定<br>　　对于30%的数据，1&lt;=n&lt;=20，1&lt;=m&lt;=100；<br>　　对于50%的数据，1&lt;=n&lt;=500，1&lt;=m&lt;=10000；<br>　　对于100%的数据，1&lt;=n&lt;=10000，1&lt;=m&lt;=100000，1&lt;=a, b&lt;=n， 1&lt;=t&lt;=100000。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;algorithm&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 100000+5</span><br><span class="line">struct node&#123;</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">	int d;</span><br><span class="line">	node(int aa,int bb,int dd):a(aa),b(bb),d(dd)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	node()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">node g[MAX];</span><br><span class="line">	bool cmp(node a,node b)&#123;</span><br><span class="line">	return a.d&gt;b.d;&#125; </span><br><span class="line">class unionset&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">    vector&lt;int&gt; rank;</span><br><span class="line">	</span><br><span class="line">    unionset(int n)&#123;</span><br><span class="line">    parent=vector&lt;int&gt;(n+1,0);</span><br><span class="line">    rank=vector&lt;int&gt;(n+1,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">	parent[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bool Union(int u1,int u2)&#123;</span><br><span class="line">		int p1=find(u1);</span><br><span class="line">		int p2=find(u2);</span><br><span class="line">		if(p1==p2) return false;</span><br><span class="line">		if(rank[p1]&gt;rank[p2])&#123;</span><br><span class="line">			parent[p2]=p1;</span><br><span class="line">		&#125;</span><br><span class="line">        else if(rank[p2]&gt;rank[p1])&#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">            rank[p2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    int find(int num)&#123;</span><br><span class="line">        if(num!=parent[num])&#123;</span><br><span class="line">            parent[num]=find(parent[num]);//find(num)一直自己调用自己 错的 find(parent[num]) 往上回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[num];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	int x1,x2,v;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x1&gt;&gt;x2&gt;&gt;v;</span><br><span class="line">		g[i]=node(x1,x2,v);</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	//!! 按边的权值排序 sort(g,g+n,cmp) 错误 </span><br><span class="line">	sort(g,g+m,cmp);</span><br><span class="line">	int pre=-1,cnt=0;</span><br><span class="line">	unionset uf(n+1);</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		if(uf.Union(g[i].a,g[i].b)&amp;&amp;pre!=g[i].d)&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			pre=g[i].d; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考博客</p>
<p><a href="https://blog.csdn.net/qiqi_skystar/article/details/50923574" target="_blank" rel="noopener">https://blog.csdn.net/qiqi_skystar/article/details/50923574</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯 四平方和</title>
    <url>/2019/03/23/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C/</url>
    <content><![CDATA[<p>四平方和</p>
<p>四平方和定理，又称为拉格朗日定理：<br>每个正整数都可以表示为至多4个正整数的平方和。<br>如果把0包括进去，就正好可以表示为4个数的平方和。</p>
<p>比如：<br>5 = 0^2 + 0^2 + 1^2 + 2^2<br>7 = 1^2 + 1^2 + 1^2 + 2^2<br>（^符号表示乘方的意思）</p>
<p>对于一个给定的正整数，可能存在多种平方和的表示法。<br>要求你对4个数排序：<br>0 &lt;= a &lt;= b &lt;= c &lt;= d<br>并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法<br><a id="more"></a><br>程序输入为一个正整数N (N&lt;5000000)<br>要求输出4个非负整数，按从小到大排序，中间用空格分开</p>
<p>例如，输入：<br>5<br>则程序应该输出：<br>0 0 1 2<br>再例如，输入：<br>12<br>则程序应该输出：<br>0 2 2 2<br>再例如，输入：<br>773535<br>则程序应该输出：<br>1 1 267 838</p>
<p>资源约定：<br>峰值内存消耗 &lt; 256M<br>CPU消耗 &lt; 3000ms</p>
<p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p>
<p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。</p>
<p>注意: main函数需要返回0<br>注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。<br>注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。</xxx></p>
<p>提交时，注意选择所期望的编译器类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//四平方和</span><br><span class="line">//类似打表的思想</span><br><span class="line"></span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 5000001</span><br><span class="line">int mp[MAX];</span><br><span class="line">void init()&#123;</span><br><span class="line">	for(int i=0;i*i&lt;=MAX;i++)&#123;</span><br><span class="line">		for(int j=0;j*j&lt;=MAX;j++)&#123;</span><br><span class="line">			if(i*i+j*j &lt;= MAX)//! 没有这个可能会超内存 </span><br><span class="line">			mp[i*i+j*j]=1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	init();</span><br><span class="line">	bool flag=false;</span><br><span class="line">	for(int  i=0;i*i&lt;MAX&amp;&amp;!flag;i++)&#123;</span><br><span class="line">		for(int j=0;j*j&lt;MAX&amp;&amp;!flag;j++)&#123;</span><br><span class="line">			if(mp[n-i*i-j*j]==0) continue;</span><br><span class="line">			for(int k=0;k*k&lt;MAX&amp;&amp;!flag;k++)&#123;</span><br><span class="line">				double tt=sqrt(n-i*i-j*j-k*k);</span><br><span class="line">				if((tt)==(int)(tt))&#123;</span><br><span class="line">					printf(&quot;%d %d %d %d\n&quot;,i,j,k,(int)tt);</span><br><span class="line">					flag=true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接<br><a href="https://blog.csdn.net/y1196645376/article/details/50938608" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/50938608</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title>地图着色</title>
    <url>/2018/12/20/%E5%9C%B0%E5%9B%BE%E7%9D%80%E8%89%B2/</url>
    <content><![CDATA[<p> 地图染色问题可以根据四色定理来解决。所谓四色定理，就是指可以用不多于四种的颜色对地图着色，使相邻的行政区域不重色，因此我们可以用四色定理的结论，用回溯算法对一幅给定的地图染色。<br><a id="more"></a><br>算法的基本思想是：从第(1)号行政区域开始染色，每个区域逐次用颜色1#、2#、3#、4#进行试探，若当前所取的颜色与周围已染色的行政区域不重色，则用栈记下该区域的颜色序号，否则依次用下一颜色进行试探；若出现用1#到4#颜色均与相邻区域的颜色重色，则需退栈回溯，修改当前栈顶的颜色序号，再进行试探。直到所有行政区域都已分配合适的颜色。</p>
<p>递归求解；在前面的n-1个节点都合法的着色之后，开始对第n个节点着色。这时候枚举可用的m个颜色，通过和与它相邻的节点的颜色相比较，来判断这个颜色是否合法。找到一种颜色能使第n个节点合法着色即可完成中国地图着色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 100</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt;g;</span><br><span class="line">int x[MAX];</span><br><span class="line">int n,m,e;</span><br><span class="line">bool ok(int t)&#123;</span><br><span class="line">	//t节点邻接表中序号小于t的颜色是否有相同的 剪枝 </span><br><span class="line">	for(int i=0;i&lt;g[t].size();i++)&#123;</span><br><span class="line">		if(x[g[t][i]]==x[t]&amp;&amp;g[t][i]&lt;t)</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int sum=0;</span><br><span class="line">void back(int t)&#123;</span><br><span class="line">	if(t&gt;n)&#123;</span><br><span class="line">		sum++;</span><br><span class="line">		cout&lt;&lt;&quot;第&quot;&lt;&lt;sum&lt;&lt;&quot;种方案:&quot;; </span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">		cout&lt;&lt;x[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">    //!! 1-&gt;m 没有颜色的默认是x[] 值是0</span><br><span class="line">		for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">			x[t]=j;//t位置填充j </span><br><span class="line">			if(ok(t))</span><br><span class="line">			&#123;</span><br><span class="line">			back(t+1);	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	cin&gt;&gt;e;</span><br><span class="line">	int k1,k2;</span><br><span class="line">	g=vector&lt;vector&lt;int&gt; &gt;(n+1);</span><br><span class="line">	for(int i=0;i&lt;e;i++)&#123;</span><br><span class="line">		cin&gt;&gt;k1&gt;&gt;k2;</span><br><span class="line">		g[k1].push_back(k2);</span><br><span class="line">		g[k2].push_back(k1);</span><br><span class="line">	&#125;</span><br><span class="line">	back(1);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考博客<br><a href="https://blog.csdn.net/tengweitw/article/details/17641017" target="_blank" rel="noopener">https://blog.csdn.net/tengweitw/article/details/17641017</a></p>
<p><a href="http://blog.51cto.com/qmkkd/1767279" target="_blank" rel="noopener">http://blog.51cto.com/qmkkd/1767279</a></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fydf1tiyz5j306z0a83z9.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>趣学算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>历届试题 地宫取宝</title>
    <url>/2019/03/10/%E5%9C%B0%E5%AE%AB%E5%8F%96%E5%AE%9D/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　X 国王有一个地宫宝库。是 n x m 个格子的矩阵。每个格子放一件宝贝。每个宝贝贴着价值标签。<br><a id="more"></a><br>　　地宫的入口在左上角，出口在右下角。</p>
<p>　　小明被带到地宫的入口，国王要求他只能向右或向下行走。</p>
<p>　　走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。</p>
<p>　　当小明走到出口时，如果他手中的宝贝恰好是k件，则这些宝贝就可以送给小明。</p>
<p>　　请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这k件宝贝。</p>
<p>输入格式</p>
<p>　　输入一行3个整数，用空格分开：n m k (1&lt;=n,m&lt;=50, 1&lt;=k&lt;=12)</p>
<p>　　接下来有 n 行数据，每行有 m 个整数 Ci (0&lt;=Ci&lt;=12)代表这个格子上的宝物的价值</p>
<p>输出格式</p>
<p>　　要求输出一个整数，表示正好取k个宝贝的行动方案数。该数字可能很大，输出它对 1000000007 取模的结果。</p>
<p>样例输入</p>
<p>2 2 2<br>1 2<br>2 1</p>
<p>样例输出</p>
<p>2</p>
<p>样例输入</p>
<p>2 3 2<br>1 2 3<br>2 1 5</p>
<p>样例输出</p>
<p>14</p>
<p>记忆化搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX 51</span><br><span class="line">const int eps=1000000007;  </span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,k;</span><br><span class="line">int dp[50][50][13][13];</span><br><span class="line">int map[MAX][MAX];</span><br><span class="line">int dfs(int i,int j,int num,int max)&#123;</span><br><span class="line">	//max -1</span><br><span class="line">	if(dp[i][j][num][max+1]!=-1) return dp[i][j][num][max+1];</span><br><span class="line">	long long cnt=0;</span><br><span class="line">	if(i==n&amp;&amp;j==m)&#123;</span><br><span class="line">		if(map[i][j]&gt;max&amp;&amp;num==k-1) cnt++;</span><br><span class="line">		if(num==k) cnt++;</span><br><span class="line">		return dp[i][j][num][max+1]=cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	if(i+1&lt;=n)&#123;</span><br><span class="line">		if(map[i][j]&gt;max) &#123;</span><br><span class="line">			cnt+=dfs(i+1,j,num+1,map[i][j]);</span><br><span class="line">						cnt%=eps; </span><br><span class="line">		&#125;</span><br><span class="line">		cnt+=dfs(i+1,j,num,max);</span><br><span class="line">		//!</span><br><span class="line">		cnt%=eps;  </span><br><span class="line">	&#125;</span><br><span class="line">	if(j+1&lt;=m)&#123;</span><br><span class="line">		if(map[i][j]&gt;max) &#123;</span><br><span class="line">			cnt+=dfs(i,j+1,num+1,map[i][j]);</span><br><span class="line">			cnt%=eps;  </span><br><span class="line">		&#125;</span><br><span class="line">		cnt+=dfs(i,j+1,num,max);</span><br><span class="line">		cnt%=eps;  </span><br><span class="line">	&#125;</span><br><span class="line">	dp[i][j][num][max+1]=cnt;</span><br><span class="line">	return cnt;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	//! i从1开始</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=m;j++)</span><br><span class="line">		cin&gt;&gt;map[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	//!</span><br><span class="line">	memset(dp,-1,sizeof(dp));</span><br><span class="line">	dfs(1,1,0,-1);</span><br><span class="line">	cout&lt;&lt;dp[1][1][0][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//超时代码 </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 100</span><br><span class="line">int n,m,k;</span><br><span class="line">int num[MAX][MAX];</span><br><span class="line">int ans=0;</span><br><span class="line">void dfs(int x,int y,int sum,int max)&#123;</span><br><span class="line">	//递归终止条件 </span><br><span class="line">	if(x==n-1&amp;&amp;y==m-1)&#123;</span><br><span class="line">		if(sum==k-1&amp;&amp;num[x][y]&gt;max) ans++;</span><br><span class="line">		 if(sum==k) ans++ ;</span><br><span class="line">		return; </span><br><span class="line">	&#125;</span><br><span class="line">	//搜索</span><br><span class="line">	//所在的格子的价值比max大 </span><br><span class="line">	 if(x+1&lt;n)&#123;</span><br><span class="line">	 	if(num[x][y]&gt;max) dfs(x+1,y,sum+1,num[x][y]);</span><br><span class="line">	 	dfs(x+1,y,sum,max);</span><br><span class="line">	 	</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	 if(y+1&lt;m)&#123;</span><br><span class="line">	 	if(num[x][y]&gt;max) dfs(x,y+1,sum+1,num[x][y]);</span><br><span class="line">	 	dfs(x,y+1,sum,max);//!! </span><br><span class="line">	 	</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//	freopen(&quot;y1.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">			cin&gt;&gt;num[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(0,0,0,-1);</span><br><span class="line">	printf(&quot;%d\n&quot;,ans%1000000007);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考<br><a href="http://www.voidcn.com/article/p-nloxrfju-zq.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-nloxrfju-zq.html</a><br><a href="https://blog.csdn.net/Enjoying_Science/article/details/44944253" target="_blank" rel="noopener">https://blog.csdn.net/Enjoying_Science/article/details/44944253</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CNN的年龄和性别检测</title>
    <url>/2018/05/06/%E5%9F%BA%E4%BA%8ECNN%E7%9A%84%E5%B9%B4%E9%BE%84%E5%92%8C%E6%80%A7%E5%88%AB%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<p>原文地址：<a href="http://blog.csdn.net/hjimce/article/details/49255013" target="_blank" rel="noopener">http://blog.csdn.net/hjimce/article/details/49255013</a></p>
<p>作者：hjimce</p>
<p>一、相关理论</p>
<p>　　本篇博文主要讲解2015年一篇paper《Age and Gender Classification using Convolutional Neural Networks》，个人感觉这篇文献没啥难度，只要懂得Alexnet，实现这篇文献的算法，会比较容易。其实读完这篇paper之后，我一直在想paper的创新点在哪里？因为我实在没有看出paper的创新点在哪里，估计是自己水平太lower了，看文献没<br>抓到文献的创新点。<br><a id="more"></a><br>难道是因为利用CNN做年龄和性别分类的paper很少吗？网上搜索了一下，性别预测，以前很多都是用SVM算法，用CNN搞性别分类就只搜索到这一篇文章。个人感觉利用CNN进行图片分类已经不是什么新鲜事了，年龄、和性别预测，随便搞个CNN网络，然后开始训练跑起来，也可以获得不错的精度。</p>
<p>　　性别分类自然而然是二分类问题，然而对于年龄怎么搞？年龄预测是回归问题吗？paper采用的方法是把年龄划分为多个年龄段，每个年龄段相当于一个类别，这样性别也就多分类问题了。所以我们不要觉得现在的一些APP，功能好像很牛逼，什么性别、年龄、衣服类型、是否佩戴眼镜等识别问题，其实这种识别对于CNN来说，基本上是松松搞定的事，当然你如果要达到非常高的识别精度，是另外一回事了，就需要各种调参了。</p>
<p>言归正传，下面开始讲解2015年paper《Age and Gender Classification using Convolutional Neural Networks》的网络结构，这篇文章没有什么新算法，只有调参，改变网络层数、卷积核大小等……所以如果已经对Alexnet比较熟悉的，可能会觉得看起来没啥意思，这篇papar的相关源码和训练数据，文献作者有给我们提供，可以到Caffe zoo model：<a href="https://github.com/BVLC/caffe/wiki/Model-Zoo" target="_blank" rel="noopener">https://github.com/BVLC/caffe/wiki/Model-Zoo</a>  或者文献的主页：<a href="http://www.openu.ac.il/home/hassner/projects/cnn_agegender/。下载相关训练好的模型，paper性别、年龄预测的应用场景比较复杂，都是一些非常糟糕的图片，比较模糊的图片等，所以如果我们想要直接利用paper训练好的模型，用到我们自己的项目上，可能精度会比较低，后面我将会具体讲一下利用paper的模型进行fine-tuning，以适应我们的应用，提高我们自己项目的识别精度。" target="_blank" rel="noopener">http://www.openu.ac.il/home/hassner/projects/cnn_agegender/。下载相关训练好的模型，paper性别、年龄预测的应用场景比较复杂，都是一些非常糟糕的图片，比较模糊的图片等，所以如果我们想要直接利用paper训练好的模型，用到我们自己的项目上，可能精度会比较低，后面我将会具体讲一下利用paper的模型进行fine-tuning，以适应我们的应用，提高我们自己项目的识别精度。</a></p>
<p>二、算法实现</p>
<p>因为paper的主页，有提供网络结构的源码，我将结合网络结构文件进行讲解。</p>
<p>1、 网络结构</p>
<p>Paper所用的网络包含：3个卷积层，还有2个全连接层。这个算是层数比较少的CNN网络模型了，这样可以避免过拟合。对于年龄的识别，paper仅仅有8个年龄段，相当于8分类模型；然后对于性别识别自然而然是二分类问题了。</p>
<p>然后图像处理直接采用3通道彩色图像进行处理，图片6都统一缩放到256<em>256，然后再进行裁剪，为227</em>227（训练过程随机裁剪，验证测试过程通过矩形的四个角+中心裁剪），也就是说网络的输入时227*227的3通道彩色图像，总之基本上跟Alexnet一样。</p>
<p>网络模型：</p>
<p>(1)第一层：采用96个卷积核，每个卷积核参数个数为3<em>7</em>7，这个就相当于3个7<em>7大小的卷积核在每个通道进行卷积。激活函数采用ReLU，池化采用最大重叠池化，池化的size选择3</em>3，strides选择2。然后接着再来一个局部响应归一化层。什么叫局部响应归一化，自己可以查看一下文献：《ImageNet Classification with Deep Convolutional Neural Networks》，局部响应归一化可以提高网络的泛化能力。</p>
<p>局部响应归一化，这个分成两种情况，一种是3D的归一化，也就是特征图之间对应像素点的一个归一化。还有一种是2D归一化，就是对特征图的每个像素的局部做归一化。局部响应归一化其实这个可有可无，精度提高不了多少，如果你还不懂上面那个公式也没有关系。我们可以利用最新的算法：Batch Normalize ，这个才牛逼呢，2015年，我觉得最牛逼的算法之一，不仅提高了训练速度，连精度也提高了。过程：通过7<em>7大小的卷积核，对227</em>227图片卷积，然后特征图的个数为96个，每个特征图都是三通道的,这个作者没有讲到卷积层的stride大小，不过我们大体可以推测出来，因为paper的网络结构是模仿：ImageNet Classification with Deep Convolutional Neural Networks的网络结构的，连输入图片的大小也是一样的，这篇文献的第一层如下所示：</p>
<p>我们可以推测出，paper选择的卷积步长为4，这样经过卷积后，然后pad为2，这样经过卷积后图片的大小为：(227-7)/4+1=56。然后经过3<em>3，且步长为2的大小，进行重叠池化，可以得到：56/2=28</em>28大小的图片，具体边界需要补齐。下面是原文的第一层结构示意图：</p>
<p>[python] view plain copy 在CODE上查看代码片派生到我的代码片<br>layers {<br>  name: “conv1”<br>  type: CONVOLUTION<br>  bottom: “data”<br>  top: “conv1”<br>  blobs_lr: 1<br>  blobs_lr: 2<br>  weight_decay: 1<br>  weight_decay: 0<br>  convolution_param {<br>    num_output: 96<br>    kernel_size: 7<br>    stride: 4<br>    weight_filler {<br>      type: “gaussian”<br>      std: 0.01<br>    }<br>    bias_filler {<br>      type: “constant”<br>      value: 0<br>    }<br>  }<br>}<br>layers {<br>  name: “relu1”<br>  type: RELU<br>  bottom: “conv1”<br>  top: “conv1”<br>}<br>layers {<br>  name: “pool1”<br>  type: POOLING<br>  bottom: “conv1”<br>  top: “pool1”<br>  pooling_param {<br>    pool: MAX<br>    kernel_size: 3<br>    stride: 2<br>  }<br>}<br>layers {<br>  name: “norm1”<br>  type: LRN<br>  bottom: “pool1”<br>  top: “norm1”<br>  lrn_param {<br>    local_size: 5<br>    alpha: 0.0001<br>    beta: 0.75<br>  }<br>}  </p>
<p>(2)第二层：第二层的输入也就是96<em>28</em>28的单通道图片，因为我们上一步已经把三通道合在一起进行卷积了。第二层结构，选择256个滤波器，滤波器大小为5*5，卷积步长为1，这个也可以参考AlexNet的结构。池化也是选择跟上面的一样的参数。</p>
<p>[python] view plain copy 在CODE上查看代码片派生到我的代码片<br>layers {<br>  name: “conv2”<br>  type: CONVOLUTION<br>  bottom: “norm1”<br>  top: “conv2”<br>  blobs_lr: 1<br>  blobs_lr: 2<br>  weight_decay: 1<br>  weight_decay: 0<br>  convolution_param {<br>    num_output: 256<br>    pad: 2<br>    kernel_size: 5<br>    weight_filler {<br>      type: “gaussian”<br>      std: 0.01<br>    }<br>    bias_filler {<br>      type: “constant”<br>      value: 1<br>    }<br>  }<br>}<br>layers {<br>  name: “relu2”<br>  type: RELU<br>  bottom: “conv2”<br>  top: “conv2”<br>}<br>layers {<br>  name: “pool2”<br>  type: POOLING<br>  bottom: “conv2”<br>  top: “pool2”<br>  pooling_param {<br>    pool: MAX<br>    kernel_size: 3<br>    stride: 2<br>  }<br>}<br>layers {<br>  name: “norm2”<br>  type: LRN<br>  bottom: “pool2”<br>  top: “norm2”<br>  lrn_param {<br>    local_size: 5<br>    alpha: 0.0001<br>    beta: 0.75<br>  }<br>}<br>(3)第三层：滤波器个数选择384，卷积核大小为3*3。</p>
<p>[python] view plain copy 在CODE上查看代码片派生到我的代码片<br>layers {<br>  name: “conv3”<br>  type: CONVOLUTION<br>  bottom: “norm2”<br>  top: “conv3”<br>  blobs_lr: 1<br>  blobs_lr: 2<br>  weight_decay: 1<br>  weight_decay: 0<br>  convolution_param {<br>    num_output: 384<br>    pad: 1<br>    kernel_size: 3<br>    weight_filler {<br>      type: “gaussian”<br>      std: 0.01<br>    }<br>    bias_filler {<br>      type: “constant”<br>      value: 0<br>    }<br>  }<br>}<br>layers {<br>  name: “relu3”<br>  type: RELU<br>  bottom: “conv3”<br>  top: “conv3”<br>}<br>layers {<br>  name: “pool5”<br>  type: POOLING<br>  bottom: “conv3”<br>  top: “pool5”<br>  pooling_param {<br>    pool: MAX<br>    kernel_size: 3<br>    stride: 2<br>  }<br>}<br>(4)第四层：第一个全连接层，神经元个数选择512。</p>
<p>[python] view plain copy 在CODE上查看代码片派生到我的代码片<br>layers {<br>  name: “fc6”<br>  type: INNER_PRODUCT<br>  bottom: “pool5”<br>  top: “fc6”<br>  blobs_lr: 1<br>  blobs_lr: 2<br>  weight_decay: 1<br>  weight_decay: 0<br>  inner_product_param {<br>    num_output: 512<br>    weight_filler {<br>      type: “gaussian”<br>      std: 0.005<br>    }<br>    bias_filler {<br>      type: “constant”<br>      value: 1<br>    }<br>  }<br>}<br>layers {<br>  name: “relu6”<br>  type: RELU<br>  bottom: “fc6”<br>  top: “fc6”<br>}<br>layers {<br>  name: “drop6”<br>  type: DROPOUT<br>  bottom: “fc6”<br>  top: “fc6”<br>  dropout_param {<br>    dropout_ratio: 0.5<br>  }<br>}  </p>
<p>(5)第五层：第二个全连接层，神经元个数也是选择512。</p>
<p>[python] view plain copy 在CODE上查看代码片派生到我的代码片<br>layers {<br>  name: “fc7”<br>  type: INNER_PRODUCT<br>  bottom: “fc6”<br>  top: “fc7”<br>  blobs_lr: 1<br>  blobs_lr: 2<br>  weight_decay: 1<br>  weight_decay: 0<br>  inner_product_param {<br>    num_output: 512<br>    weight_filler {<br>      type: “gaussian”<br>      std: 0.005<br>    }<br>    bias_filler {<br>      type: “constant”<br>      value: 1<br>    }<br>  }<br>}<br>layers {<br>  name: “relu7”<br>  type: RELU<br>  bottom: “fc7”<br>  top: “fc7”<br>}<br>layers {<br>  name: “drop7”<br>  type: DROPOUT<br>  bottom: “fc7”<br>  top: “fc7”<br>  dropout_param {<br>    dropout_ratio: 0.5<br>  }<br>}  </p>
<p>(6)第六次：输出层，对于性别来说是二分类，输入神经元个数为2。</p>
<p>[python] view plain copy 在CODE上查看代码片派生到我的代码片<br>layers {<br>  name: “fc8”<br>  type: INNER_PRODUCT<br>  bottom: “fc7”<br>  top: “fc8”<br>  blobs_lr: 10<br>  blobs_lr: 20<br>  weight_decay: 1<br>  weight_decay: 0<br>  inner_product_param {<br>    num_output: 2<br>    weight_filler {<br>      type: “gaussian”<br>      std: 0.01<br>    }<br>    bias_filler {<br>      type: “constant”<br>      value: 0<br>    }<br>  }<br>}<br>layers {<br>  name: “accuracy”<br>  type: ACCURACY<br>  bottom: “fc8”<br>  bottom: “label”<br>  top: “accuracy”<br>  include: { phase: TEST }<br>}<br>layers {<br>  name: “loss”<br>  type: SOFTMAX_LOSS<br>  bottom: “fc8”<br>  bottom: “label”<br>  top: “loss”<br>}  </p>
<p>网络方面，paper没有什么创新点，模仿AlexNet结构。</p>
<p>2、网络训练</p>
<p>(1)初始化参数：权重初始化方法采用标准差为0.01，均值为0的高斯正太分布。</p>
<p>(2)网络训练：采用dropout，来限制过拟合。Drop out比例采用0.5，还有就是数据扩充，数据扩充石通过输入256<em>256的图片，然后进行随机裁剪，裁剪为227</em>227的图片，当然裁剪要以face中心为基础，进行裁剪。</p>
<p>(3)训练方法采用，随机梯度下降法，min-batch 大小选择50，学习率大小0.001，然后当迭代到10000次以后，把学习率调为0.0001。</p>
<p>(4)结果预测：预测方法采用输入一张256<em>256的图片，然后进行裁剪5张图片为227</em>227大小，其中四张图片的裁剪方法分别采用以256*256的图片的4个角为基点点，进行裁剪。然后最后一张，以人脸的中心为基点进行裁剪。然后对这5张图片进行预测，最后对预测结果进行平均。</p>
<p>三、实际应用</p>
<p>　　文献作者给我们提供，可以到Caffe zoo model：<a href="https://github.com/BVLC/caffe/wiki/Model-Zoo" target="_blank" rel="noopener">https://github.com/BVLC/caffe/wiki/Model-Zoo</a>  或者文献的主页：<a href="http://www.openu.ac.il/home/hassner/projects/cnn_agegender/。下载相关训练好的模型，paper性别、年龄预测的应用场景比较复杂，都是一些非常糟糕的图片，比较模糊的图片等，所以如果我们想要直接利用paper训练好的模型，用到我们自己的项目上，可能精度会比较低。我测试了一下，直接使用paper给的模型，在我的数据上进行测试，我的数据是中国人、，然后也比较清晰，直接用作者训练好的模型，精度为0.82左右，这个精度对于我们实际的工程应用还差很远。后面就要发挥自己的调参、技巧把精度提高上去，才能达到95%以上的精度，具体因为项目保密，所以不再啰嗦。最后预测结果如下：" target="_blank" rel="noopener">http://www.openu.ac.il/home/hassner/projects/cnn_agegender/。下载相关训练好的模型，paper性别、年龄预测的应用场景比较复杂，都是一些非常糟糕的图片，比较模糊的图片等，所以如果我们想要直接利用paper训练好的模型，用到我们自己的项目上，可能精度会比较低。我测试了一下，直接使用paper给的模型，在我的数据上进行测试，我的数据是中国人、，然后也比较清晰，直接用作者训练好的模型，精度为0.82左右，这个精度对于我们实际的工程应用还差很远。后面就要发挥自己的调参、技巧把精度提高上去，才能达到95%以上的精度，具体因为项目保密，所以不再啰嗦。最后预测结果如下：</a></p>
<p>　　　　　　　</p>
<p>测试精度：</p>
<p>总结：看完这篇文献，感觉没看到什么比较牛逼的创新点，只是把Alexnet网络改一改而已，个人感觉AlexNet的一些算法已经过时了，现在各种最新牛逼文献的算法一大堆，随便找一个，调一调参，应该可以得到更高的精度，因为毕竟图片分类的算法更新太快了。年龄预测方面，因为自己的项目用不到，而且年龄预测这个东西，精度一向很低，很容易受光照、拍摄角度等因素影响，即便是我们人类，也很难精确判断一个人的年龄，有的人五十几岁了，但是看起来却很年轻……</p>
<p>PS：赶紧研究深度学习算法去，现在大部分深度学习的文章，有的文献只是稍微改一下参数、改一下结构，然后发现精度state-of-art，于是发表paper，很容易就被录用了。</p>
<p>参考文献：</p>
<p>1、《Age and Gender Classification using Convolutional Neural Networks》</p>
<p>2、《ImageNet Classification with Deep Convolutional Neural Networks》</p>
<p>3、<a href="http://www.openu.ac.il/home/hassner/projects/cnn_agegender/" target="_blank" rel="noopener">http://www.openu.ac.il/home/hassner/projects/cnn_agegender/</a></p>
<p>４、<a href="https://github.com/BVLC/caffe/wiki/Model-Zoo" target="_blank" rel="noopener">https://github.com/BVLC/caffe/wiki/Model-Zoo</a> </p>
<p><strong><strong><strong>***</strong></strong></strong>作者：hjimce   时间：2015.10.15  联系QQ：1393852684 <strong><strong><strong>***</strong></strong></strong>  </p>
<p><strong><strong><strong>**</strong></strong></strong>原创文章，转载请保留原文地址、作者等信息<strong><strong><strong>***</strong></strong></strong></p>
<p>附：基于 CNN的年龄和性别检测 </p>
<pre><code>CNN年龄、性别、表情识别

Age and Gender Classification using Convolutional Neural Networks

     project link：http://www.openu.ac.il/home/hassner/projects/cnn_agegender/
</code></pre>]]></content>
      <tags>
        <tag>CNN,年龄和性别检测</tag>
      </tags>
  </entry>
  <entry>
    <title>基于遗传算法的自动拼图(一）</title>
    <url>/2018/09/27/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%BC%E5%9B%BE-%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>参考自github项目 <a href="https://github.com/nemanja-m/gaps" target="_blank" rel="noopener">https://github.com/nemanja-m/gaps</a></p>
<p>加了注释及自己的理解<br><a id="more"></a></p>
<p>先选择一张图片 男神镇楼<br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fvqtjgw27xj30g90bwn5b.jpg" alt></p>
<h2 id="把一张图片变成拼图"><a href="#把一张图片变成拼图" class="headerlink" title="把一张图片变成拼图"></a>把一张图片变成拼图</h2><!--more-->
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def create_puzzle(image_path, output_path, piece_size):</span><br><span class="line">    image = cv2.imread(image_path)</span><br><span class="line">    pieces, rows, columns = image_helpers.flatten_image(image, piece_size)</span><br><span class="line"></span><br><span class="line">    # Randomize pieces in order to make puzzle</span><br><span class="line">    np.random.shuffle(pieces)</span><br><span class="line"></span><br><span class="line">    # Create puzzle by stacking pieces</span><br><span class="line">    puzzle = image_helpers.assemble_image(pieces, rows, columns)</span><br><span class="line">	# 把拼图写入指定路径</span><br><span class="line">    cv2.imwrite(output_path, puzzle)</span><br><span class="line">    print_messages([&quot;Puzzle created with &#123;&#125; pieces&quot;.format(len(pieces))])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def flatten_image(image, piece_size, indexed=False):</span><br><span class="line">    #//是整除符号</span><br><span class="line">    #每块碎片大小都一样 所给图片能整除这块碎片的宽和高</span><br><span class="line">    rows, columns = image.shape[0] // piece_size, image.shape[1] // piece_size</span><br><span class="line">    pieces = []</span><br><span class="line"></span><br><span class="line">    # Crop pieces from original image</span><br><span class="line">    for y in range(rows):</span><br><span class="line">        for x in range(columns):</span><br><span class="line">            left, top, w, h = x * piece_size, y * piece_size, (x + 1) * piece_size, (y + 1) * piece_size</span><br><span class="line">            piece = np.empty((piece_size, piece_size, image.shape[2]))</span><br><span class="line">            piece[:piece_size, :piece_size, :] = image[top:h, left:w, :]</span><br><span class="line">            pieces.append(piece)</span><br><span class="line"></span><br><span class="line">    if indexed:</span><br><span class="line">        pieces = [Piece(value, index) for index, value in enumerate(pieces)]</span><br><span class="line"></span><br><span class="line">    return pieces, rows, columns</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> class Piece(object):</span><br><span class="line"> &quot;&quot;&quot;</span><br><span class="line">  Usage::</span><br><span class="line"></span><br><span class="line">        &gt;&gt;&gt; from gaps.piece import Piece</span><br><span class="line">        &gt;&gt;&gt; piece = Piece(image[:28, :28, :], 42)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, image, index):</span><br><span class="line">        self.image = image[:]</span><br><span class="line">        self.id = index</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        return self.image.__getitem__(index)</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        &quot;&quot;&quot;Returns piece size&quot;&quot;&quot;</span><br><span class="line">        return self.image.shape[0]</span><br><span class="line"></span><br><span class="line">    def shape(self):</span><br><span class="line">        &quot;&quot;&quot;Returns shape of piece&apos;s image&quot;&quot;&quot;</span><br><span class="line">        return self.image.shape</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def assemble_image(pieces, rows, columns):</span><br><span class="line">   ##竖直的栈</span><br><span class="line">   vertical_stack = []</span><br><span class="line">   for i in range(rows):</span><br><span class="line">       ##水平的栈</span><br><span class="line">       horizontal_stack = []</span><br><span class="line">       for j in range(columns):</span><br><span class="line">           horizontal_stack.append(pieces[i * columns + j])</span><br><span class="line">       vertical_stack.append(np.hstack(horizontal_stack))</span><br><span class="line">   return np.vstack(vertical_stack).astype(np.uint8)</span><br></pre></td></tr></table></figure>
<p> <img src="https://ws1.sinaimg.cn/large/006wtREyly1fvo9ehcoeoj30fg0boaap.jpg" alt></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p> 关于 hstack和vstack函数<br> <a href="https://blog.csdn.net/garfielder007/article/details/51378296" target="_blank" rel="noopener">https://blog.csdn.net/garfielder007/article/details/51378296</a></p>
<p> <a href="https://blog.csdn.net/csdn15698845876/article/details/73380803" target="_blank" rel="noopener">https://blog.csdn.net/csdn15698845876/article/details/73380803</a></p>
]]></content>
      <categories>
        <category>MachineLearning</category>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>基于遗传算法的自动拼图(三)</title>
    <url>/2018/09/29/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%BC%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="交叉配对"><a href="#交叉配对" class="headerlink" title="交叉配对"></a>交叉配对</h2><a id="more"></a>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Crossover(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, first_parent, second_parent):</span><br><span class="line">        self._parents = (first_parent, second_parent)</span><br><span class="line">        self._pieces_length = len(first_parent.pieces)</span><br><span class="line"></span><br><span class="line">        self._child_rows = first_parent.rows</span><br><span class="line">        self._child_columns = first_parent.columns</span><br><span class="line"></span><br><span class="line">        # Borders of growing kernel</span><br><span class="line">        self._min_row = 0</span><br><span class="line">        self._max_row = 0</span><br><span class="line">        self._min_column = 0</span><br><span class="line">        self._max_column = 0</span><br><span class="line"> # 初始化第一哥小拼图块的位置(0,0)，如果其下方没有拼图快，则可以在(0,-1)处继续放拼图块 此时min_row=-1</span><br><span class="line">        </span><br><span class="line">        #字典&#123;piece_id：(row, column)&#125;</span><br><span class="line">        self._kernel = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        self._taken_positions = set()</span><br><span class="line"></span><br><span class="line">        # Priority queue</span><br><span class="line">        #[(priority, (position, piece_id), relative_piece(piece_id, orientation))]</span><br><span class="line">        self._candidate_pieces = []</span><br></pre></td></tr></table></figure>
<h3 id="run函数"><a href="#run函数" class="headerlink" title="run函数"></a>run函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def run(self):</span><br><span class="line">    self._initialize_kernel()</span><br><span class="line"></span><br><span class="line">    while len(self._candidate_pieces) &gt; 0:</span><br><span class="line">        _, (position, piece_id), relative_piece = heapq.heappop(self._candidate_pieces)</span><br><span class="line"></span><br><span class="line">        if position in self._taken_positions:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        # If piece is already placed, find new piece candidate and put it back to</span><br><span class="line">        # priority queue</span><br><span class="line">        if piece_id in self._kernel:</span><br><span class="line">            self.add_piece_candidate(relative_piece[0], relative_piece[1], position)</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        self._put_piece_to_kernel(piece_id, position)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _initialize_kernel(self):</span><br><span class="line">        root_piece = self._parents[0].pieces[int(random.uniform(0, self._pieces_length))]</span><br><span class="line">        self._put_piece_to_kernel(root_piece.id, (0, 0))</span><br><span class="line"></span><br><span class="line">    def _put_piece_to_kernel(self, piece_id, position):</span><br><span class="line">        self._kernel[piece_id] = position</span><br><span class="line">        self._taken_positions.add(position)</span><br><span class="line">        self._update_candidate_pieces(piece_id, position)</span><br><span class="line"></span><br><span class="line">    def _update_candidate_pieces(self, piece_id, position):</span><br><span class="line">        available_boundaries = self._available_boundaries(position)</span><br><span class="line"></span><br><span class="line">        for orientation, position in available_boundaries:</span><br><span class="line">            #原拼图块，方向，空着的拼图块的位置</span><br><span class="line">            self.add_piece_candidate(piece_id, orientation, position)</span><br><span class="line"></span><br><span class="line">    def add_piece_candidate(self, piece_id, orientation, position):</span><br><span class="line">        #返回父母共享的那个方向的拼图块的id</span><br><span class="line">        shared_piece = self._get_shared_piece(piece_id, orientation)</span><br><span class="line">        if self._is_valid_piece(shared_piece):</span><br><span class="line">        #共享块的ID,坐标，原相邻拼图块的ID,相对于原相邻拼图块的方向</span><br><span class="line">            self._add_shared_piece_candidate(shared_piece, position, (piece_id, orientation))</span><br><span class="line">            return</span><br><span class="line">        #如果没有父母共享的那个方向的拼图块的id</span><br><span class="line">        #根据色差相似度fitness比较 返回跟父母中某一个一样相似的拼图块ID</span><br><span class="line">        buddy_piece = self._get_buddy_piece(piece_id, orientation)</span><br><span class="line">        if self._is_valid_piece(buddy_piece):</span><br><span class="line">        #相似块的ID,坐标，原相邻拼图块的ID,相对于原相邻拼图块的方向</span><br><span class="line">            self._add_buddy_piece_candidate(buddy_piece, position, (piece_id, orientation))</span><br><span class="line">            return</span><br><span class="line">        #如果和父母都不相似</span><br><span class="line">        #返回根据色差相似度fitness比较 最佳匹配的拼图块</span><br><span class="line">        best_match_piece, priority = self._get_best_match_piece(piece_id, orientation)</span><br><span class="line">        if self._is_valid_piece(best_match_piece):</span><br><span class="line">            self._add_best_match_piece_candidate(best_match_piece, position, priority, (piece_id, orientation))</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">    def _get_shared_piece(self, piece_id, orientation):</span><br><span class="line">        first_parent, second_parent = self._parents</span><br><span class="line">        first_parent_edge = first_parent.edge(piece_id, orientation)</span><br><span class="line">        second_parent_edge = second_parent.edge(piece_id, orientation)</span><br><span class="line"></span><br><span class="line">        if first_parent_edge == second_parent_edge:</span><br><span class="line">            return first_parent_edge</span><br><span class="line"></span><br><span class="line">    def _get_buddy_piece(self, piece_id, orientation):</span><br><span class="line">        first_buddy = ImageAnalysis.best_match(piece_id, orientation)</span><br><span class="line">        second_buddy = ImageAnalysis.best_match(first_buddy, complementary_orientation(orientation))</span><br><span class="line"></span><br><span class="line">        if second_buddy == piece_id:</span><br><span class="line">            #和父母中任何一个的edge的一样即可</span><br><span class="line">            for edge in [parent.edge(piece_id, orientation) for parent in self._parents]:</span><br><span class="line">                if edge == first_buddy:</span><br><span class="line">                    return edge</span><br><span class="line"></span><br><span class="line">    def _get_best_match_piece(self, piece_id, orientation):</span><br><span class="line">        for piece, dissimilarity_measure in ImageAnalysis.best_match_table[piece_id][orientation]:</span><br><span class="line">            if self._is_valid_piece(piece):</span><br><span class="line">                return piece, dissimilarity_measure</span><br><span class="line"></span><br><span class="line">    def _add_shared_piece_candidate(self, piece_id, position, relative_piece):</span><br><span class="line">        piece_candidate = (SHARED_PIECE_PRIORITY, (position, piece_id), relative_piece)</span><br><span class="line">        heapq.heappush(self._candidate_pieces, piece_candidate)</span><br></pre></td></tr></table></figure>
<h3 id="判断该拼图块是否合理-is-valid-piece"><a href="#判断该拼图块是否合理-is-valid-piece" class="headerlink" title="判断该拼图块是否合理 is_valid_piece"></a>判断该拼图块是否合理 is_valid_piece</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _is_valid_piece(self, piece_id):</span><br><span class="line">    return piece_id is not None and piece_id not in self._kernel</span><br></pre></td></tr></table></figure>
<h3 id="返回其子代"><a href="#返回其子代" class="headerlink" title="返回其子代"></a>返回其子代</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def child(self):</span><br><span class="line">    pieces = [None] * self._pieces_length</span><br><span class="line"></span><br><span class="line">    for piece, (row, column) in self._kernel.items():</span><br><span class="line">        index = (row - self._min_row) * self._child_columns + (column - self._min_column)</span><br><span class="line">        pieces[index] = self._parents[0].piece_by_id(piece)</span><br><span class="line">    #通过piece的id找到id对应的那一块拼图</span><br><span class="line">    return Individual(pieces, self._child_rows, self._child_columns, shuffle=False)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MachineLearning</category>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>基于遗传算法的自动拼图(四）</title>
    <url>/2018/09/29/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%BC%E5%9B%BE-%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="拼图的主函数"><a href="#拼图的主函数" class="headerlink" title="拼图的主函数"></a>拼图的主函数</h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 参数处理 </span><br><span class="line">## 参数依次为:输入的拼图,迭代次数,种群大小,一小块拼图的尺寸,是否显示每次迭代完最适应的拼图的解决方案，保存拼图结果图片</span><br><span class="line">## default则为默认参数</span><br><span class="line">def parse_arguments():</span><br><span class="line">    parser = argparse.ArgumentParser(description=&quot;A Genetic based solver for jigsaw puzzles&quot;)</span><br><span class="line">    parser.add_argument(&quot;--image&quot;, type=str, default=&quot;2.jpg&quot;, help=&quot;Input image.&quot;)</span><br><span class="line">    parser.add_argument(&quot;--generations&quot;, type=int, default=GENERATIONS, help=&quot;Num of generations.&quot;)</span><br><span class="line">    parser.add_argument(&quot;--population&quot;, type=int, default=POPULATION, help=&quot;Size of population.&quot;)</span><br><span class="line">    parser.add_argument(&quot;--size&quot;, type=int, help=&quot;Single piece size in pixels.&quot;)</span><br><span class="line">    parser.add_argument(&quot;--verbose&quot;, action=&quot;store_true&quot;,default=True,help=&quot;Show best individual after each generation.&quot;)</span><br><span class="line">    parser.add_argument(&quot;--save&quot;, action=&quot;store_true&quot;, help=&quot;Save puzzle result as image.&quot;)</span><br><span class="line">    return parser.parse_args()</span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    args = parse_arguments()</span><br><span class="line">    image = cv2.imread(args.image)</span><br><span class="line">    #在OpenCV中，图像不是用常规的RGB颜色通道来存储的，它们用的是BGR顺序</span><br><span class="line">    # 当读取一幅图像后，默认的是BGR</span><br><span class="line">    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">    if args.size is not None:</span><br><span class="line">        piece_size = args.size</span><br><span class="line">    else:</span><br><span class="line">        detector = SizeDetector(image)</span><br><span class="line">        piece_size = detector.detect_piece_size()</span><br><span class="line"></span><br><span class="line">    print(&quot;\n=== Population:  &#123;&#125;&quot;.format(args.population))</span><br><span class="line">    print(&quot;=== Generations: &#123;&#125;&quot;.format(args.generations))</span><br><span class="line">    print(&quot;=== Piece size:  &#123;&#125; px&quot;.format(piece_size))</span><br><span class="line"></span><br><span class="line">    # Let the games begin! And may the odds be in your favor!</span><br><span class="line">    start = time()</span><br><span class="line">    algorithm = GeneticAlgorithm(image, piece_size, args.population, args.generations)</span><br><span class="line">    solution = algorithm.start_evolution(args.verbose)</span><br><span class="line">    end = time()</span><br><span class="line"></span><br><span class="line">    print(&quot;\n=== Done in &#123;0:.3f&#125; s&quot;.format(end - start))</span><br><span class="line"></span><br><span class="line">    solution_image = solution.to_image()</span><br><span class="line">    solution_image_name = args.image.split(&quot;.&quot;)[0] + &quot;_solution.jpg&quot;</span><br><span class="line"></span><br><span class="line">    if args.save:</span><br><span class="line">        cv2.imwrite(solution_image_name, solution_image)</span><br><span class="line">        print(&quot;=== Result saved as &apos;&#123;&#125;&apos;&quot;.format(solution_image_name))</span><br><span class="line"></span><br><span class="line">    print(&quot;=== Close figure to exit&quot;)</span><br><span class="line">    show_image(solution_image, &quot;Solution&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="plot画图"><a href="#plot画图" class="headerlink" title="plot画图"></a>plot画图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Plot(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, image, title=&quot;Initial problem&quot;):</span><br><span class="line">        aspect_ratio = image.shape[0] / float(image.shape[1])</span><br><span class="line"></span><br><span class="line">        width = 8</span><br><span class="line">        height = width * aspect_ratio</span><br><span class="line">        #定义一个图像窗口,没有边框</span><br><span class="line">        fig = plt.figure(figsize=(width, height), frameon=False)</span><br><span class="line"></span><br><span class="line">        # Let image fill the figure</span><br><span class="line">        ax = plt.Axes(fig, [0., 0., 1., .9])</span><br><span class="line">        ax.set_axis_off()</span><br><span class="line">        fig.add_axes(ax)</span><br><span class="line"></span><br><span class="line">        self._current_image = ax.imshow(image, aspect=&quot;auto&quot;, animated=True)</span><br><span class="line">        self.show_fittest(image, title)</span><br><span class="line"></span><br><span class="line">    def show_fittest(self, image, title):</span><br><span class="line">        ##添加标题在正上方</span><br><span class="line">        plt.suptitle(title, fontsize=20)</span><br><span class="line">        self._current_image.set_data(image)</span><br><span class="line">        plt.draw()</span><br><span class="line"></span><br><span class="line">        # Give pyplot 0.05s to draw image</span><br><span class="line">        plt.pause(0.05)</span><br></pre></td></tr></table></figure>
<h2 id="函数参考链接"><a href="#函数参考链接" class="headerlink" title="函数参考链接"></a>函数参考链接</h2><p><a href="https://www.jianshu.com/p/dcecaf62da71" target="_blank" rel="noopener">https://www.jianshu.com/p/dcecaf62da71</a><br><a href="https://blog.csdn.net/hjxu2016/article/details/77833336" target="_blank" rel="noopener">https://blog.csdn.net/hjxu2016/article/details/77833336</a></p>
<h3 id="threshold函数的使用"><a href="#threshold函数的使用" class="headerlink" title="threshold函数的使用"></a>threshold函数的使用</h3><p><a href="https://blog.csdn.net/u012566751/article/details/77046445" target="_blank" rel="noopener">https://blog.csdn.net/u012566751/article/details/77046445</a><br><a href="https://blog.csdn.net/keith_bb/article/details/54617625" target="_blank" rel="noopener">https://blog.csdn.net/keith_bb/article/details/54617625</a></p>
<h3 id="findContours函数"><a href="#findContours函数" class="headerlink" title="findContours函数"></a>findContours函数</h3><p><a href="https://blog.csdn.net/qq_18343569/article/details/47982045" target="_blank" rel="noopener">https://blog.csdn.net/qq_18343569/article/details/47982045</a><br><a href="https://www.jianshu.com/p/4bc3349b4611" target="_blank" rel="noopener">https://www.jianshu.com/p/4bc3349b4611</a><br><a href="https://blog.csdn.net/dcrmg/article/details/51987348" target="_blank" rel="noopener">https://blog.csdn.net/dcrmg/article/details/51987348</a></p>
<h3 id="bisect函数"><a href="#bisect函数" class="headerlink" title="bisect函数"></a>bisect函数</h3><p>数组二分算法<br><a href="https://www.cnblogs.com/skydesign/archive/2011/09/02/2163592.html" target="_blank" rel="noopener">https://www.cnblogs.com/skydesign/archive/2011/09/02/2163592.html</a></p>
<h2 id="腐蚀与膨胀"><a href="#腐蚀与膨胀" class="headerlink" title="腐蚀与膨胀"></a>腐蚀与膨胀</h2><p><a href="http://ex2tron.top/2017/12/19/Python-OpenCV%E6%95%99%E7%A8%8B12%EF%BC%9A%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/" target="_blank" rel="noopener">http://ex2tron.top/2017/12/19/Python-OpenCV%E6%95%99%E7%A8%8B12%EF%BC%9A%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/</a></p>
<h3 id="bitwise-not函数"><a href="#bitwise-not函数" class="headerlink" title="bitwise_not函数"></a>bitwise_not函数</h3><p><a href="https://blog.csdn.net/u011028345/article/details/77278467" target="_blank" rel="noopener">https://blog.csdn.net/u011028345/article/details/77278467</a></p>
<h3 id="matplotlib的axes使用"><a href="#matplotlib的axes使用" class="headerlink" title="matplotlib的axes使用"></a>matplotlib的axes使用</h3><p><a href="https://ask.hellobi.com/blog/yuguiyang1990/9252" target="_blank" rel="noopener">https://ask.hellobi.com/blog/yuguiyang1990/9252</a><br><a href="https://blog.csdn.net/Feynman1999/article/details/80280556" target="_blank" rel="noopener">https://blog.csdn.net/Feynman1999/article/details/80280556</a></p>
<h3 id="max中运用lambda表达式"><a href="#max中运用lambda表达式" class="headerlink" title="max中运用lambda表达式"></a>max中运用lambda表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=&#123;&apos;28&apos;:1,&apos;33&apos;:4,&apos;44&apos;:5&#125;</span><br><span class="line">t=max(a,key=a.get) #key后面的是函数名</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Out[1]: &apos;44&apos;</span><br></pre></td></tr></table></figure>
<p><a href="https://code.i-harness.com/zh-CN/q/1172fb3" target="_blank" rel="noopener">https://code.i-harness.com/zh-CN/q/1172fb3</a><br><a href="http://zhoufeng1989.github.io/Key-parameter-in-max-min-sorted/" target="_blank" rel="noopener">http://zhoufeng1989.github.io/Key-parameter-in-max-min-sorted/</a></p>
<h2 id="python下划线"><a href="#python下划线" class="headerlink" title="python下划线"></a>python下划线</h2><p><a href="https://blog.csdn.net/hudiedd/article/details/12581485" target="_blank" rel="noopener">https://blog.csdn.net/hudiedd/article/details/12581485</a></p>
]]></content>
      <categories>
        <category>MachineLearning</category>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>基于遗传算法的自动拼图(二)</title>
    <url>/2018/09/29/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%BC%E5%9B%BE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="适应度度量"><a href="#适应度度量" class="headerlink" title="适应度度量"></a>适应度度量</h2><p>两块拼图如果拼在一块的话 则Left-Right方向 相邻的两列色差较小。同理Top-down方向相邻两行的色差会较小<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dissimilarity_measure(first_piece, second_piece, orientation=&quot;LR&quot;):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">依据：在所有颜色通道上的所有相邻像素上的颜色差异。</span><br><span class="line">原始图像中相邻的拼图块趋于共享</span><br><span class="line">类似的颜色沿其邻接边缘，即，即所有相邻像素的平方色差之和</span><br><span class="line">(在所有三个颜色带上)</span><br><span class="line">应该是最小的。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">    rows, columns, _ = first_piece.shape()</span><br><span class="line">    color_difference = None</span><br><span class="line"></span><br><span class="line">    # | L | - | R |</span><br><span class="line">    if orientation == &quot;LR&quot;:</span><br><span class="line">        color_difference = first_piece[:rows, columns - 1, :] - second_piece[:rows, 0, :]</span><br><span class="line"></span><br><span class="line">    # | T |</span><br><span class="line">    #   |</span><br><span class="line">    # | D |</span><br><span class="line">    if orientation == &quot;TD&quot;:</span><br><span class="line">        color_difference = first_piece[rows - 1, :columns, :] - second_piece[0, :columns, :]</span><br><span class="line"></span><br><span class="line">    squared_color_difference = np.power(color_difference / 255.0, 2)</span><br><span class="line">    #行相加</span><br><span class="line">    color_difference_per_row = np.sum(squared_color_difference, axis=1)</span><br><span class="line">    #列相加</span><br><span class="line">    total_difference = np.sum(color_difference_per_row, axis=0)</span><br><span class="line"></span><br><span class="line">    value = np.sqrt(total_difference)</span><br><span class="line"></span><br><span class="line">    return value</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#个体：拼图的一种解决方案</span><br><span class="line">class Individual(object):</span><br><span class="line">    def __init__(self, pieces, rows, columns, shuffle=True):</span><br><span class="line">        self.pieces = pieces[:]</span><br><span class="line">        self.rows = rows</span><br><span class="line">        self.columns = columns</span><br><span class="line">        self._fitness = None</span><br><span class="line">#python装饰器 把一个getter方法变成属性，只需要加上@property就可以了</span><br><span class="line">    @property</span><br><span class="line">    def fitness(self):</span><br><span class="line">        &quot;&quot;&quot;Evaluates fitness value.</span><br><span class="line"></span><br><span class="line">        Fitness value is calculated as sum of dissimilarity measures between each adjacent pieces.</span><br><span class="line">        适应度值是计算每个相邻块之间不同度量值的总和。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self._fitness is None:</span><br><span class="line">            fitness_value = 1 / self.FITNESS_FACTOR</span><br><span class="line">            # For each two adjacent pieces in rows</span><br><span class="line">            for i in range(self.rows):</span><br><span class="line">                for j in range(self.columns - 1):</span><br><span class="line">                    ids = (self[i][j].id, self[i][j + 1].id)</span><br><span class="line">                    fitness_value += ImageAnalysis.get_dissimilarity(ids, orientation=&quot;LR&quot;)</span><br><span class="line">            # For each two adjacent pieces in columns</span><br><span class="line">            for i in range(self.rows - 1):</span><br><span class="line">                for j in range(self.columns):</span><br><span class="line">                    ids = (self[i][j].id, self[i + 1][j].id)</span><br><span class="line">                    fitness_value += ImageAnalysis.get_dissimilarity(ids, orientation=&quot;TD&quot;)</span><br><span class="line"></span><br><span class="line">            self._fitness = self.FITNESS_FACTOR / fitness_value</span><br><span class="line"></span><br><span class="line">        return self._fitness</span><br></pre></td></tr></table></figure>
<h2 id="轮盘赌选择法"><a href="#轮盘赌选择法" class="headerlink" title="轮盘赌选择法"></a>轮盘赌选择法</h2><p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fvsqaf84jpj30dw0g7tc5.jpg" alt><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fvsqayw9hsj30dv02aaal.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#轮盘赌选择</span><br><span class="line">def roulette_selection(population, elites=4):</span><br><span class="line">    &quot;&quot;&quot;Roulette wheel selection.</span><br><span class="line"></span><br><span class="line">    Each individual is selected to reproduce, with probability directly</span><br><span class="line">    proportional to its fitness score.</span><br><span class="line"></span><br><span class="line">    :params population: Collection of the individuals for selecting.</span><br><span class="line">    :params elite: Number of elite individuals passed to next generation.</span><br><span class="line"></span><br><span class="line">    Usage::</span><br><span class="line"></span><br><span class="line">        &gt;&gt;&gt; from gaps.selection import roulette_selection</span><br><span class="line">        &gt;&gt;&gt; selected_parents = roulette_selection(population, 10)</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    fitness_values = [individual.fitness for individual in population]</span><br><span class="line">    probability_intervals = [sum(fitness_values[:i + 1]) for i in range(len(fitness_values))]</span><br><span class="line">    def select_individual():</span><br><span class="line">        &quot;&quot;&quot;Selects random individual from population based on fitess value&quot;&quot;&quot;</span><br><span class="line">        random_select = random.uniform(0, probability_intervals[-1])</span><br><span class="line">        selected_index = bisect.bisect_left(probability_intervals, random_select)</span><br><span class="line">        return population[selected_index]</span><br><span class="line"></span><br><span class="line">    selected = []</span><br><span class="line">    for i in xrange(len(population) - elites):</span><br><span class="line">        first, second = select_individual(), select_individual()</span><br><span class="line">        selected.append((first, second))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return selected</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/zheng_zhiwei/article/details/23209729" target="_blank" rel="noopener">https://blog.csdn.net/zheng_zhiwei/article/details/23209729</a><br><a href="https://www.cnblogs.com/adelaide/articles/5679475.html" target="_blank" rel="noopener">https://www.cnblogs.com/adelaide/articles/5679475.html</a></p>
]]></content>
      <categories>
        <category>MachineLearning</category>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>复习BST树(java)</title>
    <url>/2018/05/21/%E5%A4%8D%E4%B9%A0BST%E6%A0%91-java/</url>
    <content><![CDATA[<p>BST树算法掌握不够熟练 对递归有了更深的了解<br>找最大，最小节点，插入节点，查找节点，遍历不算太难 注意细心<br>删除某个节点有三种可能（考虑root节点是否为空）<br>1.删除叶子节点</p>
<p>2.删除只有左子树或者只有右子树的节点（要考虑它是否为根节点，考虑它是父节点的左孩子还是右孩子）</p>
<p>3.删除既有左子树也有右子树的节点（找大于它的最小值—-&gt;找右子树中最左边的节点，替换该节点位置的值，并删除这个最左边的节点（要考虑这个节点是否有右子树，是父节点的左孩子还是右孩子))<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package solution;</span><br><span class="line"></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">	int value;</span><br><span class="line">	TreeNode parent;</span><br><span class="line">	TreeNode left;</span><br><span class="line">	TreeNode right;</span><br><span class="line">	public TreeNode(int val) &#123;</span><br><span class="line">		this.value = val;</span><br><span class="line">		this.left = this.right = null;</span><br><span class="line">	&#125;</span><br><span class="line">	public TreeNode(int value, TreeNode parent, TreeNode left, TreeNode right) &#123;</span><br><span class="line">		this.value = value;</span><br><span class="line">		this.parent = parent;</span><br><span class="line">		this.left = left;</span><br><span class="line">		this.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setParent(TreeNode parent )</span><br><span class="line">	&#123;</span><br><span class="line">		this.parent=parent;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setLeft(TreeNode x )</span><br><span class="line">	&#123;</span><br><span class="line">		this.left=x;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setRight(TreeNode x )</span><br><span class="line">	&#123;</span><br><span class="line">		this.right=x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">	public static TreeNode getMax(TreeNode root) &#123;</span><br><span class="line">		if (root == null) // 注意判断root为空的情况</span><br><span class="line">			return null;</span><br><span class="line">		while (root.right != null)</span><br><span class="line">			root = root.right;</span><br><span class="line">		return root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static TreeNode getMin(TreeNode root) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			return null;</span><br><span class="line">		while (root.left != null)</span><br><span class="line">			root = root.left;</span><br><span class="line">		return root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static TreeNode pre(TreeNode root, TreeNode x) &#123;</span><br><span class="line">		if (x.left != null)// 有左子树找左子树的最大的</span><br><span class="line">			return getMax(x.left);</span><br><span class="line">		else &#123;</span><br><span class="line">			TreeNode p = x.parent;</span><br><span class="line">			while (p != null &amp;&amp; p.left == x) &#123;</span><br><span class="line">				x = p;</span><br><span class="line">				p = p.parent;</span><br><span class="line">			&#125;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static TreeNode post(TreeNode root, TreeNode x) &#123;</span><br><span class="line">		if (x.right != null)// 有右子树找右子树的最小的</span><br><span class="line">			return getMin(x.right);</span><br><span class="line">		else &#123;</span><br><span class="line">			TreeNode p = x.parent;// 来记录父节点</span><br><span class="line">			while (p != null &amp;&amp; p.right == x) &#123;</span><br><span class="line">				x = p;</span><br><span class="line">				p = p.parent;</span><br><span class="line">			&#125;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static TreeNode search1(TreeNode root, int val) &#123;//注意递归条件</span><br><span class="line">		if (root == null)</span><br><span class="line">			return null;</span><br><span class="line">		if (val &lt; root.value)</span><br><span class="line">			return search1(root.left, val);</span><br><span class="line">		else if (val &gt; root.value)</span><br><span class="line">		return	search1(root.right, val);//**不可以少写return**</span><br><span class="line"></span><br><span class="line">		 return root;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static TreeNode search2(TreeNode root, int val) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			return null;</span><br><span class="line">		while (root != null) &#123;</span><br><span class="line">			if (val &lt; root.value)</span><br><span class="line">				root = root.left;</span><br><span class="line">			else if (val &gt; root.value)</span><br><span class="line">				root = root.right;</span><br><span class="line">			else</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">		return root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static TreeNode insert1(TreeNode root, TreeNode x) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			root = x;</span><br><span class="line">		if (x.value &lt; root.value)</span><br><span class="line">			root.left = insert1(root.left, x);</span><br><span class="line">		if (x.value &gt; root.value)</span><br><span class="line">			root.right = insert1(root.right, x);</span><br><span class="line">		return root;// 记录根节点并返回</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static TreeNode insert2(TreeNode root, TreeNode x) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			root = x;</span><br><span class="line">		TreeNode p = null;// 来记录父节点</span><br><span class="line">		while (root != null) &#123;</span><br><span class="line">			p = root;</span><br><span class="line">			if (x.value &lt; root.value)</span><br><span class="line">				root = root.left;</span><br><span class="line">			if (x.value &gt; root.value)</span><br><span class="line">				root = root.right;</span><br><span class="line">		&#125;</span><br><span class="line">		x.parent = p;</span><br><span class="line">		if (x.value &lt; p.value)</span><br><span class="line">			p.left = x;</span><br><span class="line">		else</span><br><span class="line">			p.right = x;</span><br><span class="line">		return root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void delete(TreeNode root, TreeNode x) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			return;</span><br><span class="line">		TreeNode p = null;</span><br><span class="line">		while (root != null) &#123;</span><br><span class="line">			if (x.value &lt; root.value)</span><br><span class="line">				</span><br><span class="line">			&#123;</span><br><span class="line">				p = root;//**不可以放在if外面**</span><br><span class="line">				root = root.left;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			else if (x.value &gt; root.value)</span><br><span class="line">			&#123;</span><br><span class="line">				p = root;</span><br><span class="line">				root = root.right;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">			else &#123;</span><br><span class="line">				if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">					p.left = null;</span><br><span class="line">					p.right = null;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				else if (root.left != null &amp;&amp; root.right == null) &#123;</span><br><span class="line">					if (p == null)</span><br><span class="line">						root = root.left;</span><br><span class="line">					else &#123;</span><br><span class="line">						// 如果是一个节点的左孩子</span><br><span class="line">						if (p.left == root)</span><br><span class="line">							p.left = root.left;</span><br><span class="line">						// 如果是一个节点的右孩子</span><br><span class="line">						if (p.right == root)</span><br><span class="line">							p.right = root.left;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else if (root.right != null &amp;&amp; root.left == null) &#123;</span><br><span class="line">					if (p == null)</span><br><span class="line">						root = root.right;</span><br><span class="line">					else &#123;</span><br><span class="line">						// 如果是一个节点的左孩子</span><br><span class="line">						if (p.left == root)</span><br><span class="line">							p.left = root.right;</span><br><span class="line">						// 如果是一个节点的右孩子</span><br><span class="line">						if (p.right == root)</span><br><span class="line">							p.right = root.right;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				// 有两个孩子的情况</span><br><span class="line">				else &#123;</span><br><span class="line">					TreeNode rmin = root.right;</span><br><span class="line">					TreeNode rminp = null;</span><br><span class="line">					while (rmin.left != null) &#123;</span><br><span class="line">						rminp = rmin;</span><br><span class="line">						rmin = rmin.left;</span><br><span class="line">					&#125;</span><br><span class="line">					root.value = rmin.value;</span><br><span class="line">					if (rminp.left == rmin)// 如果要删的节点是父节点的左孩子</span><br><span class="line">						rminp.left = rmin.right;</span><br><span class="line">					if (rminp.right == rmin)// 如果要删的节点是父节点的右孩子</span><br><span class="line">						rminp.right = rmin.right;</span><br><span class="line">				&#125;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void tranverse(TreeNode root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(root==null) return;</span><br><span class="line">		System.out.println(root.value);</span><br><span class="line">		if(root.left!=null) tranverse(root.left);</span><br><span class="line">		if(root.right!=null) tranverse(root.right);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode node12=new TreeNode(12);</span><br><span class="line">		TreeNode node16=new TreeNode(16);</span><br><span class="line">		TreeNode node17=new TreeNode(17);</span><br><span class="line">		TreeNode node14=new TreeNode(14);</span><br><span class="line">		TreeNode node10=new TreeNode(10);</span><br><span class="line">		TreeNode node11=new TreeNode(11);</span><br><span class="line">		TreeNode node5=new TreeNode(5);</span><br><span class="line">		node5.setParent(node10);</span><br><span class="line">		node12.setParent(node11);</span><br><span class="line">		node16.setParent(node17);</span><br><span class="line">		node11.setRight(node12);</span><br><span class="line">		node11.setParent(node14);</span><br><span class="line">		node17.setLeft(node16);</span><br><span class="line">		node17.setParent(node14);</span><br><span class="line">		node14.setLeft(node11);</span><br><span class="line">		node14.setRight(node17);</span><br><span class="line">		node14.setParent(node10);</span><br><span class="line">		node10.setLeft(node5);</span><br><span class="line">		node10.setRight(node14);</span><br><span class="line">		TreeNode max=getMax(node10);</span><br><span class="line">		System.out.println(&quot;max:&quot;+max.value);</span><br><span class="line">		TreeNode min=getMin(node10);</span><br><span class="line">		System.out.println(&quot;min:&quot;+min.value);</span><br><span class="line">		TreeNode x=new TreeNode(12);</span><br><span class="line">		TreeNode y=new TreeNode(14);</span><br><span class="line">		System.out.println(&quot;\n删除12:&quot;);</span><br><span class="line">		delete(node10, x);</span><br><span class="line">		tranverse(node10);</span><br><span class="line">		System.out.println(&quot;\n插入12:&quot;);</span><br><span class="line">		insert1(node10, x);</span><br><span class="line">		tranverse(node10);</span><br><span class="line">		TreeNode t=search1(node10, 14);</span><br><span class="line">		System.out.println(&quot;查找14的节点的父节点值&quot;+t.parent.value);</span><br><span class="line">		System.out.println(&quot;\n删除14:&quot;);</span><br><span class="line">		delete(node10, y);</span><br><span class="line">		tranverse(node10);</span><br><span class="line">		TreeNode pt= post(node10,node16);</span><br><span class="line">		System.out.println(&quot;\n16的后继节点:&quot;+pt.value);</span><br><span class="line">		TreeNode pre= pre(node10,node11);</span><br><span class="line">		System.out.println(&quot;\n11的前驱节点:&quot;+pre.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1frjdk3lc0nj30dl0afwft.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
  </entry>
  <entry>
    <title>keyTyped、keyPressed、keyRelease的区别</title>
    <url>/2018/06/17/%E5%A4%8D%E4%B9%A0java/</url>
    <content><![CDATA[<p>keyPressed(): when the key goes down<br>keyReleased(): when the key comes up<br>keyTyped(): when the unicode character represented by this key is sent by the keyboard to system input.<br>KeyPressed是键被按下，KeyReleased是键被弹起，这两个都是更底层一些的事件。<br>KeyTyped是指有字符被输入，比如按住shift，再按A键，如果当时Caps Lock不亮，就产生一个输入大写A的事件。<br><a id="more"></a></p>
<p>If you want to get a immediate response, whether or not a character, use keyPressed().</p>
<p>If you want to get a single command, whether or not a character, you’d better use keyReleased().</p>
<p>If you want to input only a character and hit again and again while holding the key, then you use keyTyped().</p>
<p>KEY_TYPED<br>public static final int KEY_TYPED<br>The “key typed” event. This event is generated when a character is entered. In the simplest case, it is produced by a single key press. Often, however, characters are produced by series of key presses, and the mapping from key pressed events to key typed events may be many-to-one or many-to-many. </p>
<hr>
<p>KEY_PRESSED<br>public static final int KEY_PRESSED<br>The “key pressed” event. This event is generated when a key is pushed down. </p>
<hr>
<p>KEY_RELEASED<br>public static final int KEY_RELEASED<br>The “key released” event. This event is generated when a key is let up.</p>
]]></content>
  </entry>
  <entry>
    <title>复习python</title>
    <url>/2018/05/31/%E5%A4%8D%E4%B9%A0python/</url>
    <content><![CDATA[<h1 id="或与非"><a href="#或与非" class="headerlink" title="或与非"></a>或与非</h1><p>Python使用“or”、“and”、“not”来表示“||”、“&amp;&amp;”、“！”。<br><a id="more"></a></p>
<h1 id="判断和循环语句"><a href="#判断和循环语句" class="headerlink" title="判断和循环语句"></a>判断和循环语句</h1><ul>
<li>if-else</li>
<li>while</li>
<li>for<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1>字符串切片<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2>跟find()方法一样，只不过如果str不在 mystr中会报一个异常.</li>
</ul>
<p>mystr.index(str, start=0, end=len(mystr))<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name=&quot;hello word ha ha&quot;</span><br><span class="line">print(name.index(&quot;h&quot;))</span><br></pre></td></tr></table></figure></p>
<h2 id="split-切片-mystr"><a href="#split-切片-mystr" class="headerlink" title="split 切片 mystr"></a>split 切片 mystr</h2><p>空白字符：空格、tab、换行、回车以及formfee<br>当不给split函数传递任何参数时，分隔符sep会采用任意形式的空白字符：空格、tab、换行、回车以及formfeed。maxsplit参数表明要分割得到的list长度。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python split()通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串</span><br><span class="line">语法</span><br><span class="line">split()方法语法：</span><br><span class="line">str.split(str=&quot;&quot;, num=string.count(str)).</span><br><span class="line">参数</span><br><span class="line">str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。</span><br><span class="line">num -- 分割次数。</span><br><span class="line">返回值</span><br><span class="line">返回分割后的字符串列表。</span><br><span class="line">name=&quot;hello word ha ha&quot;</span><br><span class="line">s=name.split(&quot; &quot;,2)</span><br><span class="line">print(s[0])</span><br><span class="line">print(s[1])</span><br></pre></td></tr></table></figure></p>
<p>##capitalize<br>mystr.capitalize()</p>
<h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &quot;hello itcast&quot;</span><br><span class="line">&gt;&gt;&gt; a.title()</span><br><span class="line">&apos;Hello Itcast&apos;</span><br></pre></td></tr></table></figure>
<h2 id="startswith"><a href="#startswith" class="headerlink" title="startswith"></a>startswith</h2><p>检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False<br>mystr.startswith(obj)</p>
<h2 id="endswith"><a href="#endswith" class="headerlink" title="endswith"></a>endswith</h2><p>检查字符串是否以obj结束，如果是返回True,否则返回 False.</p>
<p>mystr.endswith(obj)</p>
<h2 id="lower"><a href="#lower" class="headerlink" title="lower"></a>lower</h2><p>转换 mystr 中所有大写字符为小写</p>
<p>mystr.lower()    </p>
<p>##upper<br>转换 mystr 中的小写字母为大写</p>
<p>mystr.upper()    </p>
<h1 id="容器Containers"><a href="#容器Containers" class="headerlink" title="容器Containers"></a>容器Containers</h1><ul>
<li>列表 a=[1,2,3]</li>
<li>元祖 t=(1,2) t=(1,)<br>tuple一旦初始化就不能修改</li>
<li>字典 d = {key1 : value1, key2 : value2 }</li>
<li>集合<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1>定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>斐波拉契数列(Fibonacci)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fabi(n):</span><br><span class="line">    if n==0 :</span><br><span class="line">        return 1</span><br><span class="line">    if n==1 :</span><br><span class="line">        return 1</span><br><span class="line">    return fabi(n-1)+fabi(n-2)</span><br><span class="line">print(fabi(4))</span><br></pre></td></tr></table></figure></p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def quick_sort(array,left,right):</span><br><span class="line">    low=left</span><br><span class="line">    high=right</span><br><span class="line">    if low&gt;=high:</span><br><span class="line">        return</span><br><span class="line">    tmp=array[low]</span><br><span class="line">    while low&lt;high:</span><br><span class="line">        while array[high]&gt;tmp and low&lt;high:</span><br><span class="line">            high-=1</span><br><span class="line">        array[low]=array[high]#赋值注意</span><br><span class="line">        while array[low]&lt;tmp and low&lt;high:</span><br><span class="line">            low+=1</span><br><span class="line">        array[high]=array[low]</span><br><span class="line">    array[low]=tmp</span><br><span class="line">    quick_sort(array,left,low-1)</span><br><span class="line">    quick_sort(array,low+1,right)</span><br><span class="line">array = [10, 3, 5, 11, 6]</span><br><span class="line">quick_sort(array, 0, len(array)-1)</span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>发现一个很赞的中文的python3 notebook~~~小开心<br><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p11_pick_things_at_random.html?highlight=random" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p11_pick_things_at_random.html?highlight=random</a></p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
  </entry>
  <entry>
    <title>复习快排算法</title>
    <url>/2018/05/17/%E5%A4%8D%E4%B9%A0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>基础知识还是要经常复习的！用的时候又有点忘了,特来复习一下。</p>
<p>网上快排大概有两种写法 不过思想差不多</p>
<p>一种是把第一个元素作为基准，先从右向左扫描，替换数组元素的值，最后把基准赋给i=j相遇时位置的值</p>
<p>另一种是往左移，往右移找出比基准大和往左移比基准小的元素交换位置，如果下标i&lt;j的话，就交换两个元素，如果i=j的话，就把这个位置数组和元素的值和基准交换<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">postOr</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Q1sort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp=nums[low];<span class="comment">//以第一个元素为基准</span></span><br><span class="line">    <span class="keyword">int</span> i=low,j=high;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">while</span>(nums[j]&gt;=tmp&amp;&amp;i&lt;j)<span class="comment">//从右向左扫描</span></span><br><span class="line">        <span class="comment">//往左移，找出比基准小的记录位置</span></span><br><span class="line">    		j--;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">while</span>(nums[i]&lt;=tmp&amp;&amp;i&lt;j)<span class="comment">//从左向右扫描</span></span><br><span class="line">    		<span class="comment">//要有等于号！ 往右移，找比基准大的记录位置</span></span><br><span class="line">    		i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)                     <span class="comment">//如果i&lt;j，交换它们</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            nums[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[low]=nums[i];</span><br><span class="line">    nums[i]=tmp;</span><br><span class="line">	Q1sort(nums,low,i-<span class="number">1</span> );</span><br><span class="line">	Q1sort(nums,i+<span class="number">1</span>,high );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Q2sort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low&gt;=high) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp=nums[low];</span><br><span class="line">    <span class="keyword">int</span> i=low,j=high;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">while</span>(nums[j]&gt;=tmp&amp;&amp;i&lt;j)<span class="comment">//从右向左扫描, 必须先从右向左，之前的tmp保存的是左边的值</span></span><br><span class="line">    		j--;</span><br><span class="line">    	nums[i]=nums[j];</span><br><span class="line">    	<span class="keyword">while</span>(nums[i]&lt;=tmp&amp;&amp;i&lt;j)<span class="comment">//从左向右扫描</span></span><br><span class="line">    		i++;</span><br><span class="line">    	nums[j]=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i]=tmp;</span><br><span class="line">	Q2sort(nums,low,i-<span class="number">1</span> );</span><br><span class="line">	Q2sort(nums,i+<span class="number">1</span>,high );</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">		   <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">		   Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		   <span class="keyword">int</span> n=in.nextInt();</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    a[i]=in.nextInt();</span><br><span class="line">		   Q1sort(a,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    System.out.print(a[i]+<span class="string">" "</span>);</span><br><span class="line">		   Q2sort(a,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    System.out.print(a[i]+<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接</p>
<p><a href="https://www.jianshu.com/p/442399ef0cf7" target="_blank" rel="noopener">https://www.jianshu.com/p/442399ef0cf7</a></p>
<p><a href="http://www.cnblogs.com/vanezkw/archive/2012/06/21/2557685.html" target="_blank" rel="noopener">http://www.cnblogs.com/vanezkw/archive/2012/06/21/2557685.html</a></p>
<p><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/quick_sort.html" target="_blank" rel="noopener">http://www.cnblogs.com/kkun/archive/2011/11/23/quick_sort.html</a></p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
  </entry>
  <entry>
    <title>复数运算</title>
    <url>/2018/12/23/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97-1/</url>
    <content><![CDATA[<p>编程实现两个复数的运算。设有两个复数 和 ，则他们的运算公式为：</p>
<p>　　要求：（1）定义一个结构体类型来描述复数。<br>　　（2）复数之间的加法、减法、乘法和除法分别用不用的函数来实现。<br>　　（3）必须使用结构体指针的方法把函数的计算结果返回。<br>　　说明：用户输入：运算符号(+,-,*,/) a b c d.<br>　　输出：a+bi，输出时不管a,b是小于0或等于0都按该格式输出，输出时a,b都保留两位。<br><a id="more"></a><br>输入：<br>　　- 2.5 3.6 1.5 4.9<br>输出：<br>　　1.00+-1.30i</p>
<p>分析：一看就是一道大水题。</p>
<p>看到结构体指针。好久没编过了。不如试一试吧。（当然也可以不用结构，直接计算就行）</p>
<p><strong>注意：结构体指针初始化要不然就会变成野指针</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct fu&#123;</span><br><span class="line">	double x;</span><br><span class="line">	double y;</span><br><span class="line">	fu(double xx,double yy):x(xx),y(yy)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	fu()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">fu* add(fu f1,fu f2)&#123;</span><br><span class="line">	//!</span><br><span class="line">	fu *ans=(fu*)malloc(sizeof(fu));</span><br><span class="line">	ans-&gt;x=f1.x+f2.x;</span><br><span class="line">	ans-&gt;y=f1.y+f2.y;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">fu *sub(fu f1,fu f2)&#123;</span><br><span class="line">	fu *ans=(fu*)malloc(sizeof(fu));</span><br><span class="line">	ans-&gt;x=f1.x-f2.x;</span><br><span class="line">	ans-&gt;y=f1.y-f2.y;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">fu *mul(fu f1,fu f2)&#123;</span><br><span class="line">	fu *ans=(fu*)malloc(sizeof(fu));</span><br><span class="line">	ans-&gt;x=f1.x*f2.x-f1.y*f2.y;</span><br><span class="line">	ans-&gt;y=f1.x*f2.y+f1.y*f2.x; </span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fu *div(fu f1,fu f2)&#123;</span><br><span class="line">	fu *ans=(fu*)malloc(sizeof(fu));</span><br><span class="line">	int t=f2.x*f2.x+f2.y*f2.y;</span><br><span class="line">	if(f2.x==0||f2.y==0) return NULL;</span><br><span class="line">	ans-&gt;x=(f1.x*f2.x+f1.y*f2.y)/t;</span><br><span class="line">	ans-&gt;y=(f1.y*f2.x-f1.x*f2.y)/t; </span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;	</span><br><span class="line">	char c;</span><br><span class="line">	double x1,x2,y1,y2; </span><br><span class="line">	cin&gt;&gt;c;</span><br><span class="line">	cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">	fu f1(x1,y1);</span><br><span class="line">	fu f2(x2,y2);</span><br><span class="line">	fu *ans;</span><br><span class="line">		switch(c)</span><br><span class="line">	&#123;</span><br><span class="line">		case &apos;+&apos;:ans=add(f1,f2);break;</span><br><span class="line">		case &apos;-&apos;:ans=sub(f1,f2);break;</span><br><span class="line">		case &apos;*&apos;:ans=mul(f1,f2);break;</span><br><span class="line">		case &apos;/&apos;:ans=div(f1,f2);break;</span><br><span class="line">		default :break;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%.2lf+%.2lfi\n&quot;,ans-&gt;x,ans-&gt;y);	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考博客<br><a href="https://blog.csdn.net/qq_33850438/article/details/50812130" target="_blank" rel="noopener">https://blog.csdn.net/qq_33850438/article/details/50812130</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
  </entry>
  <entry>
    <title>算法训练 小朋友排队</title>
    <url>/2018/12/23/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。 </p>
<p>　　每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。<br><a id="more"></a><br>　　如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。 </p>
<p>　　请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。 </p>
<p>　　如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。<br>输入格式<br>　　输入的第一行包含一个整数n，表示小朋友的个数。<br>　　第二行包含 n 个整数 H1 H2 … Hn，分别表示每个小朋友的身高。<br>输出格式<br>　　输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。<br>样例输入<br>3<br>3 2 1<br>样例输出<br>9<br>样例说明<br>　　首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。<br>数据规模和约定<br>　　对于10%的数据， 1&lt;=n&lt;=10；<br>　　对于30%的数据， 1&lt;=n&lt;=1000；<br>　　对于50%的数据， 1&lt;=n&lt;=10000；<br>　　对于100%的数据，1&lt;=n&lt;=100000，0&lt;=Hi&lt;=1000000。</p>
<p>他的交换次数取决于他前面有多少个比他高的,他的后面有多少个比他矮的.就可以得到该小朋友的交换次数,进而计算得到不高兴程度.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define maxn 100001</span><br><span class="line">#define max 1000001</span><br><span class="line">using namespace std;</span><br><span class="line">int c[max],b[maxn];</span><br><span class="line">int num[maxn];</span><br><span class="line">int lowbit(int x)</span><br><span class="line">&#123;</span><br><span class="line">	return x&amp;(-x);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void add(int w,int v)&#123;</span><br><span class="line">	int i=w;</span><br><span class="line">	while(i&lt;=max)&#123;</span><br><span class="line">		c[i]+=v;</span><br><span class="line">		i+=lowbit(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int  sum(int w)&#123;</span><br><span class="line">	int i=w;</span><br><span class="line">	int res=0;</span><br><span class="line">	while(i&gt;0)&#123;</span><br><span class="line">		res+=c[i];</span><br><span class="line">		i-=lowbit(i);</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	int num1,num2;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;num[i]);</span><br><span class="line">		add(num[i]+1,1);</span><br><span class="line">		int d=sum(num[i]);</span><br><span class="line">			b[i]=i-1-d;</span><br><span class="line">			b[i]-=sum(num[i]+1)-sum(num[i])-1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	memset(c,0,sizeof(c));</span><br><span class="line">		for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">		add(num[i]+1,1);</span><br><span class="line">			b[i]+=sum(num[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	long long res=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	res+=(long long)(b[i]+1)*b[i]/2;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="http://www.voidcn.com/article/p-vkgstvdl-tk.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-vkgstvdl-tk.html</a><br><a href="https://blog.csdn.net/liangzhaoyang1/article/details/51067709" target="_blank" rel="noopener">https://blog.csdn.net/liangzhaoyang1/article/details/51067709</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>历届试题 大臣的旅费</title>
    <url>/2019/03/12/%E5%A4%A7%E8%87%A3%E7%9A%84%E6%97%85%E8%B4%B9/</url>
    <content><![CDATA[<p>问题描述<br>很久以前，T王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。</p>
<p>为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。<br><a id="more"></a><br>J是T国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。他有一个钱袋，用于存放往来城市间的路费。</p>
<p>聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。</p>
<p>J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？</p>
<p>输入格式<br>输入的第一行包含一个整数n，表示包括首都在内的T王国的城市数</p>
<p>城市从1开始依次编号，1号城市为首都。</p>
<p>接下来n-1行，描述T国的高速路（T国的高速路一定是n-1条）</p>
<p>每行三个整数Pi, Qi, Di，表示城市Pi和城市Qi之间有一条高速路，长度为Di千米。</p>
<p>输出格式<br>输出一个整数，表示大臣J最多花费的路费是多少。</p>
<p>样例输入1<br>5<br>1 2 2<br>1 3 1<br>2 4 5<br>2 5 4<br>样例输出1<br>135<br>输出格式<br>大臣J从城市4到城市5要花费135的路费。</p>
<p>100分代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#define MAX 1000005</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int v;</span><br><span class="line">	int c;</span><br><span class="line">	node(int vv,int cc):v(vv),c(cc)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; g[MAX];</span><br><span class="line">bool vis[MAX];</span><br><span class="line">int dis[MAX];</span><br><span class="line"></span><br><span class="line">void dfs(int cur,int dis[])&#123;</span><br><span class="line">	vis[cur]=true;</span><br><span class="line">	for(int i=0;i&lt;g[cur].size();i++)&#123;</span><br><span class="line">		node t=g[cur][i];</span><br><span class="line">		if(vis[t.v]) continue;</span><br><span class="line">		dis[t.v]=dis[cur]+t.c;</span><br><span class="line">		dfs(t.v,dis);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	memset(dis,0,sizeof(dis));</span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		int a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		g[a].push_back(node(b,c));</span><br><span class="line">		g[b].push_back(node(a,c));</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(1,dis);</span><br><span class="line">	int  max=-1,k=-1; </span><br><span class="line">	for(int i=2;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(dis[i]&gt;max)&#123;</span><br><span class="line">			max=dis[i];</span><br><span class="line">			k=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">		memset(dis,0,sizeof(dis));</span><br><span class="line">	dfs(k,dis);</span><br><span class="line">		max=-1;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(i==k) continue;</span><br><span class="line">		if(dis[i]&gt;max)&#123;</span><br><span class="line">			max=dis[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;(21+max)*max/2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>75分代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#define MAX  7010</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int g[MAX][MAX];</span><br><span class="line">bool vis[MAX];</span><br><span class="line">int dis[MAX];</span><br><span class="line">int n;</span><br><span class="line">void dfs(int cur,int dis[])&#123;</span><br><span class="line">	vis[cur]=true;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(vis[i]||g[cur][i]==INF) continue;</span><br><span class="line">		dis[i]=dis[cur]+g[cur][i];</span><br><span class="line">		dfs(i,dis);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	fill(g[0],g[0]+MAX*MAX,INF);</span><br><span class="line">	memset(dis,0,sizeof(dis));</span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		int a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		g[a][b]=c;</span><br><span class="line">		g[b][a]=c;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(1,dis);</span><br><span class="line"></span><br><span class="line">	int  max=-1,k=-1; </span><br><span class="line">	for(int i=2;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(dis[i]&gt;max)&#123;</span><br><span class="line">			max=dis[i];</span><br><span class="line">			k=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">		memset(dis,0,sizeof(dis));</span><br><span class="line">	dfs(k,dis);</span><br><span class="line">    </span><br><span class="line">	max=-1;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(i==k) continue;</span><br><span class="line">		if(dis[i]&gt;max)&#123;</span><br><span class="line">			max=dis[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;(21+max)*max/2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="http://www.voidcn.com/article/p-zmmwoeih-zq.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-zmmwoeih-zq.html</a><br><a href="https://blog.csdn.net/Lionel_D/article/details/43456559" target="_blank" rel="noopener">https://blog.csdn.net/Lionel_D/article/details/43456559</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>凸多边形的最优三角划分</title>
    <url>/2018/12/19/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>问题相关定义：</p>
<p>(1)凸多边形的三角剖分：将凸多边形分割成互不相交的三角形的弦的集合T。 </p>
<p>(2)最优剖分：给定凸多边形P，以及定义在由多边形的边和弦组成的三角形上的权函数w。要求确定该凸多边形的三角剖分，使得该三角剖分中诸三角形上权之和为最小。<br><a id="more"></a><br>凸多边形三角剖分如下图所示：<br><img src="https://img-blog.csdn.net/20171217201609187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1d2VpeXV4aWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<p>设m[i][j]，1&lt;=i &lt; j&lt;=n 为凸多边形{Vi-1,Vi……Vj}的最优三角剖分所对应的权值函数值，即其最优值。最优剖分包含三角形Vi-1VkVj的权，子多边形{Vi-1,Vi……Vk}的权，子多边形{Vk，Vk+1……Vj}的权之和。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">int s[MAX][MAX],m[MAX][MAX],g[MAX][MAX];</span><br><span class="line">int n;</span><br><span class="line">using namespace std;</span><br><span class="line">//点i-1 i.....j构成的凸多边形的划分 </span><br><span class="line">void print(int i,int j)&#123;</span><br><span class="line">	if(i==j) return;</span><br><span class="line">	//i-1---&gt;s[i][j]是弦 不是边 </span><br><span class="line">	if(s[i][j]&gt;i) &#123;</span><br><span class="line">		cout&lt;&lt;&quot;&#123;v&quot;&lt;&lt;i-1&lt;&lt;&quot; v&quot;&lt;&lt;s[i][j]&lt;&lt;&quot;&#125;&quot;&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	//s[i][j]---&gt;j是弦 不是边 </span><br><span class="line">	if(s[i][j]+1&lt;j)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;&#123;v&quot;&lt;&lt;s[i][j]&lt;&lt;&quot; v&quot;&lt;&lt;j&lt;&lt;&quot;&#125;&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	print(i,s[i][j]);</span><br><span class="line">	print(s[i][j]+1,j);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	n--;</span><br><span class="line">	for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;=n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;g[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	for(int d=2;d&lt;=n;d++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i=1;i&lt;=n+d-1;i++)&#123;</span><br><span class="line">			int j=i+d-1;</span><br><span class="line">			m[i][j]=m[i+1][j]+g[i-1][i]+g[i][j]+g[i-1][j];</span><br><span class="line">			s[i][j]=i;</span><br><span class="line">			for(int k=i+1;k&lt;j;k++)&#123;</span><br><span class="line">				if(m[i][j]&gt;m[i][k]+m[k+1][j]+g[i-1][k]+g[i-1][j]+g[k][j])</span><br><span class="line">				&#123;</span><br><span class="line">					m[i][j]=m[i][k]+m[k+1][j]+g[i-1][k]+g[i-1][j]+g[k][j];</span><br><span class="line">					s[i][j]=k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;m[1][n]&lt;&lt;endl;</span><br><span class="line">	print(1,n);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考博客<br><a href="https://blog.csdn.net/liuweiyuxiang/article/details/78827474" target="_blank" rel="noopener">https://blog.csdn.net/liuweiyuxiang/article/details/78827474</a></p>
]]></content>
      <categories>
        <category>趣学算法</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>记录的博客链接</title>
    <url>/2018/05/10/%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/firstcsharp/p/4025689.html" target="_blank" rel="noopener">https://www.cnblogs.com/firstcsharp/p/4025689.html</a></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="http://blog.csdn.net/fansongy/article/details/6798278" target="_blank" rel="noopener">http://blog.csdn.net/fansongy/article/details/6798278</a><br><a href="http://blog.csdn.net/lanchunhui/article/details/50485338" target="_blank" rel="noopener">http://blog.csdn.net/lanchunhui/article/details/50485338</a><br><a href="http://blog.csdn.net/overload1997" target="_blank" rel="noopener">http://blog.csdn.net/overload1997</a><br><a id="more"></a></p>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p01_read_write_csv_data.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p01_read_write_csv_data.html</a><br><a href="https://www.xncoding.com/categories/python/" target="_blank" rel="noopener">https://www.xncoding.com/categories/python/</a></p>
<h2 id="搭建vps"><a href="#搭建vps" class="headerlink" title="搭建vps"></a>搭建vps</h2><p><a href="https://blog.csdn.net/sinat_32829963/article/details/79261297" target="_blank" rel="noopener">https://blog.csdn.net/sinat_32829963/article/details/79261297</a><br><a href="https://twiceyuan.com/tags/Docker/" target="_blank" rel="noopener">https://twiceyuan.com/tags/Docker/</a><br><a href="http://www.hl10502.com/tags/" target="_blank" rel="noopener">http://www.hl10502.com/tags/</a><br><a href="http://www.chinagfw.org/2013/09/blog-post.html" target="_blank" rel="noopener">http://www.chinagfw.org/2013/09/blog-post.html</a><br><a href="https://chinadigitaltimes.net/chinese/2017/07/%E7%BF%BB%E5%A2%99%E6%9C%8D%E5%8A%A1%E5%95%86%E5%80%92%E4%B8%8B%E4%BA%86%EF%BC%8C%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E6%90%AD%E6%A2%AF%E5%AD%90%E7%BF%BB%E5%A2%99%EF%BC%8C%E6%90%AD/" target="_blank" rel="noopener">https://chinadigitaltimes.net/chinese/2017/07/%E7%BF%BB%E5%A2%99%E6%9C%8D%E5%8A%A1%E5%95%86%E5%80%92%E4%B8%8B%E4%BA%86%EF%BC%8C%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E6%90%AD%E6%A2%AF%E5%AD%90%E7%BF%BB%E5%A2%99%EF%BC%8C%E6%90%AD/</a></p>
<h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p><a href="http://www.cnblogs.com/fengxiongZz/" target="_blank" rel="noopener">http://www.cnblogs.com/fengxiongZz/</a><br><a href="https://blog.phpgao.com/vpses.html" target="_blank" rel="noopener">https://blog.phpgao.com/vpses.html</a><br><a href="https://anjingwd.github.io/AnJingwd.github.io/2017/08/02/%E4%BF%AE%E6%94%B9host%E6%96%87%E4%BB%B6-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" target="_blank" rel="noopener">https://anjingwd.github.io/AnJingwd.github.io/2017/08/02/%E4%BF%AE%E6%94%B9host%E6%96%87%E4%BB%B6-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</a><br><a href="https://blog.csdn.net/shinanhualiu/article/details/48599231" target="_blank" rel="noopener">https://blog.csdn.net/shinanhualiu/article/details/48599231</a><br><a href="http://www.cnblogs.com/rio2607/p/4456332.html" target="_blank" rel="noopener">http://www.cnblogs.com/rio2607/p/4456332.html</a><br><a href="http://x-wei.github.io/archives.html" target="_blank" rel="noopener">http://x-wei.github.io/archives.html</a></p>
<h2 id="数据集搜集整理"><a href="#数据集搜集整理" class="headerlink" title="数据集搜集整理"></a>数据集搜集整理</h2><p><a href="https://blog.csdn.net/hk_john/article/details/78193573" target="_blank" rel="noopener">https://blog.csdn.net/hk_john/article/details/78193573</a></p>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p><a href="https://www.cnblogs.com/freeweb/category/670085.html" target="_blank" rel="noopener">https://www.cnblogs.com/freeweb/category/670085.html</a></p>
<p>多看看别人写的博客，多积累自己的知识，多发现自己的不足，有一天你会发现你在慢慢进步。</p>
]]></content>
      <categories>
        <category>好的博客</category>
      </categories>
  </entry>
  <entry>
    <title>头文件 bits/stdc++.h</title>
    <url>/2019/03/21/%E5%A4%B4%E6%96%87%E4%BB%B6bits-stdc-h/</url>
    <content><![CDATA[<p>#include&lt;bits/stdc++.h&gt;这个头文件包含以下等等C++中包含的所有头文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;set&gt;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p> 使用</p>
<p> #include&lt;bits/stdc++.h&gt;<br>    using namespace std;<br>    int main()<br>    {<br>        int a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cout&lt;&lt;a+b&lt;&lt;endl;<br>        return 0;<br>    }  </p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>紫书7.3 子集生成</title>
    <url>/2018/11/03/%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<p>1.增量构造法</p>
<p>k1 数组 存放集合元素</p>
<p>pos数组 来存放子集中遍历元素的位置<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int k1[10];//存放具体数据</span><br><span class="line">int pos[10];//存放每次查找下一个元素的在集合k1中元素的具体位置</span><br><span class="line"> </span><br><span class="line">void add_cl (int cur)//从一定程度上，我们可以这么理解cur参数：即cur是我们进行图的遍历的层数</span><br><span class="line">&#123;</span><br><span class="line">	if(cur != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i=0;i&lt;cur; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;k1[pos[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	int dingwei = cur ? pos[cur-1] + 1 : 0;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	for (int i=dingwei;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pos[cur] = i;</span><br><span class="line">		cout&lt;&lt;&quot;pos:&quot;&lt;&lt;pos[cur]&lt;&lt;endl;</span><br><span class="line">		add_cl(cur+1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">	while (cin&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(k1,0,sizeof(k1));</span><br><span class="line">		memset(pos,0,sizeof(pos));</span><br><span class="line">		for (int i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;k1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		add_cl (0);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.二进制法<br>用二进制表示子集<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[20];</span><br><span class="line">int n;</span><br><span class="line">void check(int s)&#123;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(s&amp;(1&lt;&lt;i)) cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">	</span><br><span class="line">	&#125;cout&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;(1&lt;&lt;n);i++)</span><br><span class="line">	check(i);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>把*号放开头</title>
    <url>/2018/10/28/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8F%B7%E6%94%BE%E5%BC%80%E5%A4%B4/</url>
    <content><![CDATA[<p>一个字符串只包含<em>和数字，请把</em>都放开头<br><a id="more"></a><br>法一 快排思想 相对位置变了</p>
<p>循环不变法：[0…i-1]都是*  [i…j]都是数字 [j…n-1]未探测<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char str[20];</span><br><span class="line">	cin&gt;&gt;str;</span><br><span class="line">	int n=strlen(str);</span><br><span class="line">	for(int i=0,j=0;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(str[j]==&apos;*&apos;)</span><br><span class="line">		&#123;</span><br><span class="line">			char t=str[i];</span><br><span class="line">			str[i]=str[j];</span><br><span class="line">			str[j]=t;</span><br><span class="line">				i++;</span><br><span class="line">		 &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>法二：数字相对顺序不变</p>
<p>倒着<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char str[20];</span><br><span class="line">	cin&gt;&gt;str;</span><br><span class="line">	int n=strlen(str);</span><br><span class="line">	int i=n-1;</span><br><span class="line">	for(int j=i;j&gt;=0;j--)</span><br><span class="line">	&#123;</span><br><span class="line">		if(str[j]!=&apos;*&apos;)</span><br><span class="line">		str[i--]=str[j];</span><br><span class="line">	 &#125; </span><br><span class="line">	 for(int k=0;k&lt;=i;k++)</span><br><span class="line">	 str[k]=&apos;*&apos;;</span><br><span class="line">	 cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>字符串比较== strcmp</title>
    <url>/2019/03/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>strcmp是用来判断char<em>类型的字符串是否相等的，char</em>字符串实际上就是字符串的首地址。<br><a id="more"></a><br>而==是直接判断左边和右边是否相等，如果用==来判断char<em>字符串的话，就是相当于比较他们的首地址，这当然无法判断字符串的值是否一致了。<br>而如果是std::string，因为已经重载了==运算符，所以可以直接用==进行比较。<br>另外std::string有const char</em>的构造函数，平时可以用string(“abc”) == “abc”是因为匹配string的==运算符时，后面的abc发生了隐式类型转换。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string a, b;</span><br><span class="line">a = &quot;hello&quot;;</span><br><span class="line">b = &quot;world&quot;;</span><br><span class="line">if( a==b ) printf(&quot;a==b&quot;);</span><br><span class="line">else printf(&quot;a!=b\n&quot;);</span><br></pre></td></tr></table></figure></p>
<p>如果你不想这样做，也可以使用strcmp的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string a, b;</span><br><span class="line">a = &quot;hello&quot;;</span><br><span class="line">b = &quot;world&quot;;</span><br><span class="line">if( strcmp(a.c_str(), b.c_str())==0 ) printf(&quot;a==b&quot;);</span><br><span class="line">else printf(&quot;a!=b\n&quot;);</span><br><span class="line"> 33    48</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>字符串转整形 整形转字符串</title>
    <url>/2019/03/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E5%BD%A2_%E6%95%B4%E5%BD%A2%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>atoi() 与 itoa()函数用法<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int num = 10;</span><br><span class="line">	char str[100];</span><br><span class="line">	itoa(num, str, 8);      //将整数10转换为八进制保存在str字符数组中</span><br><span class="line">    string s(str);</span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">	printf(&quot;%s\n&quot;, str);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code></code></p>
<p>#include&lt;bits/stdc++.h&gt;</p>
<p>#define MAX 100<br>int a[MAX];<br>using namespace std;<br>int main(){<br>int n=30;//整形<br>int num=0;<br>while(n){<br>    a[num++]=n%10;<br>    n/=10;<br>}<br>string s;<br>for(int i=num-1;i&gt;=0;i–)<br>    s+=a[i]+’0’;<br>cout&lt;&lt;s&lt;&lt;endl;<br>}<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面是一个十进制转二进制的方法：</span><br></pre></td></tr></table></figure></p>
<p>#include “stdio.h”</p>
<p>#include “stdlib.h”</p>
<p>int main(void)<br>{<br>    int num = 15;<br>    char str[100];<br>    int n = atoi(itoa(num, str, 2));   //先把num转换为二进制的字符串，再把该字符串转换为整数<br>    printf(“%d\n”,n);<br>    system(“pause”);<br>    return 0;<br>}<br>转载请附上博文链接！<br><code>`</code></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>算法提高 学霸的迷宫  </title>
    <url>/2019/03/10/%E5%AD%A6%E9%9C%B8%E7%9A%84%E8%BF%B7%E5%AE%AB/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　学霸抢走了大家的作业，班长为了帮同学们找回作业，决定去找学霸决斗。但学霸为了不要别人打扰，住在一个城堡里，城堡外面是一个二维的格子迷宫，要进城堡必须得先通过迷宫。因为班长还有妹子要陪，磨刀不误砍柴功，他为了节约时间，从线人那里搞到了迷宫的地图，准备提前计算最短的路线。可是他现在正向妹子解释这件事情，于是就委托你帮他找一条最短的路线。<br><a id="more"></a><br>输入格式</p>
<p>　　第一行两个整数n， m，为迷宫的长宽。<br>　　接下来n行，每行m个数，数之间没有间隔，为0或1中的一个。0表示这个格子可以通过，1表示不可以。假设你现在已经在迷宫坐标(1,1)的地方，即左上角，迷宫的出口在(n,m)。每次移动时只能向上下左右4个方向移动到另外一个可以通过的格子里，每次移动算一步。数据保证(1,1)，(n,m)可以通过。</p>
<p>输出格式</p>
<p>　　第一行一个数为需要的最少步数K。<br>　　第二行K个字符，每个字符∈{U,D,L,R},分别表示上下左右。如果有多条长度相同的最短路径，选择在此表示方法下字典序最小的一个。</p>
<p>样例输入</p>
<p>Input Sample 1:<br>3 3<br>001<br>100<br>110</p>
<p>Input Sample 2:<br>3 3<br>000<br>000<br>000</p>
<p>样例输出</p>
<p>Output Sample 1:<br>4<br>RDRD</p>
<p>Output Sample 2:<br>4<br>DDRR</p>
<p>数据规模和约定</p>
<p>　　有20%的数据满足：1&lt;=n,m&lt;=10<br>　　有50%的数据满足：1&lt;=n,m&lt;=50<br>　　有100%的数据满足：1&lt;=n,m&lt;=500。</p>
<p>开数组的时候开到了1e4，结果每次提交都显示运行错误，以后开数组的时候注意注意，够用就可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 505</span><br><span class="line">	int n,m;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y,step;</span><br><span class="line">	node(int xx,int yy,int ss):x(xx),y(yy),step(ss)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	node()&#123;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">//DLRU</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line">//char d[4]=&#123;&apos;D&apos;,&apos;L&apos;,&apos;R&apos;,&apos;U&apos;&#125;;</span><br><span class="line">int dire[4][2]=&#123;&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">int num[MAX][MAX],vis[MAX][MAX],ss[MAX][MAX];</span><br><span class="line">char maze[MAX][MAX];</span><br><span class="line">bool isvalid(int x,int y)&#123;</span><br><span class="line">	if(vis[x][y]||num[x][y]==1) return false;</span><br><span class="line">	if(x&lt;1||y&lt;1||x&gt;n||y&gt;m) return false;</span><br><span class="line">	else return true;</span><br><span class="line">&#125; </span><br><span class="line">void p(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">    int xx=n;</span><br><span class="line">    int yy=m;</span><br><span class="line">    stack&lt;char&gt;st;</span><br><span class="line">    while(ss[xx][yy]!=4)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ss[xx][yy]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(&apos;D&apos;);</span><br><span class="line">            xx--;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(ss[xx][yy]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(&apos;L&apos;);</span><br><span class="line">            yy++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(ss[xx][yy]==2)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(&apos;R&apos;);</span><br><span class="line">            yy--;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(ss[xx][yy]==3)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(&apos;U&apos;);</span><br><span class="line">            xx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(!st.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	fill(ss[0],ss[0]+MAX*MAX,4);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=m;j++)</span><br><span class="line">		cin&gt;&gt;maze[i][j];</span><br><span class="line">	&#125; </span><br><span class="line">	//把char数组转成Num </span><br><span class="line">	 for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[i][j]=maze[i][j]-&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	q.push(node(1,1,0));</span><br><span class="line">	vis[1][1]=1;</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		node tmp=q.front();</span><br><span class="line">		//vis[tmp.x][tmp.y]=true;</span><br><span class="line">		if(tmp.x==n&amp;&amp;tmp.y==m)&#123;</span><br><span class="line">			cout&lt;&lt;tmp.step&lt;&lt;endl;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		q.pop();</span><br><span class="line">		int step=tmp.step;</span><br><span class="line">		for(int i=0;i&lt;4;i++) &#123;</span><br><span class="line">			int newx=tmp.x+dire[i][0];</span><br><span class="line">			int newy=tmp.y+dire[i][1];	</span><br><span class="line">			if(isvalid(newx,newy))&#123;</span><br><span class="line">				q.push(node(newx,newy,step+1));</span><br><span class="line">				vis[newx][newy]=1;</span><br><span class="line">				ss[newx][newy]=i;</span><br><span class="line">				</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		p(n,m); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转换成整数</title>
    <url>/2018/05/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>算法涉及较少，主要是考虑细节</p>
<ul>
<li>字符串为null或空””</li>
<li>-,+判断</li>
<li>illegal的字符（字符串中包含非数字）</li>
<li>字符串长度问题，只有’+’或’-‘</li>
<li>溢出问题</li>
</ul>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package StringToInteger;</span><br><span class="line"></span><br><span class="line">public class stringToInteger &#123;</span><br><span class="line">public static int convert(String s) throws Exception&#123;</span><br><span class="line">	if(s==null||s.length()==0)</span><br><span class="line">		throw new Exception(&quot;illegal number input&quot;);</span><br><span class="line">	int result=0;</span><br><span class="line">	int sign=1; </span><br><span class="line">	float MAX_DIV=Integer.MAX_VALUE/10;</span><br><span class="line">	float MIN_DIV=Integer.MIN_VALUE/10;</span><br><span class="line">	float  MAX_M=Integer.MAX_VALUE%10;</span><br><span class="line">	float  MIN_M=Integer.MIN_VALUE%10;</span><br><span class="line">	char c=s.charAt(0);</span><br><span class="line">	if(c==&apos;-&apos;||c==&apos;+&apos;)</span><br><span class="line">	&#123;</span><br><span class="line">		if(c==&apos;-&apos;) sign=-1;</span><br><span class="line">		if(s.length()==1) throw new Exception(&quot;illegal number input&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">for(int i=1;i&lt;s.length();i++)</span><br><span class="line">&#123;</span><br><span class="line">	int digit=s.charAt(i)-&apos;0&apos;;</span><br><span class="line">	if(digit&gt;=0&amp;&amp;digit&lt;=9)</span><br><span class="line">	&#123;</span><br><span class="line">		if(sign&gt;0&amp;&amp;(result&gt;MAX_DIV||(result==MAX_DIV&amp;&amp;digit&gt;MAX_M)))</span><br><span class="line">				throw new Exception(&quot;number overflow&quot;);</span><br><span class="line">		if(sign&lt;0&amp;&amp;(result&lt;MIN_DIV||(result==MIN_DIV&amp;&amp;digit&gt;MIN_M)))</span><br><span class="line">			throw new Exception(&quot;number overflow&quot;);</span><br><span class="line">			result=result*10+digit;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		throw new Exception(&quot;illegal number input&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">result=sign&gt;0?result:-result;</span><br><span class="line">		return result;</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">	int a=convert(&quot;+11&quot;);</span><br><span class="line">	int b=convert(&quot;-11&quot;);	</span><br><span class="line">	System.out.println(a);</span><br><span class="line">	System.out.println(b);</span><br><span class="line">	</span><br><span class="line">&#125;catch(Exception e)</span><br><span class="line">	&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般判断溢出会这样判断 digit &gt; INT_MAX - result*10 （先不考虑正负问题），但是这段代码是有问题的。</p>
<p>INT_MAX = 2147483647， 如果输入的字符串是2147483657，那么执行到最后一位时，会有 result*10 = 2147483650 &gt; INT_MAX，此时已经溢出，所以答案必然出错。</p>
<blockquote>
<p>对于正数来说，溢出有两种可能：<br>一种是诸如 2147483650，即 result &gt; MAX/10 的；<br>一种是诸如 2147483649，即 result == MAX/10 &amp;&amp; digit &gt; MAX%10 的。</p>
</blockquote>
<p><strong>解决办法</strong></p>
<ul>
<li>先用result与INT_MAX/10比较，如果result&gt;INT_MAX/10,那么必然溢出</li>
<li>如果result=INT_MAX/10,比较此时的digit位,如果digit&gt;INT_MAX%10,那么也必然溢出</li>
</ul>
<p>INT_MAX = 2147483647 而 INT_MIN = -2147483648，两者绝对值不相等。因此，正负数溢出的条件不一样，所以代码中用了两个条件来判断溢出情况。</p>
<h2 id="JDK-中-parseInt"><a href="#JDK-中-parseInt" class="headerlink" title="JDK 中 parseInt"></a>JDK 中 parseInt</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Integer 类中的 parseInt 函数</span><br><span class="line"> * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> */</span><br><span class="line">public static int parseInt (String s) throws NumberFormatException &#123;</span><br><span class="line">    return parseInt(s,10);</span><br><span class="line">&#125;</span><br><span class="line">public static int parseInt(String s, int radix)</span><br><span class="line">            throws NumberFormatException</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     * WARNING: This method may be invoked early during VM initialization</span><br><span class="line">     * before IntegerCache is initialized. Care must be taken to not use</span><br><span class="line">     * the valueOf method.</span><br><span class="line">     */</span><br><span class="line">    if (s == null) &#123;</span><br><span class="line">        throw new NumberFormatException( &quot;null&quot;);        //判断null的情况</span><br><span class="line">    &#125;</span><br><span class="line">    if (radix &lt; Character. MIN_RADIX) &#123;                  //转换的进制不能小于2</span><br><span class="line">        throw new NumberFormatException( &quot;radix &quot; + radix +</span><br><span class="line">                                        &quot; less than Character.MIN_RADIX&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (radix &gt; Character. MAX_RADIX) &#123;               //转换的进制不能大于36</span><br><span class="line">        throw new NumberFormatException( &quot;radix &quot; + radix +</span><br><span class="line">                                        &quot; greater than Character.MAX_RADIX&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int result = 0;                    //对应整数结果</span><br><span class="line">    boolean negative = false;          //保存整数的正负状态</span><br><span class="line">    int i = 0, len = s.length();</span><br><span class="line">    int limit = -Integer. MAX_VALUE;     //合法数字的上限（下限）</span><br><span class="line">    int multmin;                         //在做乘法计算时能走到的合法上限（下限）</span><br><span class="line">    int digit;     //当前字符对应的数字</span><br><span class="line">    if (len &gt; 0) &#123;</span><br><span class="line">        char firstChar = s.charAt(0);</span><br><span class="line">        if (firstChar &lt; &apos;0&apos;) &#123; // Possible leading &quot;+&quot; or &quot;-&quot;</span><br><span class="line">            if (firstChar == &apos;-&apos;) &#123;</span><br><span class="line">                negative = true;</span><br><span class="line">                limit = Integer. MIN_VALUE;</span><br><span class="line">            &#125; else if (firstChar != &apos;+&apos;)</span><br><span class="line">                throw NumberFormatException. forInputString(s);</span><br><span class="line">            if (len == 1) //不能只有一个&quot;+&quot;或者&quot;-&quot;</span><br><span class="line">                throw NumberFormatException. forInputString(s);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        multmin = limit / radix;</span><br><span class="line">        while (i &lt; len) &#123;</span><br><span class="line">            // Accumulating negatively avoids surprises near MAX_VALUE</span><br><span class="line">            digit = Character. digit(s.charAt(i++),radix);     //以指定的进制转换整数字符</span><br><span class="line">            if (digit &lt; 0) &#123;                                   //不能是非数字</span><br><span class="line">                throw NumberFormatException. forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            if (result &lt; multmin) &#123;                         //判断溢出</span><br><span class="line">                throw NumberFormatException. forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result *= radix;</span><br><span class="line">            if (result &lt; limit + digit) &#123;</span><br><span class="line">                throw NumberFormatException. forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result -= digit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;     //字符串不能为&quot;&quot;，即长度要大于0</span><br><span class="line">        throw NumberFormatException. forInputString(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return negative ? result : -result;</span><br><span class="line">&#125;</span><br><span class="line">可以看到parseInt(String s)函数调用了parseInt(String s, int radix)，源码中参数的检查，异常输入的判断都非常全面。可以说严谨和巧妙是这段程序最大的特点。比较难懂的可能是溢出判断那一段。</span><br><span class="line"></span><br><span class="line">if (result &lt; multmin) &#123;                         //判断溢出</span><br><span class="line">    throw NumberFormatException. forInputString(s);</span><br><span class="line">&#125;</span><br><span class="line">result *= radix;</span><br><span class="line">if (result &lt; limit + digit) &#123;</span><br><span class="line">    throw NumberFormatException. forInputString(s);</span><br><span class="line">&#125;</span><br><span class="line">result -= digit;</span><br></pre></td></tr></table></figure>
<p> JDK 将所有的整数先当做负数来处理了，为什么呢？</p>
<blockquote>
<p>我们知道有符号 int 的上下限是-2147483648 ~ 2147483647，可见负数表达的范围比正数多一个，这样就好理解为什么在开头要把 limit 全部表达为负数（下限）。这样的操作减少了后续的判断，可以一步到位，相当于二者选择取其大一样，大的包含了小的，不用像我的代码一样正负数情况都判断一次。同理，那么 multmin 也都是负数了，而且可以认为是只和进制参数 radix 有关系。在这里 multmin 就是-INT_MAX/10，当负数时就是INT_MIN/10。所以与上文类似，第一个条件就是若-result &lt; -INT_MAX/10则是溢出。不满足第一个条件的情况下，result<em>10肯定不会溢出了。所以第二个条件判断若 - result</em>10 &lt; -INT_MAX + digit，则是溢出。</p>
</blockquote>
<p>比如对于最大的负数来说，当扫描到最后一位时，result = -214748364，multmin=-214748364<br>第一个条件result &lt; multmin不满足， 执行result *= radix之后，result = -2147483640<br>第二个条件result &lt; limit + digit，即 -2147483640&lt;-2147483648+8 也不满足条件。<br>所以正常输出。</p>
]]></content>
      <categories>
        <category>parseInt</category>
      </categories>
      <tags>
        <tag>字符串转换成整数</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练 安慰奶牛</title>
    <url>/2019/03/07/%E5%AE%89%E6%85%B0%E5%A5%B6%E7%89%9B/</url>
    <content><![CDATA[<p>问题描述<br>Farmer John变得非常懒，他不想再继续维护供奶牛之间供通行的道路。道路被用来连接N个牧场，牧场被连续地编号为1到N。每一个牧场都是一个奶牛的家。FJ计划除去P条道路中尽可能多的道路，但是还要保持牧场之间 的连通性。你首先要决定那些道路是需要保留的N-1条道路。第j条双向道路连接了牧场Sj和Ej(1 &lt;= Sj &lt;= N; 1 &lt;= Ej &lt;= N; Sj != Ej)，而且走完它需要Lj的时间。没有两个牧场是被一条以上的道路所连接。奶牛们非常伤心，因为她们的交通系统被削减了。你需要到每一个奶牛的住处去安慰她们。每次你到达第i个牧场的时候(即使你已经到过)，你必须花去Ci的时间和奶牛交谈。你每个晚上都会在同一个牧场(这是供你选择的)过夜，直到奶牛们都从悲伤中缓过神来。在早上 起来和晚上回去睡觉的时候，你都需要和在你睡觉的牧场的奶牛交谈一次。这样你才能完成你的 交谈任务。假设Farmer John采纳了你的建议，请计算出使所有奶牛都被安慰的最少时间。<br><a id="more"></a><br>输入格式<br>第1行包含两个整数N和P。</p>
<p>接下来N行，每行包含一个整数Ci。</p>
<p>接下来P行，每行包含三个整数Sj, Ej和Lj。</p>
<p>输出格式<br>输出一个整数, 所需要的总时间(包含和在你所在的牧场的奶牛的两次谈话时间)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入</span><br><span class="line">5 7</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">6</span><br><span class="line">30</span><br><span class="line">1 2 5</span><br><span class="line">2 3 5</span><br><span class="line">2 4 12</span><br><span class="line">3 4 17</span><br><span class="line">2 5 15</span><br><span class="line">3 5 6</span><br><span class="line">样例输出</span><br><span class="line">176</span><br><span class="line">数据规模与约定</span><br><span class="line">5 &lt;= N &lt;= 10000，N-1 &lt;= P &lt;= 100000，0 &lt;= Lj &lt;= 1000，1 &lt;= Ci &lt;= 1,000。</span><br></pre></td></tr></table></figure></p>
<p>最小生成树 krustal算法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//最小生成树 无环 </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 10001</span><br><span class="line">#define MAXN 100001</span><br><span class="line">#define INF 0x3f3f3f3f </span><br><span class="line">int n,p,sum=0;</span><br><span class="line">int c[MAX],f[MAX];</span><br><span class="line">struct road&#123;</span><br><span class="line">	int s,e,l;</span><br><span class="line">	road(int ss,int ee,int ll):s(ss),e(ee),l(ll)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	road()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line">bool cmp(road r1,road r2)&#123;</span><br><span class="line">	return r1.l&lt;r2.l;</span><br><span class="line">&#125;</span><br><span class="line">road r[MAXN];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(f[x]==-1) return x; </span><br><span class="line">	return f[x]=find(f[x]);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void merge(int s,int e,int l)&#123;</span><br><span class="line">	int a=find(s);</span><br><span class="line">	int b=find(e);</span><br><span class="line">	if(a!=b)&#123;</span><br><span class="line">		f[a]=b;</span><br><span class="line">		sum+=l;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">		memset(f, -1, sizeof(f));</span><br><span class="line">	int minn=INF;</span><br><span class="line">	//for(int i=0....错误的  注意下标 位置 </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;c[i]; </span><br><span class="line">		if(c[i]&lt;minn)&#123;</span><br><span class="line">			minn=c[i];</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;p;i++)&#123;</span><br><span class="line">		int s,e,ll;</span><br><span class="line">		cin&gt;&gt;s&gt;&gt;e&gt;&gt;ll;</span><br><span class="line">		r[i].s=s;r[i].e=e;</span><br><span class="line">		r[i].l=c[s]+2*ll+c[e];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort(r,r+p,cmp);</span><br><span class="line">	for(int i=0;i&lt;p;i++)&#123;</span><br><span class="line">		merge(r[i].s,r[i].e,r[i].l);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum+minn&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 2102 A计划</title>
    <url>/2018/12/15/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F-ccf/</url>
    <content><![CDATA[<p>可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。<br>现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用<em>表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。<br><a id="more"></a><br>Input<br>输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小N</em>M（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前N<em>M表示迷宫的第一层的布置情况，后N</em>M表示迷宫第二层的布置情况。</p>
<p>Output<br>如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。</p>
<p>Sample Input<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 5 14</span><br><span class="line">S*#*.</span><br><span class="line">.#...</span><br><span class="line">.....</span><br><span class="line">****.</span><br><span class="line">...#.</span><br><span class="line"></span><br><span class="line">..*.P</span><br><span class="line">#.*..</span><br><span class="line">***..</span><br><span class="line">...*.</span><br><span class="line">*.#..</span><br></pre></td></tr></table></figure></p>
<p>Sample Output</p>
<p>YES</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define  MAX 10</span><br><span class="line">int m,n,lim;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y,z,step;</span><br><span class="line">	node(int xx,int yy,int zz,int ss):x(xx),y(yy),z(zz),step(ss)&#123;</span><br><span class="line">	&#125; </span><br><span class="line">	node()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">char grid[MAX][MAX][2]; </span><br><span class="line">int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int cases;</span><br><span class="line">	//freopen(&quot;12.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;cases;</span><br><span class="line">	while(cases--)&#123;</span><br><span class="line">		int flag=0;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		memset(grid,&apos;*&apos;,sizeof(grid));</span><br><span class="line">		cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">		cin&gt;&gt;lim;</span><br><span class="line">		for(int k=0;k&lt;2;k++)</span><br><span class="line">		&#123;</span><br><span class="line">				for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;grid[i][j][k];</span><br><span class="line">		&#125; </span><br><span class="line">		&#125; 	</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		queue&lt;node&gt; q;</span><br><span class="line">		q.push(node(0,0,0,0));</span><br><span class="line">		while(!q.empty())&#123;</span><br><span class="line">			node t=q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			if(grid[t.x][t.y][t.z]==&apos;P&apos;) &#123;</span><br><span class="line">				flag=1;</span><br><span class="line">				break;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			if(grid[t.x][t.y][t.z]==&apos;*&apos;) &#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			grid[t.x][t.y][t.z]=&apos;*&apos;;</span><br><span class="line">			for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">				int nx=t.x+dir[i][0];</span><br><span class="line">				int ny=t.y+dir[i][1];</span><br><span class="line">				int nz=t.z;</span><br><span class="line">				if(t.step+1&gt;lim) &#123;</span><br><span class="line">				continue;</span><br><span class="line">				&#125;</span><br><span class="line">                //!!</span><br><span class="line">			if(nx&lt;0||nx&gt;=m||ny&lt;0||ny&gt;=n) continue;</span><br><span class="line">				if(grid[nx][ny][nz]==&apos;*&apos;) continue;</span><br><span class="line"></span><br><span class="line">				if(grid[nx][ny][nz]==&apos;#&apos;) &#123;</span><br><span class="line">					//!!</span><br><span class="line">					grid[nx][ny][nz]=&apos;*&apos;;</span><br><span class="line">						nz=1-nz;</span><br><span class="line">				if(grid[nx][ny][nz]==&apos;#&apos; || grid[nx][ny][nz]==&apos;*&apos;) &#123;</span><br><span class="line">                    grid[nx][ny][nz]= grid[nx][ny][1-nz] = &apos;*&apos;;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">				&#125;				</span><br><span class="line">				q.push(node(nx,ny,nz,t.step+1));</span><br><span class="line">				</span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if(flag==1)	cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">		else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 677. Map Sum Pairs</title>
    <url>/2018/05/19/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>Implement a MapSum class with insert, and sum methods.</p>
<p>For the method insert, you’ll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.<br><a id="more"></a><br>For the method sum, you’ll be given a string representing the prefix, and you need to return the sum of all the pairs’ value whose key starts with the prefix.</p>
<p>Example 1:</p>
<p>Input: insert(“apple”, 3), Output: Null</p>
<p>Input: sum(“ap”), Output: 3</p>
<p>Input: insert(“app”, 2), Output: Null</p>
<p>Input: sum(“ap”), Output: 5</p>
<p>hashtable 一个存单词表 一个存前缀表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MapSum &#123;</span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MapSum() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void insert(string key, int val) &#123;</span><br><span class="line">        if(vals.count(key)) val-=vals[key];</span><br><span class="line">        vals[key]=val;</span><br><span class="line">        for(int i=1;i&lt;=key.length();i++)&#123;</span><br><span class="line">            string t=key.substr(0,i);</span><br><span class="line">            pre[t]+=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sum(string prefix) &#123;</span><br><span class="line">        return pre[prefix];</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,int&gt; vals;</span><br><span class="line">    unordered_map&lt;string,int&gt; pre;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MapSum object will be instantiated and called as such:</span><br><span class="line"> * MapSum obj = new MapSum();</span><br><span class="line"> * obj.insert(key,val);</span><br><span class="line"> * int param_2 = obj.sum(prefix);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>例题7-6 带宽</title>
    <url>/2018/11/04/%E5%B8%A6%E5%AE%BD/</url>
    <content><![CDATA[<p>给出一个n个节点的图G和一个节点的排列，定义节点i的带宽b(i)为i和相邻节点在排列中最远的距离，而所有b(i)的最大值就是整个图的带宽。给定图G，求出让带宽最小的节点排列。<br><a id="more"></a></p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>暴力全排列就行了。<br>记录下当前已找到的最小带宽k</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cctype&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int MAX = 300;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">char a[MAX];</span><br><span class="line">vector&lt;char&gt; G[MAX];</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;s.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(scanf(&quot;%s&quot;,a),a[0] != &apos;#&apos;)&#123;</span><br><span class="line">    	cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">        for(int i = &apos;A&apos;; i &lt;= &apos;Z&apos;; ++i)</span><br><span class="line">            G[i].clear();</span><br><span class="line">        vector&lt;char&gt; b;</span><br><span class="line">        int n = strlen(a);</span><br><span class="line">        for(int i = 0; i &lt; n;++i)&#123;</span><br><span class="line">            int s = a[i];</span><br><span class="line">            b.push_back(s);</span><br><span class="line">            G[s].clear();</span><br><span class="line">            i += 2;</span><br><span class="line">            while(isalpha(a[i]))&#123;</span><br><span class="line">                G[s].push_back(a[i]);</span><br><span class="line">                G[a[i]].push_back(s);</span><br><span class="line">                b.push_back(a[i++]);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">            for(vector&lt;char&gt;::iterator it=b.begin();it&lt;b.end();it++)</span><br><span class="line">			cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">        sort(b.begin(),b.end());</span><br><span class="line">            for(vector&lt;char&gt;::iterator it=b.begin();it&lt;b.end();it++)</span><br><span class="line">			cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">        b.erase(unique(b.begin(),b.end()),b.end());</span><br><span class="line">//        for(vector&lt;char&gt;::iterator it=b.begin();it&lt;b.end();it++)</span><br><span class="line">//			cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">//		cout&lt;&lt;endl;</span><br><span class="line">        vector&lt;char&gt; ans(b.size());</span><br><span class="line">        int res = INF;</span><br><span class="line">        do&#123;</span><br><span class="line">            int t = 0;</span><br><span class="line">            for(int i = 0, sz = b.size(); i &lt; sz; ++i)&#123;</span><br><span class="line">                for(int j = 0, szz = G[b[i]].size(); j &lt; szz; ++j)</span><br><span class="line">                    t = max(t, abs(i -(int)(find(b.begin(),b.end(),G[b[i]][j]) - b.begin())));</span><br><span class="line">            &#125;</span><br><span class="line">            if(t &lt; res)&#123;</span><br><span class="line">                res = t ;</span><br><span class="line">                copy(b.begin(),b.end(),ans.begin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while(next_permutation(b.begin(),b.end()));</span><br><span class="line">        for(int i = 0, sz = ans.size(); i &lt; sz ; ++i)</span><br><span class="line">            printf(&quot;%c &quot;,ans[i]);</span><br><span class="line">        printf(&quot;-&gt; %d\n&quot;,res);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>1.首先对字母进行散列，保存每个字符对应的编号，每个编号对应的字母。</p>
<p>2.不用暴力查找位置，而是直接记录位置，根据记录的位置直接求出结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define INF 10000</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int id[256];</span><br><span class="line">	int letter[20];</span><br><span class="line">	char s[1000];</span><br><span class="line">	while(scanf(&quot;%s&quot;,s)==1&amp;&amp;s[0]!=&apos;#&apos;)&#123;</span><br><span class="line">			int n=0;</span><br><span class="line">	for(char ch=&apos;A&apos;;ch&lt;=&apos;Z&apos;;ch++)&#123;</span><br><span class="line">		if(strchr(s,ch)!=NULL)&#123;</span><br><span class="line">		id[ch]=n;</span><br><span class="line">		letter[n]=ch;</span><br><span class="line">		n++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	int p=0,q=0;</span><br><span class="line">	vector&lt;int&gt; u,v;</span><br><span class="line">	int len=strlen(s);</span><br><span class="line"></span><br><span class="line">//!!!	for(int i=0;i&lt;len;i++)</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		while(p&lt;len&amp;&amp;s[p]!=&apos;:&apos;) p++;</span><br><span class="line">		if(p==len) break;</span><br><span class="line">		while(q&lt;len&amp;&amp;s[q]!=&apos;;&apos;) q++;</span><br><span class="line">		for(int k=p+1;k&lt;q;k++)&#123;</span><br><span class="line">			u.push_back(id[s[p-1]]);</span><br><span class="line">			v.push_back(id[s[k]]);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		p++;q++;</span><br><span class="line">	&#125;</span><br><span class="line">//	for(vector&lt;int&gt;::iterator it=u.begin();it!=u.end();it++)</span><br><span class="line">//	printf(&quot;%c &quot;,letter[*it]);</span><br><span class="line">//	cout&lt;&lt;endl;</span><br><span class="line">//		for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++)</span><br><span class="line">//	cout&lt;&lt;letter[*it]&lt;&lt;&quot; &quot;;</span><br><span class="line">//	cout&lt;&lt;endl;</span><br><span class="line">	int best_p[20];</span><br><span class="line">	int pos[20];</span><br><span class="line">	int num[20]; </span><br><span class="line">	for(int i=0;i&lt;n;i++) num[i]=i;</span><br><span class="line">		int	min=n;</span><br><span class="line">	do&#123;</span><br><span class="line">	for(int i=0;i&lt;n;i++) 	pos[num[i]]=i;</span><br><span class="line">				int maxn=0;	</span><br><span class="line">		for(int i=0;i&lt;u.size();i++)&#123;</span><br><span class="line">			maxn=max(maxn,abs(pos[u[i]]-pos[v[i]]));</span><br><span class="line">		&#125;</span><br><span class="line">		if(min&gt;maxn) </span><br><span class="line">		</span><br><span class="line">		&#123;</span><br><span class="line">			min=maxn;</span><br><span class="line">		 memcpy(best_p, num, sizeof(num));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;while(next_permutation(num,num+n));</span><br><span class="line">	 for(int i=0;i&lt;n;i++)</span><br><span class="line">	 printf(&quot;%c &quot;,letter[best_p[i]]);</span><br><span class="line">	 printf(&quot;-&gt; %d\n&quot;, min);			</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考博客<br><a href="https://blog.csdn.net/u013537860/article/details/49532053" target="_blank" rel="noopener">https://blog.csdn.net/u013537860/article/details/49532053</a><br><a href="https://blog.csdn.net/u012139398/article/details/39355601" target="_blank" rel="noopener">https://blog.csdn.net/u012139398/article/details/39355601</a></p>
]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>平滑图形处理</title>
    <url>/2020/04/20/%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>一、何为图像噪声？噪声是妨碍人的感觉器官所接受信源信息理解的因素，是不可预测只能用概率统计方法认识的随机误差。<br><a id="more"></a><br>　　我们可以观察到噪声的特点：1&gt;位置随机 2&gt;大小不规则。我们将这种噪声称为随机噪声（random noise），这是一种非常常见的噪声类型。</p>
<p>　　二、噪声的类型</p>
<p>　　噪声可以借用随机过程以及概率密度函数（Probability Density Function，PDF）来描述，通常可采用其数组特征，即均值，方差，相关函数等。按照概率密度函数分为高斯噪声、瑞利噪声、伽马噪声、指数分布噪声、均匀分布噪声、脉冲噪声、泊松噪声等。有的噪声与图像信号的强度不相关，如图像传输过程引入的信道噪声、摄像机扫描噪声等，这种噪声称为加性噪声（additive noise）。常见的加性噪声按照概率密度函数特征分为短拖尾加性噪声（如均匀分布噪声）、中拖尾加性噪声（高斯分布噪声）、长拖尾加性噪声（如指数分布噪声）、脉冲噪声（如椒盐噪声、随机数脉冲噪声等）。</p>
<p>　　有的噪声与图像信号有关，往往随着图像信号的变化而变化，如光照变化引起的噪声、飞机扫描图像中的噪声、电视扫描光栅中的相干噪声、斑点噪声等。这种噪声称为乘性噪声（multiplicative noise）。</p>
<p>　　matlab向图中添加噪声的指令：</p>
<p>　　I1=imnoise(I,type,parameters);</p>
<p>　　其中，当type为gaussian，所加入噪声是parameters为m（均值）、v（方差）的高斯噪声，这是最普通的噪声。</p>
<p>　　当type为localvar时，所加入噪声是parameters为0（均衡）、v（方差）的高斯噪声。</p>
<p>　　当type为poission时，所加入的是无参数的泊松噪声，在照度非常小时出现，或在高倍电子放大线路中出现。</p>
<p>　　当type为salt&amp;pepper时，所加入的噪声是parameters为d（密度）的椒盐噪声。</p>
<p>　　当type为speckle时，所加入的噪声是parameters为0（均值）、v（方差）的均匀分布噪声（斑点噪声）。</p>
<p>　　例子1：向图像中加入椒盐噪声matlab示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I=imread(&apos;eight.tif&apos;); </span><br><span class="line">J=imnoise(I,&apos;salt &amp; pepper&apos;,0.02); </span><br><span class="line">subplot(121),imshow(I),title(&apos;原始图像&apos;); </span><br><span class="line">subplot(122),imshow(J),title(&apos;加入椒盐噪声的图像&apos;);</span><br></pre></td></tr></table></figure>
<p> 　　例子2：利用多帧图像平均法，对受零均值随机高斯噪声干扰的图像进行平滑处理<br><code>I=imread(&#39;eight.tif&#39;); 
[m,n]=size(I);
I1=zeros(m,n);
for i=1:16
    I2(:,:,i)=imnoise(I,&#39;gaussian&#39;,0,0.01);%由原始图像叠加随机高斯噪声生成1-16帧图像
    I1=I1+double(I2(:,:,i));%多帧带有随机噪声的图像叠加
    if or(or(i==1,i==4),or(i==8,i==16));
        figure,imshow(uint8(I1/i))%取平均并显示结果
    end
end</code> 　　</p>
<p>　　分别显示施加噪声后的图像和叠加平均后的图像，可以发现叠加平均图像的数量级越多，噪声消除效果越好，对16帧图像取平均后几乎消除了所有噪声。</p>
<p>　　三、图像平滑消除噪声</p>
<p>　　对于只有一帧带有噪声的图像是无法用上述方法消除噪声的，此时又该怎么办呢？根据噪声的特点可以知道噪声的灰度与其周围的灰度之间有明显的灰度差，因此造成了视觉障碍。此时消除噪声的方法要利用图像平滑（image smoothing），简称平滑（smoothing），因此如何把边缘部分与噪声部分区分开，只消除噪声是图像平滑的关键所在。</p>
<p>　　图像平滑的方法可分为频率域法（频率法）和空间域法（空域法）两类。频域法的处理基础是傅里叶变换和低通滤波技术，空域法的处理基础是模板卷积。</p>
<p>　　（1）低通滤波（lowpass filter）</p>
<p>　　低通滤波属于频域平滑滤波法，通过滤除高频成分，保留低频成分，在频域中实现平滑处理。其滤波公式为G(U,V)=H(U,V)F(U,V)，其中F(U,V)是原始图像频谱，G(U,V)是平滑图像频谱，H(U,V)是传递（转移）函数。</p>
<p>　　步骤：将原始图像f（x，y）进行傅里叶变换，把图像从空间域变换到频率域，得到图像频谱F(U,V)，再通过传递函数H(U,V)用低通滤波公式改变F(U,V)，最后对滤波处理后的频谱G(U,V)进行傅里叶反变换，即可得到过滤后的图像g（x，y）。</p>
<p>　　1.理想低通滤波器（Ideal Low-Pass Filter，ILPF）的传递函数</p>
<p>　　</p>
<p>　　D0是截止频率，D(u，v)=（u^2+v^2）^(1/2)为频率平面原点到点（u，v）的距离。其特点是物理上不可实现，有抖动现象，滤除高频成分使图像变模糊。</p>
<p>　　</p>
<p>　　2.巴特沃斯低通滤波器(Butterworth Low-Pass Filter,BLPF)具有如下传递函数</p>
<p>　　</p>
<p>　　与理想低通滤波器不同，该滤波器的传递函数不是在D0处突然不连续，而是平滑过渡。当H(U,V)降为最大值的1/2时，D(U,V)=D0。n为阶数，阶数越大，传递函数越陡峭。</p>
<p>　　</p>
<p>　　3.指数形低通滤波器（Exponential Low-Pass Filter，ELPF）具有如下传递函数：</p>
<p>　　</p>
<p>　　当D（U,V）=D0时，H(u，v)降为最大值的1/(2^(1/2))时的频率可作为截止频率。</p>
<p>　　</p>
<p>　　4.梯形低通滤波器（Trapezoidal Low-Pass Filter，TLPF）具有如下传递函数：</p>
<p>　　</p>
<p>　　</p>
<p>　　例子：巴特沃斯低通滤波器</p>
<p>%巴特沃斯低通滤波器<br>I=imread(‘eight.tif’);<br>I1=imnoise(I,’salt &amp; pepper’);<br>figure,imshow(I1);<br>f=double(I1);<br>g=fft2(f);%傅里叶变换<br>g=fftshift(g);%直流分量移到频谱中心<br>[M,N]=size(g);%计算图像的高和宽<br>d0=50;nn=2;%截止频率为50的二阶巴特沃斯低通滤波器<br>m=round(M/2);n=round(N/2);%数据取整<br>for i=1:M<br>    for j=1:N<br>        d=sqrt((i-m)^2+(j-n)^2);%计算频率平面原点到各点的距离<br>        h=1/(1+0.414<em>(d/d0)^(2</em>nn));%传递公式<br>        result(i,j)=h*g(i,j);%滤波公式<br>    end<br>end<br>result=ifftshift(result);%直流分量移回到左上角<br>I2=ifft2(result);%傅里叶反变换<br>I3=uint8(real(I2));%取幅值并转换成8位无符号整数<br>figure,imshow(I3);</p>
<p>参考链接<a href="https://www.cnblogs.com/luyaoblog/p/7160948.html" target="_blank" rel="noopener">https://www.cnblogs.com/luyaoblog/p/7160948.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>历届试题 幸运数字</title>
    <url>/2019/03/12/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>问题描述<br>幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成<br><a id="more"></a><br>。<br>首先从1开始写出自然数1,2,3,4,5,6,….</p>
<p>1 就是第一个幸运数。</p>
<p>我们从2这个数开始。把所有序号能被2整除的项删除，变为：</p>
<p>1 _ 3 _ 5 _ 7 _ 9 ….</p>
<p>把它们缩紧，重新记序，为：</p>
<p>1 3 5 7 9 …. 。这时，3为第2个幸运数，然后把所有能被3整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被3整除!! 删除的应该是5，11, 17, …</p>
<p>此时7为第3个幸运数，然后再删去序号位置能被7整除的(19,39,…)</p>
<p>最后剩下的序列类似：</p>
<p>1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, …</p>
<p>输入格式<br>输入两个正整数m n, 用空格分开 (m &lt; n &lt; 1000*1000)<br>输出格式<br>程序输出 位于m和n之间的幸运数的个数（不包含m和n）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入1</span><br><span class="line">1 20</span><br><span class="line">样例输出1</span><br><span class="line">5</span><br><span class="line">样例输入2</span><br><span class="line">30 69</span><br><span class="line">样例输出2</span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 1000009</span><br><span class="line">using namespace std;</span><br><span class="line">int a[MAX];</span><br><span class="line">int m,n;</span><br><span class="line">void dfs(int s)&#123;</span><br><span class="line">	//幸运数的个数 </span><br><span class="line">	int cnt=s;</span><br><span class="line">	if(a[s]&gt;m) return;</span><br><span class="line">	int t=a[s]; </span><br><span class="line">	//下标能被幸运数整除 则删去</span><br><span class="line">	for(int i=s;i&lt;m;i++)&#123;</span><br><span class="line">		if(i%t) a[cnt++]=a[i];</span><br><span class="line"> 	&#125; </span><br><span class="line">	dfs(s+1);</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;m;i++)&#123;</span><br><span class="line">		a[i]=2*i-1;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(1);</span><br><span class="line">	int i=1;</span><br><span class="line">	int ans=0;</span><br><span class="line">	while(a[i]&lt;m)&#123;</span><br><span class="line">		if(a[i++]&gt;n) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    int a[500005];</span><br><span class="line">    int sum = 0;</span><br><span class="line">    //除去2以后的数组</span><br><span class="line">    for (int i = 1; i &lt;500005; i++)</span><br><span class="line">        a[i] = 2 * i - 1;</span><br><span class="line">    int temp = 2;</span><br><span class="line">    int k = 500005;</span><br><span class="line">    int b[500005];    //b[n]是收缩后的新数组</span><br><span class="line">    while (temp &lt;= 1000) &#123;</span><br><span class="line">        int t = 1;</span><br><span class="line">        for (int i = 1; i &lt;k; i++)    //幸运数从3开始，因为每一次收缩后都形成新的数组，所以t每一轮都要重新赋1</span><br><span class="line">            if (i%a[temp] != 0) &#123;</span><br><span class="line">                b[t] = a[i];</span><br><span class="line">                t++;      //新数组共t-1个数字</span><br><span class="line">            &#125;</span><br><span class="line">        for (int j = 1; j &lt; t; j++)</span><br><span class="line">            a[j] = b[j];</span><br><span class="line">        temp++;</span><br><span class="line">        k = t;    //k是新数组元素个数，下一轮只需要循环k轮</span><br><span class="line">    &#125;</span><br><span class="line">    //统计m到n之间有多少幸运数</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (a[i] &gt; m&amp;&amp;a[i] &lt; n)</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2018/05/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。<br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fqza5q7u10j31d411m0z8.jpg" alt="image"><br><a id="more"></a></p>
<h2 id="文字解释"><a href="#文字解释" class="headerlink" title="文字解释"></a>文字解释</h2><p>归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。<br>如　设有数列{6，202，100，301，38，8，1}<br>初始状态：6,202,100,301,38,8,1<br>第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；<br>第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；<br>第三次归并后：{1,6,8,38,100,202,301},比较次数：4；<br>总的比较次数为：3+4+4=11,；<br>逆序数为14；</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fqzausnybzj30cs09sq6v.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fqzav2wjl8j30cv08wn14.jpg" alt="image"></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>递归法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void MergeArray(int a[],int first,int mid,int last)</span><br><span class="line">&#123;</span><br><span class="line">    int b[100],k=0;</span><br><span class="line">    int i=first,j=mid+1;</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=last)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]&lt;a[j])</span><br><span class="line">            b[k++]=a[i++];</span><br><span class="line">        else b[k++]=a[j++];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    while(i&lt;=mid)</span><br><span class="line">        b[k++]=a[i++];</span><br><span class="line">    while(j&lt;=last)</span><br><span class="line">        b[k++]=a[j++];</span><br><span class="line">    for(int i=0; i&lt;k; i++)</span><br><span class="line">        a[first+i]=b[i];</span><br><span class="line">&#125;</span><br><span class="line">void MergeSort(int first,int last,int a[])</span><br><span class="line">&#123;</span><br><span class="line">    if(first&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        int    mid=(first+last)/2;</span><br><span class="line">        MergeSort(first,mid,a);</span><br><span class="line">        MergeSort(mid+1,last,a);</span><br><span class="line">        MergeArray(a,first,mid,last);</span><br><span class="line">        //这里也可不传mid参数</span><br><span class="line">        //可写成MergeArray(a,first,last),可以在合并有序数组时算一下mid</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int a[10]= &#123;6,202,100,301,38,8,1&#125;;</span><br><span class="line">    MergeSort(0,6,a);</span><br><span class="line">    for(int i=0; i&lt;7; i++)</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fqzckwq5gkj30cj03q74s.jpg" alt="image"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>归并排序它为什么会快呢？</strong></p>
<p>想回答这个问题可以先想一下提高排序速度的两个重要的途径：一个是减少比较次数，一个是减少交换次数。</p>
<p>对于归并排序而言，我们来从之前的例子应该可以看到，两个数组的合并过程是线性时间的，也就是说我们每一次比较都可以确定出一个元素的位置。这是一个重要的性质。</p>
<p>我们来看一个可以用一个例子来体会一下假如有这样一个数组｛ 3，7，2，5，1，0，4，6 ｝，</p>
<p>冒泡和选择排序的比较次数是25次。</p>
<p>直接插入排序用了15次。</p>
<p>而归并排序的次数是相对稳定的，由我们上面提到的比较次数的计算方法，我们的例子要合并4对长度为1的，2对长度为2的，和1对长度为4的。</p>
<p>归并排序的最多的比较次数为4 <em> 1 + 2 </em> 3 + 7 = 17次。</p>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>  算法提高 快乐司机  </title>
    <url>/2019/03/17/%E5%BF%AB%E4%B9%90%E5%8F%B8%E6%9C%BA/</url>
    <content><![CDATA[<p>问题描述<br>　　“嘟嘟嘟嘟嘟嘟<br>　　喇叭响<br>　　我是汽车小司机<br>  <a id="more"></a><br>　　我是小司机<br>　　我为祖国运输忙<br>　　运输忙”<br>　　这是儿歌“快乐的小司机”。话说现在当司机光有红心不行，还要多拉快跑。多拉不是超载，是要让所载货物价值最大，特别是在当前油价日新月异的时候。司机所拉货物为散货，如大米、面粉、沙石、泥土……<br>　　现在知道了汽车核载重量为w，可供选择的物品的数量n。每个物品的重量为gi,价值为pi。求汽车可装载的最大价值。（n&lt;10000,w&lt;10000,0&lt;gi&lt;=100,0&lt;=pi&lt;=100)<br>输入格式<br>　　输入第一行为由空格分开的两个整数n w<br>　　第二行到第n+1行，每行有两个整数，由空格分开，分别表示gi和pi<br>输出格式<br>　　最大价值（保留一位小数）<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入</span><br><span class="line">5 36</span><br><span class="line">99 87</span><br><span class="line">68 36</span><br><span class="line">79 43</span><br><span class="line">75 94</span><br><span class="line">7 35</span><br><span class="line">样例输出</span><br><span class="line">71.3</span><br><span class="line">解释：</span><br><span class="line">先装第5号物品，得价值35，占用重量7</span><br><span class="line">再装第4号物品，得价值36.346,占用重量29</span><br><span class="line">最后保留一位小数，得71.3</span><br></pre></td></tr></table></figure></p>
<p>贪心 优先选择单位价值高的商品<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAXN 10001</span><br><span class="line">using namespace std;</span><br><span class="line">struct good&#123;</span><br><span class="line">	int w,c;</span><br><span class="line">	double pv;</span><br><span class="line">	good()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">good g[MAXN];</span><br><span class="line">bool cmp(good a,good b)&#123;</span><br><span class="line">	return a.pv&gt;b.pv;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,W;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;W;</span><br><span class="line">	int max=-1;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;g[i].w&gt;&gt;g[i].c; </span><br><span class="line">		g[i].pv=g[i].c*1.0/g[i].w;		</span><br><span class="line">	&#125;</span><br><span class="line">	double sum=0;</span><br><span class="line">	int w=W;</span><br><span class="line">	int i=0;</span><br><span class="line">	sort(g,g+n,cmp);</span><br><span class="line">	while(w&gt;0)&#123;</span><br><span class="line">		if(w&gt;=g[i].w)&#123;sum+=g[i].c;</span><br><span class="line">		w-=g[i].w;</span><br><span class="line">		i++;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			sum+=1.0*w*g[i].pv;</span><br><span class="line">			break;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%.1f\n&quot;,sum);</span><br><span class="line">//	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯 快速排序</title>
    <url>/2019/03/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>排序在各种场合经常被用到。<br>快速排序是十分常用的高效率的算法。<br><a id="more"></a><br>其思想是：先选一个“标尺”，<br>用它把整个队列过一遍筛子，<br>以保证：其左边的元素都不大于它，其右边的元素都不小于它。</p>
<p>这样，排序问题就被分割为两个子区间。<br>再分别对子区间排序就可以了。</p>
<p>下面的代码是一种实现，请分析并填写划线部分缺少的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swap(int a[], int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">int t = a[i];</span><br><span class="line">a[i] = a[j]; </span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int partition(int a[], int p, int r)</span><br><span class="line">&#123;</span><br><span class="line">int i = p;</span><br><span class="line">int j = r + 1;</span><br><span class="line">int x = a[p];</span><br><span class="line">while(1)&#123;</span><br><span class="line">while(i&lt;r &amp;&amp; a[++i]&lt;x);</span><br><span class="line">while(a[--j]&gt;x);</span><br><span class="line">cout&lt;&lt;&quot;i&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;&quot;j:&quot;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">if(i&gt;=j) break;</span><br><span class="line">swap(a,i,j);</span><br><span class="line">&#125;</span><br><span class="line">______________________;</span><br><span class="line">//swap(a,p,j)</span><br><span class="line">return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quicksort(int a[], int p, int r)</span><br><span class="line">&#123;</span><br><span class="line">if(p&lt;r)&#123;</span><br><span class="line">int q = partition(a,p,r);  		</span><br><span class="line">cout&lt;&lt;&quot;q:&quot;&lt;&lt;q&lt;&lt;endl;				</span><br><span class="line">quicksort(a,p,q-1);</span><br><span class="line">quicksort(a,q+1,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int a[] = &#123;2,5,3,-1,4&#125;;</span><br><span class="line">int N = 5;</span><br><span class="line"></span><br><span class="line">quicksort(a, 0, N-1);</span><br><span class="line"></span><br><span class="line">for(i=0; i&lt;N; i++) printf(&quot;%d &quot;, a[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/006wtREyly1g1cg5v62s0j304n04t3ym.jpg" alt></p>
<p>快排单步(就是将一堆数按照某个数作为基准数分成左右两堆)这个实现方式有几种代码表现。在这里答案是swap(a,p,j).<br>不能填swap(a,p,i).</p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>周总结(29)</title>
    <url>/2020/05/06/%E6%80%BB%E7%BB%93-33/</url>
    <content><![CDATA[<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>说不出来的有种迷茫</p>
<p>或许是对自己跨专业的不自信<br><a id="more"></a><br>或是对未来的不确定</p>
<p>与过去的自己相比，自己退步了不少</p>
<p>想想当时看论文 写总结的心情，倒是最享受的</p>
<p>没有任何功利，只是想多学点知识</p>
<p>嗯…也许现在更需要这种心态</p>
<p>不要在乎结果，要注重过程，因为很多事都是说不准的，现在的结果都是过去的每一步影响的，找调剂也是如此。你要相信自己一定可以的。</p>
<p>拼尽全力去做一件事的时候 你是如此的自信。</p>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结（22）</title>
    <url>/2018/12/10/%E6%80%BB%E7%BB%93%EF%BC%8822%EF%BC%89/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li><p>考完csp认证才发现自己和别人的差距并不是一点，会发现自己离自己想要的目标还有很远，而且很多东西都是在那一到两个月内学的 承认自己的不足  毕竟我们都在路上 能做的只是怎么样才能让今天的自己比昨天的自己好一点</p>
</li>
<li><p>希望你清楚自己正在干什么 活在当下 日积月累的进步才会让你看到不一样的自己</p>
</li>
<li><p>不要太关注结果 毕竟过程与体验是最难忘的 也是最珍贵的礼物</p>
<a id="more"></a>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2></li>
<li><p>刷了一遍电影 狗十三 发现懂事是个微乎其微的词，在电影里总会产生某种共鸣，看不懂的人该是有多幸运，只是成长必定是付出了某些代价。</p>
</li>
<li><p>在懂事 听话面前没有任何让你反驳的机会，因为你早已预料到了结果，谁又会真正地从事情的出发点去考虑 从对与错考虑。在大人的世界里 你的话永远无足轻重，哪怕你真的已经尽力了。</p>
</li>
<li><p>有些事放不下的就忘了吧 释然是对自己最好的礼物。</p>
</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li><p>把高数复习完</p>
</li>
<li><p>带着看一节算法视频</p>
</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>  历届试题 打印十字图  </title>
    <url>/2019/03/12/%E6%89%93%E5%8D%B0%E5%8D%81%E5%AD%97%E5%9B%BE-1/</url>
    <content><![CDATA[<p>问题描述<br>小明为某机构设计了一个十字型的徽标（并非红十字会啊），如下所示：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..$$$$$$$$$$$$$..</span><br><span class="line">..$...........$..</span><br><span class="line">$$$.$$$$$$$$$.$$$</span><br><span class="line">$...$.......$...$</span><br><span class="line">$.$$$.$$$$$.$$$.$</span><br><span class="line">$.$...$...$...$.$</span><br><span class="line">$.$.$$$.$.$$$.$.$</span><br><span class="line">$.$.$...$...$.$.$</span><br><span class="line">$.$.$.$$$$$.$.$.$</span><br><span class="line">$.$.$...$...$.$.$</span><br><span class="line">$.$.$$$.$.$$$.$.$</span><br><span class="line">$.$...$...$...$.$</span><br><span class="line">$.$$$.$$$$$.$$$.$</span><br><span class="line">$...$.......$...$</span><br><span class="line">$$$.$$$$$$$$$.$$$</span><br><span class="line">..$...........$..</span><br><span class="line">..$$$$$$$$$$$$$..</span><br></pre></td></tr></table></figure></p>
<p>对方同时也需要在电脑dos窗口中以字符的形式输出该标志，并能任意控制层数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">一个正整数 n (n&lt;30) 表示要求打印图形的层数。</span><br><span class="line">输出格式</span><br><span class="line">对应包围层数的该标志。</span><br><span class="line">样例输入1</span><br><span class="line">1</span><br><span class="line">样例输出1</span><br><span class="line">..$$$$$..</span><br><span class="line">..$...$..</span><br><span class="line">$$$.$.$$$</span><br><span class="line">$...$...$</span><br><span class="line">$.$$$$$.$</span><br><span class="line">$...$...$</span><br><span class="line">$$$.$.$$$</span><br><span class="line">..$...$..</span><br><span class="line">..$$$$$..</span><br><span class="line">样例输入2</span><br><span class="line">3</span><br><span class="line">样例输出2</span><br><span class="line">..$$$$$$$$$$$$$..</span><br><span class="line">..$...........$..</span><br><span class="line">$$$.$$$$$$$$$.$$$</span><br><span class="line">$...$.......$...$</span><br><span class="line">$.$$$.$$$$$.$$$.$</span><br><span class="line">$.$...$...$...$.$</span><br><span class="line">$.$.$$$.$.$$$.$.$</span><br><span class="line">$.$.$...$...$.$.$</span><br><span class="line">$.$.$.$$$$$.$.$.$</span><br><span class="line">$.$.$...$...$.$.$</span><br><span class="line">$.$.$$$.$.$$$.$.$</span><br><span class="line">$.$...$...$...$.$</span><br><span class="line">$.$$$.$$$$$.$$$.$</span><br><span class="line">$...$.......$...$</span><br><span class="line">$$$.$$$$$$$$$.$$$</span><br><span class="line">..$...........$..</span><br><span class="line">..$$$$$$$$$$$$$..</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//先打印中间的十字形 再打印上下左右四条横线 再补全几个小方块</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX  1000</span><br><span class="line">using namespace std;</span><br><span class="line">char g[MAX][MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	fill(g[0],g[0]+MAX*MAX,&apos;.&apos;);</span><br><span class="line">	for(int i=2*n;i&lt;=2*n+4;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		g[2*n+2][i]=&apos;$&apos;;</span><br><span class="line">		g[i][2*n+2]=&apos;$&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		int a=2*i,b=2*(i+1),c=4*n+5;</span><br><span class="line">		for(int k=b;k&lt;c-b;k++)&#123;</span><br><span class="line">			g[k][a]=&apos;$&apos;;</span><br><span class="line">			g[k][c-1-a]=&apos;$&apos;;</span><br><span class="line">			g[a][k]=&apos;$&apos;;</span><br><span class="line">			g[c-1-a][k]=&apos;$&apos;;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		//左上 </span><br><span class="line">		g[b][b]=&apos;$&apos;;</span><br><span class="line">		g[b-1][b]=&apos;$&apos;;</span><br><span class="line">		g[b][b-1]=&apos;$&apos;;</span><br><span class="line">		</span><br><span class="line">		g[c-1-b][b]=&apos;$&apos;;</span><br><span class="line">		g[c-b][b]=&apos;$&apos;;</span><br><span class="line">		g[c-1-b][b-1]=&apos;$&apos;;</span><br><span class="line">		</span><br><span class="line">		g[b][c-1-b]=&apos;$&apos;;</span><br><span class="line">		g[b-1][c-1-b]=&apos;$&apos;;</span><br><span class="line">		g[b][c-b]=&apos;$&apos;;</span><br><span class="line">		</span><br><span class="line">		g[c-1-b][c-1-b]=&apos;$&apos;;</span><br><span class="line">		g[c-b][c-1-b]=&apos;$&apos;;</span><br><span class="line">		g[c-1-b][c-b]=&apos;$&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;4*n+5;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;4*n+5;j++)</span><br><span class="line">			cout&lt;&lt;g[i][j];</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接<br><a href="https://blog.csdn.net/bear_huangzhen/article/details/78465458" target="_blank" rel="noopener">https://blog.csdn.net/bear_huangzhen/article/details/78465458</a><br><a href="http://www.voidcn.com/article/p-xxsmrnet-cr.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-xxsmrnet-cr.html</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title> 蓝桥杯 承压计算</title>
    <url>/2019/03/22/%E6%89%BF%E5%8E%8B%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>标题：承压计算</p>
<p>X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。<br> <a id="more"></a><br>每块金属原料的外形、尺寸完全一致，但重量不同。<br>金属材料被严格地堆放成金字塔形。<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                             7 </span><br><span class="line">                            5 8 </span><br><span class="line">                           7 8 8 </span><br><span class="line">                          9 2 7 2 </span><br><span class="line">                         8 1 4 9 1 </span><br><span class="line">                        8 1 8 8 4 1 </span><br><span class="line">                       7 9 6 1 4 5 4 </span><br><span class="line">                      5 6 5 5 6 9 5 6 </span><br><span class="line">                     5 5 4 7 9 3 5 5 1 </span><br><span class="line">                    7 5 7 9 7 4 7 3 3 1 </span><br><span class="line">                   4 6 4 5 5 8 8 3 2 4 3 </span><br><span class="line">                  1 1 3 3 1 6 6 5 5 4 4 2 </span><br><span class="line">                 9 9 9 2 1 9 1 9 2 9 5 7 9 </span><br><span class="line">                4 3 3 7 7 9 3 6 1 3 8 8 3 7 </span><br><span class="line">               3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 </span><br><span class="line">              8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 </span><br><span class="line">             8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 </span><br><span class="line">            2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 </span><br><span class="line">           7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 </span><br><span class="line">          9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 </span><br><span class="line">         5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 </span><br><span class="line">        6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 </span><br><span class="line">       2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 </span><br><span class="line">      7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 </span><br><span class="line">     1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 </span><br><span class="line">    2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 </span><br><span class="line">   7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 </span><br><span class="line">  7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 </span><br><span class="line"> 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 </span><br><span class="line">X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X</span><br></pre></td></tr></table></figure></p>
<p>其中的数字代表金属块的重量（计量单位较大）。<br>最下一层的X代表30台极高精度的电子秤。</p>
<p>假设每块原料的重量都十分精确地平均落在下方的两个金属块上，<br>最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。<br>电子秤的计量单位很小，所以显示的数字很大。</p>
<p>工作人员发现，其中读数最小的电子秤的示数为：2086458231</p>
<p>请你推算出：读数最大的电子秤的示数为多少？</p>
<p>注意：需要提交的是一个整数，不要填写任何多余的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1000</span><br><span class="line">double dp[MAX][MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n=30;</span><br><span class="line">	freopen(&quot;22.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;=i;j++)&#123;</span><br><span class="line">			cin&gt;&gt;dp[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;=i;j++)&#123;</span><br><span class="line">			dp[i+1][j]+=dp[i][j]*1.0/2;</span><br><span class="line">			dp[i+1][j+1]+=dp[i][j]*1.0/2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  int mi = 0,mx = 0;</span><br><span class="line">    for(int i =0 ; i &lt;n ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dp[n-1][i] &gt; dp[n-1][mx])mx = i;</span><br><span class="line">        if(dp[n-1][i] &lt; dp[n-1][mi])mi = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lf\n&quot;,dp[n-1][mi]);//3.886331</span><br><span class="line">      printf(&quot;%lf\n&quot;,dp[n-1][mx]);//135.349469</span><br><span class="line">   //对于单精度数，使用%f格式符输出时，仅前7位是有效数字，小数6位．</span><br><span class="line">//对于双精度数，使用%lf格式符输出时，前16位是有效数字，小数6位．</span><br><span class="line">      printf(&quot;%lf\n&quot;,135.349469*((long long)2086458231)/3.886331 );//72665198526.972961</span><br><span class="line">      //先计算完再输出 </span><br><span class="line">    printf(&quot;%lf\n&quot;,dp[n-1][mx]*((long long)2086458231)/dp[n-1][mi]);//72665192664.000000</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意精度问题<br>double 只能精确到小数点后  15位<br>还有double型数字的输出<br>printf(“%lf”,dp[n-1][mx]);</p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练 操作格子 </title>
    <url>/2019/03/09/%E6%93%8D%E4%BD%9C%E6%A0%BC%E5%AD%90-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>线段树 思想<br>问题描述<br>有n个格子，从左到右放成一排，编号为1-n。<br>共有m次操作，有3种操作类型：<br>1.修改一个格子的权值，<br>2.求连续一段格子权值和，<br>3.求连续一段格子的最大值。<br><a id="more"></a><br>对于每个2、3操作输出你所求出的结果。<br>输入格式<br>第一行2个整数n，m。<br>接下来一行n个整数表示n个格子的初始权值。<br>接下来m行，每行3个整数p,x,y，p表示操作类型，p=1时表示修改格子x的权值为y，p=2时表示求区间[x,y]内格子权值和，p=3时表示求区间[x,y]内格子最大的权值。<br>输出格式<br>有若干行，行数等于p=2或3的操作总数。<br>每行1个整数，对应了每个p=2或3操作的结果。<br>样例输入<br>4 3<br>1 2 3 4<br>2 1 3<br>1 4 3<br>3 1 4<br>样例输出<br>6<br>3<br>数据规模与约定<br>对于20%的数据n &lt;= 100，m &lt;= 200。<br>对于50%的数据n &lt;= 5000，m &lt;= 5000。<br>对于100%的数据1 &lt;= n &lt;= 100000，m &lt;= 100000，0 &lt;= 格子权值 &lt;= 10000。</p>
<p><strong>用结构体数组建立一棵线段树~当p==1时从上到下更新这个线段树的值，当p==2的时候搜索对应区间内的总和~当p==3的时候搜索对应区间的最大值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define max(a, b) a &gt; b ? a : b;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">struct node &#123;</span><br><span class="line">    int l;</span><br><span class="line">    int r;</span><br><span class="line">    int maxvalue;</span><br><span class="line">    int sum;</span><br><span class="line">&#125; a[1000000];</span><br><span class="line"> </span><br><span class="line">void init(int left, int right, int i) &#123;</span><br><span class="line">    a[i].l = left;</span><br><span class="line">    a[i].r = right;</span><br><span class="line">    a[i].maxvalue = 0;</span><br><span class="line">    a[i].sum = 0;</span><br><span class="line">    if(left != right) &#123;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        init(left, mid, 2 * i);</span><br><span class="line">        init(mid + 1, right, 2*i+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void insert(int i, int j, int value) &#123;</span><br><span class="line">    if(a[i].l == a[i].r) &#123;</span><br><span class="line">        a[i].maxvalue = value;</span><br><span class="line">        a[i].sum = value;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (a[i].l + a[i].r) / 2;</span><br><span class="line">    if(j &lt;= mid)</span><br><span class="line">        insert(2 * i, j, value);</span><br><span class="line">    else</span><br><span class="line">        insert(2 * i + 1, j, value);</span><br><span class="line">    a[i].maxvalue = max(a[2*i].maxvalue, a[2*i+1].maxvalue);</span><br><span class="line">    a[i].sum = a[2*i].sum + a[2*i+1].sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int find_sum(int i, int x, int y) &#123;</span><br><span class="line">    if(x == a[i].l &amp;&amp; y == a[i].r) &#123;</span><br><span class="line">        return a[i].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (a[i].l + a[i].r) / 2;</span><br><span class="line">    if(y &lt;= mid)</span><br><span class="line">        return find_sum(2*i, x, y);</span><br><span class="line">    else if(x &gt; mid)</span><br><span class="line">        return find_sum(2*i+1, x, y);</span><br><span class="line">    else</span><br><span class="line">    		//错误 </span><br><span class="line">		//return find_sum(i,l,mid)+ find_sum(i,mid+1,r);</span><br><span class="line">        return find_sum(2*i, x, mid)+ find_sum(2*i+1, mid+1, y);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int find_max(int i, int x, int y) &#123;</span><br><span class="line">    if(x == a[i].l &amp;&amp; y == a[i].r) &#123;</span><br><span class="line">        return a[i].maxvalue;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (a[i].l + a[i].r) / 2;</span><br><span class="line">    if(y &lt;= mid)</span><br><span class="line">        return find_max(2*i, x, y);</span><br><span class="line">    else if(x &gt; mid)</span><br><span class="line">        return find_max(2*i+1, x, y);</span><br><span class="line">    else</span><br><span class="line">        return max(find_max(2*i, x, mid), find_max(2*i+1, mid+1, y));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    init(1, n, 1);</span><br><span class="line">    int value;</span><br><span class="line">    for(int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">        cin &gt;&gt; value;</span><br><span class="line">        insert(1, j, value);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int k = 0; k &lt; m; k++) &#123;</span><br><span class="line">        int p, x, y;</span><br><span class="line">        cin &gt;&gt; p &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        if(p == 1)</span><br><span class="line">            insert(1, x, y);</span><br><span class="line">        if(p == 2)</span><br><span class="line">            cout &lt;&lt; find_sum(1, x, y) &lt;&lt; endl;</span><br><span class="line">        if(p == 3)</span><br><span class="line">            cout &lt;&lt; find_max(1, x, y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考<br><a href="https://www.liuchuo.net/archives/1338" target="_blank" rel="noopener">https://www.liuchuo.net/archives/1338</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
  </entry>
  <entry>
    <title>  算法提高 拿糖果  </title>
    <url>/2019/03/15/%E6%8B%BF%E7%B3%96%E6%9E%9C%E3%80%81/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　妈妈给小B买了N块糖！但是她不允许小B直接吃掉。<br>　　假设当前有M块糖，小B每次可以拿P块糖，其中P是M的一个不大于根号下M的质因数。这时，妈妈就会在小B拿了P块糖以后再从糖堆里拿走P块糖。然后小B就可以接着拿糖。<br>　　现在小B希望知道最多可以拿多少糖。<br>输入格式<br>　　一个整数N<br>输出格式<br>　　最多可以拿多少糖<br>样例输入</p>
<p>15</p>
<p>样例输出</p>
<p>6</p>
<p>数据规模和约定</p>
<p>　　N &lt;= 100000</p>
<p> 注意p会随着n的减少而减少，所以外层应该放质量，内层放选法，最后感觉这规模没必要倍筛</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX  100002</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int dp[MAX];</span><br><span class="line">bool is_p(int x)&#123;</span><br><span class="line">	for(int i=2;i*i&lt;x;i++)&#123;</span><br><span class="line">		if(x%i==0) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=4;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=2;j*j&lt;=i;j++)&#123;</span><br><span class="line">			if(i%j==0&amp;&amp;is_p(j))&#123;</span><br><span class="line">				dp[i]=max(dp[i],dp[i-2*j]+j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>数字三角形</title>
    <url>/2018/12/18/%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　 请编一个程序计算从顶至底的某处的一条路<br>　　径，使该路径所经过的数字的总和最大。</p>
<p>●每一步可沿左斜线向下或右斜线向下走；</p>
<p>●1＜三角形行数≤100；<br>　<br> ●三角形中的数字为整数0，1，…99；<br><a id="more"></a><br>输入格式<br>　　文件中首先读到的是三角形的行数。</p>
<p>　　接下来描述整个三角形<br>输出格式<br>　　最大总和（整数）</p>
<p>样例输入</p>
<p>5</p>
<p>7</p>
<p>3 8</p>
<p>8 1 0</p>
<p>2 7 4 4</p>
<p>4 5 2 6 5</p>
<p>样例输出<br>30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 100</span><br><span class="line">int a[MAX][MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;=i;j++)&#123;</span><br><span class="line">			cin&gt;&gt;a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=n-1;i&gt;=1;i--)&#123;</span><br><span class="line">			for(int j=0;j&lt;i;j++)</span><br><span class="line">		a[i-1][j]+=max(a[i][j],a[i][j+1]);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">cout&lt;&lt;a[0][0]&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>201503-2 数字排序</title>
    <url>/2018/11/26/%E6%95%B0%E5%AD%97%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>给定n个整数，请统计出每个整数出现的次数，按出现次数从多到少的顺序输出。</p>
<p>输入格式</p>
<p>输入的第一行包含一个整数n，表示给定数字的个数。</p>
<p>第二行包含n个整数，相邻的整数之间用一个空格分隔，表示所给定的整数。<br><a id="more"></a><br>输出格式</p>
<p>输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的次数。按出现次数递减的顺序输出。如果两个整数出现的次数一样多，则先输出值较小的，然后输出值较大的。</p>
<p>样例输入</p>
<p>12</p>
<p>5 2 3 3 1 3 4 2 5 2 3 5</p>
<p>样例输出</p>
<p>3 4</p>
<p>2 3</p>
<p>5 3</p>
<p>1 1</p>
<p>4 1</p>
<p>评测用例规模与约定<br>　　1 ≤ n ≤ 1000，给出的数都是不超过1000的非负整数。</p>
<p>问题链接：CCF201503试题。</p>
<p>问题描述：</p>
<p>  给定n个整数，请统计出每个整数出现的次数，按出现次数从多到少的顺序输出。</p>
<p>  这是一个统计排序的问题，先统计，后排序。一般用数组进行统计和排序，时空上难以获得完美。使用STL的包装类实现是一个好的选择。</p>
<p>map+优先队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int k,v;</span><br><span class="line">	node(int kk,int vv):k(kk),v(vv)&#123;</span><br><span class="line">	&#125;; </span><br><span class="line">	bool operator &lt;(const node &amp;p)const&#123;</span><br><span class="line">	if(p.v&gt;v) return true;</span><br><span class="line">	if(p.v==v) return p.k&lt;k;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,k;</span><br><span class="line">	map&lt;int,int&gt; dict;</span><br><span class="line">	int cnt=0;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	priority_queue&lt;node&gt; pq; </span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		if(!dict.count(k)) dict[k]=1;</span><br><span class="line">		else dict[k]++;</span><br><span class="line">	&#125;</span><br><span class="line">		for(map&lt;int,int&gt;::iterator it=dict.begin();it!=dict.end();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		pq.push(node(it-&gt;first,it-&gt;second));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line">		node t=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		cout&lt;&lt;t.k&lt;&lt;&quot; &quot;&lt;&lt;t.v&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>数据库中的restrict cascade 和set null</title>
    <url>/2018/06/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84restrict-cascade-%E5%92%8Cset-null/</url>
    <content><![CDATA[<p>restrict和cascade都是在外码定义时指定的关键字。</p>
<p>外码所指定的字段取值受限制，可以取两种值：</p>
<p>所参照主码中出现过的值；<br><a id="more"></a><br>可以取空值。</p>
<p>外码所指定的字段中数据的增删改是受到外码约束的限制的，在数据增删改时会检查是否满足外码约束条件，当不满足外码的条件时，所做的处理与定义外码时指定的restrict关键字或者cascade关键字有关。</p>
<p>下面以一个具体例子说明：</p>
<p>设有两张表：student和class，表定义语句为：</p>
<p>create table class(cno int primary key, cname varchar(20))</p>
<p>create table student(sno int primary key, sname varchar(10), cno int, foreign key(cno) references class(cno) on delete restrict)</p>
<p>第一张表class中，cno是主码，第二张表student中，sno是主码，cno是外码，外码的取值必须在class的主码cno中出现过，或者取空值。注意，在外码定义时指定了restrict关键字，此时，如果从class表中删除一条数据（即删除一个班级），student表中恰好有该班级的学生，则会报错，不允许删除。</p>
<p>如果在student表的外码定义时指定的是cascade，即</p>
<p>create table student(sno int primary key, sname varchar(10), cno int, foreign key(cno) references class(cno) on delete cascade)</p>
<p>则表示级联删除，删除class表中的一条数据时，会把student表中对应的数据一起删除掉。此外，在外码定义时还可以指定on delete set null，表示删除class表中的一条数据时，如果student表中有对应的数据，则把这些对应的数据的cno设置为空值NULL。</p>
]]></content>
  </entry>
  <entry>
    <title>矩阵快速幂</title>
    <url>/2019/03/17/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91-1/</url>
    <content><![CDATA[<p>cot数组一开始是A0，temp数组一开始是A1。我们来模拟下求第13项的斐波那契值是怎么求的。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步:n = 13，执行Matrix(cot,temp)和Matrix(temp,temp)，得到cot数组为A1，t数组为A2，n = 6</span><br><span class="line">第二步:n = 6，执行Matrix(temp,temp)，得到cot数组为A1，t数组为A4，n = 3</span><br><span class="line">第三步:n = 3，执行Matrix(cot,temp)和Matrix(temp,temp)，得到cot数组为A5，t数组为A8，n = 1</span><br><span class="line">第四步:n = 1，执行Matrix(cot,temp)和Matrix(temp,temp)，得到cot数组为A13，t数组为A16，n = 0</span><br><span class="line">退出while循环并输出cot数组对应的值。一共进行了4步。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N = 10000,n;</span><br><span class="line">void Matrix(int (&amp;a)[2][2],int b[2][2])&#123;</span><br><span class="line">    int tmp[2][2] = &#123;0&#125;;</span><br><span class="line">    for(int i = 0; i &lt; 2; ++i)</span><br><span class="line">        for(int j = 0; j &lt; 2; ++j)</span><br><span class="line">            for(int k = 0; k &lt; 2; ++k)</span><br><span class="line">                tmp[i][j] = (tmp[i][j] + a[i][k] * b[k][j]) % N;</span><br><span class="line">    for(int i = 0; i &lt; 2; ++i)</span><br><span class="line">        for(int j = 0; j &lt; 2; ++j)</span><br><span class="line">            a[i][j] = tmp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(cin&gt;&gt;n &amp;&amp; n!=-1)&#123;</span><br><span class="line">        int temp[2][2] = &#123;1, 1, 1, 0&#125;,cot[2][2] = &#123;1, 0, 0, 1&#125;;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            if(n &amp; 1) Matrix(cot,temp);</span><br><span class="line">            Matrix(temp,temp);</span><br><span class="line"></span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;cot[0][1]&lt;&lt;endl;//!</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接<br><a href="https://www.jianshu.com/p/1c3f88f63dec" target="_blank" rel="noopener">https://www.jianshu.com/p/1c3f88f63dec</a></p>
<p><a href="https://blog.csdn.net/acdreamers/article/details/21822165" target="_blank" rel="noopener">https://blog.csdn.net/acdreamers/article/details/21822165</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>新建Microsoft Word文档</title>
    <url>/2018/12/20/%E6%96%B0%E5%BB%BA/</url>
    <content><![CDATA[<hr>
]]></content>
  </entry>
  <entry>
    <title>201403-4无线网络</title>
    <url>/2018/12/10/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>问题描述<br>　　目前在一个很大的平面房间里有 n 个无线路由器,每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。<br>　<a id="more"></a><br> 除此以外,另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。<br>　<br> 你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少?</p>
<p>输入格式</p>
<p>第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。<br>　<br> 接下来 n 行,每行包含两个整数 xi 和 yi,表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。</p>
<p>接下来 m 行,每行包含两个整数 xi 和 yi,表示 (xi, yi) 点处可以增设 一个路由器。</p>
<p>输入中所有的坐标的绝对值不超过 108,保证输入中的坐标<br> 各不相同。</p>
<p>输出格式</p>
<p>输出只有一个数,即在指定的位置中增设 k 个路由器后,从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。</p>
<p>样例输入</p>
<p>5 3 1 3</p>
<p>0 0</p>
<p>5 5</p>
<p>0 3</p>
<p>0 5</p>
<p>3 5</p>
<p>3 3</p>
<p>4 4</p>
<p>3 0</p>
<p>样例输出</p>
<p>2</p>
<p>正确解法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cstring&gt; </span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#define INF 1e8</span><br><span class="line">using namespace std;</span><br><span class="line">struct room&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	room(int xx,int yy):x(xx),y(yy)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y,steps,kcnt;</span><br><span class="line">	node(int xx,int yy,int ss,int kk):x(xx),y(yy),steps(ss),kcnt(kk)&#123; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool vis[202]=&#123;false&#125;;//n+m</span><br><span class="line">vector&lt;room&gt; rooms;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	int n,m,k,r,x,y;</span><br><span class="line">//freopen(&quot;t1.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;n+m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">		rooms.push_back(room(x,y));</span><br><span class="line">	&#125;</span><br><span class="line">	int sr=rooms[0].x;</span><br><span class="line">	int sc=rooms[0].y;</span><br><span class="line">	int destr=rooms[1].x;</span><br><span class="line">	int destc=rooms[1].y;</span><br><span class="line">	</span><br><span class="line">	int ans=INF;</span><br><span class="line">			queue&lt;node&gt;q;</span><br><span class="line">		q.push(node(sr,sc,0,0));</span><br><span class="line">		</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">	int size=q.size();</span><br><span class="line">	while(size--)&#123;</span><br><span class="line">		node t=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		if(t.x==destr&amp;&amp;t.y==destc) &#123;</span><br><span class="line">			ans=min(ans,t.steps);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=1;j&lt;n+m;j++)&#123;</span><br><span class="line">			if(vis[j]) continue;</span><br><span class="line">			int x=rooms[j].x;</span><br><span class="line">		int	y=rooms[j].y;</span><br><span class="line">		double tmp=sqrt(pow(t.x-x,2)+pow(t.y-y,2));</span><br><span class="line">		 if(tmp&gt;r) continue;</span><br><span class="line">			if(t.kcnt&gt;=k&amp;&amp;j&gt;=n) continue;</span><br><span class="line">			vis[j]=true;</span><br><span class="line">			if(j&gt;=n)</span><br><span class="line">			q.push(node(x,y,t.steps+1,t.kcnt+1));</span><br><span class="line">			else</span><br><span class="line">			q.push(node(x,y,t.steps+1,t.kcnt));</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans-1&lt;&lt;endl;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>样例比较少的原因 所以暴力过了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cstring&gt; </span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">#define INF 1e8</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	node(int xx,int yy):x(xx),y(yy)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line">bool vis[MAX]=&#123;false&#125;;//n+m</span><br><span class="line">  //bool vis[MAX][MAX] 是错误的</span><br><span class="line">  //存储的是坐标有无被访问过 可能是负数</span><br><span class="line">  //!!!</span><br><span class="line">  vector&lt;node&gt; room;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	int n,m,k,r,x,y;</span><br><span class="line">//	freopen(&quot;t1.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;n+m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">		room.push_back(node(x,y));</span><br><span class="line">	&#125;</span><br><span class="line">	int sr=room[0].x;</span><br><span class="line">	int sc=room[0].y;</span><br><span class="line">	int destr=room[1].x;</span><br><span class="line">	int destc=room[1].y;</span><br><span class="line">	</span><br><span class="line">	int ans=INF;</span><br><span class="line">			queue&lt;node&gt;q;</span><br><span class="line">		q.push(node(sr,sc));</span><br><span class="line">		int steps=0;</span><br><span class="line">		while(!q.empty())&#123;</span><br><span class="line">			int size=q.size();</span><br><span class="line">			while(size--)&#123;</span><br><span class="line">				node t=q.front();</span><br><span class="line">				q.pop();</span><br><span class="line">				int x=t.x;</span><br><span class="line">				int y=t.y;</span><br><span class="line">				if(t.x==destr&amp;&amp;t.y==destc) &#123;</span><br><span class="line">			ans=min(ans,steps);</span><br><span class="line">				&#125; </span><br><span class="line">				for(int c=1;c&lt;n+m;c++)&#123;</span><br><span class="line">								if(vis[c]) continue;</span><br><span class="line">		</span><br><span class="line">				double tmp=sqrt(pow(abs(room[c].x-x),2)+pow(abs(room[c].y-y),2));</span><br><span class="line">		</span><br><span class="line">					if(tmp&lt;=r) &#123;</span><br><span class="line">						q.push(room[c]);</span><br><span class="line">						vis[c]=true;//!! 一维数组 </span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;</span><br><span class="line">			steps++;	</span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;ans-1&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复习<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">#define INF 1e8</span><br><span class="line">using namespace std;</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    edge(int xx,int yy):x(xx),y(yy)&#123;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,kcnt;</span><br><span class="line">    node(int xx,int yy,int cn):x(xx),y(yy),kcnt(cn)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line">int n,m,k,r;</span><br><span class="line">vector&lt;edge&gt; g;</span><br><span class="line">bool vis[MAX]=&#123;false&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;r;</span><br><span class="line">    for(int i=0;i&lt;n+m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g.push_back(edge(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    int sr=g[0].x,sc=g[0].y;</span><br><span class="line">    int dsr=g[1].x,dsc=g[1].y;</span><br><span class="line">    int step=0,ans=INF;</span><br><span class="line">    int sum=0;</span><br><span class="line">    queue&lt;node&gt; qu;</span><br><span class="line">    qu.push(node(sr,sc,0));</span><br><span class="line">    </span><br><span class="line">    while(!qu.empty())&#123;</span><br><span class="line">        int size=qu.size();</span><br><span class="line">        while(size--)&#123;</span><br><span class="line">            node t=qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        if(t.x==dsr&amp;&amp;t.y==dsc) &#123;</span><br><span class="line">            ans=min(ans,step);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;n+m;i++)&#123;</span><br><span class="line">            if(t.kcnt&gt;k&amp;&amp;i&gt;=n) continue;</span><br><span class="line">            if(vis[i]) continue;</span><br><span class="line">            </span><br><span class="line">            int nx=g[i].x;</span><br><span class="line">            int ny=g[i].y;</span><br><span class="line">            if(sqrt(pow(nx-t.x,2)+pow(ny-t.y,2))&gt;r) continue; </span><br><span class="line">            vis[i]=1;</span><br><span class="line">            if(i&gt;=n)&#123;</span><br><span class="line">                qu.push(node(nx,ny,t.kcnt+1));</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">                qu.push(node(nx,ny,t.kcnt));</span><br><span class="line">        &#125;   </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans-1&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>日常刷题</title>
    <url>/2020/04/20/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h2 id="13-Implement-strStr"><a href="#13-Implement-strStr" class="headerlink" title="13. Implement strStr()"></a>13. Implement strStr()</h2><p>对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 -1。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int strLen(const char*str)</span><br><span class="line">&#123;</span><br><span class="line">    int len=0;</span><br><span class="line">    while(str[len])</span><br><span class="line">        ++len;</span><br><span class="line">    return len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int strStr(const char *source, const char *target)</span><br><span class="line">&#123;</span><br><span class="line">    // write your code here</span><br><span class="line">    if(!source||!target)</span><br><span class="line">        return -1;</span><br><span class="line">    int sLen=strLen(source);</span><br><span class="line">    int tLen=strLen(target);</span><br><span class="line">    for(int i=0; i&lt;=sLen-tLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int j;</span><br><span class="line">        for(j=0; j&lt;tLen; j++)</span><br><span class="line">            if(source[i+j] == &apos;\0&apos; ||source[i+j]!=target[j])</span><br><span class="line">                break;</span><br><span class="line">        if(j==tLen) return i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a=strStr(&quot;abcdabc&quot;,&quot;bcd&quot;);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int strStr(const char *source, const char *target)</span><br><span class="line">&#123;</span><br><span class="line">    // write your code here</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    if(!source||!target)</span><br><span class="line">        return -1;</span><br><span class="line">  while(*source)</span><br><span class="line">  &#123;</span><br><span class="line">      const char *p=source;</span><br><span class="line">      const char *q=target;</span><br><span class="line">      while(*p==*q&amp;&amp;*q!=&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        p++;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">   if(*q==0) return i;</span><br><span class="line">      source++;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a=strStr(&quot;\0&quot;,&quot;\0&quot;);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="452删除链表中的元素"><a href="#452删除链表中的元素" class="headerlink" title="452删除链表中的元素"></a>452删除链表中的元素</h2><p>给出链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;5-&gt;3, 和 val = 3, 你需要返回删除3之后的链表：1-&gt;2-&gt;4-&gt;5。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param head: a ListNode</span><br><span class="line">     * @param val: An integer</span><br><span class="line">     * @return: a ListNode</span><br><span class="line">     */</span><br><span class="line">  ListNode*  removeElements(ListNode * head, int val) &#123;</span><br><span class="line">        // write your code </span><br><span class="line">        ListNode *pre,*node;</span><br><span class="line">        pre=NULL;</span><br><span class="line">        node=head;</span><br><span class="line">        while(node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node-&gt;val==val)&#123;</span><br><span class="line">                if(pre)</span><br><span class="line">                    pre-&gt;next=node-&gt;next;</span><br><span class="line">                else</span><br><span class="line">                    head=head-&gt;next;</span><br><span class="line">                  node=node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                pre=node;</span><br><span class="line">                node=node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>CCF201509-2 日期计算</title>
    <url>/2018/11/26/%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>问题描述<br>　　给定一个年份y和一个整数d，问这一年的第d天是几月几日？</p>
<p>注意闰年的2月有29天。满足下面条件之一的是闰年：</p>
<p>1） 年份是4的整数倍，而且不是100的整数倍；</p>
<p>2） 年份是400的整数倍。<br><a id="more"></a><br>输入格式</p>
<p>输入的第一行包含一个整数y，表示年份，年份在1900到2015之间（包含1900和2015）。</p>
<p>输入的第二行包含一个整数d，d在1至365之间。</p>
<p>输出格式</p>
<p>输出两行，每行一个整数，分别表示答案的月份和日期。</p>
<p>样例输入</p>
<p>2015</p>
<p>80</p>
<p>样例输出</p>
<p>3</p>
<p>21</p>
<p>样例输入</p>
<p>2000</p>
<p>40</p>
<p>样例输出</p>
<p>2<br>9</p>
<p>法一</p>
<p>累计到当前月份的天数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int run[13]=&#123;0,31,60,91,121,152,182,213,244,274,305,335,366&#125;;</span><br><span class="line">int pu[13]=&#123;0,31,59,90,120,151,181,212,243,273,304,334,365&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int y,d;</span><br><span class="line">	cin&gt;&gt;y&gt;&gt;d;</span><br><span class="line"></span><br><span class="line">	int i=0,minus=0,tmp;</span><br><span class="line">	while(1) </span><br><span class="line">	&#123;</span><br><span class="line">	if(y%400==0||(y%4==0&amp;&amp;y%100!=0))</span><br><span class="line">	&#123;</span><br><span class="line">		minus=run[i];</span><br><span class="line">	&#125;</span><br><span class="line">	else minus=pu[i];	</span><br><span class="line">	if(d-minus&lt;=0) &#123;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		i++;</span><br><span class="line">	tmp=minus;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;d-tmp&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>法二</p>
<p>  需要注意闰年问题。根据天数d，逐月计算月份，最后算出月份内的日，即采用天数逐月减去１月份天数、二月份天数、…的办法进行计算。</p>
<p>程序说明：</p>
<p>  使用数组days[]存储每月的天数。使用根据年判断闰年的函数isleapyear()调整二月份的天数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int days[12] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;</span><br><span class="line"> </span><br><span class="line">// 闰年计算函数</span><br><span class="line">int leapyear(int year) &#123;</span><br><span class="line">    return ((year%4 == 0 &amp;&amp; year%100 != 0) || year%400 == 0) ? 1 : 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int y, d, month=0, day, i;</span><br><span class="line"> </span><br><span class="line">    // 输入数据</span><br><span class="line">    cin &gt;&gt; y &gt;&gt; d;</span><br><span class="line"> </span><br><span class="line">    // 计算月与日</span><br><span class="line">    days[1] += leapyear(y);</span><br><span class="line">    i = 0;</span><br><span class="line">    while(d &gt; 0) &#123;</span><br><span class="line">        if(d &lt;= days[i]) &#123;</span><br><span class="line">            month = i + 1;</span><br><span class="line">            day = d;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            d -= days[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 输出结果</span><br><span class="line">    cout &lt;&lt; month &lt;&lt; endl &lt;&lt; day &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>201412-4 最优灌溉</title>
    <url>/2018/12/03/%E6%9C%80%E4%BC%98%E7%81%8C%E6%BA%89/</url>
    <content><![CDATA[<p>问题描述</p>
<p>雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。<br>　　为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。</p>
<p>现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。<br><a id="more"></a><br>输入格式</p>
<p>输入的第一行包含两个正整数n, m，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。</p>
<p>接下来m行，每行包含三个整数ai, bi, ci，表示第ai片麦田与第bi片麦田之间可以建立一条水渠，所需要的费用为ci。</p>
<p>输出格式</p>
<p>输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。</p>
<p>样例输入</p>
<p>4 4</p>
<p>1 2 1</p>
<p>2 3 4</p>
<p>2 4 2</p>
<p>3 4 3</p>
<p>样例输出</p>
<p>6</p>
<p>样例说明</p>
<p>建立以下三条水渠：麦田1与麦田2、麦田2与麦田4、麦田4与麦田3。</p>
<p>评测用例规模与约定<br>　<br> 前20%的评测用例满足：n≤5。<br>　<br> 前40%的评测用例满足：n≤20。<br>　<br> 前60%的评测用例满足：n≤100。<br>　　<br>  所有评测用例都满足：1≤n≤1000，1≤m≤100,000，1≤ci≤10,000。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最小生成树 优先队列 并查集思想</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt; </span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define INF 1e8</span><br><span class="line">using namespace std; </span><br><span class="line">struct node&#123;</span><br><span class="line">	int num;</span><br><span class="line">	int cost;</span><br><span class="line">	node(int nn,int cc):num(nn),cost(cc)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &lt; (const node &amp;p)const&#123;</span><br><span class="line">	return cost&gt;p.cost;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">class unionset&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">    vector&lt;int&gt; rank;</span><br><span class="line">	</span><br><span class="line">    unionset(int n)&#123;</span><br><span class="line">    parent=vector&lt;int&gt;(n+1,0);</span><br><span class="line">    rank=vector&lt;int&gt;(n+1,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">	parent[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bool Union(int u1,int u2)&#123;</span><br><span class="line">		int p1=find(u1);</span><br><span class="line">		int p2=find(u2);</span><br><span class="line">		if(p1==p2) return false;</span><br><span class="line">		if(rank[p1]&gt;rank[p2])&#123;</span><br><span class="line">			parent[p2]=p1;</span><br><span class="line">		&#125;</span><br><span class="line">        else if(rank[p2]&gt;rank[p1])&#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            parent[p2]=p1;</span><br><span class="line">            rank[p1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    int find(int num)&#123;</span><br><span class="line">        if(num!=parent[num])&#123;</span><br><span class="line">            parent[num]=find(parent[num]);//find(num)一直自己调用自己 错的 find(parent[num]) 往上回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[num];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;node&gt; &gt; g=vector&lt;vector&lt;node&gt; &gt;(1000+1);</span><br><span class="line">int vis[1000+1];</span><br><span class="line">int cost[1000+1];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int m,n,a,b,c;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	unionset u(n);</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		u.Union(a,b);</span><br><span class="line">		g[a].push_back(node(b,c));</span><br><span class="line">		g[b].push_back(node(a,c));</span><br><span class="line">	&#125;</span><br><span class="line">	set&lt;int&gt; s; </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">	s.insert(u.find(i));</span><br><span class="line">	cost[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	long ans=0;</span><br><span class="line">	for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)&#123;</span><br><span class="line">		cost[*it]=0;</span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">		priority_queue&lt;node&gt; q;</span><br><span class="line">		q.push(node(*it,0));</span><br><span class="line">		while(!q.empty())&#123;</span><br><span class="line">			node t=q.top();</span><br><span class="line">			q.pop();</span><br><span class="line">			if(vis[t.num]) continue;</span><br><span class="line">			vis[t.num]=1;</span><br><span class="line">			for(int i=0;i&lt;g[t.num].size();i++)&#123;</span><br><span class="line">				node nn=g[t.num][i];</span><br><span class="line">				if(vis[nn.num]) continue; </span><br><span class="line">				if(nn.cost&lt;cost[nn.num]) </span><br><span class="line">				&#123;</span><br><span class="line">				</span><br><span class="line">				cost[nn.num]=nn.cost;</span><br><span class="line">				q.push(node(nn.num,cost[nn.num]));</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans+=cost[i];</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复习了一遍  发现并查集中没有用rank来合并优化的时候 超时了(只有80分)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAX 1000+2</span><br><span class="line">#define INF 1e8</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int num;</span><br><span class="line">	int cost;</span><br><span class="line">	node(int nn,int cc):num(nn),cost(cc)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	node()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &lt; (const node p)const&#123;</span><br><span class="line">		return cost&gt;p.cost;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">class UF&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">    vector&lt;int&gt; rank;</span><br><span class="line">    UF(int n)&#123;</span><br><span class="line">    parent=vector&lt;int&gt;(n+1,0);</span><br><span class="line">    rank=vector&lt;int&gt;(n+1,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">	parent[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bool Union(int u1,int u2)&#123;</span><br><span class="line">		int p1=find(u1);</span><br><span class="line">		int p2=find(u2);</span><br><span class="line">		if(p1==p2) return false;</span><br><span class="line">		</span><br><span class="line">		if(rank[p1]&gt;rank[p2])&#123;</span><br><span class="line">			parent[p2]=p1;</span><br><span class="line">		&#125;</span><br><span class="line">        else if(rank[p2]&gt;rank[p1])&#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">            rank[p2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    int find(int num)&#123;</span><br><span class="line">        if(num!=parent[num])&#123;</span><br><span class="line">            parent[num]=find(parent[num]);//find(num)一直自己调用自己 错的 find(parent[num]) 往上回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[num];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">int cost[MAX];</span><br><span class="line">int vis[MAX];</span><br><span class="line">vector&lt;vector&lt;node&gt; &gt;g;</span><br><span class="line">int main()&#123;</span><br><span class="line">//	freopen(&quot;12-13.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	g=vector&lt;vector&lt;node&gt; &gt;(n+1);</span><br><span class="line">	UF u(n);</span><br><span class="line"></span><br><span class="line">	int w,f,v;</span><br><span class="line">	for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">		</span><br><span class="line">		cin&gt;&gt;w&gt;&gt;f&gt;&gt;v;</span><br><span class="line">		g[w].push_back(node(f,v));</span><br><span class="line">		//!!</span><br><span class="line">		g[f].push_back(node(w,v)); </span><br><span class="line">		u.Union(w,f);	</span><br><span class="line">	&#125;</span><br><span class="line">	set&lt;int&gt; s;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int r=u.find(i);</span><br><span class="line">		s.insert(r);</span><br><span class="line">		cost[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)&#123;</span><br><span class="line">			memset(vis,0,sizeof(vis));</span><br><span class="line">				priority_queue&lt;node&gt; pq;</span><br><span class="line">		pq.push(node(*it,0));</span><br><span class="line">		cost[*it]=0;</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line">		node t=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		vis[t.num]=1;</span><br><span class="line">		for(int i=0;i&lt;g[t.num].size();i++)&#123;</span><br><span class="line">			node p=g[t.num][i];</span><br><span class="line">			if(vis[p.num]) continue;</span><br><span class="line">			if(p.cost&lt;cost[p.num]) &#123;</span><br><span class="line">				cost[p.num]=p.cost;</span><br><span class="line">				pq.push(node(p.num,cost[p.num]));</span><br><span class="line">			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	long ans=0;</span><br><span class="line">	for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">	//	cout&lt;&lt;cost[j]&lt;&lt;&quot; &quot;;</span><br><span class="line">		ans+=cost[j];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>最优二叉搜索树</title>
    <url>/2018/12/20/%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<ol>
<li>概述<br>　　利用最优二叉搜索树来实现树的搜索代价最小。树上的每一个节点都有一个被搜索到的概率值，搜索一个节点的花费为，如何构造一个二叉查找树使搜索树上的 所有节点的花费最小即为实现最优二叉查找树的问题。该问题可以用动态规划的思路实现。<br>　　形式化定义：给定n个不同关键字已经排序的序列,我们希望用这些关键字构造一个二叉搜索树。对每个关键字,都有概率表示起搜索概率。有些要搜索的值可能不再K中，因此我们还需要n+1个伪关键字，对于每一个伪关键字都有一个概率表示对应的搜索概率。<a id="more"></a></li>
<li>问题案例<br>　　n=5的关键字集合以及如下的搜索概率，构造二叉搜索树。 </li>
</ol>
<p><img src="https://img-blog.csdn.net/20160311101024375" alt="image"></p>
<p>期望搜索代价的计算公式：<br><img src="https://img-blog.csdn.net/20160311101207074" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">//!</span><br><span class="line">double p[MAX];</span><br><span class="line">double q[MAX];</span><br><span class="line">double w[MAX][MAX],c[MAX][MAX],s[MAX][MAX]; </span><br><span class="line">void print(int i,int j,int flag)&#123;</span><br><span class="line">	if(flag==0)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;root:&quot;&lt;&lt;s[i][j]&lt;&lt;endl;</span><br><span class="line">		flag=1;</span><br><span class="line">	&#125;</span><br><span class="line">	int k=s[i][j];</span><br><span class="line">	if(k&gt;=i+1)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;S&quot;&lt;&lt;k-1&lt;&lt;&quot;is the left child of&quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">		print(i,k-1,1);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">			cout&lt;&lt;&quot;E&quot;&lt;&lt;i-1&lt;&lt;&quot;is the left child of&quot;&lt;&lt;&quot;E&quot;&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">		if(k&lt;j)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;S&quot;&lt;&lt;k+1&lt;&lt;&quot;is the right child of&quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">		print(k+1,j,1);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">			cout&lt;&lt;&quot;E&quot;&lt;&lt;k&lt;&lt;&quot;is the right child of&quot;&lt;&lt;&quot;E&quot;&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;p[i];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;=n;i++)</span><br><span class="line">	cin&gt;&gt;q[i];</span><br><span class="line">	for(int i=1;i&lt;=n+1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">				w[i][i-1]=q[i-1];</span><br><span class="line">				c[i][i-1]=0;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int d=1;d&lt;=n;d++)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n-d+1;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			int j=i+d-1;</span><br><span class="line">			w[i][j]=w[i][j-1]+p[j]+q[j];</span><br><span class="line">			double tmp=c[i+1][j]+w[i][j];//保存i-j构成二叉搜索树查找次数的最小值 </span><br><span class="line">				s[i][j]=i;</span><br><span class="line">				for(int k=i+1;k&lt;=j;k++)&#123;</span><br><span class="line">					if(c[i][k-1]+c[k+1][j]+w[i][j]&lt;tmp&amp;&amp;fabs(c[i][k-1]+c[k+1][j]+w[i][j]-tmp)&gt;1e-6)&#123;</span><br><span class="line">						tmp=c[i][k-1]+c[k+1][j]+w[i][j];</span><br><span class="line">						s[i][j]=k;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				c[i][j]=tmp;</span><br><span class="line">				</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;c[1][n]&lt;&lt;endl;</span><br><span class="line">	print(1,n,0);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fyd9qyxhcmj308408j754.jpg" alt="image"></p>
<p>參考博客</p>
<p><a href="https://blog.csdn.net/zhangyifei521/article/details/50833792" target="_blank" rel="noopener">https://blog.csdn.net/zhangyifei521/article/details/50833792</a></p>
]]></content>
      <categories>
        <category>趣学算法</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2545 树上战争</title>
    <url>/2018/12/13/%E6%9C%80%E4%BC%98%E9%85%8D%E9%A4%90/</url>
    <content><![CDATA[<p>Problem Description<br>给一棵树，如果树上的某个节点被某个人占据，则它的所有儿子都被占据，lxh和pfz初始时分别站在两个节点上，谁当前所在的点被另一个人占据，他就输了比赛，问谁能获胜</p>
<a id="more"></a>
<p>Input<br>输入包含多组数据<br>每组第一行包含两个数N，M（N，M&lt;=100000），N表示树的节点数，M表示询问数，N=M=0表示输入结束。节点的编号为1到N。<br>接下来N-1行，每行2个整数A，B(1&lt;=A,B&lt;=N)，表示编号为A的节点是编号为B的节点的父亲<br>接下来M行，每行有2个数，表示lxh和pfz的初始位置的编号X，Y(1&lt;=X,Y&lt;=N,X!=Y)，lxh总是先移动</p>
<p>Output<br>对于每次询问，输出一行，输出获胜者的名字</p>
<p>Sample Input</p>
<p>2 1</p>
<p>1 2</p>
<p>1 2</p>
<p>5 2</p>
<p>1 2</p>
<p>1 3 </p>
<p>3 4</p>
<p>3 5 </p>
<p>4 2 </p>
<p>4 5</p>
<p>0 0</p>
<p>Sample Output<br>lxh pfz lxh 提示： 本题输入、输出都很多，请使用scanf和printf代替cin、cout。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">class UF&#123;</span><br><span class="line">	public:</span><br><span class="line">	vector&lt;int&gt;v;</span><br><span class="line">	UF(int n)&#123;</span><br><span class="line">		v=vector&lt;int&gt;(n+2);</span><br><span class="line">		for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">			v[i]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Union(int a,int b)&#123;</span><br><span class="line">		v[b]=a;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	int getDis(int a)&#123;</span><br><span class="line">		int dis=0;</span><br><span class="line">		while(a!=v[a])&#123;</span><br><span class="line">			a=v[a];</span><br><span class="line">			dis++;</span><br><span class="line">		&#125;</span><br><span class="line">		return dis;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">	UF u(n); </span><br><span class="line">	if(n==0&amp;&amp;m==0) break;</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">	u.Union(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;y; </span><br><span class="line">	int l1=u.getDis(x);</span><br><span class="line">	int l2=u.getDis(y);</span><br><span class="line">	//cout&lt;&lt;l1&lt;&lt;&quot; &quot;&lt;&lt;l2&lt;&lt;endl;</span><br><span class="line">	if(l1&lt;=l2) &#123;</span><br><span class="line">		cout&lt;&lt;&quot;lxh&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else cout&lt;&lt;&quot;pfz&quot;&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hdu</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1874最短路</title>
    <url>/2018/12/15/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<p>Problem Description<br>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。</p>
<p>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。</p>
<a id="more"></a>
<p>Input<br>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。</p>
<p>Output<br>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 3</span><br><span class="line">0 1 1</span><br><span class="line">0 2 3</span><br><span class="line">1 2 1</span><br><span class="line">0 2</span><br><span class="line">3 1</span><br><span class="line">0 1 1</span><br><span class="line">1 2</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>SPFA算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define INF 1e8</span><br><span class="line">#define MAX 205</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int v;</span><br><span class="line">	node(int xx,int vv):x(xx),v(vv)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; g[MAX];</span><br><span class="line">int dis[MAX],isq[MAX];</span><br><span class="line">void init(int n)&#123;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	g[i].clear();</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	dis[i]=INF;	</span><br><span class="line">	memset(isq,0,sizeof(isq));</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int u,v,w;</span><br><span class="line">	</span><br><span class="line">	while(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line"></span><br><span class="line">	init(n);</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">			g[u].push_back(node(v,w));</span><br><span class="line">			g[v].push_back(node(u,w));</span><br><span class="line">	&#125;</span><br><span class="line">	int s,t;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	q.push(s);</span><br><span class="line">	isq[s]=1;</span><br><span class="line">	dis[s]=0;</span><br><span class="line">	while(!q.empty())	</span><br><span class="line">	&#123;</span><br><span class="line">		int num=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		isq[num]=0;</span><br><span class="line">		for(int i=0;i&lt;g[num].size();i++)&#123;</span><br><span class="line">			int v=g[num][i].v;</span><br><span class="line">			int x=g[num][i].x;</span><br><span class="line">			if(dis[num]+v&lt;dis[x])&#123;</span><br><span class="line">				dis[x]=dis[num]+v;</span><br><span class="line">				if(isq[x]) continue;</span><br><span class="line">				q.push(x);</span><br><span class="line">				isq[x]=1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">				</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	if(dis[t]==INF) cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">	else cout&lt;&lt;dis[t]&lt;&lt;endl;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SPFA中取数字的方式有很多除了使用优先队列以外还有队列、数组、堆、栈等，总之它们的作用的就是不断的更新每个点到起点的路程。同时更新后又将它加入到队列/数组/堆/栈中。（需要注意如果是用队列优化则在加入队列前还需要判断它是否在队列中。）</p>
<p>参考<br><a href="https://blog.csdn.net/ccutyear/article/details/53894625/53894625" target="_blank" rel="noopener">https://blog.csdn.net/ccutyear/article/details/53894625/53894625</a></p>
]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>spfa</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2018/11/10/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>给出两个字符串，求出这样的一个最长的公共子序列的长度：子序列中的每个字符都能在两个原串中找到，而且每个字符的先后顺序和原串中的先后顺序一致。<br><a id="more"></a></p>
<p>Sample Input</p>
<p>abcfbc abfcab</p>
<p>programming contest</p>
<p>abcd mnp</p>
<p>Sample Output</p>
<p>4</p>
<p>2</p>
<p>0</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><p>输入两个串s1,s2,<br>设MaxLen(i,j)表示:<br>s1的左边i个字符形成的子串，与s2左边的j个<br>字符形成的子串的最长公共子序列的长度(i,j从0<br>开始算）<br>MaxLen(i,j) 就是本题的“状态”<br>假定 len1 = strlen(s1),len2 = strlen(s2）<br>那么题目就是要求 MaxLen(len1,len2)</p>
</li>
<li><p>分析： </p>
</li>
</ul>
<p>MaxLen(n,0) = 0 ( n= 0…len1）</p>
<p>MaxLen(0,n) = 0 ( n=0…len2）</p>
<p>递推公式：</p>
<p>if ( s1[i-1] == s2[j-1] ) //s1的最左边字符是s1[0] </p>
<p>MaxLen(i,j) = MaxLen(i-1,j-1) + 1;</p>
<p>else</p>
<p>MaxLen(i,j) = Max(MaxLen(i,j-1),MaxLen(i-1,j) );</p>
<ul>
<li>时间复杂度O(mn) m,n是两个字串长度</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//时间复杂度o(mn) </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">int MaxLen[100][100];</span><br><span class="line">char s1[500],s2[500];</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int length1,length2;</span><br><span class="line"></span><br><span class="line">	while(cin&gt;&gt;s1&gt;&gt;s2)&#123;</span><br><span class="line">	length1=strlen(s1);</span><br><span class="line">	length2=strlen(s2);</span><br><span class="line">	//比较s1的前length1个字符和s2的前length2相同的字符数目 </span><br><span class="line">	for(int i=0;i&lt;=length1;i++) MaxLen[i][0]=0;</span><br><span class="line">	for(int i=0;i&lt;=length2;i++) MaxLen[0][i]=0;</span><br><span class="line">	for(int i=1;i&lt;=length1;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=length2;j++)&#123;</span><br><span class="line">			if(s1[i-1]==s2[j-1]) MaxLen[i][j]=MaxLen[i-1][j-1]+1;</span><br><span class="line">			else MaxLen[i][j]=max(MaxLen[i-1][j],MaxLen[i][j-1]);</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;MaxLen[length1][length2]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx31oq8zh2j30c306jt9a.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>201312-3 最大的矩形</title>
    <url>/2018/11/29/%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<p>问题描述<br>　　在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。<br> <a id="more"></a><br>　　请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。<br><img src="http://118.190.20.162/RequireFile.do?fid=gNe4DHhD" alt="image"><br>输入格式<br>　　第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。<br>　　第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。<br>输出格式<br>　　输出一行，包含一个整数，即给定直方图内的最大矩形的面积。<br>样例输入<br>6<br>3 1 6 5 2 3<br>样例输出<br>10</p>
<p>暴力</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//int a[1001];</span><br><span class="line">int maxi=0,sum=0;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">//分解成子問題 从第i到j个连续矩形块的最大面积 </span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,a,area=0,ans=0;</span><br><span class="line">//	freopen(&quot;11-29.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a;	</span><br><span class="line">		v.push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;v.size();i++)&#123;</span><br><span class="line">		int height=v[i];</span><br><span class="line">		for(int j=i;j&lt;v.size();j++)&#123;</span><br><span class="line">			if(v[j]&lt;height) //!! 求从i到j的最小高度 </span><br><span class="line">			&#123;</span><br><span class="line">				height=v[j];</span><br><span class="line">			&#125;</span><br><span class="line">			area=(height)*(j-i+1);</span><br><span class="line"></span><br><span class="line">			if(ans&lt;area)&#123;</span><br><span class="line">			ans=area;	</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 261 Graph Valid Tree 图验证树</title>
    <url>/2018/12/09/%E6%9D%83%E9%99%90-1/</url>
    <content><![CDATA[<p>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p>For example:</p>
<p>Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.<br><a id="more"></a></p>
<p>Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.</p>
<p>Hint:</p>
<p>Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree?<br>According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”<br>Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<p>这道题给了我们一个无向图，让我们来判断其是否为一棵树，我们知道如果是树的话，所有的节点必须是连接的，也就是说必须是连通图，而且不能有环，所以我们的焦点就变成了验证是否是连通图和是否含有环。我们首先用DFS来做，根据pair来建立一个图的结构，用邻接链表来表示，还需要一个一位数组v来记录某个节点是否被访问过，然后我们用DFS来搜索节点0，遍历的思想是，当DFS到某个节点，先看当前节点是否被访问过，如果已经被访问过，说明环存在，直接返回false，如果未被访问过，我们现在将其状态标记为已访问过，然后我们到邻接链表里去找跟其相邻的节点继续递归遍历，注意我们还需要一个变量pre来记录上一个节点，以免回到上一个节点，这样遍历结束后，我们就把和节点0相邻的节点都标记为true，然后我们在看v里面是否还有没被访问过的节点，如果有，则说明图不是完全连通的，返回false，反之返回true</p>
<p><strong>验证是否是连通图和是否含有环</strong></p>
<!--more-->
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;vector&lt;int&gt; &gt; g;</span><br><span class="line">    bool validTree(int n, vector&lt;pair&lt;int, int&gt; &gt;&amp; edges) &#123;</span><br><span class="line">    	g=vector&lt;vector&lt;int&gt; &gt;(n,vector&lt;int&gt;());</span><br><span class="line">        for(pair&lt;int, int&gt; t:edges)&#123;</span><br><span class="line">  </span><br><span class="line">        	g[t.first].push_back(t.second);</span><br><span class="line">        	g[t.second].push_back(t.first); </span><br><span class="line">		&#125;</span><br><span class="line">		 vector&lt;bool&gt; v(n, false);</span><br><span class="line">        if(!dfs(0,-1,v)) </span><br><span class="line">		&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">        for(auto a:v)&#123;</span><br><span class="line">        	if(!a) &#123;</span><br><span class="line">        		return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">   &#125;</span><br><span class="line">   //传参 传的是引用  </span><br><span class="line">   bool dfs(int cur,int pre,vector&lt;bool&gt; &amp;v)&#123;</span><br><span class="line">   	if(v[cur])   return false;</span><br><span class="line">   	v[cur]=true;</span><br><span class="line">   	cout&lt;&lt;cur&lt;&lt;endl;</span><br><span class="line">   	for(auto a: g[cur])</span><br><span class="line">   	&#123;</span><br><span class="line">   		if(a==pre) continue;</span><br><span class="line">   		if(!dfs(a,cur,v)) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	 vector&lt;pair&lt;int, int&gt; &gt; edges; </span><br><span class="line">	 edges.push_back(pair&lt;int,int&gt;&#123;0,1&#125;);</span><br><span class="line">	 edges.push_back(pair&lt;int,int&gt;&#123;0,2&#125;);	 </span><br><span class="line">	 edges.push_back(pair&lt;int,int&gt;&#123;0,3&#125;);</span><br><span class="line">	 edges.push_back(pair&lt;int,int&gt;&#123;1,4&#125;);	 </span><br><span class="line">	 Solution so;	     </span><br><span class="line">	 if(so.validTree(5,edges)) cout&lt;&lt;&quot;t&quot;&lt;&lt;endl;</span><br><span class="line">	 else cout&lt;&lt;&quot;f&quot;&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考<br><a href="http://www.cnblogs.com/grandyang/p/5257919.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5257919.html</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>201612-3 权限查询</title>
    <url>/2018/12/09/%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。<br>　　本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。<br>  <a id="more"></a><br>　　具体地，用户名和角色名称都是由小写字母组成的字符串，长度不超过 32。权限分为分等级权限和不分等级权限两大类。分等级权限由权限类名和权限等级构成，中间用冒号“:”分隔。其中权限类名也是由小写字母组成的字符串，长度不超过 32。权限等级是一位数字，从 0 到 9，数字越大表示权限等级越高。系统规定如果用户具有某类某一等级的权限，那么他也将自动具有该类更低等级的权限。例如在上面的例子中，除 crm:2 外，用户 david 也具有 crm:1 和 crm:0 权限。不分等级权限在描述权限时只有权限类名，没有权限等级（也没有用于分隔的冒号）。<br>　　给出系统中用户、角色和权限的描述信息，你的程序需要回答多个关于用户和权限的查询。查询可分为以下几类：</p>
<ul>
<li>不分等级权限的查询：如果权限本身是不分等级的，则查询时不指定等级，返回是否具有该权限；
　<ul>
<li>分等级权限的带等级查询：如果权限本身分等级，查询也带等级，则返回是否具有该类的该等级权限；
　</li>
</ul>
</li>
<li>分等级权限的不带等级查询：如果权限本身分等级，查询不带等级，则返回具有该类权限的等级；如果不具有该类的任何等级权限，则返回“否”。</li>
</ul>
<p>输入格式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入第一行是一个正整数 p，表示不同的权限类别的数量。紧接着的 p 行被称为 P 段，每行一个字符串，描述各个权限。对于分等级权限，格式为 &lt;category&gt;:&lt;level&gt;，其中 &lt;category&gt; 是权限类名，&lt;level&gt; 是该类</span><br><span class="line">权限的最高等级。对于不分等级权限，字符串只包含权限类名。</span><br><span class="line"></span><br><span class="line">接下来一行是一个正整数 r，表示不同的角色数量。紧接着的 r 行被称为 R 段，每行描述一种角色，格式为</span><br><span class="line"></span><br><span class="line">&lt;role&gt; &lt;s&gt; &lt;privilege 1&gt; &lt;privilege 2&gt; ... &lt;privilege s&gt;</span><br><span class="line"></span><br><span class="line">其中 &lt;role&gt; 是角色名称，&lt;s&gt; 表示该角色具有多少种权限。后面 &lt;s&gt; 个字符串描述该角色具有的权限，格式同 P 段。</span><br><span class="line"></span><br><span class="line">接下来一行是一个正整数 u，表示用户数量。紧接着的 u 行被称为 U 段，每行描述一个用户，格式为</span><br><span class="line">　　&lt;user&gt; &lt;t&gt; &lt;role 1&gt; &lt;role 2&gt; ... &lt;role t&gt;</span><br><span class="line"></span><br><span class="line">其中 &lt;user&gt; 是用户名，&lt;t&gt; 表示该用户具有多少种角色。后面 &lt;t&gt; 个字符串描述该用户具有的角色。</span><br><span class="line"></span><br><span class="line">接下来一行是一个正整数 q，表示权限查询的数量。紧接着的 q 行被称为 Q 段，每行描述一个授权查询，格式为 &lt;user&gt; &lt;privilege&gt;，表示查询用户 &lt;user&gt; 是否具有 &lt;privilege&gt; 权限。如果查询的权限是分等级权限，则查询中的 &lt;privilege&gt; 可指定等级，表示查询该用户是否具有该等级的权限；也可以不指定等级，表示查询该用户具有该权限的等级。对于不分等级权限，只能查询该用户是否具有该权限，查询中不能指定等级。</span><br><span class="line">输出格式</span><br><span class="line">　　输出共 q 行，每行为 false、true，或者一个数字。false 表示相应的用户不具有相应的权限，true 表示相应的用户具有相应的权限。对于分等级权限的不带等级查询，如果具有权限，则结果是一个数字，表示该用户具有该权限的（最高）等级。如果用户不存在，或者查询的权限没有定义，则应该返回 false。</span><br></pre></td></tr></table></figure></p>
<p>样例输入</p>
<p>3</p>
<p>crm:2</p>
<p>git:3</p>
<p>game</p>
<p>4</p>
<p>hr 1 crm:2</p>
<p>it 3 crm:1 git:1 game</p>
<p>dev 2 git:3 game</p>
<p>qa 1 git:2</p>
<p>3</p>
<p>alice 1 hr</p>
<p>bob 2 it qa</p>
<p>charlie 1 dev</p>
<p>9</p>
<p>alice game</p>
<p>alice crm:2</p>
<p>alice git:0</p>
<p>bob git</p>
<p>bob poweroff</p>
<p>charlie game</p>
<p>charlie crm</p>
<p>charlie git:3</p>
<p>malice game</p>
<p>样例输出</p>
<p>false</p>
<p>true</p>
<p>false</p>
<p>2</p>
<p>false</p>
<p>true</p>
<p>false</p>
<p>true</p>
<p>false</p>
<p>样例说明</p>
<p>样例输入描述的场景中，各个用户实际的权限如下：</p>
<ul>
<li><p>用户 alice 具有 crm:2 权限</p>
</li>
<li><p>用户 bob 具有 crm:1、git:2 和 game 权限</p>
</li>
<li><p>用户 charlie 具有 git:3 和 game 权限</p>
</li>
<li><p>用户 malice 未描述，因此不具有任何权限</p>
</li>
</ul>
<p>评测用例规模与约定</p>
<p>评测用例规模：<br>　　<em> 1 ≤ p, r, u ≤ 100
　　</em> 1 ≤ q ≤ 10 000<br>　　* 每个用户具有的角色数不超过 10，每种角色具有的权限种类不超过 10</p>
<p>约定：</p>
<ul>
<li>输入保证合法性，包括：</li>
</ul>
<p>1) 角色对应的权限列表（R 段）中的权限都是之前（P 段）出现过的，权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准</p>
<p>2) 用户对应的角色列表（U 段）中的角色都是之前（R 段）出现过的，如果多个角色都具有某一分等级权限，以等级最高的为准</p>
<p>3) 查询（Q 段）中的用户名和权限类名不保证在之前（U 段和 P 段）出现过</p>
<ul>
<li><p>前 20% 的评测用例只有一种角色</p>
</li>
<li><p>前 50% 的评测用例权限都是不分等级的，查询也都不带等级</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;string,int&gt; cate;</span><br><span class="line">map&lt;string,map&lt;string,int&gt; &gt; roles;</span><br><span class="line">map&lt;string,map&lt;string,int&gt; &gt; usr;</span><br><span class="line"></span><br><span class="line">int to_int(string s,int pos)&#123;</span><br><span class="line">	int t=0;</span><br><span class="line">	for(int i=pos;i&lt;s.size();i++)&#123;</span><br><span class="line">		t=t*10+s[i]-&apos;0&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">void find(string user,string p,int index)&#123;</span><br><span class="line">	if(usr.count(user)&gt;0&amp;&amp;usr[user].count(p)&gt;0)&#123;</span><br><span class="line">		int v=usr[user][p];</span><br><span class="line">		if(index==-1)&#123;</span><br><span class="line">			if(v&gt;-1) cout&lt;&lt;v&lt;&lt;endl;</span><br><span class="line">			else cout&lt;&lt;&quot;true&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if(index&lt;=v)  cout&lt;&lt;&quot;true&quot;&lt;&lt;endl;</span><br><span class="line">			else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int p,r,u,q,cnt;</span><br><span class="line">	cin&gt;&gt;p;</span><br><span class="line">	int pos;</span><br><span class="line">	string s,ss,name;</span><br><span class="line">	while(p--)&#123;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		if((pos=s.find(&quot;:&quot;))!=-1) </span><br><span class="line">		&#123;</span><br><span class="line">			string c=s.substr(0,pos);</span><br><span class="line">			int  r=to_int(s,pos+1);</span><br><span class="line">		//角色对应的权限列表（R 段）中的权限都是之前（P 段）出现过的，权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准 </span><br><span class="line">			cate[c]=max(cate[c],r);</span><br><span class="line">		&#125; </span><br><span class="line">		 else cate[s]=-1;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;r;</span><br><span class="line">		while(r--)&#123;</span><br><span class="line">		cin&gt;&gt;s&gt;&gt;cnt;</span><br><span class="line">		for(int j=0;j&lt;cnt;j++)&#123;</span><br><span class="line">			cin&gt;&gt;ss;</span><br><span class="line">		if((pos=ss.find(&quot;:&quot;))!=-1) </span><br><span class="line">		&#123;</span><br><span class="line">			string c=ss.substr(0,pos);</span><br><span class="line">			int  r=to_int(ss,pos+1);</span><br><span class="line">			roles[s][c]=max(roles[s][c],r);</span><br><span class="line">		&#125; </span><br><span class="line">		 else roles[s][ss]=-1;</span><br><span class="line">			</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;u;</span><br><span class="line">	while(u--)&#123;</span><br><span class="line">		cin&gt;&gt;s&gt;&gt;cnt;</span><br><span class="line">		while(cnt--)&#123;</span><br><span class="line">			cin&gt;&gt;ss;</span><br><span class="line">			for(map&lt;string,int&gt;::iterator it=roles[ss].begin();it!=roles[ss].end();it++)&#123;</span><br><span class="line">				//!! role amy:git 2  role: mike:git3</span><br><span class="line">				//看它之前有没有被赋值过 </span><br><span class="line">				//不能用 usr[s][it-&gt;first]&gt;0 这样就回默认创建一个 所以必须区分是否存在 要不然默认的0会覆盖-1 </span><br><span class="line">				if(usr[s].count(it-&gt;first)) </span><br><span class="line">				usr[s][it-&gt;first]=max(usr[s][it-&gt;first],it-&gt;second);</span><br><span class="line">				else usr[s][it-&gt;first]=it-&gt;second;	</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;q;</span><br><span class="line">	while(q--)&#123;</span><br><span class="line">		cin&gt;&gt;name;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">			if((pos=s.find(&quot;:&quot;))!=string::npos) </span><br><span class="line">		&#123;</span><br><span class="line">			string c=s.substr(0,pos);</span><br><span class="line">			int  r=to_int(s,pos+1);</span><br><span class="line">			find(name,c,r);</span><br><span class="line">		</span><br><span class="line">		&#125; </span><br><span class="line">		 else find(name,s,-1);</span><br><span class="line">			</span><br><span class="line">	&#125;	</span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>蓝桥杯 设置次数</title>
    <url>/2019/03/21/%E6%A1%A5%E6%9D%AF-1/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdn.net/20180402122032531" alt="image"><br><a id="more"></a><br>应该用dp而不是二分<br>一个问题拥有重叠子问题和最优子结构才能用动态规划来解决<br>DP：</p>
<p>假设dp[n][m]表示从n层楼m个手机找到的(在最坏情况下)摔手机不碎的最少判断次数。</p>
<p>假设一个手机从第i层扔下，那么有两种情况： </p>
<p>碎了，下面还有(i-1)层，剩下(m-1)个手机，需要dp[i-1,m-1]次。</p>
<p>没碎，上面还有(n-i)层，剩下m个手机，需要dp[n-i][m]次。(子问题)</p>
<p>有了子问题….那就动态规划：</p>
<p>状态转移方程：dp[n, m] = min{ 1 + max(dp[i - 1, m - 1], dp[n - i, m]) | i = 1..n } </p>
<p>边界: dp[i, 1] = i，dp[1, i] = 1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define Max(a,b) (a&gt;b?a:b)</span><br><span class="line">#define Min(a,b) (a&lt;b?a:b)</span><br><span class="line">int dp[1005][50];</span><br><span class="line">int n,m;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m； </span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)</span><br><span class="line">			dp[j][i]=INF;//剩j个楼层 i部手机 </span><br><span class="line">	&#125; </span><br><span class="line">		for(int i=1;i&lt;=m;i++)&#123;//m个手机 剩1层楼 次数1次 </span><br><span class="line">		dp[1][i]=1;</span><br><span class="line">	&#125;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;//剩n个楼层 1部手机  次数n次 从下往上扔 </span><br><span class="line">		dp[i][1]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=2;i&lt;=m;i++)&#123;</span><br><span class="line">		for(int j=2;j&lt;=n;j++)&#123;</span><br><span class="line">		</span><br><span class="line">			for(int k=2;k&lt;=j;k++)&#123;</span><br><span class="line">	dp[j][i]= min(dp[j][i] ,1+max(dp[k-1][i-1],dp[j-k][i]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>思路<br>想等价变换<br>对这个问题，原始问题——【100层楼，最少需要几次测试，才能得到摔碎鸡蛋的楼层】，直接考虑不容易考虑，但是，如果将这个问题进行一种等价的转换，这个问题将会变得非常容易解答。个人认为，这个转换是解决这个问题的核心，这个转换是：</p>
<p>转换问题——【两个鸡蛋，进行k次测试，最多可以测试几层楼】</p>
<p> <strong>第一次测试，不能太高也能太矮，必须恰到好处，也就是第一枚鸡蛋如果破碎，剩余k-1次机会能将剩余楼层给测试完。</strong><br>参考链接<br><a href="https://blog.csdn.net/nka_kun/article/details/79789511" target="_blank" rel="noopener">https://blog.csdn.net/nka_kun/article/details/79789511</a><br><a href="https://blog.csdn.net/qq_34202873/article/details/79784548" target="_blank" rel="noopener">https://blog.csdn.net/qq_34202873/article/details/79784548</a><br><a href="https://blog.csdn.net/qq_41923622/article/details/85038621" target="_blank" rel="noopener">https://blog.csdn.net/qq_41923622/article/details/85038621</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组 统计序列中在元素左边比该元素小的元素个数</title>
    <url>/2018/12/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>统计序列中在元素左边比该元素小的元素个数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">#define lowbit(i) ((i)&amp;(-i))</span><br><span class="line">//覆盖范围 </span><br><span class="line">int c[MAX];</span><br><span class="line">int n;</span><br><span class="line">void update(int x,int v)&#123;</span><br><span class="line">	for(int i=x;i&lt;=n;i+=lowbit(i))&#123;</span><br><span class="line">		c[i]+=v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int getSum(int x)&#123;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=x;i&gt;0;i-=lowbit(i))</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	int x;</span><br><span class="line">	memset(c,0,sizeof(c));</span><br><span class="line">	int num=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		update(x,1);//x出现次数+1 </span><br><span class="line">		int t=getSum(x-1);</span><br><span class="line">		num+=t;</span><br><span class="line">		cout&lt;&lt;&quot;第&quot;&lt;&lt;i&lt;&lt;&quot;位左边比它小的数的个数&quot;&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;&quot;sum:&quot;&lt;&lt;num&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fyfbu6txt0j30d1061gm2" alt="image"></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>BIT</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉通路和欧拉回路</title>
    <url>/2018/12/04/%E6%AC%A7%E6%8B%89/</url>
    <content><![CDATA[<p>描述<br>zyc从小就比较喜欢玩一些小游戏，其中就包括画一笔画，他想请你帮他写一个程序，判断一个图是否能够用一笔画下来。</p>
<p>规定，所有的边都只能画一次，不能重复画。<br><a id="more"></a><br>输入</p>
<p>第一行只有一个正整数N(N&lt;=10)表示测试数据的组数。<br>每组测试数据的第一行有两个正整数P,Q(P&lt;=1000,Q&lt;=2000)，分别表示这个画中有多少个顶点和多少条连线。（点的编号从1到P）<br>随后的Q行，每行有两个正整数A,B(0&lt;A,B&lt;P)，表示编号为A和B的两点之间有连线。<br>输出<br>如果存在符合条件的连线，则输出”Yes”,<br>如果不存在符合条件的连线，输出”No”。<br>样例输入<br>2</p>
<p>4 3</p>
<p>1 2</p>
<p>1 3</p>
<p>1 4</p>
<p>4 5</p>
<p>1 2</p>
<p>2 3</p>
<p>1 3</p>
<p>1 4</p>
<p>3 4</p>
<p>样例输出</p>
<p>No</p>
<p>Yes</p>
<p>一笔画问题是典型的判断欧拉通路是否存在的问题。</p>
<p>欧拉通路：通过图中每一条边且只通过一次，并且经过每一个节点的通路。（和题目的意思对应，给出P个点Q条边，所有边只画一次把所有点都连接起来）。</p>
<p>欧拉回路：通过图中每一条边且只通过一次，并且经过每一个节点的回路。</p>
<p>此题目是无向图，只让判断欧拉通路是否存在，并不需要输出欧拉路径，因此还是比较简单的。</p>
<p>下面是无向图定理：</p>
<p>无向图定理：无向图G存在欧拉通路的必要条件是：G为连通图（用并查集判断图是否连通），并且G仅有两个奇度节点（度数为奇数的节点）或者无奇度节点。</p>
<p>从而引出下面三条推论：</p>
<p>推论：</p>
<ol>
<li><p>当G时仅有两个奇度节点的连通图时，图G的欧拉通路必以此两个节点为端点。</p>
</li>
<li><p>当图G是无奇度节点的连通图时，G必有欧拉回路。（欧拉回路存在，欧拉通路必存在）。</p>
</li>
<li><p>G为欧拉图（存在欧拉回路）的充分必要条件是G为无奇度节点的连通图。</p>
</li>
</ol>
<p>无论求欧拉回路还是欧拉通路，首先图G必须是连通的。这一点可以用并查集去判断，进行并查集之后，最后只有一个节点所属于的集合是自己，则图是连通的，</p>
<p>否则图不是连通的。</p>
<p>接下来就是统计每个顶点的度数。然后统计奇度节点的个数，如果有两个或零个，则存在欧拉通路，可以解决一笔画问题。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>201509-3 模板生成系统</title>
    <url>/2018/12/13/%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>问题描述<br>　　成成最近在搭建一个网站，其中一些页面的部分内容来自数据库中不同的数据记录，但是页面的基本结构是相同的。例如，对于展示用户信息的页面，当用户为 Tom 时，网页的源代码是</p>
<p><img src="http://118.190.20.162/RequireFile.do?fid=Mbg3eNaq" alt="image"></p>
<a id="more"></a>
<p>　　而当用户为 Jerry 时，网页的源代码是</p>
<p><img src="http://118.190.20.162/RequireFile.do?fid=69mbB6TA" alt="image"></p>
<p>　　这样的例子在包含动态内容的网站中还有很多。为了简化生成网页的工作，成成觉得他需要引入一套模板生成系统。<br>　　模板是包含特殊标记的文本。成成用到的模板只包含一种特殊标记，格式为 ，其中 VAR 是一个变量。该标记在模板生成时会被变量 VAR 的值所替代。例如，如果变量 name = “Tom”，则  会生成 Tom。具体的规则如下：</p>
<p>变量名由大小写字母、数字和下划线 (_) 构成，且第一个字符不是数字，长度不超过 16 个字符。</p>
<p>变量名是大小写敏感的，Name 和 name 是两个不同的变量。</p>
<p>  变量的值是字符串。</p>
<p>  如果标记中的变量没有定义，则生成空串，相当于把标记从模板中删除。</p>
<p>模板不递归生成。也就是说，如果变量的值中包含形如  的内容，不再做进一步的替换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">　　输入的第一行包含两个整数 m, n，分别表示模板的行数和模板生成时给出的变量个数。</span><br><span class="line">　　接下来 m 行，每行是一个字符串，表示模板。</span><br><span class="line">　　接下来 n 行，每行表示一个变量和它的值，中间用一个空格分隔。值是字符串，用双引号 (&quot;) 括起来，内容可包含除双引号以外的任意可打印 ASCII 字符（ASCII 码范围 32, 33, 35-126）。</span><br><span class="line">输出格式</span><br><span class="line">　　输出包含若干行，表示模板生成的结果。</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fy3rvo5h1kj30kv0f1af9.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">评测用例规模与约定</span><br><span class="line">　　0 ≤ m ≤ 100</span><br><span class="line">　　0 ≤ n ≤ 100</span><br><span class="line">　　输入的模板每行长度不超过 80 个字符（不包含换行符）。</span><br><span class="line">　　输入保证模板中所有以 &#123;&#123; 开始的子串都是合法的标记，开始是两个左大括号和一个空格，然后是变量名，结尾是一个空格和两个右大括号。</span><br><span class="line">　　输入中所有变量的值字符串长度不超过 100 个字符（不包括双引号）。</span><br><span class="line">　　保证输入的所有变量的名字各不相同。</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>#include&lt;bits/stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>int main()<br>{<br>map&lt;string,string&gt; mapp;<br>int n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br>string res=””;<br>string line;<br>//getchar();<br>cin.ignore();<br>for(int i=0;i&lt;n;i++){<br>getline(cin,line);<br>res+=line;<br>if(i!=n-1)res+=”\n”;<br>}<br>string key,value;<br>string line2;<br>for(int j=0;j&lt;m;j++){<br>    cin&gt;&gt;key;<br>    getline(cin,line2) ;<br>    mapp[key] = line2.substr(2, line2.length()-3);<br>}<br>int pos1,pos2;<br>int pos=0;<br>while((pos1=res.find(“,pos))!=-1&&((pos2=res.find(“,pos))!=-1)){<br>    string s=res.substr(pos1+3,pos2-pos1-3);<br>    res.erase(pos1,pos2+3-pos1);<br>    if(mapp.count(s)) {<br>    res.insert(pos1,mapp[s]);<br>  //已经erase了 字符串位置变化了 pos=pos2+1是错误的<br>   pos=pos1+mapp[s].length();<br>    }<br>}<br>cout&lt;&lt;res&lt;&lt;endl;<br>}<br><code>`</code></p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(9)</title>
    <url>/2018/09/09/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93-9/</url>
    <content><![CDATA[<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>这学期课选的很少 </p>
<p>前几天真的是很闲… 突然一时不知道做什么<br><a id="more"></a><br>大抵也是个笑话</p>
<p>忙的时候有一堆事想做 闲的时候竟发现有点迷茫</p>
<p>差不多有两个月没怎么打代码吧 </p>
<p>这几天其实想了很多 关于未来 关于考研和工作</p>
<p>最后还是决定考研了</p>
<p>然而这次并不是因为父母 而是自己的追求</p>
<p>想考985 想趁着研究生出国 去看看外面的世界 去发现更多精彩和未知的事物</p>
<p>去走一走 不想让这么快就变成朝九晚五的工作 </p>
<p>也想挖掘挖掘自己的潜力</p>
<p>最近看了些关于机器学习的视频和书</p>
<p>尽管很难 但当学到东西或者明白了某个很难的推理 突然会很开心 </p>
<p>大抵做自己快乐的事就是正确的决定吧</p>
<p>于是想鼓起勇气追求一下梦想 知道是双非院校 知道有太多的未知数</p>
<p>谁也不能保证你一定考上 但凡事都是相对的 这个过程会让你学到更多的知识 何乐而不为呢</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>看了决策树和k邻近算法并用python实践</li>
<li>掌握了php基本语法，php和mysql的书还在看 觉得是本很好的入门书</li>
<li>高数上第一章看了3节 发现花在视频上时间有点多 习题倒是没怎么认真花时间</li>
<li>略读了几篇关于表情识别的论文<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2></li>
<li>高数第一，二章看完</li>
<li>完成人脸检测与预处理</li>
<li>看机器学习视频 及实现机器学习实战相关代码</li>
<li>继续带着看php的书</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>正则化方法：L1和L2 regularization、数据集扩增、dropout</title>
    <url>/2018/05/11/%E6%AD%A3%E5%88%99%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9AL1%E5%92%8CL2-regularization%E3%80%81%E6%95%B0%E6%8D%AE%E9%9B%86%E6%89%A9%E5%A2%9E%E3%80%81dropout-1/</url>
    <content><![CDATA[<h1 id="正则化方法：防止过拟合，提高泛化能力"><a href="#正则化方法：防止过拟合，提高泛化能力" class="headerlink" title="正则化方法：防止过拟合，提高泛化能力"></a>正则化方法：防止过拟合，提高泛化能力</h1><p>在训练数据不够多时，或者overtraining时，常常会导致overfitting（过拟合）。其直观的表现如下图所示，随着训练过程的进行，模型复杂度增加，在training data上的error渐渐减小，但是在验证集上的error却反而渐渐增大——因为训练出来的网络过拟合了训练集，对训练集外的数据却不work。<br><a id="more"></a></p>
<p>为了防止overfitting，可以用的方法有很多，下文就将以此展开。有一个概念需要先说明，在机器学习算法中，我们常常将原始数据集分为三部分：training data、validation data，testing data。这个validation data是什么？它其实就是用来避免过拟合的，在训练过程中，我们通常用它来确定一些超参数（比如根据validation data上的accuracy来确定early stopping的epoch大小、根据validation data确定learning rate等等）。那为啥不直接在testing data上做这些呢？因为如果在testing data做这些，那么随着训练的进行，我们的网络实际上就是在一点一点地overfitting我们的testing data，导致最后得到的testing accuracy没有任何参考意义。因此，training data的作用是计算梯度更新权重，validation data如上所述，testing data则给出一个accuracy以判断网络的好坏。</p>
<p>避免过拟合的方法有很多：early stopping、数据集扩增（Data augmentation）、正则化（Regularization）包括L1、L2（L2 regularization也叫weight decay），dropout。</p>
<h2 id="L2-regularization（权重衰减）"><a href="#L2-regularization（权重衰减）" class="headerlink" title="L2 regularization（权重衰减）"></a>L2 regularization（权重衰减）</h2><p>L2正则化就是在代价函数后面再加上一个正则化项：</p>
<p>C0代表原始的代价函数，后面那一项就是L2正则化项，它是这样来的：所有参数w的平方的和，除以训练集的样本大小n。λ就是正则项系数，权衡正则项与C0项的比重。另外还有一个系数1/2，1/2经常会看到，主要是为了后面求导的结果方便，后面那一项求导会产生一个2，与1/2相乘刚好凑整。</p>
<p>L2正则化项是怎么避免overfitting的呢？我们推导一下看看，先求导：</p>
<p>可以发现L2正则化项对b的更新没有影响，但是对于w的更新有影响:</p>
<p>在不使用L2正则化时，求导结果中w前系数为1，现在w前面系数为 1−ηλ/n ，因为η、λ、n都是正的，所以 1−ηλ/n小于1，它的效果是减小w，这也就是权重衰减（weight decay）的由来。当然考虑到后面的导数项，w最终的值可能增大也可能减小。</p>
<p>另外，需要提一下，对于基于mini-batch的随机梯度下降，w和b更新的公式跟上面给出的有点不同：</p>
<p>对比上面w的更新公式，可以发现后面那一项变了，变成所有导数加和，乘以η再除以m，m是一个mini-batch中样本的个数。</p>
<p>到目前为止，我们只是解释了L2正则化项有让w“变小”的效果，但是还没解释为什么w“变小”可以防止overfitting？一个所谓“显而易见”的解释就是：更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合刚刚好（这个法则也叫做奥卡姆剃刀），而在实际应用中，也验证了这一点，L2正则化的效果往往好于未经正则化的效果。当然，对于很多人（包括我）来说，这个解释似乎不那么显而易见，所以这里添加一个稍微数学一点的解释（引自知乎）：</p>
<p>过拟合的时候，拟合函数的系数往往非常大，为什么？如下图所示，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。</p>
<p>而正则化是通过约束参数的范数使其不要太大，所以可以在一定程度上减少过拟合情况。</p>
<p>##L1 regularization<br>在原始的代价函数后面加上一个L1正则化项，即所有权重w的绝对值的和，乘以λ/n（这里不像L2正则化项那样，需要再乘以1/2，具体原因上面已经说过。）</p>
<p>同样先计算导数：</p>
<p>上式中sgn(w)表示w的符号。那么权重w的更新规则为：</p>
<p>比原始的更新规则多出了η <em> λ </em> sgn(w)/n这一项。当w为正时，更新后的w变小。当w为负时，更新后的w变大——因此它的效果就是让w往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合。</p>
<p>另外，上面没有提到一个问题，当w为0时怎么办？当w等于0时，|W|是不可导的，所以我们只能按照原始的未经正则化的方法去更新w，这就相当于去掉η<em>λ</em>sgn(w)/n这一项，所以我们可以规定sgn(0)=0，这样就把w=0的情况也统一进来了。（在编程的时候，令sgn(0)=0,sgn(w&gt;0)=1,sgn(w&lt;0)=-1）</p>
<h2 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h2><p>L1、L2正则化是通过修改代价函数来实现的，而Dropout则是通过修改神经网络本身来实现的，它是在训练网络时用的一种技巧（trike）。它的流程如下：</p>
<p>假设我们要训练上图这个网络，在训练开始时，我们随机地“删除”一半的隐层单元，视它们为不存在，得到如下的网络：</p>
<p>保持输入输出层不变，按照BP算法更新上图神经网络中的权值（虚线连接的单元不更新，因为它们被“临时删除”了）。</p>
<p>以上就是一次迭代的过程，在第二次迭代中，也用同样的方法，只不过这次删除的那一半隐层单元，跟上一次删除掉的肯定是不一样的，因为我们每一次迭代都是“随机”地去删掉一半。第三次、第四次……都是这样，直至训练结束。</p>
<p>以上就是Dropout，它为什么有助于防止过拟合呢？可以简单地这样解释，运用了dropout的训练过程，相当于训练了很多个只有半数隐层单元的神经网络（后面简称为“半数网络”），每一个这样的半数网络，都可以给出一个分类结果，这些结果有的是正确的，有的是错误的。随着训练的进行，大部分半数网络都可以给出正确的分类结果，那么少数的错误分类结果就不会对最终结果造成大的影响。</p>
<p>更加深入地理解，可以看看Hinton和Alex两牛2012的论文《ImageNet Classification with Deep Convolutional Neural Networks》</p>
<h2 id="数据集扩增（data-augmentation）"><a href="#数据集扩增（data-augmentation）" class="headerlink" title="数据集扩增（data augmentation）"></a>数据集扩增（data augmentation）</h2><p>“有时候不是因为算法好赢了，而是因为拥有更多的数据才赢了。”</p>
<p>不记得原话是哪位大牛说的了，hinton？从中可见训练数据有多么重要，特别是在深度学习方法中，更多的训练数据，意味着可以用更深的网络，训练出更好的模型。</p>
<p>既然这样，收集更多的数据不就行啦？如果能够收集更多可以用的数据，当然好。但是很多时候，收集更多的数据意味着需要耗费更多的人力物力，有弄过人工标注的同学就知道，效率特别低，简直是粗活。</p>
<p>所以，可以在原始数据上做些改动，得到更多的数据，以图片数据集举例，可以做各种变换，如：</p>
<p>将原始图片旋转一个小角度</p>
<p>添加随机噪声</p>
<p>一些有弹性的畸变（elastic distortions），论文《Best practices for convolutional neural networks applied to visual document analysis》对MNIST做了各种变种扩增。</p>
<p>截取（crop）原始图片的一部分。比如DeepID中，从一副人脸图中，截取出了100个小patch作为训练数据，极大地增加了数据集。感兴趣的可以看《Deep learning face representation from predicting 10,000 classes》.</p>
<p>更多数据意味着什么？</p>
<p>用50000个MNIST的样本训练SVM得出的accuracy94.48%，用5000个MNIST的样本训练NN得出accuracy为93.24%，所以更多的数据可以使算法表现得更好。在机器学习中，算法本身并不能决出胜负，不能武断地说这些算法谁优谁劣，因为数据对算法性能的影响很大。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>调参技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔问题</title>
    <url>/2018/11/09/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数<br><a id="more"></a><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx1vuume3zj30g005f0tc.jpg" alt="image"></p>
<h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void Hanoi(int n,char src,char mid,char dest)&#123;</span><br><span class="line">	if(n==1)&#123;</span><br><span class="line">		cout&lt;&lt;src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;dest&lt;&lt;endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		Hanoi(n-1,src,dest,mid);</span><br><span class="line">		cout&lt;&lt;src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;dest&lt;&lt;endl;</span><br><span class="line">		Hanoi(n-1,mid,src,dest);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	Hanoi(n,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Problem&#123;</span><br><span class="line">	int n;</span><br><span class="line">	char src,mid,dest;</span><br><span class="line">	Problem(int nn,char s,char m,char de):n(nn),src(s),mid(m),dest(de)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">stack&lt;Problem&gt; stk;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	stk.push(Problem(n,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;));</span><br><span class="line">	while(!stk.empty())&#123;</span><br><span class="line">		Problem curProb=stk.top();</span><br><span class="line">		stk.pop();</span><br><span class="line">		if(curProb.n==1) &#123;</span><br><span class="line">			cout&lt;&lt;curProb.src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;curProb.dest&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			stk.push(Problem(curProb.n-1,curProb.mid,curProb.src,curProb.dest));</span><br><span class="line">			stk.push(Problem(1,curProb.src,curProb.mid,curProb.dest));</span><br><span class="line">			stk.push(Problem(curProb.n-1,curProb.src,curProb.dest,curProb.mid));			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx1vszi3ufj304r04dt8t.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>201604-4 游戏</title>
    <url>/2018/12/06/%E6%B8%B8%E6%88%8F-1/</url>
    <content><![CDATA[<p>问题描述
　　</p>
<p>  小明在玩一个电脑游戏，游戏在一个n×m的方格图上进行，小明控制的角色开始的时候站在第一行第一列，目标是前往第n行第m列。<br><a id="more"></a></p>
<p>方格图上有一些方格是始终安全的，有一些在一段时间是危险的，如果小明控制的角色到达一个方格的时候方格是危险的，则小明输掉了游戏，如果小明的角色到达了第n行第m列，则小明过关。第一行第一列和第n行第m列永远都是安全的。<br>　<br> 每个单位时间，小明的角色必须向上下左右四个方向相邻的方格中的一个移动一格。</p>
<p>经过很多次尝试，小明掌握了方格图的安全和危险的规律：每一个方格出现危险的时间一定是连续的。并且，小明还掌握了每个方格在哪段时间是危险的。
　</p>
<p> 现在，小明想知道，自己最快经过几个时间单位可以达到第n行第m列过关。<br>输入格式<br>　<br> 输入的第一行包含三个整数n, m, t，用一个空格分隔，表示方格图的行数n、列数m，以及方格图中有危险的方格数量。<br>　<br> 接下来t行，每行4个整数r, c, a, b，表示第r行第c列的方格在第a个时刻到第b个时刻之间是危险的，包括a和b。游戏开始时的时刻为0。输入数据保证r和c不同时为1，而且当r为n时c不为m。一个方格只有一段时间是危险的（或者说不会出现两行拥有相同的r和c）。</p>
<p>输出格式<br>　<br> 输出一个整数，表示小明最快经过几个时间单位可以过关。输入数据保证小明一定可以过关。</p>
<p>样例输入</p>
<p>3 3 3</p>
<p>2 1 1 1</p>
<p>1 3 2 10</p>
<p>2 2 2 10</p>
<p>样例输出</p>
<p>6</p>
<p>样例说明</p>
<p>第2行第1列时刻1是危险的，因此第一步必须走到第1行第2列。</p>
<p>第二步可以走到第1行第1列，第三步走到第2行第1列，后面经过第3行第1列、第3行第2列到达第3行第3列。<br>评测用例规模与约定</p>
<p>前30%的评测用例满足：0 &lt; n, m ≤ 10，0 ≤ t &lt; 99。<br>　　所有评测用例满足：0 &lt; n, m ≤ 100，0 ≤ t &lt; 9999，1 ≤ r ≤ n，1 ≤ c ≤ m，0 ≤ a ≤ b ≤ 100。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cstring&gt; </span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#define INF 1e8</span><br><span class="line">#define test 0</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">struct ge&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	ge(int xx,int yy):x(xx),y(yy)&#123;</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool vis[100+2][100+2][300];</span><br><span class="line">int dirs[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m,t;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">	int x,y,st,ed;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;t;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">	//	 v.push_back(ge(x,y));</span><br><span class="line">		 for(int k=st;k&lt;=ed;k++)</span><br><span class="line">		 vis[x][y][k]=1;</span><br><span class="line">	&#125; </span><br><span class="line">	int step=0;</span><br><span class="line">	</span><br><span class="line">	queue&lt;ge&gt; q;</span><br><span class="line">	q.push(ge(1,1));</span><br><span class="line">	vis[1][1][0]=true;</span><br><span class="line">	int ans=INF;</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		int size=q.size();</span><br><span class="line">		while(size--)&#123;</span><br><span class="line">		ge index=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">	</span><br><span class="line">		int x=index.x;</span><br><span class="line">		int y=index.y;</span><br><span class="line">		 </span><br><span class="line">		if(x==n&amp;&amp;y==m) &#123;</span><br><span class="line">				ans=step;</span><br><span class="line">				cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">		for(int j=0;j&lt;4;j++)&#123;</span><br><span class="line">			int newx=x+dirs[j][0];</span><br><span class="line">			int newy=y+dirs[j][1];	</span><br><span class="line">			</span><br><span class="line">			if(newx&lt;=0||newx&gt;n||newy&lt;=0||newy&gt;m) continue;		</span><br><span class="line">			</span><br><span class="line">			if(vis[newx][newy][step+1]) continue;</span><br><span class="line">			//!!递推型 </span><br><span class="line">					vis[newx][newy][step+1]=true;</span><br><span class="line">			#if test</span><br><span class="line">				cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;newx&lt;&lt;&quot; &quot;&lt;&lt;newy&lt;&lt;endl;</span><br><span class="line">			#endif</span><br><span class="line">			q.push(ge(newx,newy));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		step++;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误代码</p>
<p>不能简单的限制为访问过的格子不能再访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cstring&gt; </span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#define INF 1e8</span><br><span class="line">#define test 0</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">struct ge&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	ge(int xx,int yy):x(xx),y(yy)&#123;</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y,st,ed;</span><br><span class="line">	node(int xx,int yy,int ss,int ee):x(xx),y(yy),st(ss),ed(ee)&#123;</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; v;</span><br><span class="line">int dirs[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m,t;</span><br><span class="line">	freopen(&quot;t1.txt&quot;,&quot;r&quot;,stdin); </span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">	int x,y,st,ed;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;t;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">		 v.push_back(node(x,y,st,ed));</span><br><span class="line">	&#125; </span><br><span class="line">	int step=0;</span><br><span class="line">	</span><br><span class="line">	queue&lt;ge&gt; q;</span><br><span class="line">	q.push(ge(1,1));</span><br><span class="line">	//vis[1][1]=true;</span><br><span class="line">	int ans=INF;</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		int size=q.size();</span><br><span class="line">		while(size--)&#123;</span><br><span class="line">		ge index=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line"></span><br><span class="line">		int x=index.x;</span><br><span class="line">		int y=index.y;</span><br><span class="line">	</span><br><span class="line">		if(x==n&amp;&amp;y==m) &#123;</span><br><span class="line">				ans=step;</span><br><span class="line">				cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">		for(int j=0;j&lt;4;j++)&#123;</span><br><span class="line">			int newx=x+dirs[j][0];</span><br><span class="line">			int newy=y+dirs[j][1];	</span><br><span class="line"></span><br><span class="line">			if(newx&lt;=0||newx&gt;n||newy&lt;=0||newy&gt;m) continue;		</span><br><span class="line">			int flag=0;</span><br><span class="line">			for(int i=0;i&lt;t;i++)&#123;</span><br><span class="line">				if(newx==v[i].x&amp;&amp;newy==v[i].y&amp;&amp;step+1&gt;=v[i].st&amp;&amp;step+1&lt;=v[i].ed) </span><br><span class="line">			&#123;</span><br><span class="line">				flag=1;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">			if(flag==1) continue;</span><br><span class="line">			#if test</span><br><span class="line">				cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;newx&lt;&lt;&quot; &quot;&lt;&lt;newy&lt;&lt;endl;</span><br><span class="line">			#endif</span><br><span class="line">			q.push(ge(newx,newy));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		step++;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Leetcode815. Bus Routes</title>
    <url>/2018/12/06/%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;… forever.</p>
<p>We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.<br><a id="more"></a><br>Example:</p>
<p>Input: </p>
<p>routes = [[1, 2, 7], [3, 6, 7]]</p>
<p>S = 1</p>
<p>T = 6</p>
<p>Output: 2</p>
<p>Explanation: </p>
<p>The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.</p>
<p>Note:</p>
<p>1 &lt;= routes.length &lt;= 500.<br>1 &lt;= routes[i].length &lt;= 500.<br>0 &lt;= routes[i][j] &lt; 10 ^ 6.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>queue存储站点 如果站点是同一辆公交车可达就跳过（剪枝)</p>
<p>要不就把该站点加入到队列中</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numBusesToDestination(vector&lt;vector&lt;int&gt;&gt;&amp; routes, int S, int T) &#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    </span><br><span class="line">    map&lt;int,vector&lt;int&gt; &gt; rmap;</span><br><span class="line">        for(int i=0;i&lt;routes.size();i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;routes[i].size();j++)&#123;</span><br><span class="line">               rmap[routes[i][j]].push_back(i);</span><br><span class="line">                        </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; vis(500,0);</span><br><span class="line">        q.push(S);</span><br><span class="line">        if(S==T) return 0;</span><br><span class="line">        int steps=0;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">                int size=q.size();</span><br><span class="line">            while(size--)</span><br><span class="line">         &#123;</span><br><span class="line">            int t=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            for(auto bus:rmap[t])&#123;</span><br><span class="line">                if(vis[bus]) continue;</span><br><span class="line">                vis[bus]=1;</span><br><span class="line">                for(auto stop:routes[bus])&#123;</span><br><span class="line">                    if(T==stop) return steps+1;</span><br><span class="line">                    q.push(stop);         </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                              </span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">            steps++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>POJ1190生日蛋糕</title>
    <url>/2018/11/16/%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>要制作一个体积为N π 的M层生日蛋糕，每层都是一个圆柱体。<br>设从下往上数第i(1 &lt;= i &lt;= M)层蛋糕是半径为R i , 高度为H i 的圆柱。当i &lt; M<br>时，要求R i &gt; R i+1 且H i &gt; H i+1 。<br><a id="more"></a><br>由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的<br>下底面除外）的面积Q最小。</p>
<p>令Q = Sπ请编程对给出的N和M，找出蛋糕的制作方案（适当的Ri和Hi的值），使S最小。<br>（除Q外，以上所有数据皆为正整数）</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>深度优先搜索，枚举每一层可能的高度和半径。</p>
<p>确定搜索范围: 底层蛋糕的最大可能半径和最大可能高度</p>
<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><ul>
<li><p>剪枝1：搭建过程中发现面积超过已经求得的最优表面积，则停止搭建</p>
</li>
<li><p>剪枝2：搭建过程中预见到再往上搭，高度已经无法安排，或者半径已<br>经无法安排，则停止搭建</p>
</li>
<li><p>剪枝3：搭建过程中发现还没搭的那些层的体积，一定会超过还缺的体<br>积，则停止搭建</p>
</li>
<li><p>剪枝4：搭建过程中发现还没搭的那些层的体积，最大也到不了还缺的<br>体积，则停止搭建</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">#define MAX 100 </span><br><span class="line">using namespace std;</span><br><span class="line">int minV[MAX];</span><br><span class="line">int minA[MAX]; </span><br><span class="line">int area;</span><br><span class="line">int m,N;</span><br><span class="line">int minArea=1&lt;&lt;30;</span><br><span class="line">int maxNRH(int n,int r,int h)&#123;</span><br><span class="line">	int v=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		v+=(r-i)*(r-i)*(h-i);</span><br><span class="line">	&#125;</span><br><span class="line">	return v;</span><br><span class="line">&#125; </span><br><span class="line">//用n层去凑体积v 最底层半径不超过r 高度不超过h </span><br><span class="line">//入 求出最小表面积放入 minArea</span><br><span class="line">void dfs(int n,int v,int r,int h)&#123; </span><br><span class="line"></span><br><span class="line">	if(n==0) &#123;</span><br><span class="line">		if(v) return;</span><br><span class="line">		else&#123;</span><br><span class="line">		minArea=min(minArea,area); </span><br><span class="line">		return;</span><br><span class="line">	&#125;&#125; </span><br><span class="line">		if(v&lt;0) return;//!!</span><br><span class="line">	if(minV[n]&gt;v) return;</span><br><span class="line">	if(area+minA[n]&gt;=minArea) return ;</span><br><span class="line">	if(r&lt;n||h&lt;n) return;</span><br><span class="line">	if(maxNRH(n,r,h)&lt;v) return;</span><br><span class="line">//	if(n==m) area+=r*r//!!;</span><br><span class="line"></span><br><span class="line">	for(int rr=r;rr&gt;=n;rr--)&#123;</span><br><span class="line">			if(n==m) area=rr*rr;//!!不能写成area+</span><br><span class="line">		for(int hh=h;hh&gt;=n;hh--)&#123;</span><br><span class="line">			area+=2*rr*hh;</span><br><span class="line">			dfs(n-1,v-rr*rr*hh,rr-1,hh-1);//!!</span><br><span class="line">			area-=2*rr*hh;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//m层蛋糕体积为N </span><br><span class="line">	//freopen(&quot;cake.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;m;</span><br><span class="line">	minA[0]=minV[0]=0;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		minV[i]=minV[i-1]+i*i*i;</span><br><span class="line">		minA[i]=minA[i-1]+2*i*i; </span><br><span class="line">	&#125;</span><br><span class="line">	int R=sqrt(double((N-minV[m-1])/m))+1;</span><br><span class="line">	int H=(N-minV[m-1])/(m*m)+1;</span><br><span class="line">		</span><br><span class="line">		//	for(int rr=R;rr&gt;=m;rr--)&#123; 错的地方 应该在dfs函数功能完成 </span><br><span class="line">		//		for(int hh=H;hh&gt;=m;hh--)&#123;</span><br><span class="line">	area=0;</span><br><span class="line">	dfs(m,N,R,H);</span><br><span class="line"></span><br><span class="line">//		&#125;</span><br><span class="line">//	&#125;</span><br><span class="line">	if(minArea==1&lt;&lt;30) cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">	else cout&lt;&lt;minArea&lt;&lt;endl;</span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>201512-3 画图</title>
    <url>/2018/12/05/%E7%94%BB%E5%9B%BE/</url>
    <content><![CDATA[<p>问题描述<br>　　用 ASCII 字符来画图是一件有趣的事情，并形成了一门被称为 ASCII Art 的艺术。例如，下图是用 ASCII 字符画出来的 CSPRO 字样。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..____.____..____..____...___..</span><br><span class="line">　　./.___/.___||.._.\|.._.\./._.\.</span><br><span class="line">　　|.|...\___.\|.|_).|.|_).|.|.|.|</span><br><span class="line">　　|.|___.___).|..__/|.._.&lt;|.|_|.|</span><br><span class="line">　　.\____|____/|_|...|_|.\_\\___/.</span><br></pre></td></tr></table></figure></p>
  <a id="more"></a>
<p>  本题要求编程实现一个用 ASCII 字符来画图的程序，支持以下两种操作：<br>　　 画线：给出两个端点的坐标，画一条连接这两个端点的线段。简便起见题目保证要画的每条线段都是水平或者竖直的。水平线段用字符 - 来画，竖直线段用字符 | 来画。如果一条水平线段和一条竖直线段在某个位置相交，则相交位置用字符 + 代替。<br>　　 填充：给出填充的起始位置坐标和需要填充的字符，从起始位置开始，用该字符填充相邻位置，直到遇到画布边缘或已经画好的线段。注意这里的相邻位置只需要考虑上下左右 4 个方向，如下图所示，字符 @ 只和 4 个字符 * 相邻。</p>
<p>.*.</p>
<p><em>@</em></p>
<p>.*.</p>
<p>输入格式</p>
<p>第1行有三个整数m, n和q。m和n分别表示画布的宽度和高度，以字符为单位。q表示画图操作的个数。</p>
<p>第2行至第q + 1行，每行是以下两种形式之一：</p>
<p>0 x1 y1 x2 y2：表示画线段的操作，(x1, y1)和(x2, y2)分别是线段的两端，满足要么x1 = x2 且y1 ≠ y2，要么 y1 = y2 且 x1 ≠ x2。</p>
<p>1 x y c：表示填充操作，(x, y)是起始位置，保证不会落在任何已有的线段上；c 为填充字符，是大小写字母。</p>
<p>画布的左下角是坐标为 (0, 0) 的位置，向右为x坐标增大的方向，向上为y坐标增大的方向。这q个操作按照数据给出的顺序依次执行。画布最初时所有位置都是字符 .（小数点）。</p>
<p>输出格式<br>　　<br>  输出有n行，每行m个字符，表示依次执行这q个操作后得到的画图结果。<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入</span><br><span class="line">4 2 3</span><br><span class="line">1 0 0 B</span><br><span class="line">0 1 0 2 0</span><br><span class="line">1 0 0 A</span><br><span class="line">样例输出</span><br><span class="line">AAAA</span><br><span class="line">A--A</span><br><span class="line">样例输入</span><br><span class="line">16 13 9</span><br><span class="line">0 3 1 12 1</span><br><span class="line">0 12 1 12 3</span><br><span class="line">0 12 3 6 3</span><br><span class="line">0 6 3 6 9</span><br><span class="line">0 6 9 12 9</span><br><span class="line">0 12 9 12 11</span><br><span class="line">0 12 11 3 11</span><br><span class="line">0 3 11 3 1</span><br><span class="line">1 4 2 C</span><br><span class="line">样例输出</span><br><span class="line">................</span><br><span class="line">...+--------+...</span><br><span class="line">...|CCCCCCCC|...</span><br><span class="line">...|CC+-----+...</span><br><span class="line">...|CC|.........</span><br><span class="line">...|CC|.........</span><br><span class="line">...|CC|.........</span><br><span class="line">...|CC|.........</span><br><span class="line">...|CC|.........</span><br><span class="line">...|CC+-----+...</span><br><span class="line">...|CCCCCCCC|...</span><br><span class="line">...+--------+...</span><br><span class="line">................</span><br></pre></td></tr></table></figure></p>
<p>评测用例规模与约定<br>　　<br>  所有的评测用例满足：2 ≤ m, n ≤ 100，0 ≤ q ≤ 100，0 ≤ x &lt; m（x表示输入数据中所有位置的x坐标），0 ≤ y &lt; n（y表示输入数据中所有位置的y坐标）。</p>
<p>坐标的转换需要注意。递归填充时，需要仔细考虑有关条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char grid[100+1][100+1]; </span><br><span class="line">int m,n;</span><br><span class="line">int dir[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; </span><br><span class="line">void dfs(int curx,int cury,char t)&#123;</span><br><span class="line">	if(curx&lt;0||curx&gt;=n||cury&lt;0||cury&gt;=m||grid[curx][cury]==&apos;-&apos;||grid[curx][cury]==&apos;|&apos;||grid[curx][cury]==&apos;+&apos;)&#123;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	if(grid[curx][cury]==t) return;</span><br><span class="line">	grid[curx][cury]=t;</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">	int newx=curx+dir[i][0];</span><br><span class="line">	int newy=cury+dir[i][1];	</span><br><span class="line">	dfs(newx,newy,t);</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int q,choice;</span><br><span class="line">	int x,y,x1,y1,x2,y2;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    memset(grid, &apos;.&apos;, sizeof(grid));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;q;i++)&#123;</span><br><span class="line">		cin&gt;&gt;choice;</span><br><span class="line">		if(choice==1)&#123;</span><br><span class="line">			char t;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;</span><br><span class="line">			dfs(y,x,t);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">		cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">		if(x1==x2)&#123;</span><br><span class="line">			for(int j=min(y1,y2);j&lt;=max(y1,y2);j++)</span><br><span class="line">		&#123;</span><br><span class="line">		if(grid[j][x1]==&apos;-&apos;||grid[j][x1]==&apos;+&apos;) grid[j][x1]=&apos;+&apos;;</span><br><span class="line">			else grid[j][x1]=&apos;|&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(y1==y2)&#123;</span><br><span class="line">					for(int j=min(x1,x2);j&lt;=max(x1,x2);j++)</span><br><span class="line">		&#123;</span><br><span class="line">						if(grid[y1][j]==&apos;|&apos;||grid[y1][j]==&apos;+&apos;) grid[y1][j]=&apos;+&apos;;</span><br><span class="line">			else grid[y1][j]=&apos;-&apos;;</span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">		for(int i=n-1;i&gt;=0;i--)&#123;</span><br><span class="line">		for(int j=0;j&lt;m;j++)</span><br><span class="line">	cout&lt;&lt;grid[i][j];//!!</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>HDU1232 畅通工程【并查集】</title>
    <url>/2018/12/09/%E7%95%85%E9%80%9A/</url>
    <content><![CDATA[<p>Problem Description</p>
<p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ </p>
<a id="more"></a>
<p>Input</p>
<p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 </p>
<p>注意:两个城市之间可以有多条道路相通,也就是说</p>
<p>3 3</p>
<p>1 2</p>
<p>1 2</p>
<p>2 1</p>
<p>这种输入也是合法的</p>
<p>当N为0时，输入结束，该用例不被处理。 </p>
<p>Output</p>
<p>对每个测试用例，在1行里输出最少还需要建设的道路数目。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">4 3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">999 0</span><br><span class="line">0</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">998</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/* HDU1232 畅通工程 */</span><br><span class="line"> </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// 并查集类</span><br><span class="line">class UF &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">public:</span><br><span class="line">    UF(int n) &#123;</span><br><span class="line">        for(int i=0; i&lt;=n; i++)</span><br><span class="line">            v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int Find(int x) &#123;</span><br><span class="line">        for(;;) &#123;</span><br><span class="line">            if(v[x] != x)</span><br><span class="line">                x = v[x];</span><br><span class="line">            else</span><br><span class="line">                return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    bool Union(int x, int y) &#123;</span><br><span class="line">        x = Find(x);</span><br><span class="line">        y = Find(y);</span><br><span class="line">        if(x == y)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            v[x] = y;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, src, dest, root, count;</span><br><span class="line"> </span><br><span class="line">    while(cin &gt;&gt; n &amp;&amp; n != 0) &#123;</span><br><span class="line">        UF uf(n);</span><br><span class="line"> </span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line"> </span><br><span class="line">        // 输入边（城镇道路），构造并查集</span><br><span class="line">        while(m--) &#123;</span><br><span class="line">            cin &gt;&gt; src &gt;&gt; dest;</span><br><span class="line"> </span><br><span class="line">            if(uf.Find(src) != uf.Find(dest))</span><br><span class="line">                uf.Union(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 逐个结点（城镇）检查是否联通，如果不联通则修一条道路使其联通</span><br><span class="line">        count = 0;</span><br><span class="line">        root = uf.Find(1);</span><br><span class="line">        for(int i=2; i&lt;=n; i++)</span><br><span class="line">            if(uf.Find(i) != root) &#123;</span><br><span class="line">                uf.Union(i, 1);</span><br><span class="line"> </span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        // 输出结果</span><br><span class="line">        cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title>算法训练 2的次幂表示</title>
    <url>/2019/03/16/%E7%9A%84%E6%AC%A1%E5%B9%82%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<p>问题描述<br>　　任何一个正整数都可以用2进制表示，例如：137的2进制表示为10001001。<br>　　将这种2进制表示写成2的次幂的和的形式，令次幂高的排在前面，可得到如下表达式：137=2^7+2^3+2^0<br>  <a id="more"></a><br>　　现在约定幂次用括号来表示，即a^b表示为a（b）<br>　　此时，137可表示为：2（7）+2（3）+2（0）<br>　　进一步：7=2^2+2+2^0 （2^1用2表示）<br>　　3=2+2^0<br>　　所以最后137可表示为：2（2（2）+2+2（0））+2（2+2（0））+2（0）<br>　　又如：1315=2^10+2^8+2^5+2+1<br>　　所以1315最后可表示为：<br>　　2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）<br>输入格式<br>　　正整数（1&lt;=n&lt;=20000）<br>输出格式<br>　　符合约定的n的0，2表示（在表示中不能有空格）<br>样例输入<br>137<br>样例输出<br>2(2(2)+2+2(0))+2(2+2(0))+2(0)<br>样例输入<br>1315<br>样例输出<br>2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</p>
<p>**提示</p>
<p>用递归实现会比较简单，可以一边递归一边输出<br> 解题思路<br>     用递归来实现。将十进制数转换成二进制，记录转换过程中为1的是第几次循环，然后再判断。递归的边界就是当n==0,n==1 n==2的时候。<br>     但是应该注意的是，要判断什么时候输出+号，什么时候不输出。当不是最后一个的时候就输出 +<br>     定义数组的时候要定义为局部变量，因为每一次数组存储的都不同。<br>     **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void dg(int n)&#123;</span><br><span class="line">	int a[32];</span><br><span class="line">	memset(a,0,sizeof(a));</span><br><span class="line">	int num=0;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(n)&#123;</span><br><span class="line">		int j=n%2;</span><br><span class="line">		if(j==1)&#123;</span><br><span class="line">			a[num++]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		n/=2;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int c=num-1;c&gt;=0;c--)&#123;</span><br><span class="line">	if(a[c]==0) cout&lt;&lt;&quot;2(0)&quot;;</span><br><span class="line">	else	if(a[c]==1) cout&lt;&lt;&quot;2&quot;;	</span><br><span class="line">	//	else	if(a[c]==2) cout&lt;&lt;&quot;2(2)&quot;;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout&lt;&lt;&quot;2(&quot;;</span><br><span class="line">			dg(a[c]);</span><br><span class="line">			cout&lt;&lt;&quot;)&quot;;</span><br><span class="line">			</span><br><span class="line">		&#125;	</span><br><span class="line">	if(c&gt;0) cout&lt;&lt;&quot;+&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	dg(n);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/u012110719/article/details/44924323" target="_blank" rel="noopener">https://blog.csdn.net/u012110719/article/details/44924323</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>历届试题 矩阵乘法</title>
    <url>/2019/03/13/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<p>问题描述<br>　　有n个矩阵，大小分别为a0<em>a1, a1</em>a2, a2<em>a3, …, a[n-1]</em>a[n]，现要将它们依次相乘，只能使用结合率，求最少需要多少次运算。<br>  <a id="more"></a><br>　　两个大小分别为p<em>q和q</em>r的矩阵相乘时的运算次数计为p<em>q</em>r。<br>输入格式<br>　　输入的第一行包含一个整数n，表示矩阵的个数。<br>　　第二行包含n+1个数，表示给定的矩阵。<br>输出格式<br>　　输出一个整数，表示最少的运算次数。<br>样例输入<br>3<br>1 10 5 20<br>样例输出<br>150<br>数据规模和约定<br>　　1&lt;=n&lt;=1000, 1&lt;=ai&lt;=10000。</p>
<p>类似于合并石子问题</p>
<p>子问题：矩阵i到j合并最小花费</p>
<p>确实是一个区间dp,但是我当时写的时候也有点乱,n个矩阵给你n+1个数,那么dp[1][n]就表示从第1个矩阵合并到第n个矩阵的最小花费。我们首先观察给你n+1个数,a[i]为其行数,a[i+1]为其列数,并且对于两个矩阵 p <em>q q</em> r 合并 则合并完后为p <em>r.   花费为p</em>q<em>r; 也就是说对于(i,j)找到一个中间态的矩阵k,合并之后的花费为 a[i]</em>a[k+1]<em>a[j+1]；（这是因为如果将i k两个矩阵合并后的话变为 a[i]</em>a[k+1]的矩阵了 （第k个矩阵的列为a[k+1]）） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define inf (ll) 1&lt;&lt;62</span><br><span class="line">#define MAX 1001</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">ll dp[MAX][MAX];</span><br><span class="line">ll num[MAX];</span><br><span class="line">ll min(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b?b:a;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//cin&gt;&gt;n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	   memset(dp,0,sizeof(dp));</span><br><span class="line">	for(int i=1;i&lt;=n+1;i++)</span><br><span class="line">	scanf(&quot;%lld&quot;,&amp;num[i]);</span><br><span class="line">	 </span><br><span class="line">	for(int len=2;len&lt;=n;len++)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n-len+1;i++)&#123;</span><br><span class="line">		int j=i+len-1;		//!!</span><br><span class="line">		dp[i][j]=inf;</span><br><span class="line">		for(int k=i;k&lt;j;k++)</span><br><span class="line">		</span><br><span class="line">		dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+num[i]*num[k+1]*num[j+1]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">printf(&quot;%lld\n&quot;,dp[1][n]);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 105</span><br><span class="line">int n;</span><br><span class="line">int mod=1000000007;</span><br><span class="line">long long dp[MAX][MAX];</span><br><span class="line">int num[MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	fill(dp[0],dp[0]+MAX*MAX,0x3f3f3f);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n+1;i++)</span><br><span class="line">	cin&gt;&gt;num[i];</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			dp[i][i+1]=num[i]*num[i+1];</span><br><span class="line">		if(i!=n-1)dp[i][i+2]=num[i]*num[i+1]*num[i+2];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;n+1;i++)&#123;</span><br><span class="line">		for(int j=i+1;j&lt;n+1;j++)&#123;</span><br><span class="line">			for(int k=i+1;k&lt;j;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(dp[i][j]&gt;dp[i][k]+dp[k][j])</span><br><span class="line">				dp[i][j]=dp[i][k]+dp[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;dp[0][n];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="https://blog.csdn.net/sinat_35637319/article/details/55253915" target="_blank" rel="noopener">https://blog.csdn.net/sinat_35637319/article/details/55253915</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>201612-4 压缩编码</title>
    <url>/2018/12/12/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　给定一段文字，已知单词a1, a2, …, an出现的频率分别t1, t2, …, tn。可以用01串给这些单词编码，即将每个单词与一个01串对应，使得任何一个单词的编码（对应的01串）不是另一个单词编码的前缀，这种编码称为前缀码。<br>　　使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。一段文字经过前缀编码后的长度为：<br>　<br> L=a1的编码长度×t1+a2的编码长度×t2+…+ an的编码长度×tn。<br><a id="more"></a></p>
<p>定义一个前缀编码为字典序编码，指对于1 ≤ i &lt; n，ai的编码（对应的01串）的字典序在ai+1编码之前，即a1, a2, …, an的编码是按字典序升序排列的。<br>　　<br>  例如，文字E A E C D E B C C E C B D B E中， 5个单词A、B、C、D、E出现的频率分别为1, 3, 4, 2, 5，则一种可行的编码方案是A:000, B:001, C:01, D:10, E:11，对应的编码后的01串为1100011011011001010111010011000111，对应的长度L为3×1+3×3+2×4+2×2+2×5=34。<br>　<br> 在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是A:000, B:01, C:10, D:001, E:11，虽然最终文字编码后的总长度只有33，但是这个编码不满足字典序编码的性质，比如C的编码的字典序不在D的编码之前。<br>　　<br>  在这个例子中，有些人可能会想的另一个字典序编码是A:000, B:001, C:010, D:011, E:1，编码后的文字长度为35。<br>　<br> 请找出一个字典序编码，使得文字经过编码后的长度L最小。在输出时，你只需要输出最小的长度L，而不需要输出具体的方案。在上面的例子中，最小的长度L为34。</p>
<p>输入格式<br>　<br> 输入的第一行包含一个整数n，表示单词的数量。<br>　<br> 第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an出现的频率，即t1, t2, …, tn。请注意a1, a2, …, an具体是什么单词并不影响本题的解，所以没有输入a1, a2, …, an。</p>
<p>输出格式<br>　　<br>  输出一个整数，表示文字经过编码后的长度L的最小值。</p>
<p>样例输入</p>
<p>5</p>
<p>1 3 4 2 5</p>
<p>样例输出</p>
<p>34</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m[1002][1002],s[1002][1002];</span><br><span class="line">int sum[1002],a[1002],n;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	sum[0]=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		sum[i]=sum[i-1]+a[i];</span><br><span class="line">		m[i][i]=0;</span><br><span class="line">	//	cout&lt;&lt;sum[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	memset(s,0,sizeof(s));</span><br><span class="line">	for(int v=2;v&lt;=n;v++)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n-v+1;i++)&#123;</span><br><span class="line">			int j=i+v-1;</span><br><span class="line">			int l1=(s[i][j-1]&gt;i)?s[i][j-1]:i;</span><br><span class="line">			int l2=(s[i+1][j]&lt;j)?s[i+1][j]:j;</span><br><span class="line">			s[i][j]=l1;</span><br><span class="line">			m[i][j]=m[i][l1]+m[l1+1][j]+sum[j]-sum[i-1];</span><br><span class="line">			for(int k=l1+1;k&lt;=l2;k++)&#123;</span><br><span class="line">				if(m[i][k]+m[k+1][j]+sum[j]-sum[i-1]&lt;m[i][j])&#123;</span><br><span class="line">					m[i][j]=m[i][k]+m[k+1][j]+sum[j]-sum[i-1];</span><br><span class="line">					s[i][j]=k;</span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;m[1][n];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似 石子合并</p>
<p>题解<br>维护前缀和，枚举分割点k</p>
<p>dp[i][j]表示第i到第j堆石子合并的最优值，sum[i][j]表示第i到第j堆石子的总数量。</p>
<p>平行四边形优化</p>
<p>设m[i,j]表示动态规划的状态量。<br>m[i,j]有类似如下的状态转移方程：<br>m[i,j]=min{m[i,k]+m[k,j]}(i≤k≤j)</p>
<p>定义s(i,j)为函数m(i,j)对应的使得m(i,j)取得最大值的k值。</p>
<p>我们可以证明，s[i,j-1]≤s[i,j]≤s[i+1,j]<br>那么改变状态转移方程为：<br>m[i,j]=min{m[i,k]+m[k,j]}(s[i,j-1]≤k≤s[i+1,j])<br>记录最佳分割点point[i][j]，k从point[i][j- 1]枚举到point[i + 1][j]即可</p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵连乘</title>
    <url>/2018/12/19/%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98/</url>
    <content><![CDATA[<p>矩阵连乘问题描述</p>
<p>有n个矩阵连乘，如何找到最小的加括号方式以及最小的次数<br><a id="more"></a><br>疑问</p>
<p>A(3<em>5)A(5</em>7)A(7*2)的向乘次数和划分有关系吗？</p>
<p>(A(3<em>5)A(5</em>7))A(7<em>2)  相乘次数： (3</em>5<em>7)+(3</em>7)*2 = 147</p>
<p>A(3<em>5)(A(5</em>7)A(7<em>2))  相乘次数： (5</em>7<em>2)+3</em>(5*2) = 100</p>
<p>答案很明显是有关系的。</p>
<p>分析</p>
<p>求 A1A2A3…An</p>
<p>定义   AiAi+1…Ak…Aj-1Aj   子列， 可看成是Ai…Ak，Ak…Aj</p>
<p>确定k的位置，然后按照递归的思想来逐步解决</p>
<p>求得结果后，使i=1，j=n原问题即可求解。</p>
<p>建立递归关系（状态转移方程）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设</span><br><span class="line">Ai…Aj相乘 的最小数乘次数存储于m[i][j]中。</span><br><span class="line">S[i][j]存储最佳断开位置。</span><br><span class="line">A1：P0*P1</span><br><span class="line">A2：P1*P2</span><br><span class="line">A3：P2*P3</span><br><span class="line">…</span><br><span class="line">Ai：Pi-1*Pi</span><br><span class="line">Ai+1：Pi*Pi+1</span><br><span class="line">…</span><br><span class="line">An：Pn-1*Pn</span><br><span class="line">P0*P1*P2…*Pn——n+1个</span><br></pre></td></tr></table></figure>
<p>s[i][j]的确定方法：</p>
<p>对于Ai……Aj</p>
<p>k=i, (Ai)(…Aj)</p>
<p>k=i+1, (AiAi+1)(…Aj)</p>
<p>k=j-1, (AiAi+1…Aj-1)Aj</p>
<p>求出m[i][j]的最小k值，存入s[i][j]，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">int p[MAX];</span><br><span class="line"></span><br><span class="line">int m[MAX][MAX],s[MAX][MAX];</span><br><span class="line">void print(int i,int j)&#123;</span><br><span class="line">	if(s[i][j]==0)&#123;</span><br><span class="line">		cout&lt;&lt;i&lt;&lt;&quot;&quot;;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;(&quot;;</span><br><span class="line">	print(i,s[i][j]);</span><br><span class="line">		</span><br><span class="line">	print(s[i][j]+1,j);</span><br><span class="line">	cout&lt;&lt;&quot;)&quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n+1;i++)</span><br><span class="line">	cin&gt;&gt;p[i]; </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		m[i][i]=0;</span><br><span class="line">		s[i][i]=0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int d=2;d&lt;=n;d++)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n+d-1;i++)&#123;</span><br><span class="line">			int j=i+d-1;</span><br><span class="line">			//直接从i i+1--&gt;j </span><br><span class="line">			int min=m[i+1][j]+p[i-1]*p[i]*p[j];</span><br><span class="line">			m[i][j]=i;</span><br><span class="line">			s[i][j]=i;</span><br><span class="line">			//枚举分割点 i--&gt;k k--&gt;j(i+1&lt;=k&lt;j)</span><br><span class="line">			for(int k=i+1;k&lt;j;k++)&#123;</span><br><span class="line">				if(min&gt;m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j])&#123;</span><br><span class="line">					min=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j];</span><br><span class="line">					s[i][j]=k;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">			m[i][j]=min;			</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">		cout&lt;&lt;m[1][n]&lt;&lt;endl;</span><br><span class="line">		print(1,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fybuy5uf55j30cp04daa7.jpg" alt="iamge"><br><img src="https://ws1.sinaimg.cn/large/006wtREyly1fybuzdbmeoj31ko16i1fd.jpg" alt="image"><br>参考<br><a href="https://www.jianshu.com/p/8f2e12d6e10b" target="_blank" rel="noopener">https://www.jianshu.com/p/8f2e12d6e10b</a></p>
<p>动态规划思想：</p>
<p>将大问题划分为具有相同特征的小问题；<br>小问题之间往往相互联系；<br>从小问题一步步求解大问题。<br>适合求解最优解问题</p>
]]></content>
      <categories>
        <category>趣学算法</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>201803-2 碰撞的小球</title>
    <url>/2018/12/07/%E7%A2%B0%E6%92%9E%E7%9A%84%E5%B0%8F%E7%90%83/</url>
    <content><![CDATA[<p>数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。</p>
<p>当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。</p>
<p>当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。</p>
<p>现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。<br>提示</p>
<p>因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。</p>
<p>同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。</p>
<p>输入格式<br><a id="more"></a><br>输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。</p>
<p>第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。</p>
<p>输出格式</p>
<p>输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。</p>
<p>样例输入</p>
<p>3 10 5</p>
<p>4 6 8</p>
<p>样例输出</p>
<p>7 9 9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,L,t;</span><br><span class="line">int a[100];</span><br><span class="line">int flag[100];</span><br><span class="line">int main()&#123;</span><br><span class="line">	freopen(&quot;12-7.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;L&gt;&gt;t;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line">	//n个球 </span><br><span class="line">	memset(flag,0,sizeof(flag));</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		if(a[i]==0||a[i]==L) &#123;</span><br><span class="line">			flag[i]=!flag[i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			if(i==j) continue;</span><br><span class="line">			if(a[i]==a[j]) flag[i]=!flag[i];</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	for(int k=0;k&lt;n;k++)&#123;</span><br><span class="line">			if(flag[k]==0) a[k]=a[k]+1;</span><br><span class="line">		if(flag[k]==1) a[k]=a[k]-1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡,选择,插入排序</title>
    <url>/2018/05/01/%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%89%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="冒泡排序-O-n2"><a href="#冒泡排序-O-n2" class="headerlink" title="冒泡排序 O(n2)"></a>冒泡排序 O(n2)</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>两个数比较大小，较大的数下沉，较小的数冒起来。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>比较相邻的两个数据，如果第二个数小，就交换位置。<br>从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。<br>继续重复上述过程，依次将第2.3…n-1个最小数排好位置。<br><a id="more"></a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i-<span class="number">1</span>;j++)</span><br><span class="line">	        &#123;</span><br><span class="line">	            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">	            &#123;</span><br><span class="line">	                <span class="keyword">int</span> temp=a[j];</span><br><span class="line">	                a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">	                a[j+<span class="number">1</span>]=temp;</span><br><span class="line"></span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">		   <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">		   Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		   <span class="keyword">int</span> n=in.nextInt();</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    a[i]=in.nextInt();</span><br><span class="line">		   BubbleSort(a,n);</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    System.out.print(a[i]+<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<p>针对问题：<br>数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的。</p>
<p><strong>方案：<br>设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。<br>这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。
</strong></p>
<p>改进后:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	<span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i-<span class="number">1</span>;j++)</span><br><span class="line">	        &#123;</span><br><span class="line">	            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">	            &#123;</span><br><span class="line">	                <span class="keyword">int</span> temp=a[j];</span><br><span class="line">	                a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">	                a[j+<span class="number">1</span>]=temp;</span><br><span class="line">	                flag=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	                </span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">		   <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">		   Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		   <span class="keyword">int</span> n=in.nextInt();</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    a[i]=in.nextInt();</span><br><span class="line">		   BubbleSort(a,n);</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    System.out.print(a[i]+<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择排序-O-n2"><a href="#选择排序-O-n2" class="headerlink" title="选择排序 O(n2)"></a>选择排序 O(n2)</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；<br>第二次遍历n-2个数，找到最小的数值与第二个元素交换；<br>….<br>第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。<br><img src="http://www.runoob.com/wp-content/uploads/2015/09/12401" alt="image"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelctionSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">	        &#123;</span><br><span class="line">	            <span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">	            &#123;</span><br><span class="line">	                <span class="keyword">int</span> temp=a[i];</span><br><span class="line">	                a[i]=a[j];</span><br><span class="line">	                a[j]=temp;</span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">		   <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">		   Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		   <span class="keyword">int</span> n=in.nextInt();</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    a[i]=in.nextInt();</span><br><span class="line">		   SelctionSort(a,n);</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    System.out.print(a[i]+<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序-O-n2"><a href="#插入排序-O-n2" class="headerlink" title="插入排序 O(n2)"></a>插入排序 O(n2)</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2015/09/33403" alt="image"><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">	        &#123;</span><br><span class="line">	            <span class="keyword">if</span>(a[j]&lt;a[j-<span class="number">1</span>])</span><br><span class="line">	            &#123;</span><br><span class="line">	                <span class="keyword">int</span> temp=a[j];</span><br><span class="line">	                a[j]=a[j-<span class="number">1</span>];</span><br><span class="line">	                a[j-<span class="number">1</span>]=temp;</span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">		   <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">		   Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		   <span class="keyword">int</span> n=in.nextInt();</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    a[i]=in.nextInt();</span><br><span class="line">		   InsertionSort(a,n);</span><br><span class="line">		   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		    System.out.print(a[i]+<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>平均时间复杂度：O(n2)</p>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>线性动态规划（一）</title>
    <url>/2018/08/21/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><img src="https://ws1.sinaimg.cn/large/006wtREygy1fuh5uglhpxj30j20clwoe.jpg" alt><br><a id="more"></a></p>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>递归版本: </p>
<p>求F(n)</p>
<p>if (n==0 || n==1) return 1；</p>
<p>else  return F(n-1) + F(n-2);</p>
<p><strong>重复子问题<br>导致算法效率低下
</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package Solution;</span><br><span class="line"></span><br><span class="line">public class solution &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		 int[] a=new int[10];</span><br><span class="line">		  a[0]=1;</span><br><span class="line">		  a[1]=1;</span><br><span class="line">int sum=cal(3,a);</span><br><span class="line">System.out.println(sum);</span><br><span class="line">  &#125;</span><br><span class="line"> static int cal(int n,int[] a)&#123;</span><br><span class="line">	 </span><br><span class="line">	  if(a[n]!=0)return a[n];</span><br><span class="line">	  else return (a[n]=cal(n-1,a)+cal(n-2,a));</span><br><span class="line">	  </span><br><span class="line">	  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相当于递推<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A[0] = A[1] = 1;</span><br><span class="line">for (i =2; i &lt;= n ; i++)</span><br><span class="line">	A[i]=A[i-1] + A[i-2];</span><br><span class="line">return A[n];</span><br></pre></td></tr></table></figure></p>
<p>算法复杂度是 O(n) 记忆化搜索</p>
<p>数组等将已经算过的东西记录下来在下一次要使用的直接用已经算出的值，避免重复运算，去掉的重复的搜索树</p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREygy1fuh5v0uy52j30if0cu11o.jpg" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://ws1.sinaimg.cn/large/006wtREygy1fuh5wxt6y1j30j006qdm2.jpg" alt></p>
<h2 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>时间复杂度 o(n^2)</p>
<p>创建数组f[i]表示第i个数据的最长不下降子序列的长度</p>
<p>对每一个输入的数a[i]进行如下操作： </p>
<p>通过遍历找出k，使得f[k]为所有满足 a[k] &lt; a[i] 的值中最大的一个数</p>
<p>如果存在这样的k，那么将a[i]接在a[k]后面可以构成长度为f[k]+1的不下降子序列，因此将f[i]的值更新为f[k]+1</p>
<p>如果不存在这样的k，就说明a[i]之前不存在任何比他小的数，那么就将f[i]的值更新为1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Solution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">soll</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] a=&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">38</span>,<span class="number">24</span>,<span class="number">37</span>,<span class="number">18</span>,<span class="number">44</span>,<span class="number">19</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> big=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[j]&lt;a[i]&amp;&amp;f[j]+<span class="number">1</span>&gt;f[i])</span><br><span class="line">				&#123;</span><br><span class="line">					f[i]=f[j]+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			big=Math.max(big,f[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	    System.out.println(big);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREygy1fuh97xafu8j30is0a4q6a.jpg" alt><br><img src="https://ws1.sinaimg.cn/large/006wtREygy1fuhak0isefj307v05xgmo.jpg" alt></p>
<h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p><img src="https://ws1.sinaimg.cn/large/006wtREygy1fuhd39l0tjj30iy0augs2.jpg" alt><br>原题链接 <a href="http://poj.org/problem?id=1163" target="_blank" rel="noopener">http://poj.org/problem?id=1163</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[][] a=new int[100][100];</span><br><span class="line">		int[][] f=new int[100][100];</span><br><span class="line">		Scanner in = new Scanner(System.in);</span><br><span class="line">		int n=in.nextInt();</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">			for(int j=0;j&lt;=i;j++)</span><br><span class="line">			a[i][j]=in.nextInt();</span><br><span class="line">		f[0][0]=a[0][0];</span><br><span class="line">		</span><br><span class="line">		for(int i=1;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][0]=f[i-1][0]+a[i][0];</span><br><span class="line">			f[i][i]=f[i-1][i-1]+a[i][i];</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">			for(int i=2;i&lt;n;i++)</span><br><span class="line">			for(int j=1;j&lt;i;j++)			</span><br><span class="line">				f[i][j]=Math.max(f[i-1][j-1],f[i-1][j])+a[i][j];</span><br><span class="line">			int max=0; </span><br><span class="line">			for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">				 if(f[n-1][i]&gt;max)</span><br><span class="line">				 max=f[n-1][i];</span><br><span class="line">			&#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划适用的基本条件"><a href="#动态规划适用的基本条件" class="headerlink" title="动态规划适用的基本条件"></a>动态规划适用的基本条件</h2><p><img src="https://ws1.sinaimg.cn/large/006wtREygy1fuhdn6srjlj30i90con6v.jpg" alt></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREygy1fuhdnewqv0j30iw0d811h.jpg" alt></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREygy1fuhdo3l75yj30i50da4ai.jpg" alt></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/25173305" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25173305</a></p>
<p><a href="http://www.cnblogs.com/zhangchaoyang/articles/2012070.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhangchaoyang/articles/2012070.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>算法复杂度</title>
    <url>/2018/05/11/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p>算法复杂度分为时间复杂度和空间复杂度。其作用： 时间复杂度是度量算法执行的时间长短；而空间复杂度是度量算法所需存储空间的大小。<br><a id="more"></a></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>1.时间频度<br>　　一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。<br>2.计算方法<br>　　1. 一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f（n），因此，算法的时间复杂度记做：T（n）=O（f（n）） 　　<br>  分析：随着模块n的增大，算法执行的时间的增长率和f（n）的增长率成正比，所以f（n）越小，算法的时间复杂度越低，算法的效率越高。 　</p>
<ol start="2">
<li><p>在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出T（n）的同数量级（它的同数量级有以下：1，Log2n ，n ，nLog2n ，n的平方，n的三次方，2的n次方，n！），找出后，f（n）=该数量级，若T(n)/f(n)求极限可得到一常数c，则时间复杂度T（n）=O（f（n）） 　　<br>例：算法： 　　</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（i=<span class="number">1</span>;i&lt;=n;++i） 　　&#123; 　　</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;++j) 　　&#123; 　　c[ i ][ j ]=<span class="number">0</span>; <span class="comment">//该步骤属于基本操作 执行次数：n的平方 次 　　for(k=1;k&lt;=n;++k) 　　c[ i ][ j ]+=a[ i ][ k ]*b[ k ][ j ]; //该步骤属于基本操作 执行次数：n的三次方 次 　　&#125; 　　&#125;</span></span><br></pre></td></tr></table></figure>
<p>则有 T（n）= n的平方+n的三次方，根据上面括号里的同数量级，我们可以确定 n的三次方 为T（n）的同数量级 　　则有f（n）= n的三次方，然后根据T（n）/f（n）求极限可得到常数c 　　则该算法的 时间复杂度：T（n）=O（n的三次方）<br>3.分类<br>　　按数量级递增排列，常见的时间复杂度有： 　　<br>常数阶O(1),对数阶O(log2n),线性阶O(n),线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， 　　k次方阶O(nk), 指数阶O(2n) 。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p>
</li>
</ol>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>　　与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作: 　　S(n)=O(f(n)) 　　我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>  <img src="https://uploadfiles.nowcoder.net/images/20161118/5918115_1479455694275_012D71F55DF5DEB20EDC2483EACDACFC" alt="image"></p>
<p>每个节点都会分裂为两个子节点，因此树高为n。<br>每次执行需要访问f(n-1)和f(n-2)，2次；程序共执行n次。时间复杂度为O(2^n)<br>空间复杂度为递归深度，即为树高O(n)，每次都要return一个值，需要占用一个存储空间</p>
]]></content>
  </entry>
  <entry>
    <title>算法提高 金明的预算方案</title>
    <url>/2019/03/14/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98-%E9%87%91%E6%98%8E%E7%9A%84/</url>
    <content><![CDATA[<p>问题描述<br>　　金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：<br>  <a id="more"></a><br>主件    附件<br>电脑    打印机，扫描仪<br>书柜    图书<br>书桌    台灯，文具<br>工作椅    无</p>
<p>　　如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p>
<p>　　设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j_1，j_2，……，j_k，则所求的总和为：</p>
<p>　　v[j_1]<em>w[j_1]+v[j_2]</em>w[j_2]+ …+v[j_k]<em>w[j_k]。（其中</em>为乘号）</p>
<p>　　请你帮助金明设计一个满足要求的购物单。</p>
<p>输入格式</p>
<p>　　输入文件budget.in 的第1行，为两个正整数，用一个空格隔开：<br>　　N m<br>　　（其中N（&lt;32000）表示总钱数，m（&lt;60）为希望购买物品的个数。）<br>　　从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数</p>
<p>　　v p q<br>　　<br>  （其中v表示该物品的价格（v&lt;10000），p表示该物品的重要度（1~5），q表示该物品是主件还是附件。</p>
<p> 如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号）</p>
<p>输出格式</p>
<p>　　输出文件budget.out只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）。<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入</span><br><span class="line">1000 5</span><br><span class="line">800 2 0</span><br><span class="line">400 5 1</span><br><span class="line">300 5 1</span><br><span class="line">400 3 0</span><br><span class="line">500 2 0</span><br><span class="line">样例输出</span><br><span class="line">2200</span><br></pre></td></tr></table></figure></p>
<p><strong>分组背包</strong></p>
<p>思路 ：<br>    可以看出01背包的变种，价格相当于重量 ， 价格乘重要度相当于价值<br>    然后大致分为下面五种情况：<br>        （1） 什么也不选 （2）选主件 （3）选主件加第一个附件 （4）选主件加第二个附件 （5）选主件加两个附件<br>    有的有附件有的没有附件  就是0~2个<br>    假设都有附件，如果没有，就是0*0，对结果没有影响，多判断几次也不会耗费太长时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define MAX 66</span><br><span class="line">using namespace std;</span><br><span class="line">int cnt;</span><br><span class="line">int v[MAX][3],w[MAX][3],dp[61][33000];</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int m,n;</span><br><span class="line">	</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;m , &amp;n );</span><br><span class="line">	memset(dp,0,sizeof(dp));</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int pr,pw,pq;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;pr,&amp;pw,&amp;pq);</span><br><span class="line">		if(pq==0)&#123;</span><br><span class="line">			v[i][0]=pr;</span><br><span class="line">			w[i][0]=pw;</span><br><span class="line">		&#125; </span><br><span class="line">		else if(v[pq][1]==0)&#123;</span><br><span class="line">			v[pq][1]=pr;</span><br><span class="line">			w[pq][1]=pw;</span><br><span class="line">		&#125;</span><br><span class="line">	else if(v[pq][2]==0)&#123;</span><br><span class="line">			v[pq][2]=pr;</span><br><span class="line">			w[pq][2]=pw;	</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;	</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int r=1;r&lt;=m;r++)&#123;</span><br><span class="line">        //注意第一个大括号 if(r&gt;=v[i][0]) 接着判断比较</span><br><span class="line">        </span><br><span class="line">		if(r&gt;=v[i][0])&#123;//!!</span><br><span class="line">		dp[i][r]=max(dp[i-1][r],dp[i-1][r-v[i][0]]+v[i][0]*w[i][0]);</span><br><span class="line">		 //else if错的 </span><br><span class="line">		 //dp[i-1][r] 还是dp[i][r]要注意 </span><br><span class="line">	if(r&gt;=v[i][0]+v[i][1])</span><br><span class="line">		dp[i][r]=max(dp[i][r],dp[i-1][r-v[i][0]-v[i][1]]+v[i][0]*w[i][0]+v[i][1]*w[i][1]);	</span><br><span class="line">		</span><br><span class="line">		if(r&gt;=v[i][0]+v[i][2])</span><br><span class="line">		dp[i][r]=max(dp[i][r],dp[i-1][r-v[i][0]-v[i][2]]+v[i][0]*w[i][0]+v[i][2]*w[i][2]);</span><br><span class="line">		</span><br><span class="line">		if(r&gt;=v[i][0]+v[i][1]+v[i][2])</span><br><span class="line">		dp[i][r]=max(dp[i][r],dp[i-1][r-v[i][0]-v[i][1]-v[i][2]]+v[i][0]*w[i][0]+v[i][1]*w[i][1]+v[i][2]*w[i][2]);</span><br><span class="line">			&#125;</span><br><span class="line">		else </span><br><span class="line">		//	dp[i][r]=max(dp[i-1][r],dp[i][r]);</span><br><span class="line">			dp[i][r]=dp[i-1][r];//钱不够 只能选i-1件  不用Max </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">	cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>算法整理</title>
    <url>/2020/04/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="青蛙跳"><a href="#青蛙跳" class="headerlink" title="青蛙跳"></a>青蛙跳</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ef jumpFloor(n):</span><br><span class="line">    # 斐波那契初始化</span><br><span class="line">    fn = [1,1]</span><br><span class="line"> </span><br><span class="line">    # 计算 f(n) = f(n-1) + f(n-2)</span><br><span class="line">    for i in range(n-1):</span><br><span class="line">        fn[0], fn[1] = fn[1], fn[0]+fn[1]</span><br><span class="line"> </span><br><span class="line">    # 返回</span><br><span class="line">    return fn[-1]</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/JockLiu/article/details/91830380" target="_blank" rel="noopener">https://blog.csdn.net/JockLiu/article/details/91830380</a></p>
]]></content>
  </entry>
  <entry>
    <title> 算法训练 最大最小公倍数  </title>
    <url>/2018/12/17/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    <content><![CDATA[<p>问题描述<br>已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。<br><a id="more"></a><br>输入格式<br>输入一个正整数N。</p>
<p>输出格式<br>输出一个整数，表示你找到的最小公倍数。<br>样例输入<br>9<br>样例输出<br>504<br>数据规模与约定<br>1 &lt;= N &lt;= 106。</p>
<p>按照常理来说，最大的应该是n, n-1, n-2这三个数，如果这三个数恰好互质，那再好不过。然而恰好当n为奇数时，这三个数互质。下面来解释下为什么。首先这三个数时连续的三个数。也就是n，n-1，n-2。因为n是奇数，所以奇偶奇不可能有2这个因数。那再看3，这三个连续的数最大相差的是2，然而我们知道如果n能被3整除那n+1，n+2（减去是一样的）就不能因为没加够一个3.同理如果n能被4整除那么n+1，n+2，n+3也都不能被4整除，因为没加够一个4.证毕。<br>  再看若n是偶数，那很自然的想到吧n-2往后挪一个变成奇数n-3就好了。但是这里有个问题，如果n刚好能被3整除的话那么n-3也能。那就还要除去一个3.不划算。那不能挪后面的就把前面的挪一下吧。变成n-1，n-2,n-3。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAX 200+2</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	long long n;</span><br><span class="line">	long long  ans=0;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	if(n%2)&#123;</span><br><span class="line">		ans=n*(n-1)*(n-2);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else if(n%3)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=n*(n-1)*(n-3);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		</span><br><span class="line">		ans=(n-1)*(n-2)*(n-3);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练 结点选择</title>
    <url>/2019/03/13/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E7%BB%93%E7%82%B9%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>问题描述<br>有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？<br><a id="more"></a><br>输入格式<br>第一行包含一个整数 n 。</p>
<p>接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。</p>
<p>接下来一共 n-1 行，每行描述树上的一条边。</p>
<p>输出格式<br>输出一个整数，代表选出的点的权值和的最大值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">样例输出</span><br><span class="line">12</span><br><span class="line">样例说明</span><br><span class="line">选择3、4、5号点，权值和为 3+4+5 = 12 。</span><br><span class="line">数据规模与约定</span><br><span class="line">对于20%的数据， n &lt;= 20。</span><br><span class="line"></span><br><span class="line">对于50%的数据， n &lt;= 1000。</span><br><span class="line"></span><br><span class="line">对于100%的数据， n &lt;= 100000。</span><br><span class="line"></span><br><span class="line">权值均为不超过1000的正整数。</span><br></pre></td></tr></table></figure></p>
<p><strong><br>对于叶子节点 dp[k][0] = 0, dp[k][1] = k点权值<br>对于非叶子节点i,<br>dp[i][0] = ∑max(dp[j][0], dp[j][1]) (j是i的儿子)<br>dp[i][1] = i点权值 + ∑dp[j][0] (j是i的儿子)<br>最大权值即为max(dp[0][0], dp[0][1])
</strong></p>
<p>分析：题目给出的数据不一定是二叉树，所以可以看作图来处理～其实就是用邻接表存储啦～v[i]数组中保存i结点的孩子节点们～dp[i][0]表示不取i结点的结果～dp[i][1]表示取i结点的结果～</p>
<p>用深度优先搜索+动态规划，每个点的最大权值有取当前这个点和不取当前这个点两种情况～如果取当前点，则不能取与它相邻的任何点；不取当前点，则取与它相邻点的最大值进行累加～从底向上累加到顶部～max(dp[1][0], dp[1][1])就是所求结果～</p>
<p>用一个变量pre保存当前结点的前一个结点～如果等于pre说明访问到了它的父亲结点，为了防止重复访问，要在v[node][i]不等于pre时候继续dfs下去～否则可能会形成无限循环的环～<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt;g;</span><br><span class="line"></span><br><span class="line">int dp[100010][2];</span><br><span class="line">int n;</span><br><span class="line">void dfs(int cur,int pre)&#123;</span><br><span class="line">	for(int i=0;i&lt;g[cur].size();i++)&#123;</span><br><span class="line">			int tmp=g[cur][i];</span><br><span class="line">			//!如果等于pre说明访问到了它的父亲结点，为了防止重复访问，要在v[node][i]不等于pre时候继续dfs下去</span><br><span class="line">			//否则可能会形成无限循环的环</span><br><span class="line">		if(tmp!=pre)&#123;</span><br><span class="line">		</span><br><span class="line">			dfs(tmp,cur);</span><br><span class="line">			dp[cur][1]+=dp[tmp][0];</span><br><span class="line">			dp[cur][0]+=max(dp[tmp][0],dp[tmp][1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;dp[i][1];</span><br><span class="line">	&#125;</span><br><span class="line">	g=vector&lt;vector&lt;int&gt; &gt;(n+1);</span><br><span class="line">//	g.resize(n + 1);</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">		int a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		g[a].push_back(b);</span><br><span class="line">		g[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(1,0);</span><br><span class="line">	cout&lt;&lt;max(dp[1][0],dp[1][1])&lt;&lt;endl;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接</p>
<p><a href="https://blog.csdn.net/liuchuo/article/details/69663161" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/69663161</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>紫书7.2.1 生成1-n的排列</title>
    <url>/2018/11/03/%E7%B4%AB%E4%B9%A67-2-1-%E7%94%9F%E6%88%901-n%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>输入正数n，按字典序从小到大的顺序输出n个数的所有排列。两个序列的字典序大小关系等价于从头开始第一个不相同位置处的大小关系。<br><a id="more"></a><br>递归的边界应该很好理解吧，当集合s[]中没有一个元素的时候，按照上面的伪码，s[]中的元素只能向序列a[]中跑，s[]没了元素，那么序列a[]就是一个完整的序列了。那么，直接输出序列a[]即可。按照从小到大的顺序考虑s[]中的每个元素，每次递归的调用以a[]开始。</p>
<pre><code>如果伪码了解了，那么就得用代码实现了。很容易想到序列a[]用数组保存集合s[]中跑过来得数字，而s[]呢？如果要完成老师布置的第一个题目，那么s[]中的元素根本不要保存，因为s[]中的元素往a[]中跑，那么，跑过来得数字就间接的保存在了序列a[]中，只要没在序列a[]中出现过的数字都可以备选。由于C/C++传递数组的时候传递的是数组的首地址，所以，还需要传一个到底填了多少个数，也就是到底填到数组的第几个位置来了，我们把这个参数取名为cur
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int a[10000];</span><br><span class="line">void per(int cur)&#123;</span><br><span class="line">	if(cur==n)&#123;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		return ;</span><br><span class="line">	&#125; </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int flag=1;</span><br><span class="line">		for(int j=0;j&lt;cur;j++)&#123;</span><br><span class="line">			if(a[j]==i) flag=0;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag==1) </span><br><span class="line">		&#123;</span><br><span class="line">		a[cur]=i;</span><br><span class="line">		per(cur+1);//!!!不能放在大括号后 只有满足当前位置填的数与之前不重复 才可以填下一个 </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	per(0);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fwuog8m0ndj303m0aodg5.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>紫书7.2.2 生成可重集的排列</title>
    <url>/2018/11/03/%E7%B4%AB%E4%B9%A67-2-2-%E7%94%9F%E6%88%90%E5%8F%AF%E9%87%8D%E9%9B%86%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>输入n个数 给出这n各数的全排列（可重复）<br>如<br>1 1 1的全排列是1 1 1<br>1 3 4的全排列是1 3 4<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">枚举排列的两种方法</span><br><span class="line">- 递归枚举</span><br><span class="line">- 用STL 的next_permutation</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int a[10000];</span><br><span class="line">int p[10000];</span><br><span class="line">void per(int cur)&#123;</span><br><span class="line">	if(cur==n)&#123;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		return ;</span><br><span class="line">	&#125; </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;//遍历的p[i]元素 </span><br><span class="line">	if(!i||p[i]!=p[i-1]) &#123;//枚举的下标不重复 1,1,3 下一次 又以第二个1开头 不合理的 </span><br><span class="line"></span><br><span class="line">		int c1=0;</span><br><span class="line">		for(int j=0;j&lt;cur;j++)&#123;</span><br><span class="line">			if(a[j]==p[i]) c1++;</span><br><span class="line">		&#125;</span><br><span class="line">		//a里存的已经填好的数  cur是当前位置将要填的数 </span><br><span class="line">		int c2=0;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">		</span><br><span class="line">		if(p[i]==p[j]) c2++;&#125; </span><br><span class="line">		if(c1&lt;c2) </span><br><span class="line">		&#123;</span><br><span class="line">		a[cur]=p[i];</span><br><span class="line">		per(cur+1);//!!!不能放在大括号后 只有满足当前位置填的数与之前不重复 才可以填下一个 </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;p[i]; </span><br><span class="line">	per(0);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>紫书例题7-2 最大乘积</title>
    <url>/2018/11/03/%E7%B4%AB%E4%B9%A6%E4%BE%8B%E9%A2%987-2-%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<p>输入n个元素组成的序列s，你需要找出一个乘积最大的连续子序列。如果这个最大的成绩不是正数，应输入-1（表示无解）。输入0结束输入。1&lt;=n&lt;=18,-10&lt;=Si&lt;=10。<br>样例输入：</p>
<p>3</p>
<p>2 4 -3</p>
<p>样例输出：</p>
<p>8</p>
<p>20<br><a id="more"></a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>枚举起点与终点</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	int a[100];</span><br><span class="line">	while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">		if(n==0) break;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	int max=-1;</span><br><span class="line">	//i,j控制循环次数 </span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">	</span><br><span class="line">		for(int j=i+1;j&lt;n;j++)&#123;</span><br><span class="line">				int sum=1; </span><br><span class="line">			for(int k=i;k&lt;=j;k++) //!!!</span><br><span class="line">					sum*=a[k];</span><br><span class="line">			if(sum&gt;max) max=sum;</span><br><span class="line">				cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>紫书例题7-1 除法</title>
    <url>/2018/11/02/%E7%B4%AB%E4%B9%A6%E4%BE%8B%E9%A2%987-1-%E9%99%A4%E6%B3%95/</url>
    <content><![CDATA[<p>输入正整数n，用0~9这10个数字不重复组成两个五位数abcde和fghij，使得abcde/fghij的商为n，按顺序输出所有结果。如果没有找到则输出“There are no solutions for N.”。这里2&lt;=n&lt;=79。</p>
<a id="more"></a>
<p>样例输入： 62</p>
<p>样例输出：</p>
<p>79546/01238=62</p>
<p>94736/01528=62</p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//x用ijkmn表示，若整除n，求出y，而后用abcde表示Y,看是否重复数字 </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int i,j,k,m,n;</span><br><span class="line">	int a,b,c,d,e;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t ;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	for(i=0;i&lt;=9;i++)&#123;</span><br><span class="line">		for( j=0;j&lt;=9;j++)</span><br><span class="line">		for( k=0;k&lt;=9;k++)&#123;</span><br><span class="line">			for(m=0;m&lt;=9;m++)</span><br><span class="line">			for( n=0;n&lt;=9;n++)</span><br><span class="line">			&#123;</span><br><span class="line">				set&lt;int&gt; s;//!!!</span><br><span class="line">					int flag=1;//!!!</span><br><span class="line">				int num=i*10000+j*1000+k*100+m*10+n;</span><br><span class="line">				if(!(num%t))</span><br><span class="line">				&#123;</span><br><span class="line">					int y=num/t;</span><br><span class="line">					a=y/10000,b=y/1000%10,c=y/100%10,d=y/10%10,e=y%10;</span><br><span class="line">					s.insert(a);</span><br><span class="line">					s.insert(b);</span><br><span class="line">					s.insert(c);</span><br><span class="line">					s.insert(d);</span><br><span class="line">					s.insert(e);</span><br><span class="line">					s.insert(i);</span><br><span class="line">					s.insert(j);</span><br><span class="line">					s.insert(k);					</span><br><span class="line">					s.insert(m);</span><br><span class="line">					s.insert(n);	</span><br><span class="line">//					for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)</span><br><span class="line">//					cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">//		break;</span><br><span class="line">							if(s.size()!=10) flag=0;</span><br><span class="line">							if(flag==1) cout&lt;&lt;i&lt;&lt;j&lt;&lt;k&lt;&lt;m&lt;&lt;n&lt;&lt;&quot;/&quot;&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;e&lt;&lt;&quot;=&quot;&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>暴力枚举法</p>
<p>问题分析：没有什么好办法，就暴力枚举吧！不过还是要下点功夫，否则10！的计算量是不可想象的。</p>
<p>1.因为n&gt;=2，且abcde=fghij×n，满足abcde&gt;fghij。若a=0，则fghij的最小值为12345，abcde&lt;fghij，矛盾。所以a≠0。</p>
<p>2.因为a≠0，所以12345&lt;=abcde&lt;=98765，01234&lt;=fghij。</p>
<p>3.因为2≤n，且abcde≤98765，那么fghij = abcde/n，得fghij≤98765/2=49382，所以01234≤fghij≤49382。</p>
<p>4.因为12345≤abcde≤98765，且01234≤fghij≤49382，所以用fghij进行枚举范围比较小。（这是在任意的n的条件下得出的结论）</p>
<p>5.对于给定的n，因为abcde≤98765，那么fghij = abcde/n，得fghij≤98765/n。结论：01234≤fghij≤98765/n。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;memory.h&gt;  </span><br><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#define DIGITNUM 10  </span><br><span class="line">//这里判断两个数的每一位都不相同我用的是采用一个数组，然后把每一个数字在对应的数组中的位置的元素换成1，然后判断数组中的元素是否全部都为1即可。</span><br><span class="line">//数组下标代表0，1，2，3，4，5，6，7，8，9</span><br><span class="line">using namespace std;</span><br><span class="line">//int num[DIGITNUM]=&#123;0&#125;;</span><br><span class="line">int d,f;</span><br><span class="line">int check(int abcde, int fghij)  </span><br><span class="line">&#123;  int num[DIGITNUM]=&#123;0&#125;;</span><br><span class="line">	if(fghij &lt; 10000)  </span><br><span class="line">        num[0] = 1;  </span><br><span class="line">  </span><br><span class="line">	while(abcde)&#123;</span><br><span class="line">		d=abcde%10;</span><br><span class="line">		if(num[d]) return 0;</span><br><span class="line">		 num[d]=1;</span><br><span class="line">		abcde/=10;</span><br><span class="line">	&#125; </span><br><span class="line">	while(fghij)&#123;</span><br><span class="line">		f=fghij%10;</span><br><span class="line">		if(num[f]) return 0;</span><br><span class="line">	num[f]=1;</span><br><span class="line">		fghij/=10;			</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	int end=98765/n;</span><br><span class="line">	int cnt=0;</span><br><span class="line">	for(int i=1234;i&lt;=end;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int k=i*n;</span><br><span class="line">			if(k&gt;=12345&amp;&amp;check(k,i))&#123;  </span><br><span class="line">                printf(&quot;%05d / %05d = %d\n&quot;, k, i, n);  </span><br><span class="line">                cnt++;  </span><br><span class="line">            &#125; </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		if(cnt == 0)  </span><br><span class="line">            printf(&quot;There are no solutions for %d.\n&quot;, n);  </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>紫书例题7-3 分数拆分</title>
    <url>/2018/11/03/%E7%B4%AB%E4%B9%A6%E4%BE%8B%E9%A2%987-3-%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<p> It is easy to see that for every fraction in the form(k &gt; 0), we can always find two positive integers x and y,x ≥ y, such that:<br><a id="more"></a><br>Now our question is: can you write a program that counts how many such pairs of x and y there are for any given k?</p>
<p>Input</p>
<p>Input contains no more than 100 lines, each giving a value of k (0 &lt; k ≤ 10000).</p>
<p>Output</p>
<p>For each k, output the number of corresponding (x, y) pairs, followed by a sorted list of the values of x and y, as shown in the sample output.</p>
<p>Sample Input<br>2</p>
<p>12</p>
<p>Sample Output</p>
<p>2</p>
<p>1/2 = 1/6 + 1/3</p>
<p>1/2 = 1/4 + 1/4</p>
<p>8</p>
<p>1/12 = 1/156 + 1/13</p>
<p>1/12 = 1/84 + 1/14</p>
<p>1/12 = 1/60 + 1/15</p>
<p>1/12 = 1/48 + 1/16</p>
<p>1/12 = 1/36 + 1/18</p>
<p>1/12 = 1/30 + 1/20</p>
<p>1/12 = 1/28 + 1/21</p>
<p>1/12 = 1/24 + 1/24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int k,x;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">	for(int y=k+1;y&lt;2*k+1;y++)&#123;</span><br><span class="line">		if(y*k%(y-k)==0)</span><br><span class="line">		&#123;</span><br><span class="line">		  x=y*k/(y-k);</span><br><span class="line">			cout&lt;&lt;&quot;1/&quot;&lt;&lt;k&lt;&lt;&quot;=&quot;&lt;&lt;&quot;1/&quot;&lt;&lt;y&lt;&lt;&quot;=&quot;&lt;&lt;&quot;1/&quot;&lt;&lt;x&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接<br><a href="https://blog.csdn.net/CSDN_Liuzongyi/article/details/53501589" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_Liuzongyi/article/details/53501589</a></p>
]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>紫书例题7-4 素数环</title>
    <url>/2018/11/03/%E7%B4%AB%E4%B9%A6%E4%BE%8B%E9%A2%987-4-%E7%B4%A0%E6%95%B0%E7%8E%AF/</url>
    <content><![CDATA[<p>素数环问题：从1到n(n&lt;=10000)这n个数摆成一个环，要求相邻的任意两个数的和是一个素数。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">int a[1000];</span><br><span class="line">using namespace std;</span><br><span class="line">bool isnotPrime(int n)&#123;</span><br><span class="line">	for(int i=2;i&lt;n;i++)</span><br><span class="line">	if(n%i==0) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	 return false;               </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) a[i]=i+1;</span><br><span class="line">    do&#123;</span><br><span class="line">	int flag=1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;//!!括号的起止地方 </span><br><span class="line"></span><br><span class="line">    	if(isnotPrime(a[i]+a[(i+1)%n])) &#123;//!!逻辑问题 </span><br><span class="line">    	flag=0;</span><br><span class="line">    	break;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    if(flag==1) </span><br><span class="line">	&#123;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;while(next_permutation(a+1,a+n));//!!审题 输出时从整数1开始逆时针排列 </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"># include&lt;math.h&gt;</span><br><span class="line">int a[100]; </span><br><span class="line">int vis[100]=&#123;0&#125;;</span><br><span class="line">int n;</span><br><span class="line">using namespace std;</span><br><span class="line">bool isnotPrime(int n)&#123;</span><br><span class="line">	for(int i=2; i &lt;= sqrt(n);i++)</span><br><span class="line">	if(n%i==0) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	 return false;               </span><br><span class="line">&#125;</span><br><span class="line">void dfs(int cur)&#123;</span><br><span class="line">	if(cur==n&amp;&amp;!isnotPrime(a[n-1]+1))</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i=0;i&lt;n-1;i++)</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;a[n-1]&lt;&lt;endl;</span><br><span class="line">	 &#125; </span><br><span class="line">	else for(int i=2;i&lt;=n;i++)&#123;//!!!6</span><br><span class="line">		if(!vis[i]&amp;&amp;!isnotPrime(a[(cur-1)%n]+i))</span><br><span class="line">		&#123;a[cur]=i;</span><br><span class="line">		vis[i]=1;</span><br><span class="line">		dfs(cur+1);</span><br><span class="line">		vis[i]=0;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123; a[0]=1; </span><br><span class="line">  int i=0;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n!=0)</span><br><span class="line">    &#123;</span><br><span class="line">    	i++;</span><br><span class="line">   printf(&quot;Case %d:\n&quot;,i);</span><br><span class="line">    dfs(1);</span><br><span class="line">   </span><br><span class="line">	&#125; return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/C20190413/article/details/72630756" target="_blank" rel="noopener">https://blog.csdn.net/C20190413/article/details/72630756</a><br><a href="https://blog.csdn.net/MosBest/article/details/69085525" target="_blank" rel="noopener">https://blog.csdn.net/MosBest/article/details/69085525</a></p>
]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>紫书例题7-5 困难的串</title>
    <url>/2018/11/03/%E7%B4%AB%E4%B9%A6%E4%BE%8B%E9%A2%987-5-%E5%9B%B0%E9%9A%BE%E7%9A%84%E4%B8%B2/</url>
    <content><![CDATA[<p>如果一个字符串包含两个相邻的重复子串，则称它是“容易的串”，其他串称为“困难的串”。例如，                 BB、ABCDABCD都是容易的串，而D、DC、ABDAD、CBABCBA都是困难的串。</p>
<p>输入正整数n和L，输出由前L个字符组成的、字典序第k个困难的串。例如，当L=3时，前7个困难的串          分别为A、AB、ABA、ABAC、ABACA、ABACAB、ABACABA。输入保证答案不超过80个字符。</p>
<pre><code>样例输入：

7  3
</code></pre><p>   30 3</p>
<p>   样例输出：</p>
<p>   ABACABA</p>
<p>   ABACABCACBABCABACABCACBACABA<br>   <a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在回溯算法中，应注意避免不必要的判断，八皇后问题中，只需判断新皇后和之前的皇后是否冲突，而不必判断以前的皇后是否相互冲突。 </span><br><span class="line">这一题只需判断当前串的偶数项后缀是否对称</span><br><span class="line"></span><br><span class="line">BB,长度为1*2的后缀对称 </span><br><span class="line">ABCDACABCAB,长度为3*2的后缀对称 </span><br><span class="line">ABCDABCD长度为4*2的后缀对称</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int	s[100];</span><br><span class="line">int	n;</span><br><span class="line">int	L;</span><br><span class="line">int  dfs( int cur )</span><br><span class="line">&#123;</span><br><span class="line">	if ( cur == n )</span><br><span class="line">	&#123;</span><br><span class="line">		for ( int i = 0; i &lt; n; i++ )</span><br><span class="line">			printf( &quot;%c&quot;, &apos;A&apos; + s[i] );</span><br><span class="line">		printf( &quot;\n&quot; );</span><br><span class="line">		return(0);</span><br><span class="line">	&#125;else  &#123;</span><br><span class="line">		for ( int i = 0; i &lt; L; i++ )</span><br><span class="line">		&#123;</span><br><span class="line">			s[cur] = i;</span><br><span class="line">			int ok = 1;</span><br><span class="line">			for ( int j = 1; 2 * j &lt;= cur + 1; j++ )        /* 尝试j*2的后缀 */</span><br><span class="line">			&#123; /* 如j=1 尝试1*2的后缀 看看是否重复 */</span><br><span class="line">				int equal = 1;                          /* !!! */</span><br><span class="line">				for ( int k = 0; k &lt; j; k++ )</span><br><span class="line">				&#123;</span><br><span class="line">					if ( s[cur - k] != s[cur - j - k] )</span><br><span class="line">              //只要确定了后缀j*2中有一个不相等，则可以确定前一半与后一半不相等</span><br><span class="line">					&#123;</span><br><span class="line">						equal = 0;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if ( equal == 1 )</span><br><span class="line">				&#123;</span><br><span class="line">					ok = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if ( ok == 1 )</span><br><span class="line">			&#123;</span><br><span class="line">				if ( !dfs( cur + 1 ) )</span><br><span class="line">					return(0);  //!! 最后一层算完 会返回上一层 如果已经找到解就退出 </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; L;</span><br><span class="line">	dfs( 0 );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>紫书</category>
      </categories>
  </entry>
  <entry>
    <title>九度题目1188 约瑟夫环</title>
    <url>/2019/03/28/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    <content><![CDATA[<p>题目描述：<br>    N个人围成一圈顺序编号，从1号开始按1、2、3……顺序报数，报p者退出圈外，其余的<br><a id="more"></a><br>人再从1、2、3开始报数，报p的人再退出圈外，以此类推。<br>    请按退出顺序输出每个退出人的原序号。</p>
<p>输入：<br>包括一个整数N(1&lt;=N&lt;=3000)及一个整数p。</p>
<p>输出：<br>测试数据可能有多组，对于每一组数据，<br>按退出顺序输出每个退出人的原序号。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入： </span><br><span class="line">7 3</span><br><span class="line">样例输出： </span><br><span class="line">3 6 2 7 5 1 4</span><br></pre></td></tr></table></figure></p>
<p>链表环思想</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1000</span><br><span class="line">vector&lt;int&gt; vec(MAX,0);</span><br><span class="line">struct node&#123;</span><br><span class="line">	int v;</span><br><span class="line">	bool flag;</span><br><span class="line">	node *next;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,P;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;P;</span><br><span class="line">	node *head=new node();</span><br><span class="line">	head-&gt;flag=false;</span><br><span class="line">//	head-&gt;next</span><br><span class="line">	head-&gt;v=1;</span><br><span class="line">	node *tmp=head;</span><br><span class="line">	for(int i=2;i&lt;=n;i++) &#123;</span><br><span class="line">		node *t=new node();</span><br><span class="line">		t-&gt;v=i;</span><br><span class="line">		t-&gt;flag=false;</span><br><span class="line">		tmp-&gt;next=t;</span><br><span class="line">		tmp=t;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	tmp-&gt;next=head;</span><br><span class="line">	node *p=head;</span><br><span class="line">	int num=0;</span><br><span class="line">	</span><br><span class="line">	bool flag1=false;</span><br><span class="line">	while(p&amp;&amp;n&gt;0)&#123;</span><br><span class="line">		if(!p-&gt;flag)&#123;</span><br><span class="line">			num++;</span><br><span class="line">			if(num==P)&#123;</span><br><span class="line">				if(flag1==false)</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;p-&gt;v;</span><br><span class="line">				flag1=true;</span><br><span class="line">			&#125;</span><br><span class="line">			else cout&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;v;</span><br><span class="line">			num=0;//重新計數 </span><br><span class="line">			n--;//出去的个数 </span><br><span class="line">			p-&gt;flag=true;	//做标记 </span><br><span class="line">			&#125;		</span><br><span class="line">		//	p-&gt;flag=true;	注意放的位置 </span><br><span class="line">		&#125;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接<br><a href="https://blog.csdn.net/wzy_1988/article/details/8924408" target="_blank" rel="noopener">https://blog.csdn.net/wzy_1988/article/details/8924408</a></p>
]]></content>
      <categories>
        <category>九度</category>
      </categories>
      <tags>
        <tag>链表环</tag>
      </tags>
  </entry>
  <entry>
    <title>未名湖边的烦恼</title>
    <url>/2018/12/17/%E8%8E%AB%E5%90%8D%E8%83%A1/</url>
    <content><![CDATA[<p>问题描述 　　</p>
<p>每年冬天，北大未名湖上都是滑冰的好地方。北大体育组准备了许多冰鞋，可是人太多了，每天下午收工后，常常一双冰鞋都不剩。 　　每天早上，租鞋窗口都会排起长龙，假设有还鞋的m个，有需要租鞋的n个。现在的问题是，这些人有多少种排法，可以避免出现体育组没有冰鞋可租的尴尬场面。（两个同样需求的人（比如都是租鞋或都是还鞋）交换位置是同一种排法）<br><a id="more"></a><br>输入格式 　　两个整数，表示m和n 输出格式 　　一个整数，表示队伍的排法的方案数。 </p>
<p>样例输入 3 2</p>
<p>样例输出 5</p>
<p>数据规模和约定 　　m,n∈［0,18］</p>
<p>f(m, n)表示m人还鞋，n人租鞋的情况下排序种数 首先 如果 m &lt; n 还鞋的如果比租鞋的少，那肯定无解 return 0; 其次 如果 n == 0 鞋没人租 那肯定就一个解 全是还鞋的 return 1; 排除了 m &lt; n 和 n == 0 的情况 递推过程如下： f(m, n) -&gt; f(m – 1, n) + f(m, n – 1) -&gt; …- &gt; f(5, 1) + f(4, 2) + f(3, 3) -&gt; f(4, 1) + f(3, 2) -&gt; f(3, 1) + f (2, 2) -&gt; f(2, 1) -&gt; f (1, 1)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f(int m, int n) &#123;</span><br><span class="line">    if (m &lt; n)</span><br><span class="line">        return 0;</span><br><span class="line">    if(n == 0)</span><br><span class="line">        return 1;</span><br><span class="line">    return f(m - 1, n) + f(m, n - 1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; f(m, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>A1102 Invert a Binary Tree </title>
    <url>/2019/03/23/%E8%93%9D%E6%A1%A5%E6%9D%AF-1/</url>
    <content><![CDATA[<p>The following is from Max Howell @twitter:</p>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.<br>Now it’s your turn to prove that YOU CAN invert a binary tree!<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node from 0 to N−1, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space.</p>
<p>Output Specification:<br>For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input:</span><br><span class="line">8</span><br><span class="line">1 -</span><br><span class="line">- -</span><br><span class="line">0 -</span><br><span class="line">2 7</span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line">5 -</span><br><span class="line">4 6</span><br><span class="line">Sample Output:</span><br><span class="line">3 7 2 6 4 0 5 1</span><br><span class="line">6 5 7 4 3 2 0 1</span><br></pre></td></tr></table></figure></p>
<p>题目要求输出反转后的二叉树层序和终须遍历序列</p>
<p><strong>由于给的是节点编号 所以用二叉树的静态写法更方便
</strong><br><strong><br>在后序遍历访问到根节点时 交换它的左右孩子 即可反转二叉树
</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt; </span><br><span class="line">#define MAX 12</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">int N,sum=0,num=0;</span><br><span class="line">int notR[MAX];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">	int left;</span><br><span class="line">	int right;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">node nodes[MAX];</span><br><span class="line">void bfs(int root)&#123;</span><br><span class="line">	queue&lt;int&gt; que;</span><br><span class="line">	que.push(root);</span><br><span class="line">	while(!que.empty())&#123;</span><br><span class="line">		int t=que.front();</span><br><span class="line">		cout&lt;&lt;t;</span><br><span class="line">		que.pop();</span><br><span class="line">		num++;</span><br><span class="line">		if(num&lt;N) cout&lt;&lt;&quot; &quot;;</span><br><span class="line">		if(nodes[t].left!=-1) que.push(nodes[t].left);</span><br><span class="line">		if(nodes[t].right!=-1) que.push(nodes[t].right);		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void porder(int root)&#123;</span><br><span class="line">	if(root==-1) return;</span><br><span class="line">	porder(nodes[root].left);</span><br><span class="line">	porder(nodes[root].right);</span><br><span class="line">	swap(nodes[root].left,nodes[root].right);</span><br><span class="line">&#125; </span><br><span class="line">void inorder(int root)&#123; </span><br><span class="line">	if(root==-1) return;</span><br><span class="line">	inorder(nodes[root].left);</span><br><span class="line">	cout&lt;&lt;root;</span><br><span class="line">	sum++;</span><br><span class="line">	if(sum&lt;N) cout&lt;&lt;&quot; &quot;; </span><br><span class="line">	inorder(nodes[root].right);</span><br><span class="line">&#125;</span><br><span class="line">int strto(char a)&#123;</span><br><span class="line">	if(a==&apos;-&apos;) return -1;</span><br><span class="line">	else &#123;</span><br><span class="line">		int b=a-&apos;0&apos;;</span><br><span class="line">		notR[b]=true;//!</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int findR()&#123;</span><br><span class="line">	int i=-1;</span><br><span class="line">	for(i=0;i&lt;N;i++)&#123;</span><br><span class="line">		if(notR[i]==false)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		char a,b;</span><br><span class="line">		getchar();</span><br><span class="line">		scanf(&quot;%c %c&quot;,&amp;a,&amp;b); </span><br><span class="line">		int l=strto(a);</span><br><span class="line">		int r=strto(b);</span><br><span class="line">		nodes[i].left=l;nodes[i].right=r; </span><br><span class="line">	&#125;</span><br><span class="line">	int root=findR();</span><br><span class="line">	porder(root);</span><br><span class="line">	bfs(root);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	inorder(root);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>A1088/B1034 Rational Arithmetic  </title>
    <url>/2019/03/23/%E8%93%9D%E6%A1%A5%E6%9D%AF-2/</url>
    <content><![CDATA[<p>For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient.<br><a id="more"></a><br>Input Specification:<br>Each input file contains one test case, which gives in one line the two rational numbers in the format  a1/b1 a2/b2. The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers.</p>
<p>Output Specification:<br>For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is number1 operator number2 = result. Notice that all the rational numbers must be in their simplest form k a/b, where k is the integer part, and a/b is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output Inf as the result. It is guaranteed that all the output integers are in the range of long int.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample Input 1:</span><br><span class="line">2/3 -4/2</span><br><span class="line">Sample Output 1:</span><br><span class="line">2/3 + (-2) = (-1 1/3)</span><br><span class="line">2/3 - (-2) = 2 2/3</span><br><span class="line">2/3 * (-2) = (-1 1/3)</span><br><span class="line">2/3 / (-2) = (-1/3)</span><br><span class="line">Sample Input 2:</span><br><span class="line">5/3 0/6</span><br><span class="line">Sample Output 2:</span><br><span class="line">1 2/3 + 0 = 1 2/3</span><br><span class="line">1 2/3 - 0 = 1 2/3</span><br><span class="line">1 2/3 * 0 = 0</span><br><span class="line">1 2/3 / 0 = Inf</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">struct fract&#123;</span><br><span class="line">	ll a,b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int n;</span><br><span class="line">ll gcd(ll a,ll b)&#123;</span><br><span class="line">	if(a%b==0) return b;</span><br><span class="line">	gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fract redu(fract m)&#123;</span><br><span class="line">	fract res;</span><br><span class="line">	if(m.b&lt;0)&#123;</span><br><span class="line">		m.b=-m.b;</span><br><span class="line">		m.a=-m.a;</span><br><span class="line">	&#125; </span><br><span class="line">	if(m.b==0) &#123;</span><br><span class="line">		fract tmp;</span><br><span class="line">		tmp.b=0;</span><br><span class="line">		tmp.a=1;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	ll g=gcd(abs(m.a),abs(m.b));</span><br><span class="line">	res.a=m.a/g;</span><br><span class="line">	res.b=m.b/g;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">fract add(fract m,fract n)&#123;</span><br><span class="line">	fract res;</span><br><span class="line">	res.b=m.b*n.b;</span><br><span class="line">	res.a=m.a*n.b+n.a*m.b;</span><br><span class="line">	return redu(res); </span><br><span class="line">&#125;</span><br><span class="line">fract min(fract m,fract n)&#123;</span><br><span class="line">	fract res;</span><br><span class="line">	res.b=m.b*n.b;</span><br><span class="line">	res.a=m.a*n.b-n.a*m.b;</span><br><span class="line">	return redu(res); </span><br><span class="line">&#125;</span><br><span class="line">fract chen(fract m,fract n)&#123;</span><br><span class="line">	fract res;</span><br><span class="line">	res.b=m.b*n.b;</span><br><span class="line">	res.a=m.a*n.a;</span><br><span class="line">	return redu(res); </span><br><span class="line">&#125;</span><br><span class="line">fract chu(fract m,fract n)&#123;</span><br><span class="line">	fract res;</span><br><span class="line">		res.a=m.a*n.b;</span><br><span class="line">	res.b=m.b*n.a;</span><br><span class="line"></span><br><span class="line">	return redu(res); </span><br><span class="line">&#125;</span><br><span class="line">void show(fract ff)&#123;</span><br><span class="line">	ff=redu(ff);</span><br><span class="line">	if(ff.a&lt;0) cout&lt;&lt;&quot;(&quot;; </span><br><span class="line">	if(ff.b==1) &#123;</span><br><span class="line">	printf(&quot;%lld&quot;,ff.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else if(abs(ff.a)&gt;ff.b)&#123;</span><br><span class="line">	printf(&quot;%lld %lld/%lld&quot;,ff.a/ff.b,abs(ff.a)%ff.b,ff.b);</span><br><span class="line">&#125;</span><br><span class="line">else 	printf(&quot;%lld/%lld&quot;,ff.a,ff.b);</span><br><span class="line">if(ff.a&lt;0) cout&lt;&lt;&quot;)&quot;; </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	fract sum1,sum2,sum3,sum4,f,g;</span><br><span class="line">		scanf(&quot;%lld/%lld %lld/%lld&quot;,&amp;f.a,&amp;f.b,&amp;g.a,&amp;g.b);</span><br><span class="line">		sum1=add(f,g);</span><br><span class="line">		sum2=min(f,g);</span><br><span class="line">		sum3=chen(f,g);</span><br><span class="line">	</span><br><span class="line">		show(f);</span><br><span class="line">		cout&lt;&lt;&quot; + &quot;;</span><br><span class="line">		show(g);</span><br><span class="line">		cout&lt;&lt;&quot; = &quot;;</span><br><span class="line">		show(sum1);</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">		show(f);</span><br><span class="line">		cout&lt;&lt;&quot; - &quot;;</span><br><span class="line">		show(g);</span><br><span class="line">			cout&lt;&lt;&quot; = &quot;;</span><br><span class="line">		show(sum2);</span><br><span class="line">		cout&lt;&lt;endl;	</span><br><span class="line">		</span><br><span class="line">		show(f);</span><br><span class="line">		cout&lt;&lt;&quot; * &quot;;</span><br><span class="line">		show(g);	cout&lt;&lt;&quot; = &quot;;</span><br><span class="line">		show(sum3);</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		show(f);</span><br><span class="line">		cout&lt;&lt;&quot; / &quot;;</span><br><span class="line">		show(g);	cout&lt;&lt;&quot; = &quot;;</span><br><span class="line">		if(g.a==0) &#123;</span><br><span class="line">		cout&lt;&lt;&quot;Inf&quot;&lt;&lt;endl; </span><br><span class="line">		&#125;</span><br><span class="line">		else 	show(chu(f,g));	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯 全球变暖</title>
    <url>/2019/03/21/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdn.net/20180402152629874" alt="image"><br><a id="more"></a><br>注意读题</p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX 1000 </span><br><span class="line">using namespace std;</span><br><span class="line">bool vis[MAX][MAX];</span><br><span class="line">char g[MAX][MAX],tmp[MAX][MAX];</span><br><span class="line">int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int n;</span><br><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line">	if(vis[x][y]||x&lt;0||x&gt;n||y&lt;0||y&gt;n)&#123;</span><br><span class="line">		return ;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	vis[x][y]=true;</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int newx=x+dir[i][0];</span><br><span class="line">		int newy=y+dir[i][1];</span><br><span class="line">		if(vis[newx][newy]) continue;</span><br><span class="line">		if(g[x][y]==&apos;#&apos;&amp;&amp;g[newx][newy]==&apos;.&apos;)&#123;</span><br><span class="line">				g[x][y]=&apos;.&apos;;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		if(g[newx][newy]==&apos;#&apos;)</span><br><span class="line">		&#123;</span><br><span class="line">			dfs(newx,newy);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	freopen(&quot;3-21.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	int num=0,num2=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;g[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			if(!vis[i][j]&amp;&amp;g[i][j]==&apos;#&apos;)&#123;</span><br><span class="line">					</span><br><span class="line">				dfs(i,j); </span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">			for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">			if(!vis[i][j]&amp;&amp;g[i][j]==&apos;#&apos;)&#123;</span><br><span class="line">				num2++;</span><br><span class="line">				dfs(i,j); </span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//	cout&lt;&lt;num&lt;&lt;&quot; &quot;&lt;&lt;num2&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;num1-num2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>1 如何判断有几个岛屿？想用dfs判断，做多遍dfs。这个思路是对的，其实我们用两个for循环搜索第一个未被访问过的#, 做dfs就好。</p>
<p>2 怎么把每个岛屿记录下来？之后判断岛屿是否会被全部淹没。但是其实这个过程我们可以在找岛屿的过程中就进行判断，判断在该岛屿中是否存在一个点#,它的四周都是#</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int mp[110][110];</span><br><span class="line">int ans[11000];</span><br><span class="line">bool vis[110][110];</span><br><span class="line">void dfs(int x,int y,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(mp[x][y]==&apos;.&apos;)</span><br><span class="line">        return;</span><br><span class="line">    if(vis[x][y])</span><br><span class="line">        return;</span><br><span class="line">    vis[x][y]=1;</span><br><span class="line">    if(mp[x-1][y]==&apos;#&apos;&amp;&amp;mp[x+1][y]==&apos;#&apos;&amp;&amp;mp[x][y-1]==&apos;#&apos;&amp;&amp;mp[x][y+1]==&apos;#&apos;)</span><br><span class="line">        ans[k]++;</span><br><span class="line">    dfs(x+1,y,k);</span><br><span class="line">    dfs(x-1,y,k);</span><br><span class="line">    dfs(x,y-1,k);</span><br><span class="line">    dfs(x,y+1,k);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            scanf(&quot;%c&quot;,&amp;mp[i][j]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    int len=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(mp[i][j]==&apos;#&apos;&amp;&amp;!vis[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i,j,len);</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int i=0;i&lt;len;i++)</span><br><span class="line">        if(ans[i]==0)</span><br><span class="line">            sum++;</span><br><span class="line">    printf(&quot;%d\n&quot;,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法三"><a href="#法三" class="headerlink" title="法三"></a>法三</h2><p>用bfs去求出一共有多少个岛，再求出有多少个岛不会被完全淹没，然后相减就是会被完全淹没的个数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define maxn 1005</span><br><span class="line">using namespace std;</span><br><span class="line">struct Node&#123;</span><br><span class="line">  int x,y;</span><br><span class="line">&#125;S,Next, Now;</span><br><span class="line">int dir[4][2] = &#123;1,0, 0,1, -1,0, 0,-1&#125;;</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">string str[maxn];</span><br><span class="line">int n,m;</span><br><span class="line">bool flag;</span><br><span class="line"> </span><br><span class="line">bool Check(int x,int y)&#123;</span><br><span class="line">  for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">    int X = x + dir[i][0];</span><br><span class="line">    int Y = y + dir[i][1];</span><br><span class="line">    if(str[X][Y] == &apos;.&apos;) return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool in(int x,int y)&#123;</span><br><span class="line">  if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; str[x][y] == &apos;#&apos; &amp;&amp; vis[x][y] == false) return true;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void bfs(int x,int y)&#123;</span><br><span class="line">  queue&lt;Node&gt; q;</span><br><span class="line">  S.x = x;</span><br><span class="line">  S.y = y;</span><br><span class="line">  q.push(S);</span><br><span class="line">  while(!q.empty())&#123;</span><br><span class="line">    Now = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    if(Check(Now.x, Now.y))&#123;</span><br><span class="line">      flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">      Next.x = Now.x + dir[i][0];</span><br><span class="line">      Next.y = Now.y + dir[i][1];</span><br><span class="line">      if(in(Next.x, Next.y))&#123;</span><br><span class="line">        vis[Next.x][Next.y] = true;</span><br><span class="line">        q.push(Next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">  for(int i=0;i&lt;n;i++) cin&gt;&gt;str[i];</span><br><span class="line">  memset(vis,false,sizeof(vis));</span><br><span class="line">  int ans = 0, cnt = 0;</span><br><span class="line">  for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">    for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">      if(str[i][j] == &apos;#&apos; &amp;&amp; vis[i][j] == false)&#123;</span><br><span class="line">        flag = false;</span><br><span class="line">        bfs(i, j);</span><br><span class="line">        ans ++;</span><br><span class="line">        if(flag == true) cnt ++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%d\n&quot;, ans - cnt);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="https://blog.csdn.net/charles_zaqdt/article/details/79786821" target="_blank" rel="noopener">https://blog.csdn.net/charles_zaqdt/article/details/79786821</a><br><a href="https://www.cnblogs.com/wkfvawl/p/10547467.html" target="_blank" rel="noopener">https://www.cnblogs.com/wkfvawl/p/10547467.html</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯 国王的烦恼</title>
    <url>/2019/03/16/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC/</url>
    <content><![CDATA[<p>问题描述<br>　　C国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然而，由于海水冲刷，有一些大桥面临着不能使用的危险。<br><a id="more"></a><br>　　如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。</p>
<p>　　现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。<br>输入格式<br>　　输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。<br>　　接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。<br>输出格式<br>　　输出一个整数，表示居民们会抗议的天数。<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入</span><br><span class="line">4 4</span><br><span class="line">1 2 2</span><br><span class="line">1 3 2</span><br><span class="line">2 3 1</span><br><span class="line">3 4 3</span><br><span class="line">样例输出</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">样例说明</span><br><span class="line">　　第一天后2和3之间的桥不能使用，不影响。</span><br><span class="line">　　第二天后1和2之间，以及1和3之间的桥不能使用，居民们会抗议。</span><br><span class="line">　　第三天后3和4之间的桥不能使用，居民们会抗议。</span><br><span class="line">数据规模和约定</span><br><span class="line">　　对于30%的数据，1&lt;=n&lt;=20，1&lt;=m&lt;=100；</span><br><span class="line">　　对于50%的数据，1&lt;=n&lt;=500，1&lt;=m&lt;=10000；</span><br><span class="line">　　对于100%的数据，1&lt;=n&lt;=10000，1&lt;=m&lt;=100000，1&lt;=a, b&lt;=n， 1&lt;=t&lt;=100000。</span><br></pre></td></tr></table></figure></p>
<p><strong>题目最终转化为了求连通分支的数目，但是因为随这时间是要不断查找的，如果出现了一次时间就查找一次的话，并查集好像没有这么强大，并且时间也是不允许的，所以我们巧妙的转化一下，转化为按照时间的从后向前的顺序重新建一遍树，这样相当于逆向的把树重新建了一遍，成功的在一次遍历的时候就完成了建树过程，逆向完成</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#define MAX 1000005</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">struct bridge&#123;</span><br><span class="line">	int a,b,t;</span><br><span class="line">	bridge(int aa,int bb,int tt):a(aa),b(bb),t(tt)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	bridge()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class unionset&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">    vector&lt;int&gt; rank;</span><br><span class="line">	</span><br><span class="line">    unionset(int n)&#123;</span><br><span class="line">    parent=vector&lt;int&gt;(n+1,0);</span><br><span class="line">    rank=vector&lt;int&gt;(n+1,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">	parent[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bool Union(int u1,int u2)&#123;</span><br><span class="line">		int p1=find(u1);</span><br><span class="line">		int p2=find(u2);</span><br><span class="line">		if(p1==p2) return false;</span><br><span class="line">		if(rank[p1]&gt;rank[p2])&#123;</span><br><span class="line">			parent[p2]=p1;</span><br><span class="line">		&#125;</span><br><span class="line">        else if(rank[p2]&gt;rank[p1])&#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">            rank[p2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    int find(int num)&#123;</span><br><span class="line">        if(num!=parent[num])&#123;</span><br><span class="line">            parent[num]=find(parent[num]);//find(num)一直自己调用自己 错的 find(parent[num]) 往上回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[num];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(bridge b1,bridge b2)&#123;</span><br><span class="line">	return b1.t&gt;b2.t;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	unionset u(n);</span><br><span class="line">	bridge br[m];</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		int a,b,c;</span><br><span class="line">		cin&gt;&gt;br[i].a&gt;&gt;br[i].b&gt;&gt;br[i].t;</span><br><span class="line">	&#125;</span><br><span class="line">	int sum=0;</span><br><span class="line">	sort(br,br+m,cmp);</span><br><span class="line">	//天数可能是相等 </span><br><span class="line">	int last=-1;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		if(u.Union(br[i].a,br[i].b)&amp;&amp;br[i].t!=last) &#123;</span><br><span class="line">				sum++;		</span><br><span class="line">						last=br[i].t;	</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误代码<br>忽略排完序后<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#define MAX 1000005</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">struct bridge&#123;</span><br><span class="line">	int a,b,t;</span><br><span class="line">	bridge(int aa,int bb,int tt):a(aa),b(bb),t(tt)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	bridge()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class unionset&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">    vector&lt;int&gt; rank;</span><br><span class="line">	</span><br><span class="line">    unionset(int n)&#123;</span><br><span class="line">    parent=vector&lt;int&gt;(n+1,0);</span><br><span class="line">    rank=vector&lt;int&gt;(n+1,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">	parent[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bool Union(int u1,int u2)&#123;</span><br><span class="line">		int p1=find(u1);</span><br><span class="line">		int p2=find(u2);</span><br><span class="line">		if(p1==p2) return false;</span><br><span class="line">		if(rank[p1]&gt;rank[p2])&#123;</span><br><span class="line">			parent[p2]=p1;</span><br><span class="line">		&#125;</span><br><span class="line">        else if(rank[p2]&gt;rank[p1])&#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            parent[p1]=p2;</span><br><span class="line">            rank[p2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    int find(int num)&#123;</span><br><span class="line">        if(num!=parent[num])&#123;</span><br><span class="line">            parent[num]=find(parent[num]);//find(num)一直自己调用自己 错的 find(parent[num]) 往上回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[num];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(bridge b1,bridge b2)&#123;</span><br><span class="line">	return b1.t&gt;b2.t;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	unionset u(n);</span><br><span class="line">	bridge br[m];</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		int a,b,c;</span><br><span class="line">		cin&gt;&gt;br[i].a&gt;&gt;br[i].b&gt;&gt;br[i].t;</span><br><span class="line">	&#125;</span><br><span class="line">	int sum=0;</span><br><span class="line">	sort(br,br+m,cmp);</span><br><span class="line">	//天数可能是相等 </span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		int f1=u.find(br[i].a);</span><br><span class="line">		int f2=u.find(br[i].b);</span><br><span class="line">		cout&lt;&lt;f1&lt;&lt;&quot; &quot;&lt;&lt;f2&lt;&lt;endl;; </span><br><span class="line">		if(f1!=f2) &#123;</span><br><span class="line">				sum++;</span><br><span class="line">				u.Union(f1,f2);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考链接<br><a href="https://blog.csdn.net/u014665013/article/details/45498425" target="_blank" rel="noopener">https://blog.csdn.net/u014665013/article/details/45498425</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯 日期问题</title>
    <url>/2019/03/22/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>标题：日期问题</p>
<p>小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。<br> <a id="more"></a><br>比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。  </p>
<p>给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>一个日期，格式是”AA/BB/CC”。  (0 &lt;= A, B, C &lt;= 9)  </p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。多个日期按从早到晚排列。  </p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>02/03/04  </p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>2002-03-04<br>2004-02-03<br>2004-03-02  </p>
<p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 1000ms</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//读懂题 a,b,c 日月年 月日年 年月日  </span><br><span class="line">int month[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; </span><br><span class="line">struct date&#123;</span><br><span class="line">	int y,m,d;</span><br><span class="line">	date(int yy,int mm,int dd):y(yy),m(mm),d(dd)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	date()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	void print()const&#123;</span><br><span class="line">		printf(&quot;%d-%02d-%02d\n&quot;,y,m,d);</span><br><span class="line">	&#125;</span><br><span class="line">	 bool operator &lt;(date other) const&#123;</span><br><span class="line">	 </span><br><span class="line">	 if(y==other.y)&#123;</span><br><span class="line">	 	if(m==other.m) return d&lt;other.d;</span><br><span class="line">	 	return m&lt;other.m;</span><br><span class="line">	 &#125;</span><br><span class="line">	 return y&lt;other.y;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;date&gt; dict;</span><br><span class="line">bool valid(date datte)&#123;</span><br><span class="line">	if(datte.y&lt;1960||datte.y&gt;2059) return false; </span><br><span class="line">	if(datte.m&lt;=0||datte.m&gt;12) return false;</span><br><span class="line">	if(datte.y%400==0||(datte.y%4==0&amp;&amp;datte.y%100!=0))&#123;</span><br><span class="line">	month[1]=29;	</span><br><span class="line">	&#125;</span><br><span class="line">	if(datte.d&lt;=0&amp;&amp;datte.d&gt;month[datte.m-1])</span><br><span class="line">	return false;</span><br><span class="line">	return true;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void insert(int a,int b,int c )&#123;</span><br><span class="line">	date obj(a,b,c);</span><br><span class="line">	if(valid(obj)) dict.insert(obj);//插入到set 结构体需要有operator &lt;比较 才知道怎么插入 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int a,b,c;</span><br><span class="line">	scanf(&quot;%d/%d/%d&quot;,a,b,c);</span><br><span class="line">	insert(1900+a,b,c);</span><br><span class="line">	insert(2000+a,b,c);</span><br><span class="line">	insert(1900+c,a,b);</span><br><span class="line">	insert(2000+c,a,b);</span><br><span class="line">	insert(1900+c,b,a);</span><br><span class="line">	insert(2000+c,b,a);	</span><br><span class="line">	for(set&lt;date&gt;::iterator it=dict.begin();it!=dict.end();it++)</span><br><span class="line">	&#123;</span><br><span class="line">//		printf(&quot;%d-%02d-%02d\n&quot;,it) 要在结构体内定义 才能遍历 </span><br><span class="line">		it-&gt;print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>蓝桥杯 方格分割</title>
    <url>/2019/03/22/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%96%B9%E6%A0%BC%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<p>标题：方格分割</p>
<p>6x6的方格，沿着格子的边线剪开成两部分。<br>要求这两部分的形状完全相同。</p>
<p>如图：p1.png, p2.png, p3.png 就是可行的分割法。<br> <a id="more"></a></p>
<p>试计算：<br>包括这3种分法在内，一共有多少种不同的分割方法。<br>注意：旋转对称的属于同一种分割法。</p>
<p>请提交该整数，不要填写任何多余的内容或说明文字。</p>
<p><img src="https://img-blog.csdn.net/20170408190907661?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveTExOTY2NDUzNzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>vis[x][y] 并不是指这个方块是否访问<br>而是指坐标点 线与线的交点是否被访问过（因为一个个点连起来才成了线 分割线）<br>所以要vis[n+1][n+1]</p>
<p>从中心点坐标（3,3）向两边dfs一个中心对称的路径，这里搜的是方格的边线而不是方格，因为dfs只能搜索连续的。搜索结束的标志是搜到大方块的边界即：x = 0||x = 6||y = 0||y = 6，因为如果向上下左右的路径形状是一样的的话，就重复了所以搜索结果再除以4即是最终答案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int n=6;</span><br><span class="line">bool vis[10][10];</span><br><span class="line">int dir[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int cnt=0;</span><br><span class="line">void dfs(int x,int y) &#123;</span><br><span class="line">	if(x==0||x==n||y==0||y==n) &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		int newx=x+dir[i][0];</span><br><span class="line">		int newy=y+dir[i][1];</span><br><span class="line">		if(!vis[newx][newy]&amp;&amp;newx&gt;=0&amp;&amp;newx&lt;=6&amp;&amp;newy&gt;=0&amp;&amp;newy&lt;=6)&#123;</span><br><span class="line">			vis[newx][newy]=true;</span><br><span class="line">			vis[n-newx][n-newy]=true;</span><br><span class="line">		dfs(newx,newy);</span><br><span class="line">		vis[newx][newy]=false;</span><br><span class="line">			vis[n-newx][n-newy]=false;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vis[3][3]=true;</span><br><span class="line">	dfs(3,3);</span><br><span class="line">	cout&lt;&lt;cnt/4&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯 生日蜡烛</title>
    <url>/2019/03/22/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%94%9F%E6%97%A5%E8%9C%A1%E7%83%9B/</url>
    <content><![CDATA[<p>某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。</p>
<p>现在算起来，他一共吹熄了236根蜡烛。</p>
<p>请问，他从多少岁开始过生日party的？</p>
<p>请填写他开始过生日party的年龄数。<br>注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p>
<p>呵呵，水题，但是出题人不严谨啊！！！怎么就不能考虑万一他今年236岁呢….好了不说了强迫症犯了。</p>
<p>蓝桥杯这种不像acm的题目的,能暴力直接暴力</p>
<p>break 只能跳出一个循环 可以考虑用flag 跳出外层所有循环<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 100000</span><br><span class="line">int num[MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int ans=0,i,j;</span><br><span class="line">	bool flag=false;</span><br><span class="line">	for(i=1;i&lt;=236&amp;&amp;!flag;i++)&#123;</span><br><span class="line">		for(j=i;j&lt;=236&amp;&amp;!flag;j++)&#123;</span><br><span class="line">			</span><br><span class="line">			int sum=0;</span><br><span class="line">			for(int k=i;k&lt;=j&amp;&amp;!flag;k++)</span><br><span class="line">				sum+=k;</span><br><span class="line">			if(sum==236) &#123;flag=true;</span><br><span class="line">			ans=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int start,end;</span><br><span class="line">	for(start = 1 ; start &lt; 236 ; start ++)</span><br><span class="line">	&#123;</span><br><span class="line">		for( end = start ; end &lt; 236 ; end ++ )</span><br><span class="line">		&#123;</span><br><span class="line">			int sum = 0;</span><br><span class="line">			for(int i = start; i &lt;= end; i ++)</span><br><span class="line">				sum += i;</span><br><span class="line">			if( sum == 236)</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;start : %d end : %d\n&quot;,start,end);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯 购物单</title>
    <url>/2019/03/21/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E8%B4%AD%E7%89%A9%E5%8D%95/</url>
    <content><![CDATA[<p>标题： 购物单<br>    小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。<br>    这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。<br>    <a id="more"></a><br>    小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。<br>    现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。<br>    取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。<br>    你的任务是计算出，小明最少需要取多少现金。<br>以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------</span><br><span class="line">****     180.90       88折</span><br><span class="line">****      10.25       65折</span><br><span class="line">****      56.14        9折</span><br><span class="line">****     104.65        9折</span><br><span class="line">****     100.30       88折</span><br><span class="line">****     297.15        半价</span><br><span class="line">****      26.75       65折</span><br><span class="line">****     130.62        半价</span><br><span class="line">****     240.28       58折</span><br><span class="line">****     270.62        8折</span><br><span class="line">****     115.87       88折</span><br><span class="line">****     247.34       95折</span><br><span class="line">****      73.21        9折</span><br><span class="line">****     101.00        半价</span><br><span class="line">****      79.54        半价</span><br><span class="line">****     278.44        7折</span><br><span class="line">****     199.26        半价</span><br><span class="line">****      12.97        9折</span><br><span class="line">****     166.30       78折</span><br><span class="line">****     125.50       58折</span><br><span class="line">****      84.98        9折</span><br><span class="line">****     113.35       68折</span><br><span class="line">****     166.57        半价</span><br><span class="line">****      42.56        9折</span><br><span class="line">****      81.90       95折</span><br><span class="line">****     131.78        8折</span><br><span class="line">****     255.89       78折</span><br><span class="line">****     109.17        9折</span><br><span class="line">****     146.69       68折</span><br><span class="line">****     139.33       65折</span><br><span class="line">****     141.16       78折</span><br><span class="line">****     154.74        8折</span><br><span class="line">****      59.42        8折</span><br><span class="line">****      85.44       68折</span><br><span class="line">****     293.70       88折</span><br><span class="line">****     261.79       65折</span><br><span class="line">****      11.30       88折</span><br><span class="line">****     268.27       58折</span><br><span class="line">****     128.29       88折</span><br><span class="line">****     251.03        8折</span><br><span class="line">****     208.39       75折</span><br><span class="line">****     128.88       75折</span><br><span class="line">****      62.06        9折</span><br><span class="line">****     225.87       75折</span><br><span class="line">****      12.89       75折</span><br><span class="line">****      34.28       75折</span><br><span class="line">****      62.16       58折</span><br><span class="line">****     129.12        半价</span><br><span class="line">****     218.37        半价</span><br><span class="line">****     289.69        8折</span><br><span class="line">--------------------</span><br></pre></td></tr></table></figure></p>
<p>需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。<br>特别地，半价是按50%计算。<br>请提交小明要从取款机上提取的金额，单位是元。<br>答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。</p>
<p>将清单复制到txt文本里面，利用Ctrl+H替换掉**这些字符和折扣。预处理好数据之后用代码计算即可！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;DATA.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    double ans = 0,a,b;</span><br><span class="line">    char buf[1110];</span><br><span class="line">    while(scanf(&quot;%s%lf%lf&quot;,buf,&amp;a,&amp;b)!=EOF)&#123;</span><br><span class="line">        ans += a*b/100;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lf\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//5136.859500</span><br><span class="line">//5200</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define maxn 1005</span><br><span class="line">using namespace std;</span><br><span class="line">int strtoint(string s)&#123;</span><br><span class="line">	int a=1,ans=0;</span><br><span class="line">	for(int i=s.length()-1;i&gt;=0;i--)&#123;</span><br><span class="line">		ans+=(s[i]-&apos;0&apos;)*a;</span><br><span class="line">		a*=10;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">double process(string s3)&#123;</span><br><span class="line">	int pos=s3.find(&quot;.&quot;);</span><br><span class="line">	string s1=s3.substr(0,pos);</span><br><span class="line">	string s2=s3.substr(pos+1);</span><br><span class="line">	int a1=strtoint(s1),b=strtoint(s2);</span><br><span class="line">	double t=a1+b*1.0/100;</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	double sum=0;</span><br><span class="line">	for(int i=1;i&lt;=50;i++)&#123;</span><br><span class="line">		string s1,s2,s3;</span><br><span class="line">		int pos,zhe;</span><br><span class="line">		cin&gt;&gt;s1&gt;&gt;s3&gt;&gt;s2;</span><br><span class="line">		cout&lt;&lt;s1&lt;&lt;&quot;  &quot;&lt;&lt;s3&lt;&lt;&quot; &quot;&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">		double value=process(s3);</span><br><span class="line">		if((pos=s2.find(&quot;折&quot;))!=-1)&#123;</span><br><span class="line">			s2=s2.substr(0,pos);</span><br><span class="line">		zhe=strtoint(s2);</span><br><span class="line">			if(zhe&lt;10) zhe*=10;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s2==&quot;半价&quot;)&#123;</span><br><span class="line">			zhe=50;</span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;value&lt;&lt;&quot; &quot;&lt;&lt;zhe&lt;&lt;endl;</span><br><span class="line">		double tmp=value*zhe*1.0/100;</span><br><span class="line">	sum+=tmp;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;//结果为5136.86 因为只能带100整张--- 5200 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	double m=0;</span><br><span class="line">	m=180.90*0.88+10.25*0.65+56.14*0.9+104.65*0.9+100.3*0.88+297.15*0.5+26.75*0.65+130.62*0.5+240.28*0.58+270.62*0.8+115.87*0.88+</span><br><span class="line">	247.34*0.95+73.21*0.9+101*0.5+79.54*0.5+278.44*0.7+199.26*0.5+12.97*0.9+166.30*0.78+125.50*0.58+</span><br><span class="line">	84.98*0.9+113.35*0.68+166.57*0.5+42.56*0.9+81.90*0.95+131.78*0.8+255.89*0.78+109.17*0.9+146.69*0.68+</span><br><span class="line">139.33*0.65+141.16*0.78+154.74*0.8+59.42*0.8+85.44*0.68+293.70*0.88+261.79*0.65+11.30*0.88+268.27*0.58+</span><br><span class="line">128.29*0.88+251.03*0.8+208.39*0.75+128.88*0.75+62.06*0.9+225.87*0.75+12.89*0.75+34.28*0.75+62.16*0.58+129.12*0.5+</span><br><span class="line">218.37*0.5+289.69*0.8;</span><br><span class="line">	printf(&quot;%lf\n&quot;,m);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯算法训练 P0505</title>
    <url>/2019/02/23/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E8%AE%AD%E7%BB%83-P0505/</url>
    <content><![CDATA[<p>一个整数n的阶乘可以写成n!，它表示从1到n这n个整数的乘积。阶乘的增长速度非常快，例如，13！就已经比较大了，已经无法存放在一个整型变量中；而35！就更大了，它已经无法存放在一个浮点型变量中。因此，当n比较大时，去计算n!是非常困难的。幸运的是，在本题中，我们的任务不是去计算n!，而是去计算n!最右边的那个非0的数字是多少。例如，5！=1<em>2</em>3<em>4</em>5=120，因此5!最右边的那个非0的数字是2。再如，7！=5040，因此7！最右边的那个非0的数字是4。再如，15！= 1307674368000，因此15！最右边的那个非0的数字是8。请编写一个程序，输入一个整数n(0&lt;n&lt;=100)，然后输出n!最右边的那个非0的数字是多少。<br><a id="more"></a><br>输入：<br>　　7</p>
<p>输出：<br>　　4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	long long sum=1;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n); </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		sum*=i;</span><br><span class="line">	while(sum%10==0) &#123;</span><br><span class="line">			sum/=10;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		sum%=1000000000;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum%10&lt;&lt;endl;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
  </entry>
  <entry>
    <title>兰顿蚂蚁 蓝桥杯</title>
    <url>/2018/12/20/%E8%93%9D%E7%9B%BE%E8%9A%82%E8%9A%81/</url>
    <content><![CDATA[<p>兰顿蚂蚁，是于1986年，由克里斯·兰顿提出来的，属于细胞自动机的一种。<br><a id="more"></a><br>　　平面上的正方形格子被填上黑色或白色。在其中一格正方形内有一只“蚂蚁”。<br>　　蚂蚁的头部朝向为：上下左右其中一方。</p>
<p>　　蚂蚁的移动规则十分简单：<br>　　若蚂蚁在黑格，右转90度，将该格改为白格，并向前移一格；<br>　　若蚂蚁在白格，左转90度，将该格改为黑格，并向前移一格。</p>
<p>　　规则虽然简单，蚂蚁的行为却十分复杂。刚刚开始时留下的路线都会有接近对称，像是会重复，但不论起始状态如何，蚂蚁经过漫长的混乱活动后，会开辟出一条规则的“高速公路”。</p>
<p>　　蚂蚁的路线是很难事先预测的。</p>
<p>　　你的任务是根据初始状态，用计算机模拟兰顿蚂蚁在第n步行走后所处的位置。<br>输入格式<br>　　输入数据的第一行是 m n 两个整数（3 &lt; m, n &lt; 100），表示正方形格子的行数和列数。<br>　　接下来是 m 行数据。<br>　　每行数据为 n 个被空格分开的数字。0 表示白格，1 表示黑格。</p>
<p>　　接下来是一行数据：x y s k, 其中x y为整数，表示蚂蚁所在行号和列号（行号从上到下增长，列号从左到右增长，都是从0开始编号）。s 是一个大写字母，表示蚂蚁头的朝向，我们约定：上下左右分别用：UDLR表示。k 表示蚂蚁走的步数。</p>
<p>输出格式</p>
<p>输出数据为两个空格分开的整数 p q, 分别表示蚂蚁在k步后，所处格子的行号和列号。</p>
<p>样例输入</p>
<p>5 6</p>
<p>0 0 0 0 0 0</p>
<p>0 0 0 0 0 0</p>
<p>0 0 1 0 0 0</p>
<p>0 0 0 0 0 0</p>
<p>0 0 0 0 0 0</p>
<p>2 3 L 5</p>
<p>样例输出</p>
<p>1 3</p>
<p>样例输入</p>
<p>3 3</p>
<p>0 0 0</p>
<p>1 1 1</p>
<p>1 1 1</p>
<p>1 1 U 6</p>
<p>样例输出</p>
<p>0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int grid[100][100];</span><br><span class="line">	int m,n;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y,f;</span><br><span class="line">	char dir;</span><br><span class="line">	node(int xx,int yy,int ff,char dd):x(xx),y(yy),f(ff),dir(dd)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">void fun(char c,int x,int y,int &amp;nx,int &amp;ny)&#123;</span><br><span class="line">	switch(c)&#123;</span><br><span class="line">		case &apos;U&apos;:&#123;</span><br><span class="line">			nx=(x-1+m)%m;</span><br><span class="line">			ny=y;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		case &apos;D&apos;:&#123;</span><br><span class="line">			nx=(x+1)%m;</span><br><span class="line">			ny=y;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		case &apos;L&apos;:&#123;</span><br><span class="line">			nx=x;</span><br><span class="line">			ny=(y-1+n)%n;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		case &apos;R&apos;:&#123;</span><br><span class="line">			nx=x;</span><br><span class="line">			ny=(y+1)%n;</span><br><span class="line">			break;</span><br><span class="line">		&#125;		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int x,y,k;</span><br><span class="line">	char s;</span><br><span class="line">	string sdir=&quot;URDL&quot;;</span><br><span class="line">	string ndir=&quot;ULDR&quot;;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;n;j++)</span><br><span class="line">		cin&gt;&gt;grid[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;y&gt;&gt;s&gt;&gt;k;</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	q.push(node(x,y,grid[x][y],s));</span><br><span class="line">	int step=0;</span><br><span class="line">		int nx,ny;</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		node t=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		if(step==k)&#123;</span><br><span class="line">			cout&lt;&lt;t.x&lt;&lt;&quot; &quot;&lt;&lt;t.y&lt;&lt;endl;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(grid[t.x][t.y])&#123;</span><br><span class="line">			char s=t.dir;</span><br><span class="line">			grid[t.x][t.y]=0;</span><br><span class="line">			char fang=sdir[(sdir.find(s)+1)%4];</span><br><span class="line">				fun(fang,t.x,t.y,nx,ny);</span><br><span class="line">				q.push(node(nx,ny,grid[nx][ny],fang));</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			char s=t.dir;</span><br><span class="line">			grid[t.x][t.y]=1;</span><br><span class="line">		</span><br><span class="line">			char fang=ndir[(ndir.find(s)+1)%4];</span><br><span class="line">				fun(fang,t.x,t.y,nx,ny);</span><br><span class="line">				q.push(node(nx,ny,grid[nx][ny],fang));	</span><br><span class="line">		&#125;</span><br><span class="line">		step++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考博客<br><a href="https://blog.csdn.net/hurmishine/article/details/60477275" target="_blank" rel="noopener">https://blog.csdn.net/hurmishine/article/details/60477275</a><br><a href="https://blog.csdn.net/wr132/article/details/43770473" target="_blank" rel="noopener">https://blog.csdn.net/wr132/article/details/43770473</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>基于caffe的表情识别</title>
    <url>/2018/05/23/%E8%A1%A8%E6%83%85%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>跟着别人的博客跑了遍流程，准确率0.61，不算很好，但是也是大概跑个流程，感觉开心的表情识别较好，感觉调参这块还是得自己多实践。</p>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>采用的数据集是fer2013人脸表情数据集。fer2013，即Kaggle facial expression recognition challenge dataset，是目前较大的人脸表情识别公开数据库。<br>  <a id="more"></a><br>  该数据库共包含35887张人脸图片，其中训练集28709张、验证集3589张、测试集3589张。数据库中的图片均为灰度图片，大小为48*48像素，样本被分为0=anger(生气)、1=disgust(厌恶)、2=fear(恐惧)、3=happy(开心)、4=sad(伤心)、5=surprised(惊讶)、6=normal(中性)七类，各种类型分布基本均匀。</p>
<p>  数据分布（训练集）：angry：3995 、disgust：436 、fear：4097 、happy：7215 、sad：4830 、surprise：3171 、normal：4965 </p>
<p>下载数据集:<a href="https://pan.baidu.com/s/1i6p40jb" target="_blank" rel="noopener">https://pan.baidu.com/s/1i6p40jb</a></p>
<p>1）准备labels.txt文件，表示分类序号于分类对应关系<br>    在data目录下创建一个空白文档，取名为labels.txt，并输入下面内容：</p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1frlnez3gb4j30co07stac.jpg" alt="image"></p>
<p>2）准备train.txt，标明训练图片路径及其对应分类，路径和分类序号直接用空格分隔<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls train/0 | sed &quot;s:^:0/:&quot; | sed &quot;s:$: 0:&quot; &gt;&gt; train.txt  </span><br><span class="line">ls train/1 | sed &quot;s:^:1/:&quot; | sed &quot;s:$: 1:&quot; &gt;&gt; train.txt  </span><br><span class="line">ls train/2 | sed &quot;s:^:2/:&quot; | sed &quot;s:$: 2:&quot; &gt;&gt; train.txt  </span><br><span class="line">ls train/3 | sed &quot;s:^:3/:&quot; | sed &quot;s:$: 3:&quot; &gt;&gt; train.txt  </span><br><span class="line">ls train/4 | sed &quot;s:^:4/:&quot; | sed &quot;s:$: 4:&quot; &gt;&gt; train.txt  </span><br><span class="line">ls train/5 | sed &quot;s:^:5/:&quot; | sed &quot;s:$: 5:&quot; &gt;&gt; train.txt  </span><br><span class="line">ls train/6 | sed &quot;s:^:6/:&quot; | sed &quot;s:$: 6:&quot; &gt;&gt; train.txt</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1frlodlh56wj30do0c9gnf.jpg" alt="image"><br>3）准备val.txt，标明验证图片路径及其对应分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls val/0 | sed &quot;s:^:0/:&quot; | sed &quot;s:$: 0:&quot; &gt;&gt; val.txt  </span><br><span class="line">ls val/1 | sed &quot;s:^:1/:&quot; | sed &quot;s:$: 1:&quot; &gt;&gt; val.txt  </span><br><span class="line">ls val/2 | sed &quot;s:^:2/:&quot; | sed &quot;s:$: 2:&quot; &gt;&gt; val.txt  </span><br><span class="line">ls val/3 | sed &quot;s:^:3/:&quot; | sed &quot;s:$: 3:&quot; &gt;&gt; val.txt  </span><br><span class="line">ls val/4 | sed &quot;s:^:4/:&quot; | sed &quot;s:$: 4:&quot; &gt;&gt; val.txt  </span><br><span class="line">ls val/5 | sed &quot;s:^:5/:&quot; | sed &quot;s:$: 5:&quot; &gt;&gt; val.txt  </span><br><span class="line">ls val/6 | sed &quot;s:^:6/:&quot; | sed &quot;s:$: 6:&quot; &gt;&gt; val.txt</span><br></pre></td></tr></table></figure>
<p>4)生成lmdb文件<br><img src="https://ws1.sinaimg.cn/large/006wtREyly1frloalheuqj30ft0gck26.jpg" alt="image"><br>5)计算均值文件<br><img src="https://ws1.sinaimg.cn/large/006wtREyly1frloimki1yj30k900zta4.jpg" alt="image"></p>
<h2 id="搭建网络结构"><a href="#搭建网络结构" class="headerlink" title="搭建网络结构"></a>搭建网络结构</h2><p>type：网络中每一层的类型。我们的网络首先是一个Data层，然后紧跟3个卷积层和3个池化层，最后是3个全连接层</p>
<p>kernel_size：卷积核的尺寸</p>
<p>kernel_num：卷积核的个数</p>
<p>stride：步长，即卷积核每次移动的长度</p>
<p>pad：扩充边缘，使得图像经过卷积之后得到的特征图象不会改变尺寸</p>
<p>output：经过该层处理后，输出结果的维度</p>
<p>dropout：减少过拟合</p>
<h2 id="编写-train-val-prototxt"><a href="#编写-train-val-prototxt" class="headerlink" title="编写 train_val.prototxt"></a>编写 train_val.prototxt</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: &quot;FacialNet&quot;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;data&quot;</span><br><span class="line">  type: &quot;Data&quot;</span><br><span class="line">  top: &quot;data&quot;</span><br><span class="line">  top: &quot;label&quot;</span><br><span class="line">  include &#123;</span><br><span class="line">    phase: TRAIN</span><br><span class="line">  &#125;</span><br><span class="line">  transform_param &#123;</span><br><span class="line">    mirror: true</span><br><span class="line">    crop_size: 42</span><br><span class="line">    mean_file: &quot;/home/dlnu/faceR/meantrain.binaryproto&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  data_param &#123;</span><br><span class="line">    source: &quot;/home/dlnu/faceR/lmdb/fer2013_train_lmdb&quot;</span><br><span class="line">    batch_size: 64 </span><br><span class="line">    backend: LMDB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;data&quot;</span><br><span class="line">  type: &quot;Data&quot;</span><br><span class="line">  top: &quot;data&quot;</span><br><span class="line">  top: &quot;label&quot;</span><br><span class="line">  include &#123;</span><br><span class="line">    phase: TEST</span><br><span class="line">  &#125;</span><br><span class="line">  transform_param &#123;</span><br><span class="line">    mirror: false</span><br><span class="line">    crop_size: 42</span><br><span class="line">    mean_file: &quot;/home/dlnu/faceR/meantrain.binaryproto&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  data_param &#123;</span><br><span class="line">    source: &quot;/home/dlnu/faceR/lmdb/fer2013_val_lmdb&quot;</span><br><span class="line">    batch_size: 32</span><br><span class="line">    backend: LMDB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;conv1&quot;</span><br><span class="line">  type: &quot;Convolution&quot;</span><br><span class="line">  bottom: &quot;data&quot;</span><br><span class="line">  top: &quot;conv1&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: 32</span><br><span class="line">    kernel_size: 5</span><br><span class="line">    pad: 2</span><br><span class="line">    stride: 1</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      type: &quot;gaussian&quot;</span><br><span class="line">      std: 0.01</span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      type: &quot;constant&quot;</span><br><span class="line">      value: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;relu1&quot;</span><br><span class="line">  type: &quot;ReLU&quot;</span><br><span class="line">  bottom: &quot;conv1&quot;</span><br><span class="line">  top: &quot;conv1&quot;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;norm1&quot;</span><br><span class="line">  type: &quot;LRN&quot;</span><br><span class="line">  bottom: &quot;conv1&quot;</span><br><span class="line">  top: &quot;norm1&quot;</span><br><span class="line">  lrn_param &#123;</span><br><span class="line">    local_size: 5</span><br><span class="line">    alpha: 0.0001</span><br><span class="line">    beta: 0.75</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;pool1&quot;</span><br><span class="line">  type: &quot;Pooling&quot;</span><br><span class="line">  bottom: &quot;norm1&quot;</span><br><span class="line">  top: &quot;pool1&quot;</span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 3</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;conv2&quot;</span><br><span class="line">  type: &quot;Convolution&quot;</span><br><span class="line">  bottom: &quot;pool1&quot;</span><br><span class="line">  top: &quot;conv2&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: 32</span><br><span class="line">    pad: 1</span><br><span class="line">    kernel_size: 4</span><br><span class="line">    stride: 2</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      type: &quot;gaussian&quot;</span><br><span class="line">      std: 0.01</span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      type: &quot;constant&quot;</span><br><span class="line">      value: 0.1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;relu2&quot;</span><br><span class="line">  type: &quot;ReLU&quot;</span><br><span class="line">  bottom: &quot;conv2&quot;</span><br><span class="line">  top: &quot;conv2&quot;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;norm2&quot;</span><br><span class="line">  type: &quot;LRN&quot;</span><br><span class="line">  bottom: &quot;conv2&quot;</span><br><span class="line">  top: &quot;norm2&quot;</span><br><span class="line">  lrn_param &#123;</span><br><span class="line">    local_size: 5</span><br><span class="line">    alpha: 0.0001</span><br><span class="line">    beta: 0.75</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;pool2&quot;</span><br><span class="line">  type: &quot;Pooling&quot;</span><br><span class="line">  bottom: &quot;norm2&quot;</span><br><span class="line">  top: &quot;pool2&quot;</span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 3</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;conv3&quot;</span><br><span class="line">  type: &quot;Convolution&quot;</span><br><span class="line">  bottom: &quot;pool2&quot;</span><br><span class="line">  top: &quot;conv3&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: 64</span><br><span class="line">    pad: 2</span><br><span class="line">    kernel_size: 5</span><br><span class="line">    stride: 1</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      type: &quot;gaussian&quot;</span><br><span class="line">      std: 0.01</span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      type: &quot;constant&quot;</span><br><span class="line">      value: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;relu3&quot;</span><br><span class="line">  type: &quot;ReLU&quot;</span><br><span class="line">  bottom: &quot;conv3&quot;</span><br><span class="line">  top: &quot;conv3&quot;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;norm3&quot;</span><br><span class="line">  type: &quot;LRN&quot;</span><br><span class="line">  bottom: &quot;conv3&quot;</span><br><span class="line">  top: &quot;norm3&quot;</span><br><span class="line">  lrn_param &#123;</span><br><span class="line">    local_size: 5</span><br><span class="line">    alpha: 0.0001</span><br><span class="line">    beta: 0.75</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;pool3&quot;</span><br><span class="line">  type: &quot;Pooling&quot;</span><br><span class="line">  bottom: &quot;norm3&quot;</span><br><span class="line">  top: &quot;pool3&quot;</span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 3</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;fc4&quot;</span><br><span class="line">  type: &quot;InnerProduct&quot;</span><br><span class="line">  bottom: &quot;pool3&quot;</span><br><span class="line">  top: &quot;fc4&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 2048</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      type: &quot;gaussian&quot;</span><br><span class="line">      std: 0.005</span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      type: &quot;constant&quot;</span><br><span class="line">      value: 0.1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;relu4&quot;</span><br><span class="line">  type: &quot;ReLU&quot;</span><br><span class="line">  bottom: &quot;fc4&quot;</span><br><span class="line">  top: &quot;fc4&quot;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;drop4&quot;</span><br><span class="line">  type: &quot;Dropout&quot;</span><br><span class="line">  bottom: &quot;fc4&quot;</span><br><span class="line">  top: &quot;fc4&quot;</span><br><span class="line">  dropout_param &#123;</span><br><span class="line">    dropout_ratio: 0.5</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;fc5&quot;</span><br><span class="line">  type: &quot;InnerProduct&quot;</span><br><span class="line">  bottom: &quot;fc4&quot;</span><br><span class="line">  top: &quot;fc5&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 1024</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      type: &quot;gaussian&quot;</span><br><span class="line">      std: 0.005</span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      type: &quot;constant&quot;</span><br><span class="line">      value: 0.1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;relu5&quot;</span><br><span class="line">  type: &quot;ReLU&quot;</span><br><span class="line">  bottom: &quot;fc5&quot;</span><br><span class="line">  top: &quot;fc5&quot;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;drop5&quot;</span><br><span class="line">  type: &quot;Dropout&quot;</span><br><span class="line">  bottom: &quot;fc5&quot;</span><br><span class="line">  top: &quot;fc5&quot;</span><br><span class="line">  dropout_param &#123;</span><br><span class="line">    dropout_ratio: 0.5</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;fc6&quot;</span><br><span class="line">  type: &quot;InnerProduct&quot;</span><br><span class="line">  bottom: &quot;fc5&quot;</span><br><span class="line">  top: &quot;fc6&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 7</span><br><span class="line">    weight_filler &#123;</span><br><span class="line">      type: &quot;gaussian&quot;</span><br><span class="line">      std: 0.005</span><br><span class="line">    &#125;</span><br><span class="line">    bias_filler &#123;</span><br><span class="line">      type: &quot;constant&quot;</span><br><span class="line">      value: 0.1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;accuracy&quot;</span><br><span class="line">  type: &quot;Accuracy&quot;</span><br><span class="line">  bottom: &quot;fc6&quot;</span><br><span class="line">  bottom: &quot;label&quot;</span><br><span class="line">  top: &quot;accuracy&quot;</span><br><span class="line">  include &#123;</span><br><span class="line">    phase: TEST</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;loss&quot;</span><br><span class="line">  type: &quot;SoftmaxWithLoss&quot;</span><br><span class="line">  bottom: &quot;fc6&quot;</span><br><span class="line">  bottom: &quot;label&quot;</span><br><span class="line">  top: &quot;loss&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写solver-prototxt"><a href="#编写solver-prototxt" class="headerlink" title="编写solver.prototxt"></a>编写solver.prototxt</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net: &quot;/home/dlnu/faceR/train_val.prototxt&quot;</span><br><span class="line">test_iter: 110</span><br><span class="line">test_interval: 1000#每迭代1000次进行一次测试</span><br><span class="line">base_lr: 0.001</span><br><span class="line">momentum: 0.9</span><br><span class="line">weight_decay: 0.0005</span><br><span class="line">lr_policy: &quot;fixed&quot;</span><br><span class="line">gamma: 0.1</span><br><span class="line">stepsize: 50000</span><br><span class="line">display: 100</span><br><span class="line">max_iter: 200000</span><br><span class="line">snapshot: 10000</span><br><span class="line">snapshot_prefix: &quot;/home/dlnu/faceR/result&quot;</span><br><span class="line">solver_mode: GPU</span><br></pre></td></tr></table></figure>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">caffe train --solver=~/faceR/solver.prototxt</span><br><span class="line">echo Trainning End</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1frln2wc1wqj30ie03vq7z.jpg" alt="image"></p>
<h2 id="编写deploy-prototxt"><a href="#编写deploy-prototxt" class="headerlink" title="编写deploy.prototxt"></a>编写deploy.prototxt</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: &quot;FacialNet&quot;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;data&quot;</span><br><span class="line">  type: &quot;Input&quot;</span><br><span class="line">  top: &quot;data&quot;</span><br><span class="line">  input_param &#123; shape: &#123; dim: 10 dim: 1 dim: 42 dim: 42 &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;conv1&quot;</span><br><span class="line">  type: &quot;Convolution&quot;</span><br><span class="line">  bottom: &quot;data&quot;</span><br><span class="line">  top: &quot;conv1&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: 32</span><br><span class="line">    kernel_size: 5</span><br><span class="line">    pad: 2</span><br><span class="line">    stride: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;relu1&quot;</span><br><span class="line">  type: &quot;ReLU&quot;</span><br><span class="line">  bottom: &quot;conv1&quot;</span><br><span class="line">  top: &quot;conv1&quot;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;norm1&quot;</span><br><span class="line">  type: &quot;LRN&quot;</span><br><span class="line">  bottom: &quot;conv1&quot;</span><br><span class="line">  top: &quot;norm1&quot;</span><br><span class="line">  lrn_param &#123;</span><br><span class="line">    local_size: 5</span><br><span class="line">    alpha: 0.0001</span><br><span class="line">    beta: 0.75</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;pool1&quot;</span><br><span class="line">  type: &quot;Pooling&quot;</span><br><span class="line">  bottom: &quot;norm1&quot;</span><br><span class="line">  top: &quot;pool1&quot;</span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 3</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;conv2&quot;</span><br><span class="line">  type: &quot;Convolution&quot;</span><br><span class="line">  bottom: &quot;pool1&quot;</span><br><span class="line">  top: &quot;conv2&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: 32</span><br><span class="line">    pad: 1</span><br><span class="line">    kernel_size: 4</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;relu2&quot;</span><br><span class="line">  type: &quot;ReLU&quot;</span><br><span class="line">  bottom: &quot;conv2&quot;</span><br><span class="line">  top: &quot;conv2&quot;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;norm2&quot;</span><br><span class="line">  type: &quot;LRN&quot;</span><br><span class="line">  bottom: &quot;conv2&quot;</span><br><span class="line">  top: &quot;norm2&quot;</span><br><span class="line">  lrn_param &#123;</span><br><span class="line">    local_size: 5</span><br><span class="line">    alpha: 0.0001</span><br><span class="line">    beta: 0.75</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;pool2&quot;</span><br><span class="line">  type: &quot;Pooling&quot;</span><br><span class="line">  bottom: &quot;norm2&quot;</span><br><span class="line">  top: &quot;pool2&quot;</span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 3</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;conv3&quot;</span><br><span class="line">  type: &quot;Convolution&quot;</span><br><span class="line">  bottom: &quot;pool2&quot;</span><br><span class="line">  top: &quot;conv3&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: 64</span><br><span class="line">    pad: 2</span><br><span class="line">    kernel_size: 5</span><br><span class="line">    stride: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;relu3&quot;</span><br><span class="line">  type: &quot;ReLU&quot;</span><br><span class="line">  bottom: &quot;conv3&quot;</span><br><span class="line">  top: &quot;conv3&quot;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;norm3&quot;</span><br><span class="line">  type: &quot;LRN&quot;</span><br><span class="line">  bottom: &quot;conv3&quot;</span><br><span class="line">  top: &quot;norm3&quot;</span><br><span class="line">  lrn_param &#123;</span><br><span class="line">    local_size: 5</span><br><span class="line">    alpha: 0.0001</span><br><span class="line">    beta: 0.75</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;pool3&quot;</span><br><span class="line">  type: &quot;Pooling&quot;</span><br><span class="line">  bottom: &quot;norm3&quot;</span><br><span class="line">  top: &quot;pool3&quot;</span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 3</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;fc4&quot;</span><br><span class="line">  type: &quot;InnerProduct&quot;</span><br><span class="line">  bottom: &quot;pool3&quot;</span><br><span class="line">  top: &quot;fc4&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;relu4&quot;</span><br><span class="line">  type: &quot;ReLU&quot;</span><br><span class="line">  bottom: &quot;fc4&quot;</span><br><span class="line">  top: &quot;fc4&quot;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;drop4&quot;</span><br><span class="line">  type: &quot;Dropout&quot;</span><br><span class="line">  bottom: &quot;fc4&quot;</span><br><span class="line">  top: &quot;fc4&quot;</span><br><span class="line">  dropout_param &#123;</span><br><span class="line">    dropout_ratio: 0.4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;fc5&quot;</span><br><span class="line">  type: &quot;InnerProduct&quot;</span><br><span class="line">  bottom: &quot;fc4&quot;</span><br><span class="line">  top: &quot;fc5&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 1024</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;relu5&quot;</span><br><span class="line">  type: &quot;ReLU&quot;</span><br><span class="line">  bottom: &quot;fc5&quot;</span><br><span class="line">  top: &quot;fc5&quot;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;drop5&quot;</span><br><span class="line">  type: &quot;Dropout&quot;</span><br><span class="line">  bottom: &quot;fc5&quot;</span><br><span class="line">  top: &quot;fc5&quot;</span><br><span class="line">  dropout_param &#123;</span><br><span class="line">    dropout_ratio: 0.4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;fc6&quot;</span><br><span class="line">  type: &quot;InnerProduct&quot;</span><br><span class="line">  bottom: &quot;fc5&quot;</span><br><span class="line">  top: &quot;fc6&quot;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 1</span><br><span class="line">    decay_mult: 1</span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: 2</span><br><span class="line">    decay_mult: 0</span><br><span class="line">  &#125;</span><br><span class="line">  inner_product_param &#123;</span><br><span class="line">    num_output: 7</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: &quot;prob&quot;</span><br><span class="line">  type: &quot;Softmax&quot;</span><br><span class="line">  bottom: &quot;fc6&quot;</span><br><span class="line">  top: &quot;prob&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写python程序，测试模型"><a href="#编写python程序，测试模型" class="headerlink" title="编写python程序，测试模型"></a>编写python程序，测试模型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import sys</span><br><span class="line">sys.path.append(&quot;/home/dlnu/caffe/python&quot;)</span><br><span class="line"></span><br><span class="line">import caffe  </span><br><span class="line">import numpy as np  </span><br><span class="line">  </span><br><span class="line">def faceRecognition(imagepath):  </span><br><span class="line">    root=&apos;/home/dlnu/faceR/&apos;   #根目录  </span><br><span class="line">    deploy=root + &apos;model/deploy.prototxt&apos;    #deploy文件  </span><br><span class="line">    caffe_model=root + &apos;result_iter_10000.caffemodel&apos;   #训练好的 caffemodel  </span><br><span class="line">    img=root + &apos;predict/&apos; + imagepath  </span><br><span class="line">    labels_filename = root + &apos;data/labels.txt&apos;  #类别名称文件，将数字标签转换回类别名称  </span><br><span class="line">    #net = caffe.Net(deploy,caffe_model,caffe.TEST)   #加载model和network  </span><br><span class="line">    net = caffe.Net(deploy,caffe_model,caffe.TEST) </span><br><span class="line"></span><br><span class="line">    #图片预处理设置  </span><br><span class="line">    transformer = caffe.io.Transformer(&#123;&apos;data&apos;: net.blobs[&apos;data&apos;].data.shape&#125;)  #设定图片的shape格式(1,1,42,42)  </span><br><span class="line">    transformer.set_transpose(&apos;data&apos;, (2,0,1))    #改变维度的顺序，由原始图片(42,42,1)变为(1,42,42)  </span><br><span class="line">    #transformer.set_mean(&apos;data&apos;, np.load(mean_file).mean(1).mean(1))    #减去均值，前面训练模型时没有减均值，这儿就不用  </span><br><span class="line">    transformer.set_raw_scale(&apos;data&apos;, 255)    # 缩放到【0，255】之间  </span><br><span class="line">    net.blobs[&apos;data&apos;].reshape(1,1,42,42)  </span><br><span class="line">    im=caffe.io.load_image(img,False)#加载图片  </span><br><span class="line">    net.blobs[&apos;data&apos;].data[...] = transformer.preprocess(&apos;data&apos;,im)#执行上面设置的图片预处理操作，并将图片载入到blob中  </span><br><span class="line">  </span><br><span class="line">    #执行测试  </span><br><span class="line">    out = net.forward()  </span><br><span class="line">    labels = np.loadtxt(labels_filename, str, delimiter=&apos;\t&apos;)   #读取类别名称文件  </span><br><span class="line">    prob= net.blobs[&apos;prob&apos;].data[0].flatten() #取出最后一层（Softmax）属于某个类别的概率值，并打印  </span><br><span class="line">    order=prob.argsort()[-1]  #将概率值排序，取出最大值所在的序号   </span><br><span class="line">    face=labels[order]  </span><br><span class="line">    return face #face是最终识别的表情  </span><br><span class="line">  </span><br><span class="line">face=faceRecognition(&apos;00146.jpg&apos;)  </span><br><span class="line">print(&quot;您的表情是：&quot;+face)</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1frlmagpmv9j30ei03jn0e.jpg" alt="image"></p>
<p>参考链接:<br><a href="https://blog.csdn.net/pangyunsheng/article/details/79481447" target="_blank" rel="noopener">https://blog.csdn.net/pangyunsheng/article/details/79481447</a></p>
]]></content>
      <categories>
        <category>caffe</category>
      </categories>
  </entry>
  <entry>
    <title>表情识别数据集整理</title>
    <url>/2018/05/06/%E8%A1%A8%E6%83%85%E8%AF%86%E5%88%AB%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<p>CK and CK+<br><a id="more"></a><br>It contains 97 subjects, which posed in a lab situation for the six universal expressions and the neutral expression. Its extension CK+ contains 123 subjects but the new videos were shot in a similar environment.<br>Reference: P. Lucey, J. F. Cohn, T. Kanade, J. Saragih, Z. Ambadar, and I. Matthews, “The Extended Cohn-Kanade Dataset (CK+): A complete dataset for action unit and emotion-specified expression,” in Proceedings of IEEE Conference on Computer Vision and Pattern Recognition Workshops CVPR4HB’10, 2010, pp. 94–101.<br>Website: <a href="http://www.pitt.edu/~emotion/ck-spread.htm" target="_blank" rel="noopener">http://www.pitt.edu/~emotion/ck-spread.htm</a><br>Modalities: Visual<br>说明: ck只有静态图片，CK+包括视频。表情标签为分类离散值。</p>
<p>JAFFE<br>It contains 219 images of 10 Japanese females. However, it has a limited number of samples, subjects and has been created in a lab controlled environment.<br>Website: <a href="http://www.kasrl.org/jaffe.html" target="_blank" rel="noopener">http://www.kasrl.org/jaffe.html</a><br>Modalities: visual<br>说明: 只有219张表情图片。表情标签为分类离散值。</p>
<p>HUMAINE Database<br>Datafiles containing emotion labels, gesture labels, speech labels and FAPS all readable in ANVI（标签等信息要用ANVI工具才能打开）<br>Modalities: Audio+visual + gesture<br>Website: <a href="http://emotion-research.net/download/pilot-db/" target="_blank" rel="noopener">http://emotion-research.net/download/pilot-db/</a><br>说明: 下载数据集后里面只有视频，没有标签等信息。</p>
<p>Recola database<br>Totally 34 subjects; 14 male, 20 female<br>Reference: FABIEN R., ANDREAS S., JUERGEN S., DENIS L.. Introducing the RECOLA multimodal corpus of collaborative and affective interactions[C]//10th IEEE Int’l conf. and workshops on automatic face and gesture recognition. Shanghai, CN: IEEE Press, 2013:1-8.<br>Website: <a href="http://diuf.unifr.ch/diva/recola/index.html" target="_blank" rel="noopener">http://diuf.unifr.ch/diva/recola/index.html</a><br>Modalities: Audio+visual+ EDA, ECG（生理模态）<br>说明: 数据集共34个视频，表情标签为Arousal-Valence的连续值。标签存在csv文件里。</p>
<p>MMI<br>The database consists of over 2900 videos and high-resolution still images of 75 subjects. It is fully annotated for the presence of AUs in videos (event coding), and partially coded on frame-level, indicating for each frame whether an AU is in either the neutral, onset, apex or offset phase. A small part was annotated for audio-visual laughters. The database is freely available to the scientific community.<br>Reference:<br>a) Induced Disgust, Happiness and Surprise: an Addition to the MMI Facial Expression Database<br>M. F. Valstar, M. Pantic. Proceedings of Int’l Conf. Language Resources and Evaluation, Workshop on EMOTION. Malta, pp. 65 - 70, May 2010.<br>b) Web-based database for facial expression analysis,M. Pantic, M. F. Valstar, R. Rademaker, L. Maat. Proceedings of IEEE Int’l Conf. Multimedia and Expo (ICME’05). Amsterdam, The Netherlands, pp. 317 - 321, July 2005.<br>Modalities: visual(视频)<br>Website: <a href="http://mmifacedb.eu/" target="_blank" rel="noopener">http://mmifacedb.eu/</a><br>　　　　  <a href="http://ibug.doc.ic.ac.uk/research/mmi-database/" target="_blank" rel="noopener">http://ibug.doc.ic.ac.uk/research/mmi-database/</a><br>说明: 该数据集很大，全部包括2900个视频，标签主要是AU的标签，标签存在xml文件里。</p>
<p>NVIE 中科大采集的一个数据集<br>中科大NVIE数据集包括自发表情库和人为表情库，本实验采用其中的自发表情库。自发表情库是通过特定视频诱发并在三种光照下（正面、左侧、右侧光照）采集的表情库，其中正面光照103人，左侧光照99人，右侧光照103人。每种光照下，每人有六种表情（喜悦、愤怒、哀 伤、恐惧、厌恶、惊奇）中的三种以上，每种表情的平静帧以及最大帧都已挑出<br>Reference: WANG Shangfei, LIU Zhilei, LV Siliang, LV Yanpeng, et al. A Natural Visible and Infrared Facial Expression Database for Expression Recognition and Emotion Inference[J]. IEEE Transactions on Multimedia, 2010, 12(7): 682-691.<br>Website: <a href="http://nvie.ustc.edu.cn/" target="_blank" rel="noopener">http://nvie.ustc.edu.cn/</a><br>Modalities: visual(图片)<br>说明: 标签以Excel文件给出，标签包括表情类的强度，如disgust的表情强度。标签还包括Arousal-Valence标签。</p>
<p>RU-FACS database<br>This database consists of spontaneous facial expressions from multiple views, with ground truth FACS codes provided by two facial expression experts.<br>We have collected data from 100 subjects, 2.5 minutes each. This database constitutes a significant contribution towards the 400-800 minute database recommended in the feasibility study for fully automating FACS. To date we have human FACS coded the upper faces of 20% the subjects.<br>Reference: M. S. Bartlett, G. Littlewort, M. G. Frank, C. Lainscsek, I. R. Fasel, and J. R. Movellan, “Automatic recognition of facial actions in spontaneous expressions,” Journal of Multimedia, vol. 1, no. 6, pp. 22–35, 2006. 3, 5<br>Website: <a href="http://mplab.ucsd.edu/grants/project1/research/rufacs1-dataset.html" target="_blank" rel="noopener">http://mplab.ucsd.edu/grants/project1/research/rufacs1-dataset.html</a><br>说明: 该数据集的标签是FACS编码的标签（只有部分视频才有标签），目前该数据集还未向研究者公开。</p>
<p>Belfast naturalistic database<br>The Belfast database consists of a combination of studio recordings and TV programme grabs labelled with particular expressions. The number of TV clips in this database is sparse<br>Modalities: Audio-visual(视频)<br>Reference: E. Douglas-Cowie, R. Cowie, and M. Schr¨oder, “A New Emotion Database: Considerations, Sources and Scope,” in ISCAITRW on Speech and Emotion, 2000, pp. 39–44.<br>Website: <a href="http://sspnet.eu/2010/02/belfast-naturalistic/" target="_blank" rel="noopener">http://sspnet.eu/2010/02/belfast-naturalistic/</a><br>说明: 数据集为视频，视频包括speech的情感识别</p>
<p>GEMEP Corpus<br>The GEneva Multimodal Emotion Portrayals (GEMEP) is a collection of audio and video recordings featuring 10 actors portraying 18 affective states, with different verbal contents and different modes of expression.<br>Modalities: Audio-visual<br>Reference: T. B¨anziger and K. Scherer, “Introducing the Geneva Multimodal Emotion Portrayal (GEMEP) Corpus,” in Blueprint for affective computing: A sourcebook, K. Scherer, T. B¨anziger, and E. Roesch, Eds. Oxford, England: Oxford University Press, 2010<br>Website: <a href="http://www.affective-sciences.org/gemep" target="_blank" rel="noopener">http://www.affective-sciences.org/gemep</a><br> 　　　　 <a href="http://sspnet.eu/2011/05/gemep-fera/" target="_blank" rel="noopener">http://sspnet.eu/2011/05/gemep-fera/</a><br>说明: FERA2011比赛采用此数据集，标签主要是分类。</p>
<p>Paleari<br>Reference: M. Paleari, R. Chellali, and B. Huet, “Bimodal emotion recognition,” in Proceeding of the Second International Conference on Social Robotics ICSR’10, 2010, pp. 305–314.<br>该数据集我没找到它的官网，我查看了上面那个引用文章的摘要发现那篇文章不是介绍表情数据集的。那个文章在springer上，学校的网只能查到到摘要和第一章。</p>
<p>VAM corpus<br>The VAM corpus consists of 12 hours of recordings of the German TV talk-show “Vera am Mittag” (Vera at noon). They are segmented into broadcasts, dialogue acts and utterances, respectively. This audio -visual speech corpus contains spontaneous and very emotional speech recorded from unscripted, authentic discussions between the guests of the talk-show<br>Modalities: Audio-visual<br>Reference: M. Grimm, K. Kroschel, and S. Narayanan, “The Vera am Mittag German audio-visual emotional speech database,” in IEEE International Confernce on Multimedia and Expo ICME’08, 2008, pp. 865–868<br>Website: <a href="http://emotion-research.net/download/vam" target="_blank" rel="noopener">http://emotion-research.net/download/vam</a><br>说明: 该数据集主要是speech视频，标签为连续值，具体包括三个维度：valence (negative vs. positive), activation (calm vs. excited) and dominance (weak vs. strong)。</p>
<p>SSPNet Conflict Corpus（严格意义上不是表情识别数据集）<br>The “SSPNet Conflict Corpus” includes 1430 clips (30 seconds each) extracted from 45 political debates televised in Switzerland. The clips are in French<br>Modalities: Audio-visual<br>Reference: S.Kim, M.Filippone, F.Valente and A.Vinciarelli “Predicting the Conflict Level in Television Political Debates: an Approach Based on Crowdsourcing, Nonverbal Communication and Gaussian Processes“ Proceedings of ACM International Conference on Multimedia, pp. 793-796, 2012.<br>Website: <a href="http://www.dcs.gla.ac.uk/vincia/?p=270" target="_blank" rel="noopener">http://www.dcs.gla.ac.uk/vincia/?p=270</a><br>说明: 该数据集主要是政治辩论中的视频，标签为conflict level。</p>
<p>Semaine database<br>The database contains approximately 240 character conversations, and recording is still ongoing. Currently approximately 80 conversations have been fully annotated for a number of dimensions in a fully continuous way using FeelTrace.<br>Website: <a href="http://semaine-db.eu/" target="_blank" rel="noopener">http://semaine-db.eu/</a><br>Modalities: Audio-visual<br>Reference: The SEMAINE database: Annotated multimodal records of emotionally coloured conversations between a person and a limited agent G. Mckeown, M. F. Valstar, R. Cowie, M. Pantic, M. Schroeder. IEEE Transactions on Affective Computing. 3: pp. 5 - 17, Issue 1. April 2012.<br>说明: 通过人机对话来触发的视频，标签为连续的情感维度值，不是分类。</p>
<p>AFEW database(Acted Facial Expressions In The Wild)<br>Acted Facial Expressions In The Wild (AFEW) is a dynamic temporal facial expressions data corpus consisting of close to real world environment extracted from movies.<br>Reference: Abhinav Dhall, Roland Goecke, Simon Lucey, Tom Gedeon, Collecting Large, Richly Annotated Facial-Expression Databases from Movies, IEEE Multimedia 2012.<br>Website: <a href="https://cs.anu.edu.au/few/AFEW.html" target="_blank" rel="noopener">https://cs.anu.edu.au/few/AFEW.html</a><br>Modalities: Audio-visual(电影剪辑片断)<br>说明: 该数据集的内容为从电影中剪辑的包含表情的视频片段，表情标签为六类基本表情+中性表情，annotation的信息保存在xml文件中。<br>AFEW数据集为Emotion Recognition In The Wild Challenge (EmotiW)系列情感识别挑战赛使用的数据集，该比赛从2013开始每年举办一次。<br>EmotiW官网：<a href="https://cs.anu.edu.au/few/" target="_blank" rel="noopener">https://cs.anu.edu.au/few/</a></p>
<p>SFEW database(Static Facial Expressions in the Wild)<br>Static Facial Expressions in the Wild (SFEW) has been developed by selecting frames from AFEW<br>Reference: Abhinav Dhall, Roland Goecke, Simon Lucey, and Tom Gedeon. Static Facial Expressions in Tough Conditions: Data, Evaluation Protocol And Benchmark, First IEEE International Workshop on Benchmarking Facial Image Analysis Technologies BeFIT, IEEE International Conference on Computer Vision ICCV2011, Barcelona, Spain, 6-13 November 2011<br>Website: <a href="https://cs.anu.edu.au/few/AFEW.html" target="_blank" rel="noopener">https://cs.anu.edu.au/few/AFEW.html</a><br>Modalities: Visual<br>说明: 该数据集是从AFEW数据集中抽取的有表情的静态帧，表情标签为六类基本表情+中性表情，annotation的信息保存在xml文件中。</p>
<p>AVEC系列数据集<br>AVEC是从2011开始每一年举办一次的表情识别挑战赛，表情识别的模型主要采用的连续情感模型。其中AVEC2012使用的情感维度为Arousal、Valence、Expectancy、Power； AVEC2013的情感维度为Valence和Arousal；AVEC2014的情感维度Valence、Arousal和Dominance。<br>AVEC2013和AVEC2014引入了depression recognition.<br>Modalities: Audio-visual<br>Website:<br><a href="http://sspnet.eu/avec2011/" target="_blank" rel="noopener">http://sspnet.eu/avec2011/</a><br><a href="http://sspnet.eu/avec2012/" target="_blank" rel="noopener">http://sspnet.eu/avec2012/</a><br><a href="http://sspnet.eu/avec2013/" target="_blank" rel="noopener">http://sspnet.eu/avec2013/</a><br><a href="http://sspnet.eu/avec2014/" target="_blank" rel="noopener">http://sspnet.eu/avec2014/</a><br>Reference: Michel Valstar , Björn W. Schuller , Jarek Krajewski , Roddy Cowie , Maja Pantic, AVEC 2014: the 4th international audio/visual emotion challenge and workshop, Proceedings of the ACM International Conference on Multimedia, November 03-07, 2014, Orlando, Florida, USA<br>说明:标签主要是针对的情感维度，通过csv的形式给出的。</p>
<p>LIRIS-ACCEDE数据集<br>LIRIS-ACCEDE数据集主要包含三个部分:<br>Discrete LIRIS-ACCEDE - Induced valence and arousal rankings for 9800 short video excerpts extracted from 160 movies. Estimated affective scores are also available.<br>Continuous LIRIS-ACCEDE - Continuous induced valence and arousal self-assessments for 30 movies. Post-processed GSR measurements are also available.<br>MediaEval 2015 affective impact of movies task - Violence annotations and affective classes for the 9800 excerpts of the discrete LIRIS-ACCEDE part, plus for additional 1100 excerpts used to extend the test set for the MediaEval 2015 affective impact of movies task.<br>Modalities: Audio-visual<br>Website:<br><a href="http://liris-accede.ec-lyon.fr/index.php" target="_blank" rel="noopener">http://liris-accede.ec-lyon.fr/index.php</a><br>Reference:<br>Y. Baveye, E. Dellandrea, C. Chamaret, and L. Chen, “LIRIS-ACCEDE: A Video Database for Affective Content Analysis,” in IEEE Transactions on Affective Computing, 2015.<br>Y. Baveye, E. Dellandrea, C. Chamaret, and L. Chen, “Deep Learning vs. Kernel Methods: Performance for Emotion Prediction in Videos,” in 2015 Humaine Association Conference on Affective Computing and Intelligent Interaction (ACII), 2015<br>M. Sjöberg, Y. Baveye, H. Wang, V. L. Quang, B. Ionescu, E. Dellandréa, M. Schedl, C.-H. Demarty, and L. Chen, “The mediaeval 2015 affective impact of movies task,” in MediaEval 2015 Workshop, 2015<br>说明: 该数据集既有离散的情感数据又有基于维度的情感数据。</p>
<p>几个重点参考的网站<br><a href="http://emotion-research.net/wiki/Databases" target="_blank" rel="noopener">http://emotion-research.net/wiki/Databases</a><br><a href="http://sspnet.eu/category/sspnet_resource_categories/resource_type_classes/dataset/" target="_blank" rel="noopener">http://sspnet.eu/category/sspnet_resource_categories/resource_type_classes/dataset/</a><br><a href="http://ibug.doc.ic.ac.uk/resources" target="_blank" rel="noopener">http://ibug.doc.ic.ac.uk/resources</a><br><a href="http://www.ecse.rpi.edu/~cvrl/database/other_facial_expression.html" target="_blank" rel="noopener">http://www.ecse.rpi.edu/~cvrl/database/other_facial_expression.html</a></p>
<p>另外还有emotionet,affectnet数据集都是百万级别的数据，可自行查看官网</p>
<p>综合了一下，打算使用CK+的数据库 来写表情识别的项目<br>下载数据库后有以下四个文件</p>
<p>1) The Images (cohn-kanade-images.zip) - there are 593 sequences across 123 subjects which are FACS coded at the peak frame. All sequences are from the neutral face to the peak expression.</p>
<p>2) The Landmarks (Landmarks.zip) - All sequences are AAM tracked with 68points landmarks for each image.</p>
<p>3) The FACS coded files (FACS_labels.zip) - for each sequence (593) there is only 1 FACS file, which is the last frame (the peak frame). Each line of the file corresponds to a specific AU and then the intensity. An example is given below.</p>
<p>4) The Emotion coded files (Emotion_labels.zip) - ONLY 327 of the 593 sequences have emotion sequences. This is because these are the only ones the fit the prototypic definition. Like the FACS files, there is only 1 Emotion file for each sequence which is the last frame (the peak frame). There should be only one entry and the number will range from 0-7 (i.e. 0=neutral, 1=anger, 2=contempt, 3=disgust, 4=fear, 5=happy, 6=sadness, 7=surprise). N.B there is only 327 files- IF THERE IS NO FILE IT MEANS THAT THERE IS NO EMOTION LABEL (sorry to be explicit but this will avoid confusion).</p>
<p>The Images (cohn-kanade-images.zip)图片库中包含了从平静到表情表现峰值的图片，实际使用中建议使用比较明显的图片，并进行相应的预处理。</p>
<p>Emotion_labels.zip标签压缩包中<br>0-中性<br>1-愤怒<br>2-蔑视<br>3-厌恶<br>4-恐惧<br>5-高兴<br>6-悲伤<br>7-惊讶<br>参考自<a href="https://blog.csdn.net/yinghua2016/article/details/77323537" target="_blank" rel="noopener">https://blog.csdn.net/yinghua2016/article/details/77323537</a></p>
]]></content>
      <categories>
        <category>数据集</category>
      </categories>
      <tags>
        <tag>表情识别,数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>表情识别流程</title>
    <url>/2018/06/18/%E8%A1%A8%E6%83%85%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>目标</p>
<p>一个live demo, 从摄像头获取视频，逐帧进行人脸检测，对每个检测到的人脸，输入一个表情分类器，输出分类结果。人脸检测使用现有的开源实现。人脸表情分类器使用现有的开源数据库和深度学习框架训练得到。<br><a id="more"></a></p>
<p>表情识别 </p>
<p>1 图像输入</p>
<pre><code> 这里的输入图像在实际应用中通常是从视频中获得，如商店中的监控视频。在我们的研究工作中，输入的图像来自一些公开的表情数据集，如JAFFE，CK，NVIE，IMM，Recola，Semaine等。

2 人脸检测

 表情识别中我们的研究对象是人脸，但通常在第一步中的输入图像中还包括了非人脸区域，所以我们需要使用人脸检测算法检测出我们感兴趣的人脸区域。人脸检测本身也是一个很热的研究点，但在表情识别中，这不是重点。

3 图像预处理

 图像预处理的对象是第二步中得到的人脸图片。为什么需要预处理呢？图像的归一化！！因为在第二步中得到的人脸区域中，它们的大小、长宽比例、光照条件通常是不一样的，所以为了后续提取特征的统一处理，就需要将它们的尺寸、光照等进行归一化处理。

4 特征提取

 计算机跟人不一样，人能一眼识别出表情，这对计算机来说却很难做到。通常计算机需要我们给它特征来区分不同的表情，所以我们应该选择区分度高的特征给计算机。这是表情识别中很关键的一步，对于特征提取方法的选择，前后有很多学者尝试了很多不同的特征，如LBP， Gabor, SIFT, DCT, FAP等等。

 特征可以分为纹理特征和几何特征，从另一个角度也可以分为全局特征和局部特征。特征提取的好坏将直接影响后续的分类或回归结果。

5 模式分类/回归

该步骤是用机器学习算法对第四步得到的特征进行训练，训练完成后就会得到一个分类器或者回归器。这一步骤也是表情识别中很关键的一步，通常我们总是希望得到的分类器或回归器具有更好的预测能力，所以很多学者也尝试了用不同的机器学习算法来设计分类器，比较常见有SVM，KNN，NN(Neural Network)，HMM，SVR，RVM等等。

6 识别结果

 最后一步就是对表情进行识别，具体来讲就是把经过前面几步提取到的表情特征送入训练好的分类器或回归器，让分类器或回归器给出一个预测的值。

表情识别中的重点和难点是特征提取和模式分类/回归，已有的研究中的大部分创新基本上都集中在这两步，如特征提取中采用多特征融合，预测时采用决策级融合等。


转载自：http://blog.csdn.net/computerme/article/details/39371557
https://blog.csdn.net/zwx2445205419/article/details/79086288
https://web.kamihq.com/web/viewer.html?source=extension_pdfhandler&amp;file=https%3A%2F%2Farxiv.org%2Fpdf%2F1802.06664.pdf
</code></pre>]]></content>
  </entry>
  <entry>
    <title>装箱问题</title>
    <url>/2019/03/28/%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>假设有N项物品，大小分别为s1,s2….si….sn，其中si为满足0&lt;=si&lt;=100的整数。要把这些物品装入到容量为100的一批箱子（序号1-N）中。装箱方法是：对每项物品, 顺序扫描箱子，把该物品放入足以能够容下它的第一个箱子中。请写一个程序模拟这种装箱过程，并输出每个物品所在的箱子序号，以及放置全部物品所需的箱子数目。<br><a id="more"></a><br>输入格式：<br>输入第一行给出物品个数N(&lt;=1000)；第二行给出N个正整数si(0&lt;=si&lt;=100，表示第i项物品的大小)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">8</span><br><span class="line">60 70 80 90 30 40 10 20</span><br><span class="line">输出样例：</span><br><span class="line">60 1</span><br><span class="line">70 2</span><br><span class="line">80 3</span><br><span class="line">90 4</span><br><span class="line">30 1</span><br><span class="line">40 5</span><br><span class="line">10 1</span><br><span class="line">20 2</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1000</span><br><span class="line">int s[MAX],v[MAX];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; mp;</span><br><span class="line">int n;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	s[i]=100;</span><br><span class="line">	for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">		cin&gt;&gt;v[j];</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			if(s[i]&gt;=v[j])&#123;</span><br><span class="line">				mp.push_back(make_pair(v[j],i));</span><br><span class="line">				s[i]-=v[j];</span><br><span class="line">				break;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;mp.size();i++)&#123;</span><br><span class="line">		cout&lt;&lt;mp[i].first&lt;&lt;&quot; &quot;&lt;&lt;mp[i].second&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;mp.size()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>简单贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>poj1054 讨厌的青蛙</title>
    <url>/2018/11/08/%E8%AE%A8%E5%8E%8C%E7%9A%84%E9%9D%92%E8%9B%99/</url>
    <content><![CDATA[<p>题意：在一个row*col的矩阵里，留了n个青蛙的脚印。已知每只青蛙的步长是一定的，且都是从一个边界外，跳到了另一边的边界外，而且跳的是直线。每跳落地就留一个脚印在那个格子。现在问你那只在地里留下最多脚印的青蛙留下了多少只脚印(只要有可能就好)。<br><img src="http://s13.sinaimg.cn/middle/6635898a4a028d1734dfc&amp;690" alt="image"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>首先针对 x 从小到大排序，然后枚举，这样为后面的剪枝提供了方便;<br>2.对于剪枝，因为题目中明确说了：青蛙是从外面跳进来，至少踩了 3 个黑点，然后跳出去的，于是可以加下面剪枝：</p>
<p>a. 确定 2 点之间的间距之后，确定出发点之前的那个点是否在稻田外面，如果不是则剪枝;</p>
<p>b. 根据当前最优情况，确定当前的点只要要走多少步才能找到一个更优解，相当于是一个启发式的剪枝;</p>
</li>
</ol>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int R,C,n;</span><br><span class="line">struct PLANT&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y; </span><br><span class="line">&#125;plants[5000];</span><br><span class="line">bool operator &lt;(PLANT t1,PLANT t2)&#123;</span><br><span class="line">	if(t1.x==t2.x) return t1.y&lt;t2.y;</span><br><span class="line">	else return t1.x&lt;t2.x;</span><br><span class="line">&#125;</span><br><span class="line">int search_path(PLANT plant,int dx,int dy)&#123;</span><br><span class="line">	PLANT t;</span><br><span class="line">	t.x=plant.x+dx;</span><br><span class="line">	t.y=plant.y+dy;</span><br><span class="line">	int steps=2;</span><br><span class="line">	while(1&lt;=t.x&amp;&amp;t.x&lt;=R&amp;&amp;t.y&gt;=1&amp;&amp;t.y&lt;=C)&#123;</span><br><span class="line">		if(!binary_search(plants,plants+n,t))&#123;</span><br><span class="line">        ////每一步都必须踩倒水稻才算合理, 否则这就不是一条行走路径</span><br><span class="line">			steps=0;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		t.x+=dx;</span><br><span class="line">		t.y+=dy;//!!</span><br><span class="line">		steps++;</span><br><span class="line">	&#125;</span><br><span class="line">	return steps;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int R1,C1;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;R,&amp;C);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;R1,&amp;C1);</span><br><span class="line">		plants[i].x=R1;</span><br><span class="line">		plants[i].y=C1;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	sort(plants,plants+n);//!! 二分查找必须先排序</span><br><span class="line">	int max=2;</span><br><span class="line">	for(int i=0;i&lt;n-2;i++)&#123;//!!</span><br><span class="line">		for(int j=i+1;j&lt;n-1;j++)&#123;</span><br><span class="line">			int dx=plants[j].x-plants[i].x;</span><br><span class="line">			int dy=plants[j].y-plants[i].y;</span><br><span class="line">			int px=plants[i].x-dx;</span><br><span class="line">			int py=plants[i].y-dy;//!!</span><br><span class="line">	if(px&gt;=1&amp;&amp;px&lt;=R&amp;&amp;py&gt;=1&amp;&amp;py&lt;=C) continue; </span><br><span class="line">    ///第一点的前一点在稻田里,</span><br><span class="line">//说明本次选的第二点导致的x方向步长不合理(太小)</span><br><span class="line">// 取下一个点作为第二点</span><br><span class="line"></span><br><span class="line">   	if(plants[i].x+(max-1)*dx&gt;R) break;</span><br><span class="line">    ////x方向过早越界了. 说明本次选的第二点不成立</span><br><span class="line">//如果换下一个点作为第二点, x方向步长只会更大, 更不成立, 所以应该</span><br><span class="line">//认为本次选的第一点必然是不成立的, 那么取下一个点作为第一点再试</span><br><span class="line">		if(plants[i].y+(max-1)*dy&lt;1||plants[i].y+(max-1)*dy&gt;C) break;</span><br><span class="line">        // //y方向过早越界了, 应换一个点作为第二点再试</span><br><span class="line">			int steps=search_path(plants[j],dx,dy);</span><br><span class="line">			if(steps&gt;max) max=steps;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	if(max==2) max=0;</span><br><span class="line">	cout&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>poj</category>
      </categories>
  </entry>
  <entry>
    <title>语法错误，将“Dimensions”插入到完整ReferenceType </title>
    <url>/2018/05/13/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%EF%BC%8C%E5%B0%86%E2%80%9CDimensions%E2%80%9D%E6%8F%92%E5%85%A5%E5%88%B0%E5%AE%8C%E6%95%B4ReferenceType/</url>
    <content><![CDATA[<p>当我们希望定义一个不包括重复整数的集时，如果使用如下代码<br>Set<int> set = new HashSet<int>();//错误<br>编译器会报错<br>  <a id="more"></a><br>语法错误，将“Dimensions”插入到完整ReferenceType 中<br>原因是泛型必须是类类型，而不能是基本类型（包括基本类型的数组）<br>上述错误正确的格式如下</int></int></p>
<p>int a = 0;<br>Integer inte = new Integer(a);<br>Set<integer> set = new HashSet<integer>();<br>set.add(inte);  </integer></integer></p>
<p>即使用包装类包装基本类型</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title> CCF201512-4 送货</title>
    <url>/2018/12/04/%E8%B4%A7/</url>
    <content><![CDATA[<p>问题描述<br>　　为了增加公司收入，F公司新开设了物流业务。由于F公司在业界的良好口碑，物流业务一开通即受到了消费者的欢迎，物流业务马上遍及了城市的每条街道。然而，F公司现在只安排了小明一个人负责所有街道的服务。<br>　　任务虽然繁重，但是小明有足够的信心，他拿到了城市的地图，准备研究最好的方案。城市中有n个交叉路口，m条街道连接在这些交叉路口之间，每条街道的首尾都正好连接着一个交叉路口。除开街道的首尾端点，街道不会在其他位置与其他街道相交。每个交叉路口都至少连接着一条街道，有的交叉路口可能只连接着一条或两条街道。<br>　　小明希望设计一个方案，从编号为1的交叉路口出发，每次必须沿街道去往街道另一端的路口，再从新的路口出发去往下一个路口，直到所有的街道都经过了正好一次。<br>输入格式<br>　　输入的第一行包含两个整数n, m，表示交叉路口的数量和街道的数量，交叉路口从1到n标号。<br>　　接下来m行，每行两个整数a, b，表示和标号为a的交叉路口和标号为b的交叉路口之间有一条街道，街道是双向的，小明可以从任意一端走向另一端。两个路口之间最多有一条街道。<br><a id="more"></a><br>输出格式<br>　　如果小明可以经过每条街道正好一次，则输出一行包含m+1个整数p1, p2, p3, …, pm+1，表示小明经过的路口的顺序，相邻两个整数之间用一个空格分隔。如果有多种方案满足条件，则输出字典序最小的一种方案，即首先保证p1最小，p1最小的前提下再保证p2最小，依此类推。<br>　　如果不存在方案使得小明经过每条街道正好一次，则输出一个整数-1。<br>样例输入<br>4 5</p>
<p>1 2</p>
<p>1 3</p>
<p>1 4</p>
<p>2 4</p>
<p>3 4<br>样例输出<br>1 2 4 1 3 4<br>样例说明<br>　　城市的地图和小明的路径如下图所示。</p>
<p>样例输入<br>4 6<br>1 2<br>1 3<br>1 4<br>2 4<br>3 4<br>2 3<br>样例输出<br>-1<br>样例说明<br>　　城市的地图如下图所示，不存在满足条件的路径。</p>
<p>评测用例规模与约定<br>　　前30%的评测用例满足：1 ≤ n ≤ 10, n-1 ≤ m ≤ 20。<br>　　前50%的评测用例满足：1 ≤ n ≤ 100, n-1 ≤ m ≤ 10000。<br>　　所有评测用例满足：1 ≤ n ≤ 10000，n-1 ≤ m ≤ 100000。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>欧拉通路的判断</p>
<p>用栈来保存路径 </p>
<p>只有80分</p>
<p>这个问题是一笔画问题，或者说是欧拉路径问题。所有需要判定图是否是连通图，然后再判定是否存在欧拉路径。判定是否是连通图，可以使用并查集来实现。判定是否存在欧拉路径的条件是：无向图的所有结点的出入度均为偶数，或者有2个出入度为奇数的结点。满足这个条件的图，必然能够找到欧拉路径。由于是从结点1出发，如果有2个出入度为奇数的结点，1的出入度必须为奇数。</p>
<p>程序说明：程序中，使用邻接表表示图，而且使用的是集合set。集合类set有自然排序的特征，构建好集合后不用专门排序。这样做,在用DFS寻找欧拉路径时，找到的第1个解即为字典顺序最小解。<br>并查集类需要是压缩的算法，不然时间上会超时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;//!!</span><br><span class="line">using namespace std;</span><br><span class="line">bool vis[10000][10000];//bool!!</span><br><span class="line">//想到用二维存储 顶点a 到顶点b的边访问过!! </span><br><span class="line">int n,m;</span><br><span class="line">stack&lt;int&gt; path;</span><br><span class="line">//!!vector&lt;set&lt;int&gt; &gt;g=vector&lt;set&lt;int&gt; &gt;(10000);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; g[10000];//领接表存储图 </span><br><span class="line">class unionset&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">	</span><br><span class="line">    unionset(int n)&#123;</span><br><span class="line">    parent=vector&lt;int&gt;(n+1,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">	parent[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bool Union(int u1,int u2)&#123;</span><br><span class="line">		int p1=find(u1);</span><br><span class="line">		int p2=find(u2);</span><br><span class="line">		if(p1==p2) return false;</span><br><span class="line">        parent[p1]=p2;</span><br><span class="line">        return true;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    int find(int num)&#123;</span><br><span class="line">        if(num!=parent[num])&#123;</span><br><span class="line">            parent[num]=find(parent[num]);//find(num)一直自己调用自己 错的 find(parent[num]) 往上回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[num];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">void dfs(int cur)&#123;</span><br><span class="line">	//cout&lt;&lt;cur&lt;&lt;&quot; &quot;; </span><br><span class="line"></span><br><span class="line">	 for(set&lt;int&gt;::iterator it=g[cur].begin(); it!=g[cur].end(); it++) &#123;</span><br><span class="line">	 	if(vis[cur][*it]) continue;</span><br><span class="line">		vis[cur][*it]=true;</span><br><span class="line">		vis[*it][cur]=true;</span><br><span class="line">		dfs(*it);</span><br><span class="line">	 &#125;</span><br><span class="line">		path.push(cur);</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	int a,b;</span><br><span class="line">	unionset u(n);</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		g[a].insert(b);</span><br><span class="line">		g[b].insert(a);</span><br><span class="line">		u.Union(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int t1=u.find(1); </span><br><span class="line"></span><br><span class="line">	for(int i=2;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(u.find(i)!=t1) &#123;</span><br><span class="line">		cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">		return 0;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">	 int count = 0;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            if(g[i].size() % 2 == 1)</span><br><span class="line">                count++;</span><br><span class="line">        if(!(count == 0 || (count == 2 &amp;&amp; g[1].size() % 2 == 1)))</span><br><span class="line">        &#123;</span><br><span class="line">        			cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">		return 0;	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">		dfs(1);</span><br><span class="line">	int t;</span><br><span class="line">        while(!path.empty()) &#123;</span><br><span class="line">            t = path.top();</span><br><span class="line">            path.pop();</span><br><span class="line"> </span><br><span class="line">            cout &lt;&lt; t &lt;&lt; &apos; &apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考博客</p>
<p><a href="http://www.voidcn.com/article/p-skxnamth-bqh.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-skxnamth-bqh.html</a></p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>贪心算法-区间问题</title>
    <url>/2018/10/31/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>已知N个事件的发生时刻和结束时刻（见下表，表中事件已按结束时刻升序排序）。一些在时间上没有重叠的事件，可以构成一个事件序列，如事件<br>{2，8，10}。事件序列包含的事件数目，称为该事件序列的长度。请编程找出一个最长的事件序列。<br><a id="more"></a></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fwrkk34ormj30fj0aj7b3.jpg" alt="image"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAXN 100</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	pair&lt;int,int&gt; inv[MAXN];</span><br><span class="line">	 int n,T[100],S[100];</span><br><span class="line">	 cin&gt;&gt;n;</span><br><span class="line">	 for(int i=0;i&lt;n;i++)</span><br><span class="line">	 cin&gt;&gt;S[i];</span><br><span class="line">	 for(int i=0;i&lt;n;i++)</span><br><span class="line">	 cin&gt;&gt;T[i];</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		inv[i].first=T[i];</span><br><span class="line">		inv[i].second=S[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(inv,inv+n);</span><br><span class="line">	int ans=0,t=0;</span><br><span class="line">	//t是最后工作的结束时间 </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(t&lt;inv[i].second)</span><br><span class="line">		&#123;</span><br><span class="line">			t=inv[i].first;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fwrlql1rnoj308f05vaah.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>贪心法</category>
      </categories>
  </entry>
  <entry>
    <title>201604-3路径解析</title>
    <url>/2018/12/09/%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>问题描述<br>　　在操作系统中，数据通常以文件的形式存储在文件系统中。文件系统一般采用层次化的组织形式，由目录（或者文件夹）和文件构成，形成一棵树的形状。文件有内容，用于存储数据。目录是容器，可包含文件或其他目录。同一个目录下的所有文件和目录的名字各不相同，不同目录下可以有名字相同的文件或目录。<br>　　为了指定文件系统中的某个文件，需要用路径来定位。在类 Unix 系统（Linux、Max OS X、FreeBSD等）中，路径由若干部分构成，每个部分是一个目录或者文件的名字，相邻两个部分之间用 / 符号分隔。<br>　　有一个特殊的目录被称为根目录，是整个文件系统形成的这棵树的根节点，用一个单独的 / 符号表示。在操作系统中，有当前目录的概念，表示用户目前正在工作的目录。根据出发点可以把路径分为两类：<br>　　 绝对路径：以 / 符号开头，表示从根目录开始构建的路径。<br>　　 相对路径：不以 / 符号开头，表示从当前目录开始构建的路径。</p>
<p>　　例如，有一个文件系统的结构如下图所示。在这个文件系统中，有根目录 / 和其他普通目录 d1、d2、d3、d4，以及文件 f1、f2、f3、f1、f4。其中，两个 f1 是同名文件，但在不同的目录下。<br><a id="more"></a><br>　　对于 d4 目录下的 f1 文件，可以用绝对路径 /d2/d4/f1 来指定。如果当前目录是 /d2/d3，这个文件也可以用相对路径 ../d4/f1 来指定，这里 .. 表示上一级目录（注意，根目录的上一级目录是它本身）。还有 . 表示本目录，例如 /d1/./f1 指定的就是 /d1/f1。注意，如果有多个连续的 / 出现，其效果等同于一个 /，例如 /d1///f1 指定的也是 /d1/f1。</p>
<p>本题会给出一些路径，要求对于每个路径，给出正规化以后的形式。一个路径经过正规化操作后，其指定的文件不变，但是会变成一个不包含 . 和 .. 的绝对路径，且不包含连续多个 / 符号。如果一个路径以 / 结尾，那么它代表的一定是一个目录，正规化操作要去掉结尾的 /。若这个路径代表根目录，则正规化操作的结果是 /。若路径为空字符串，则正规化操作的结果是当前目录。</p>
<p>输入格式</p>
<p>第一行包含一个整数 P，表示需要进行正规化操作的路径个数。</p>
<p>第二行包含一个字符串，表示当前目录。</p>
<p>以下 P 行，每行包含一个字符串，表示需要进行正规化操作的路径。<br>输出格式</p>
<p>共 P 行，每行一个字符串，表示经过正规化操作后的路径，顺序与输入对应。</p>
<p>样例输入</p>
<p>7</p>
<p>/d2/d3</p>
<p>/d2/d4/f1</p>
<p>../d4/f1</p>
<p>/d1/./f1</p>
<p>/d1///f1</p>
<p>/d1/</p>
<p>///</p>
<p>/d1/../../d2</p>
<p>样例输出</p>
<p>/d2/d4/f1</p>
<p>/d2/d4/f1</p>
<p>/d1/f1</p>
<p>/d1/f1</p>
<p>/d1</p>
<p>/</p>
<p>/d2</p>
<p>评测用例规模与约定</p>
<p>1 ≤ P ≤ 10。</p>
<p>文件和目录的名字只包含大小写字母、数字和小数点 .、减号 - 以及下划线 _。</p>
<p>不会有文件或目录的名字是 . 或 .. ，它们具有题目描述中给出的特殊含义。</p>
<p>输入的所有路径每个长度不超过 1000 个字符。</p>
<p>输入的当前目录保证是一个经过正规化操作后的路径。</p>
<p>对于前 30% 的测试用例，需要正规化的路径的组成部分不包含 . 和 .. 。</p>
<p>对于前 60% 的测试用例，需要正规化的路径都是绝对路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string cur,tmp,line;</span><br><span class="line">	int pos,k;</span><br><span class="line">	cin&gt;&gt;k&gt;&gt;cur;</span><br><span class="line">	getchar();</span><br><span class="line">	while(k--)&#123;</span><br><span class="line">		getline(cin,line);</span><br><span class="line">		if(line.empty()) &#123;</span><br><span class="line">			cout&lt;&lt;cur&lt;&lt;endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"> 		if(line[0]!=&apos;/&apos;) line=cur+&quot;/&quot;+line;</span><br><span class="line">		while((pos=line.find(&quot;//&quot;))!=string::npos)</span><br><span class="line">		line.erase(pos,1);</span><br><span class="line">		while((pos=line.find(&quot;/./&quot;))!=string::npos)</span><br><span class="line">		&#123;</span><br><span class="line">			line.erase(pos,2);	</span><br><span class="line">		&#125;</span><br><span class="line">		while((pos=line.find(&quot;/../&quot;))!=string::npos)</span><br><span class="line">		&#123;</span><br><span class="line">			if(!pos)&#123;</span><br><span class="line">				line.erase(0,3);</span><br><span class="line">			&#125; </span><br><span class="line">			else&#123;</span><br><span class="line">				int pos1=line.rfind(&apos;/&apos;,pos-1);</span><br><span class="line">				line.erase(pos1,pos-pos1+3);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		//5.末尾有/</span><br><span class="line">		if(line.size()&gt;1&amp;&amp;line[line.size()-1]==&apos;/&apos;) &#123;</span><br><span class="line">			line.erase(line.size()-1,1);</span><br><span class="line">		&#125;	</span><br><span class="line">		cout&lt;&lt;line&lt;&lt;endl; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>2018-03-1 跳一跳</title>
    <url>/2018/11/22/%E8%B7%B3%E4%B8%80%E8%B7%B3/</url>
    <content><![CDATA[<p>tmp记录上一次跳的值<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a;</span><br><span class="line">	int plus=0,tmp;</span><br><span class="line">	int sum=0;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">		if(a==0) break;</span><br><span class="line">		if(a==1)&#123;</span><br><span class="line">			sum+=1;</span><br><span class="line">		&#125; </span><br><span class="line">		else </span><br><span class="line">		&#123;</span><br><span class="line">			if(tmp==2) plus+=2;</span><br><span class="line">			else plus=2;</span><br><span class="line">			sum+=plus;</span><br><span class="line">		&#125; </span><br><span class="line">		tmp=a; </span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ccf认证</category>
      </categories>
  </entry>
  <entry>
    <title>  算法提高 身份证号码升级  </title>
    <url>/2018/12/20/%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81/</url>
    <content><![CDATA[<p>问题描述</p>
<p>　　从1999年10月1日开始，公民身份证号码由15位数字增至18位。(18位身份证号码简介)。升级方法为：<br>  <a id="more"></a><br>　　1、把15位身份证号码中的年份由2位(7,8位)改为四位。<br>　　2、最后添加一位验证码。验证码的计算方案：<br>　　将前 17 位分别乘以对应系数 (7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2) 并相加，然后除以 11 取余数，0-10 分别对应 1 0 x 9 8 7 6 5 4 3 2。<br>　　请编写一个程序，用户输入15位身份证号码，程序生成18位身份证号码。假设所有要升级的身份证的四位年份都是19××年</p>
<p>输入格式</p>
<p>一个15位的数字串，作为身份证号码</p>
<p>输出格式</p>
<p>一个18位的字符串，作为升级后的身份证号码</p>
<p>样例输入</p>
<p>110105491231002</p>
<p>样例输出</p>
<p>11010519491231002x</p>
<p>数据规模和约定<br>　　不用判断输入的15位字符串是否合理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 100</span><br><span class="line">int a[MAX];</span><br><span class="line">int num[17]=&#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;;</span><br><span class="line">string tran[11]=&#123;&quot;1&quot;,&quot;0&quot;,&quot;x&quot;,&quot;9&quot;,&quot;8&quot;,&quot;7&quot;,&quot;6&quot;,&quot;5&quot;,&quot;4&quot;,&quot;3&quot;,&quot;2&quot;&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	s.insert(6,&quot;9&quot;);</span><br><span class="line">	s.insert(6,&quot;1&quot;);</span><br><span class="line">	for(int i=0;i&lt;17;i++)&#123;</span><br><span class="line">		a[i]=s[i]-&apos;0&apos;;</span><br><span class="line">			a[17]+=a[i]*num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[17]%=11;</span><br><span class="line">	s.insert(s.size(),tran[a[17]]);</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    int weight[17]=&#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;;</span><br><span class="line">    string trans=&quot;10x98765432&quot;;</span><br><span class="line">    s=s.substr(0,6)+&quot;19&quot;+s.substr(6);</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int i=0;i&lt;s.size();++i)</span><br><span class="line">        sum+=(s[i]-&apos;0&apos;)*weight[i];</span><br><span class="line">    s+=trans[sum%11];</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>蓝桥杯 递增三元组</title>
    <url>/2019/03/21/%E9%80%92%E5%A2%9E%E4%B8%89%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdn.net/20180402151133746" alt="image"><br><a id="more"></a><br>可以先对三个数组排序，然后遍历数组b，查找a数组中有多少个小于b[i]的，c数组中有多少个大于b[i]的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#define  MAX 100000</span><br><span class="line">using namespace std;</span><br><span class="line">int a[MAX],b[MAX],c[MAX];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;b[i];	</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;c[i];	</span><br><span class="line">	int sum=0;	</span><br><span class="line">	for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">		int m1=(upper_bound(a,a+n,b[j])-a);</span><br><span class="line">		int m2=n-(lower_bound(c,c+n,b[j])-c);</span><br><span class="line">		sum+=m1*m2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>递归小游戏</title>
    <url>/2018/11/09/%E9%80%92%E5%BD%92%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>问题描述<br>• 当下面的情况满足时,<br>认为两个游戏卡片之间有一条路径相连:<br>• 路径只包含水平或者竖直的直线段<br>• 路径不能穿过别的游戏卡片<br>• 但是允许路径临时的离开矩形板<br><a id="more"></a><br>输入 (1/2)<br>• 输入包括多组数据: 一个矩形板对应一组数据<br>• 第一行包括两个整数 w和h (1 &lt;= w, h &lt;= 75),<br>分别表示矩形板的宽度和长度<br>• 下面的h行, 每行包括w个字符, 表示矩形板上的游戏卡<br>片分布情况:<br>• 使用 ‘X’ 表示这个地方有一个游戏卡片<br>• 使用 空格 表示这个地方没有游戏卡片</p>
<p> 之后每行上包括4个整数:<br>x1, y1, x2, y2 (1 &lt;= x1, x2 &lt;= w, 1 &lt;= y1, y2 &lt;= h)<br>• 给出两个卡片在矩形板上的位置<br>注意: 矩形板左上角的坐标是(1,1)<br>输入保证这两个游戏卡片所处的位置是不相同的<br>如果一行上有4个0, 表示这组测试数据的结束<br>• 如果一行上给出w = h = 0, 那么表示所有的输入结束了</p>
<p>输出<br>• 对每一个矩形板, 输出一行 “Board #n:”, n是输入数据的<br>编号<br>• 对每一组需要测试的游戏卡片输出一行. 这一行的开头<br>是 “Pair m: ”, 这里m是测试卡片的编号（对每个矩形板,<br>编号都从1开始）<br>• 如果可以相连, 找到连接这两个卡片的所有路径中包括<br>线段数最少的路径, 输出 “k segments.”<br>k是找到的最优路径中包括的线段的数目<br>• 如果不能相连, 输出 “impossible.”<br>• 每组数据之后输出一个空行<br>7<br>样例输入<br>5 4<br>X X X X X</p>
<p>X X</p>
<p>X X X X</p>
<p>X X X</p>
<p>2 3 5 3</p>
<p>1 3 4 4</p>
<p>2 3 3 4</p>
<p>0 0 0 0</p>
<p>0 0</p>
<p>样例输出</p>
<p>Board #1:</p>
<p>Pair 1: 4 segments.</p>
<p>Pair 2: 3 segments.</p>
<p>Pair 3: impossible.<br>用bfs实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">struct Point&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    int f;</span><br><span class="line">    Point(int xx,int yy,int ff):x(xx),y(yy),f(ff)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">using namespace std;</span><br><span class="line">int board[100][100];</span><br><span class="line">char maze[100][100];</span><br><span class="line">int mark[100][100];</span><br><span class="line">int dis[100][100];</span><br><span class="line">int d[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">int w,h;</span><br><span class="line">int inBoard(int n,int x0,int y0)&#123;</span><br><span class="line">    return n&gt;=x0&amp;&amp;n&lt;y0;</span><br><span class="line">&#125;</span><br><span class="line">bool bfs(int x0,int y0,int x1,int y1,int cnt)&#123;</span><br><span class="line">    memset(mark,0,sizeof(mark));</span><br><span class="line">    memset(dis,0,sizeof(dis));</span><br><span class="line">    queue&lt;Point&gt; q;</span><br><span class="line">    Point P=Point(x0,y0,-1);</span><br><span class="line">    q.push(P);</span><br><span class="line">    mark[x0][y0]=1;</span><br><span class="line">    dis[x0][y0]=0;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        Point u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int now_x=u.x;</span><br><span class="line">        int now_y=u.y;</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            int x=now_x+d[i][0];</span><br><span class="line">            int y=now_y+d[i][1];</span><br><span class="line">            if(x==x1&amp;&amp;y==y1)&#123;</span><br><span class="line">                dis[x][y]=dis[now_x][now_y]+1;</span><br><span class="line">                cout&lt;&lt;&quot;Pair &quot;&lt;&lt;cnt&lt;&lt;&quot;:&quot;&lt;&lt;dis[x][y]&lt;&lt;&quot; segments.&quot;&lt;&lt;endl;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; </span><br><span class="line">            if(inBoard(x,0,h+2)&amp;&amp;inBoard(y,0,w+2)&amp;&amp;!mark[x][y]&amp;&amp;board[x][y]==0)&#123;</span><br><span class="line">                q.push(Point(x,y,i));</span><br><span class="line">                if(u.f!=i)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[x][y]=dis[now_x][now_y]+1;//!!!</span><br><span class="line">                &#125;</span><br><span class="line">                else dis[x][y]=dis[now_x][now_y];</span><br><span class="line">                mark[x][y]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int x0,y0,x1,y1;</span><br><span class="line">    memset(board,0,sizeof(board));</span><br><span class="line">    int cnt=1;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;w,&amp;h))&#123;</span><br><span class="line">    </span><br><span class="line">        if(w==0&amp;&amp;h==0) break;</span><br><span class="line">        for(int i=1;i&lt;=h;i++)&#123;</span><br><span class="line">            getchar();//!!!</span><br><span class="line">            for(int j=1;j&lt;=w;j++)&#123;</span><br><span class="line">            maze[i][j] = getchar();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;=h;i++)&#123;</span><br><span class="line">            for(int j=1;j&lt;=w;j++)&#123;</span><br><span class="line">                if(maze[i][j]==&apos;X&apos;) board[i][j]=1;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;       </span><br><span class="line"></span><br><span class="line">        int Count=1;</span><br><span class="line">            cout&lt;&lt;&quot;Board #&quot;&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">        while(scanf(&quot;%d%d%d%d&quot;,&amp;y0,&amp;x0,&amp;y1,&amp;x1))</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(x0==0&amp;&amp;y0==0&amp;&amp;x1==0&amp;&amp;y1==0) break;</span><br><span class="line">        </span><br><span class="line">    if(!    bfs(x0,y0,x1,y1,Count)) cout&lt;&lt;&quot;Pair &quot;&lt;&lt;Count&lt;&lt;&quot;:&quot;&quot;impossible.&quot;&lt;&lt;endl;</span><br><span class="line">        Count++;</span><br><span class="line">    &#125;       </span><br><span class="line">    cnt++;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006wtREyly1fx28e63b49j307s092gma.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>算法提高 金属采集</title>
    <url>/2019/03/14/%E9%87%91%E5%B1%9E%E9%87%87%E9%9B%86/</url>
    <content><![CDATA[<p>问题描述</p>
<p>人类在火星上发现了一种新的金属！这些金属分布在一些奇怪的地方，不妨叫它节点好了。一些节点之间有道路相连，所有的节点和道路形成了一棵树。一共有 n 个节点，这些节点被编号为 1~n 。人类将 k 个机器人送上了火星，目的是采集这些金属。这些机器人都被送到了一个指定的着落点， S 号节点。每个机器人在着落之后，必须沿着道路行走。当机器人到达一个节点时，它会采集这个节点蕴藏的所有金属矿。当机器人完成自己的任务之后，可以从任意一个节点返回地球。当然，回到地球的机器人就无法再到火星去了。我们已经提前测量出了每条道路的信息，包括它的两个端点 x 和 y，以及通过这条道路需要花费的能量 w 。我们想花费尽量少的能量采集所有节点的金属，这个任务就交给你了。<br><a id="more"></a><br>输入格式<br>第一行包含三个整数 n, S 和 k ，分别代表节点个数、着落点编号，和机器人个数。</p>
<p>接下来一共 n-1 行，每行描述一条道路。一行含有三个整数 x, y 和 w ，代表在 x 号节点和 y 号节点之间有一条道路，通过需要花费 w 个单位的能量。所有道路都可以双向通行。</p>
<p>输出格式<br>输出一个整数，代表采集所有节点的金属所需要的最少能量。<br>样例输入<br>6 1 3<br>1 2 1<br>2 3 1<br>2 4 1000<br>2 5 1000<br>1 6 1000<br>样例输出<br>3004<br>样例说明<br>所有机器人在 1 号节点着陆。</p>
<p>第一个机器人的行走路径为 1-&gt;6 ，在 6 号节点返回地球，花费能量为1000。</p>
<p>第二个机器人的行走路径为 1-&gt;2-&gt;3-&gt;2-&gt;4 ，在 4 号节点返回地球，花费能量为1003。</p>
<p>第一个机器人的行走路径为 1-&gt;2-&gt;5 ，在 5 号节点返回地球，花费能量为1001。</p>
<p>数据规模与约定<br>本题有10个测试点。</p>
<p>对于测试点 1~2 ， n &lt;= 10 ， k &lt;= 5 。</p>
<p>对于测试点 3 ， n &lt;= 100000 ， k = 1 。</p>
<p>对于测试点 4 ， n &lt;= 1000 ， k = 2 。</p>
<p>对于测试点 5~6 ， n &lt;= 1000 ， k &lt;= 10 。</p>
<p>对于测试点 7~10 ， n &lt;= 100000 ， k &lt;= 10 。</p>
<p>道路的能量 w 均为不超过 1000 的正整数。</p>
<p>算法：</p>
<p>树形DP</p>
<p>定义dp（i，j）为从i出发，使用j个机器人的最小值</p>
<p>i的子树为son</p>
<p><strong><br>dp(i,j)=(dp(son,0)+cast[son]<em>2)(子树没有停留机器人)+min(dp[p][m-remain]+remain</em>cost[son]+dp[son][remain])(子树停留了remain个机器人)
</strong></p>
<p>树状数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define MAX 100002</span><br><span class="line">using namespace std;</span><br><span class="line">int n,s,K;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int v;</span><br><span class="line">	int w;</span><br><span class="line">	node(int vv,int ww):v(vv),w(ww)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	node()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; g[MAX];</span><br><span class="line">int dp[MAX][11];</span><br><span class="line">int vis[MAX];</span><br><span class="line">//dp[m][n] 表示以m节点为根 停留n个机器人 的最小花费（可以再其子树上） </span><br><span class="line">using namespace std;</span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">	vis[u]=1;</span><br><span class="line">	for(int i=0;i&lt;g[u].size();i++)&#123;</span><br><span class="line">		int v=g[u][i].v;</span><br><span class="line">		int cost=g[u][i].w;</span><br><span class="line">		if(vis[v]) continue;</span><br><span class="line">		dfs(v);</span><br><span class="line">		for(int k=K;k&gt;=0;k--)&#123;//这里要注意不能掉了0的情况</span><br><span class="line">			dp[u][k]+=dp[v][0]+cost*2;</span><br><span class="line">			for(int r=1;r&lt;=k;r++)&#123;</span><br><span class="line">				dp[u][k]=min(dp[u][k],dp[u][k-r]+dp[v][r]+cost*r);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//	freopen(&quot;57.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;s&gt;&gt;K;</span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">	memset(dp,0,sizeof(dp));</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">		int a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		g[a].push_back(node(b,c));</span><br><span class="line">		g[b].push_back(node(a,c));</span><br><span class="line">	&#125; </span><br><span class="line">	dfs(s);</span><br><span class="line">	cout&lt;&lt;dp[s][K]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接<br><a href="https://blog.csdn.net/wximo/article/details/27318767" target="_blank" rel="noopener">https://blog.csdn.net/wximo/article/details/27318767</a><br><a href="http://www.voidcn.com/article/p-omlkxdkv-qn.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-omlkxdkv-qn.html</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>历届试题 错误票据</title>
    <url>/2019/03/12/%E9%94%99%E8%AF%AF%E7%A5%A8%E6%8D%AE/</url>
    <content><![CDATA[<p>问题描述<br>某涉密单位下发了某种票据，并要在年终全部收回。</p>
<p>每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。<br><a id="more"></a></p>
<p>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。</p>
<p>你的任务是通过编程，找出断号的ID和重号的ID。</p>
<p>假设断号不可能发生在最大和最小号。</p>
<p>输入格式<br>要求程序首先输入一个整数N(N&lt;100)表示后面数据行数。</p>
<p>接着读入N行数据。</p>
<p>每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000），请注意行内和行末可能有多余的空格，你的程序需要能处理这些空格。</p>
<p>每个整数代表一个ID号。</p>
<p>输出格式<br>要求程序输出1行，含两个整数m n，用空格分隔。</p>
<p>其中，m表示断号ID，n表示重号ID<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入1</span><br><span class="line">2</span><br><span class="line">5 6 8 11 9 </span><br><span class="line">10 12 9</span><br><span class="line">样例输出1</span><br><span class="line">7 9</span><br><span class="line">样例输入2</span><br><span class="line">6</span><br><span class="line">164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196</span><br><span class="line">172 189 127 107 112 192 103 131 133 169 158 </span><br><span class="line">128 102 110 148 139 157 140 195 197</span><br><span class="line">185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190</span><br><span class="line">149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188</span><br><span class="line">113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119</span><br><span class="line">样例输出2</span><br><span class="line">105 120</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#define MAX  1000</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;string&gt; dict;</span><br><span class="line">int hasht[MAX];</span><br><span class="line">int strToInt(string s)&#123;</span><br><span class="line">	int a=1;</span><br><span class="line">	int ans=0;</span><br><span class="line">	for(int i=s.length()-1;i&gt;=0;i--)&#123;</span><br><span class="line">		//s[i]-&apos;0&apos;不能忘記 </span><br><span class="line">		ans+=(s[i]-&apos;0&apos;)*a;</span><br><span class="line">		a*=10;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">void parseStr(string s)&#123;</span><br><span class="line">	stringstream sin(s);</span><br><span class="line">	string w;</span><br><span class="line">	while(sin&gt;&gt;w)&#123;</span><br><span class="line">		dict.push_back(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	dict.clear();</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	string str;</span><br><span class="line">	memset(hasht,0,sizeof(hasht));</span><br><span class="line">	int chong;</span><br><span class="line">	getchar();</span><br><span class="line">	while(n)&#123;</span><br><span class="line">		getline(cin,str);</span><br><span class="line">		parseStr(str);</span><br><span class="line"></span><br><span class="line">		n--;</span><br><span class="line">	&#125;</span><br><span class="line">	int min=0x3f3f3f,max=-1;</span><br><span class="line">			for(int i=0;i&lt;dict.size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			int t=strToInt(dict[i]);</span><br><span class="line">			if(t&lt;min) min=t;</span><br><span class="line">			if(t&gt;max) max=t;</span><br><span class="line">			if(hasht[t]==1) chong=t; </span><br><span class="line">			else hasht[t]=1;</span><br><span class="line">		&#125;</span><br><span class="line">	for(int i=min;i&lt;=max;i++)&#123;</span><br><span class="line">		if(hasht[i]==0)&#123;</span><br><span class="line">			cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;chong&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>长江一日游-出租游艇</title>
    <url>/2018/12/18/%E9%95%BF%E6%B1%9F%E4%B8%80%E6%97%A5%E6%B8%B8/</url>
    <content><![CDATA[<p>题目：长江港口出租游艇，有1,2….n个出租站点，游客可在这个某出租站点租游艇，然后在下游任一出租站点归还游艇。游艇出租站i到j的出租费用为r(i,j);1&lt;=j&lt;j&lt;=n,计算港口1到n的最小费用。<br><a id="more"></a><br>Input</p>
<p>第 1 行中有 1 个正整数 n（n&lt;=200） ，表示有 n个游艇出租站。</p>
<p>接下来的n-1 行是r(i,j), r(i,j)为整数，1 ≤ i &lt; j ≤ n。</p>
<p>Output</p>
<p>输出从游艇出租站1到游艇出租站n所需的最少租金。</p>
<p>Sample Input</p>
<p>3<br>5 15<br>7</p>
<p>Sample Output</p>
<p>12</p>
<p>直接保存起点到每个点的最少租金</p>
<p>分析：假设出租站点1到出租站点n的最短费用不是为1到n的直通费用，就是说最短费用是在1到n中间，至少在某一个出租点还了游艇，然后又继续租游艇到站点n，所以最少费用满足min=min(Min(i,j)+Min(j,n)),1&lt;j&lt;n;所以此题满足动态规划的最优子结构性质。当我们求出租站1到出租站n的最少费用时候，我们需要知道出租站2到出租站n的最少费用，并且需要知道3-&gt;n的最少费用，当我们求出租站2到出租站n的最少费用的时候，又需要知道出租站3到出租站n的最少费用，所以此题也满足动态规划的第二个性质：子问题重叠！</p>
<p>自底向上<br>s[i][j]存的从i到j的最少租金<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line">using namespace std;</span><br><span class="line">int d[MAX][MAX],m[MAX][MAX],s[MAX][MAX];</span><br><span class="line">void print(int i,int j)&#123;</span><br><span class="line">	if(s[i][j]==0) &#123;</span><br><span class="line">		cout&lt;&lt;j&lt;&lt;&quot;--&quot;;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	print(i,s[i][j]);</span><br><span class="line">	print(s[i][j],j);</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	memset(s,0,sizeof(s));</span><br><span class="line">	memset(d,0,sizeof(d));</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=i+1;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">		cin&gt;&gt;d[i][j];</span><br><span class="line">		m[i][j]=d[i][j];	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int d=3;d&lt;=n;d++)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n-d+1;i++)&#123;</span><br><span class="line">			 int j=i+d-1;</span><br><span class="line">			for(int k=i+1;k&lt;j;k++)&#123;</span><br><span class="line">			if(m[i][k]+m[k][j]&lt;m[i][j])</span><br><span class="line">			&#123;</span><br><span class="line">				s[i][j]=k;</span><br><span class="line">				m[i][j]=m[i][k]+m[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;1;</span><br><span class="line">	print(1,n);</span><br><span class="line">	cout&lt;&lt;&quot;cost:&quot;&lt;&lt;m[1][n]&lt;&lt;endl;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自顶向下的方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/ 港口最少费用.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;   //有个表示int类型最大值的宏在这个头文件里面</span><br><span class="line"> </span><br><span class="line">int FindMinest(int (*p)[10], int (*m)[10], int k, int n);</span><br><span class="line">int Min(int a, int b);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	int p[10][10] = &#123; 0 &#125;;   //保存出租站之间的直通费用</span><br><span class="line">	int m[10][10] = &#123; 0 &#125;;    //保存出租站之间的最短费用</span><br><span class="line">	scanf_s(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 0; i &lt; n-1; ++i) &#123;  </span><br><span class="line">		for (int j = i+1; j &lt; n; ++j) &#123;</span><br><span class="line">			scanf_s(&quot;%d&quot;, &amp;p[i][j]);  //输入出租站之间的直通出租费用</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int min = FindMinest(p, m, 0, n-1);</span><br><span class="line">	printf(&quot;%d&quot;, min);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//自顶向下的方法</span><br><span class="line">int FindMinest(int(*p)[10], int(*m)[10], int k, int n) &#123;//这个函数的作用就是找到港口K到港口n的最小费用</span><br><span class="line">	int min = INT_MAX;</span><br><span class="line">	if (k == n) &#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if (m[k][n] &gt; 0) &#123;</span><br><span class="line">		return m[k][n];</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = k + 1; i &lt;= n; ++i) &#123;</span><br><span class="line">		min = Min(min, p[k][i] + FindMinest(p, m, i, n));</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	m[k][n] = min;</span><br><span class="line">	return min;</span><br><span class="line">&#125;</span><br><span class="line">int Min(int a, int b) &#123;</span><br><span class="line">	return a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">#define N 210  </span><br><span class="line">int cost[N][N];  </span><br><span class="line">int m[N];  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    int n,i,j;  </span><br><span class="line">    while(cin&gt;&gt;n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for(i=1;i&lt;n;i++)  </span><br><span class="line">            for(j=i+1;j&lt;=n;j++)  </span><br><span class="line">                cin&gt;&gt;cost[i][j];  </span><br><span class="line">        m[1]=0;  </span><br><span class="line">        int min;  </span><br><span class="line">        for(i=2;i&lt;=n;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            min=cost[1][i];  </span><br><span class="line">            for(j=1;j&lt;=i-1;j++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                if(m[j]+cost[j][i]&lt;min)  </span><br><span class="line">                    min=m[j]+cost[j][i];  </span><br><span class="line">            &#125;  </span><br><span class="line">            m[i]=min;  //m数组存储的是到每个点的最小租金，这是个数组而不是一个数，在计算到达一个新的游艇租赁点时，之前的每一个点的最小租金都会用到</span><br><span class="line">        &#125;  </span><br><span class="line">        cout&lt;&lt;m[n]&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>趣学算法</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>  算法提高 队列操作  </title>
    <url>/2018/12/17/%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>题描述<br>　　﻿队列操作题。根据输入的操作命令，操作队列（1）入队、（2）出队并输出、（3）计算队中元素个数并输出。<br><a id="more"></a><br>输入格式<br>　　第一行一个数字N。<br>　　下面N行，每行第一个数字为操作命令（1）入队、（2）出队并输出、（3）计算队中元素个数并输出。<br>输出格式<br>　　若干行每行显示一个2或3命令的输出结果。注意：2.出队命令可能会出现空队出队（下溢），请输出“no”，并退出。<br>样例输入<br>7</p>
<p>1 19</p>
<p>1 56</p>
<p>2</p>
<p>3</p>
<p>2</p>
<p>3</p>
<p>2<br>样例输出</p>
<p>19</p>
<p>1</p>
<p>56</p>
<p>0</p>
<p>no</p>
<p>#include<queue>中的队列操作如下</queue></p>
<p>back()返回最后一个元素</p>
<p>empty()如果队列空则返回真</p>
<p>front()返回第一个元素</p>
<p>pop()删除第一个元素<br><!--more--><br>push()在末尾加入一个元素</p>
<p>size()返回队列中元素的个数</p>
<p>queue 的基本操作举例如下：<br>queue入队，如例：q.push(x); 将x 接到队列的末端。</p>
<p>queue出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。</p>
<p>访问queue队首元素，如例：q.front()，即最早被压入队列的元素。</p>
<p>访问queue队尾元素，如例：q.back()，即最后被压入队列的元素。</p>
<p>判断queue队列空，如例：q.empty()，当队列空时，返回true。</p>
<p>访问队列中的元素个数，如例：q.size()</p>
<p>itoa用法如下：</p>
<p>itoa是广泛应用的非标准C语言扩展函数，通常在&lt;stdlib.h&gt;头文件中包含这个函数。<br>原型：char<em>itoa(int value,char</em>string,int radix);<br>int value 被转换的整数，char *string 转换后储存的字符数组，int radix 转换进制数，如2,8,10,16 进制等</p>
<p>atoi用法如下：</p>
<p>atoi (表示 alphanumeric to integer)是把字符串转换成整型数的一个函数，</p>
<p>原型：intatoi(const char *nptr);</p>
<p>参数nptr字符串，如果第一个非空格字符存在，是数字或者正负号则开始做类型转换，之后检测到非数字(包括结束符 \0) 字符时停止转换，返回整型数。否则，返回零。包含在头文件stdlib.h中。<br>这个题的思路就是根据题目要求对队列进行操作，把要输出的数放到一个string数组里，如果输出的是一个数字，就把数字转化为字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	int m;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	int s;</span><br><span class="line"></span><br><span class="line">	while(n--)&#123;</span><br><span class="line">		</span><br><span class="line">		cin&gt;&gt;m;</span><br><span class="line">		if(m==1)&#123;</span><br><span class="line">			</span><br><span class="line">			cin&gt;&gt;s;</span><br><span class="line">			q.push(s);</span><br><span class="line">		&#125; </span><br><span class="line">		else if(m==2)&#123;</span><br><span class="line">			if(!q.empty())&#123;</span><br><span class="line">				cout&lt;&lt;q.front()&lt;&lt;endl;;</span><br><span class="line">				q.pop();</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</span><br><span class="line">				if(n&gt;0)&#123;</span><br><span class="line">					cin&gt;&gt;m;</span><br><span class="line">					n--;</span><br><span class="line">				&#125;</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			</span><br><span class="line">			cout&lt;&lt;q.size()&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;   </span><br><span class="line">#include&lt;cstdlib&gt;   </span><br><span class="line">#include&lt;queue&gt;  </span><br><span class="line">#include&lt;cstring&gt;   </span><br><span class="line">  </span><br><span class="line">using namespace std;  </span><br><span class="line">queue &lt;int&gt; q;  </span><br><span class="line">int main()    </span><br><span class="line">&#123;    </span><br><span class="line">    int n,m,t,k=0,flag=1;//k用来统计要打印字符串的个数，n为输入个数，m，t都是临时变量，若输出了一个no，flag置为0  </span><br><span class="line">    cin&gt;&gt;n;  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cin&gt;&gt;m;  </span><br><span class="line">        if(m==1)//当输入为1  </span><br><span class="line">        &#123;  </span><br><span class="line">            cin&gt;&gt;t;  </span><br><span class="line">            q.push(t);  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(m==2)//当输入为2  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(q.empty()&amp;&amp;flag)//注意一定要加flag判断  </span><br><span class="line">            &#123;  </span><br><span class="line">                cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</span><br><span class="line">                flag=0;  </span><br><span class="line">            &#125;  </span><br><span class="line">            else  </span><br><span class="line">            &#123;  </span><br><span class="line">                if(flag)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    cout&lt;&lt;q.front()&lt;&lt;endl; </span><br><span class="line">                    q.pop();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(m==3)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(flag)  </span><br><span class="line">                cout&lt;&lt;q.size()&lt;&lt;endl;          </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;      </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>dfs  马踏棋盘</title>
    <url>/2019/03/23/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98/</url>
    <content><![CDATA[<p>马踏棋盘<br>5*5棋盘 从(0,0)按马字走步，填满整个棋盘可能的方案数</p>
<a id="more"></a>
<p>VOID DFS(状态 A)<br>判断当前的状态是否合法。合法则继续执行，否则则回到上次调用。<br>进行一次状态转移，也就是调用DFS(状态 A + Δ)</p>
<p>试探节点A<br>A是否在图（树）中<br>如果在 标记A<br>如果已被试探过的话 所影响的各种值<br>紧跟着去试探所有A可达的节点<br>等待所有的执行完后 还原标记A</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int cnt = 0;</span><br><span class="line">int vis[5][5];</span><br><span class="line"></span><br><span class="line">/// 打印结果</span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Case #%d:\n&quot;, ++cnt);</span><br><span class="line">	for (int i = 0; i &lt; 5; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = 0; j &lt; 4; j++)</span><br><span class="line">			printf(&quot;%4d&quot;, vis[i][j]);</span><br><span class="line">		printf(&quot;%4d\n&quot;, vis[i][4]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 判断 x 是否在范围 [l, r) 内</span><br><span class="line">inline bool inbound(int x, int l, int r) &#123; return l &lt;= x &amp;&amp; x &lt; r; &#125;</span><br><span class="line"></span><br><span class="line">/// 深度优先搜索棋盘</span><br><span class="line">///@param x 坐标x</span><br><span class="line">///@param x 坐标x</span><br><span class="line">///@param n 第n步</span><br><span class="line">void dfs(int x, int y, int n)</span><br><span class="line">&#123;</span><br><span class="line">	if (vis[x][y] == 0//判断当前位置是否合法 合法则继续进行 否则回到上次调用 </span><br><span class="line">		&amp;&amp; inbound(x, 0, 5) &amp;&amp; inbound(y, 0, 5)</span><br><span class="line">		&amp;&amp; n &lt;= 25)</span><br><span class="line">	&#123;</span><br><span class="line">		vis[x][y] = n;</span><br><span class="line">		n++;</span><br><span class="line">		if (n &gt; 25)</span><br><span class="line">			print();//找到基于x y下一个可走的位置 </span><br><span class="line">		dfs(x + 1, y + 2, n);</span><br><span class="line">		dfs(x + 1, y - 2, n);</span><br><span class="line">		dfs(x - 1, y + 2, n);</span><br><span class="line">		dfs(x - 1, y - 2, n);</span><br><span class="line">		dfs(x + 2, y + 1, n);</span><br><span class="line">		dfs(x + 2, y - 1, n);</span><br><span class="line">		dfs(x - 2, y + 1, n);</span><br><span class="line">		dfs(x - 2, y - 1, n);</span><br><span class="line">		vis[x][y] = 0;//可以回溯 </span><br><span class="line">	&#125;</span><br><span class="line">	else return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	dfs(0, 0, 1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>和深搜不同，广搜总是每次都把离上一状态最近的状态用一个队列记录下来；<br>记录之后，检查队列是否为空，如果不为空，就讲队首元素弹出，并且以这个状态为“根节点”进行广度优先搜索。<br>直到整个队列为空为止。</p>
]]></content>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>周总结 (27)</title>
    <url>/2019/06/12/%E5%91%A8%E6%80%BB%E7%BB%93-27/</url>
    <content><![CDATA[<p>第一次租房被坑 怎么说呢 心情复杂<br><a id="more"></a><br>知道是我们违约在先 但是房东正好利用我们大学生 不敢闹事的心理 想牟利 </p>
<p>法律固然是法律 可是人是有感情的</p>
<p>在那一秒 我知道我最不想成为的人的样子 也理解了社会的第一课 为错误的决定负责 其实也不是心疼这一千块 只是为了利益就可以没有底线么 人和人固然是不同的 尤其是轻易相信一个陌生人 </p>
<p>也是在那一刻 意识到有话语权的重要性 只有你有足够的资本 你才能说no</p>
<p>很想去一个好点的大学 快速提升自己的能力</p>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(26)</title>
    <url>/2019/03/28/%E5%91%A8%E6%80%BB%E7%BB%9326/</url>
    <content><![CDATA[<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>这一个星期主要看的算法和高数，高数进度有点慢，要归纳总结<br><a id="more"></a></p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>蓝桥杯水了个省二，怎么说呢，有点失落的，也许离一等奖也就差一两题的距离，后来发现自己的得失心还是太重。想了想，怎么说呢，尽全力就好，无所谓结果。天梯赛比的还可以，也算有得有失了。希望每天的自己会比昨天的自己进步一点点。</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>计算机网络哈工大课程 </li>
<li>全书高数上册</li>
<li>1800高数上册部分</li>
</ul>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
  <entry>
    <title>周总结(28)</title>
    <url>/2020/01/27/%E5%91%A8%E6%80%BB%E7%BB%93-28/</url>
    <content><![CDATA[<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>No matter what you do,the results will last</p>
<p>考完研以l后 过得有点丧</p>
<p>对未来不是很有把握<br><a id="more"></a><br>对自己不是很有自信</p>
<p>每天想努力多学一点</p>
<p>却总是泡肥皂剧</p>
<p>不想跟别人比</p>
<p>只想跟以前的自己比</p>
<p>不管会不会有好的结果</p>
<p>总是要向前</p>
<p>义无反顾</p>
<p>错过了一些学习机会 不能再错过了</p>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
  </entry>
</search>
